<!doctype html>
<!--
Tangram: real-time WebGL rendering for OpenStreetMap

http://github.com/bcamper/tangram
http://mapzen.com
-->
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Vector map</title>
<style>

body {
    margin: 0px;
    border: 0px;
    padding: 0px;
}

#map {
    background: rgba(0, 0, 0, 0);
}

<!-- For canvas feature picking demo -->
.label {
    width: 200px;
    margin-left: -100px;
    position: absolute;
    z-index: 10;
    text-align: center;
}

.labelInner {
    padding: 2px;
    background: white;
    opacity: 0.75;
}

</style>
<link rel="stylesheet" href="demos/lib/leaflet-0.8-dev.css" />
</head>

<body>

<div id="map"></div>

<script src="demos/lib/leaflet-0.8-dev.js"></script>
<script src="demos/lib/dat.gui.min.js"></script>
<script src="demos/lib/rStats.js"></script>
<script src="demos/lib/rStats.extras.js"></script>
<script src="dist/js-yaml.js"></script>
<script src="dist/vector-map.debug.js"></script>

<script>

(function(){

var tile_source = 'mapzen'; // default source, can be overriden by URL

var tile_sources = {
    'mapzen': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        // styles: 'demos/gl_styles.js'
        styles: 'demos/gl_styles.yaml'
    },
    'mapzen-dev': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://vector.dev.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-local': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://localhost:8080/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-mvt': {
        source: {
            type: 'MapboxTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.mapbox'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-topojson': {
        source: {
            type: 'TopoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-canvas': {
        source: {
            type:'GeoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/canvas_layers.js',
        styles: 'demos/canvas_styles.js',
        renderer: 'CanvasRenderer'
    },
    'osm': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://tile.openstreetmap.us/vectiles-all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapbox': {
        source: {
            type: 'MapboxTileSource',
            url: 'http://{s:[a,b,c,d]}.tiles.mapbox.com/v3/mapbox.mapbox-streets-v4/{z}/{x}/{y}.vector.pbf',
            max_zoom: 14
        },
        layers: 'demos/gl_layers_mvt.js',
        styles: 'demos/gl_styles.js'
    }
};

var locations = {
    'London': [51.508, -0.105, 15],
    'New York': [40.70531887544228, -74.00976419448853, 16],
    'Seattle': [47.609722, -122.333056, 15]
};

var osm_debug = false;


/*** URL parsing ***/

// URL hash pattern is one of:
// #[source]
// #[lat],[lng],[zoom]
// #[source],[lat],[lng],[zoom]
// #[source],[location name]
var url_hash = window.location.hash.slice(1, window.location.hash.length).split(',');

// Get tile source from URL
if (url_hash.length >= 1 && tile_sources[url_hash[0]] != null) {
    tile_source = url_hash[0];
}

// Get location from URL
var map_start_location = locations['New York'];
if (url_hash.length == 3) {
    map_start_location = url_hash.slice(0, 3);
}
if (url_hash.length > 3) {
    map_start_location = url_hash.slice(1, 4);
}
else if (url_hash.length == 2) {
    map_start_location = locations[url_hash[1]];
}


/***** GUI/debug controls *****/

var gui = new dat.GUI({ autoPlace: true });
gui.domElement.parentNode.style.zIndex = 5;
// document.body.insertBefore(gui.domElement, document.body.firstChild);
window.gui = gui;

if (url_hash.length > 4) {
    var url_ui = url_hash.slice(4);
}

// GUI options for rendering modes/effects
var gl_mode_options = {
    effect: '',
    options: {
        'None': '',
        'Rainbow': 'rainbow',
        'Pop-up': 'popup',
        'Elevator': 'elevator',
        'Breathe': 'breathe',
        'Dots': 'dots',
        'Wood': 'wood'
    },
    config: {
        'popup': {
            projection: 'PROJECTION_ISOMETRIC' // force isometric when switching to pop-up
        }
    }
};

var gl_initial = {};
gui.
    add(gl_mode_options, 'effect', gl_mode_options.options).
    onChange(setRenderModeOptions);

function setRenderModeOptions (value) {
    var layer_styles = renderer.styles.layers;

    // Save settings to restore later
    gl_initial.projection = gl_initial.projection || gl_define_options.projection.projection;
    gl_initial.buildings_mode = gl_initial.buildings_mode || layer_styles.buildings.mode.name;

        // Restore initial state
    if (value == '') {
        gl_define_options.projection.projection = gl_initial.projection;
        layer_styles.buildings.mode.name = gl_initial.buildings_mode;
    }
    // Mode-specific settings
    else {
        var settings = gl_mode_options.config[value];
        gl_define_options.projection.projection = (settings && settings.projection) || gl_initial.projection;
        layer_styles.buildings.mode.name = value;
    }

    setGLProgramDefines();
    renderer.rebuildTiles();
    updateURL();
}

// Wood GUI
// val = renderer.modes.wood.shaders.uniforms.u_wood_color1;
// gui["woodColor1"] = [val[0] * 255, val[1] * 255, val[2] * 255];
// // gui["woodColor1"] = renderer.modes.wood.shaders.uniforms.u_wood_color1;
// var wcolor1Var = gui.addColor(gui, "woodColor1");
// wcolor1Var.onChange(function(value) {
//     renderer.modes.wood.shaders.uniforms.u_wood_color1 = [value[0]/255, value[1]/255, value[2]/255];
// });

// val = renderer.modes.wood.shaders.uniforms.u_wood_color2;
// gui["woodColor2"] = [val[0] * 255, val[1] * 255, val[2] * 255];
// var wcolor2Var = gui.addColor(gui, "woodColor2");
// wcolor2Var.onChange(function(value) {
//     renderer.modes.wood.shaders.uniforms.u_wood_color2 = [value[0]/255, value[1]/255, value[2]/255];
// });

// gui["eccentricity"] = renderer.modes.wood.shaders.uniforms.u_wood_eccentricity;
// var eccVar = gui.add(gui, "eccentricity", -1, 1);
// eccVar.onChange(function(value) {
//     renderer.modes.wood.shaders.uniforms.u_wood_eccentricity = value * 1;
// });

// gui["twist"] = renderer.modes.wood.shaders.uniforms.u_wood_twist / .001;
// var twistVar = gui.add(gui, "twist", 0, 1);
// twistVar.onChange(function(value) {
//     renderer.modes.wood.shaders.uniforms.u_wood_twist = value * .001;
// });

// gui["scale"] = renderer.modes.wood.shaders.uniforms.u_wood_scale / 100;
// var scaleVar = gui.add(gui, "scale", 0, 1);
// scaleVar.onChange(function(value) {
//     renderer.modes.wood.shaders.uniforms.u_wood_scale = value * 100;
// });

// GUI options for #define-based effects
var gl_define_options = {
    projection: {
        projection: 'PROJECTION_PERSPECTIVE',
        options: {
            'None': '',
            'Perspective': 'PROJECTION_PERSPECTIVE',
            'Isometric': 'PROJECTION_ISOMETRIC'//,
            // 'Pop-Up': 'PROJECTION_POPUP'
        }
    },
    lighting_style: {
        lighting_style: 'LIGHTING_POINT',
        options: {
            'None': '',
            'Gradient': 'LIGHTING_POINT',
            'Flat': 'LIGHTING_DIRECTION',
            'Night': 'LIGHTING_NIGHT'
        }
    },
    // lighting_mode: {
    //     lighting_mode: 'LIGHTING_PIXEL',
    //     options: {
    //         'Per-Vertex': 'LIGHTING_VERTEX',
    //         'Per-Pixel': 'LIGHTING_PIXEL'
    //     }
    // },
};
window.gl_define_options = gl_define_options;

// UI settings on URL hash
// if (url_ui) {
//     // Match defined values to those passed on URL
//     for (var g in gl_define_options) {
//         for (var p in gl_define_options[g].options) {
//             if (url_ui.indexOf(gl_define_options[g].options[p]) > -1) {
//                 gl_define_options[g][g] = gl_define_options[g].options[p];
//             }
//         }
//     }
// }

Object.keys(gl_define_options).forEach(function(key) {
    gui.
        add(gl_define_options[key], key, gl_define_options[key].options).
        onChange(function(value) {
            setGLProgramDefines();
            updateURL();
        }).
        listen();
});

function setGLProgramDefines () {
    Object.keys(gl_define_options).forEach(function(key) {
        setGLProgramDefinesForOptionSet(gl_define_options[key][key], gl_define_options[key].options);
    });

    // TODO: replace with more generic render mode recompile - refreshModes?
    if (layer.renderer.compileShaders) {
        layer.renderer.compileShaders();
    }
    layer.renderer.dirty = true;
}

function setGLProgramDefinesForOptionSet (current_value, options) {
    for (var i in options) {
        Tangram.GL.Program.defines[options[i]] = ((options[i] == current_value) && options[i] != '');
    }
}

// Render/GL stats: http://spite.github.io/rstats/
// Activate with 'rstats' anywhere in options list in URL
if (url_ui && url_ui.indexOf('rstats') >= 0) {
    var glS = new glStats();
    glS.fractions = []; // turn this off till we need it

    var rS = new rStats({
        values: {
            frame: { caption: 'Total frame time (ms)', over: 5 },
            raf: { caption: 'Time since last rAF (ms)' },
            fps: { caption: 'Framerate (FPS)', below: 30 },
            rendertiles: { caption: 'Rendered tiles' },
            features: { caption: '# of geo features' },
            glbuffers: { caption: 'GL buffers (MB)' }
        },
        CSSPath : 'lib/',
        plugins: [glS]
    });

    // Move it to the bottom-left so it doesn't obscure zoom controls
    var rSDOM = document.querySelector('.rs-base');
    rSDOM.style.bottom = '0px';
    rSDOM.style.top = 'inherit';
}


/*** Map ***/

var map = L.map('map', {
    maxZoom: 20,
    inertia: false,
    keyboard: false
});
map.attributionControl.setPrefix('');

// Update URL hash on move
map.on('moveend', updateURL);
map.setView(map_start_location.slice(0, 2), map_start_location[2]);

// Resize map to window
function resizeMap () {
    document.getElementById('map').style.width = window.innerWidth + 'px';
    document.getElementById('map').style.height = window.innerHeight + 'px';
    map.invalidateSize(false);
}
window.addEventListener('resize', resizeMap);
resizeMap();


/*** Map layer ***/

var layer = Tangram.leafletLayer({
    vectorRenderer: tile_sources[tile_source].renderer,
    vectorTileSource: tile_sources[tile_source].source,
    vectorLayers: tile_sources[tile_source].layers,
    vectorStyles: tile_sources[tile_source].styles,
    numWorkers: 2,
    // debug: true,
    attribution: 'Map data &copy; OpenStreetMap contributors | <a href="https://github.com/bcamper/tangram">Source Code</a>',
    unloadInvisibleTiles: false,
    updateWhenIdle: false
});

// For easier debugging access
var renderer = layer.renderer;
window.layer = layer;
window.renderer = layer.renderer;
window.tiles = layer.renderer.tiles;

// GUI for layers
var layer_gui = gui.addFolder('Layers');
// layer_gui.open();
var layer_controls = {};
layer.renderer.layers.forEach(function(l) {
    if (layer.renderer.styles.layers[l.name] == null) {
        return;
    }

    layer_controls[l.name] = !(layer.renderer.styles.layers[l.name].visible == false);
    layer_gui.
        add(layer_controls, l.name).
        onChange(function(value) {
            layer.renderer.styles.layers[l.name].visible = value;
            layer.renderer.rebuildTiles();
        });
});

// Put current state on URL
function updateURL () {
    var map_latlng = map.getCenter();
    var url_options = [tile_source, map_latlng.lat, map_latlng.lng, map.getZoom()];

    if (rS) {
        url_options.push('rstats');
    }

    if (gl_mode_options.effect != '') {
        url_options.push('mode=' + gl_mode_options.effect);
    }

    // TODO: need to load these URL options on initial page load
    // Object.keys(gl_define_options).forEach(function(d) {
    //     if (gl_define_options[d][d] != '') {
    //         url_options.push(d + '=' + gl_define_options[d][d]);
    //     }
    // });

    window.location.hash = url_options.join(',');
}


/***** Render loop *****/

window.addEventListener('load', function () {
    layer.addTo(map);

    // Mode on URL?
    var url_mode;
    if (url_ui) {
        var re = new RegExp(/mode=(\w+)/);
        url_ui.forEach(function(u) {
            var match = u.match(re);
            url_mode = (match && match.length > 1 && match[1]);
        });
    }

    // var url_mode = (url_ui && url_ui.match(new RegExp(/mode=(\w+)/)));
    // url_mode = (url_mode && url_mode.length >= 2 && url_mode[1]);
    if (url_mode) {
        setRenderModeOptions(url_mode);
    }
    else {
        setGLProgramDefines();
    }


    if (osm_debug == true) {
        window.osm_layer =
            L.tileLayer(
                'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { opacity: 0.5 })
            .bringToFront()
            .addTo(map);
    }

    frame();
});

function frame () {
    if (rS != null) { // rstats
        rS('frame').start();
        // rS('raf').tick();
        rS('fps').frame();

        if (renderer.dirty) {
            glS.start();
        }
    }

    layer.render();

    if (rS != null) { // rstats
        rS('frame').end();
        rS('rendertiles').set(renderer.renderable_tiles_count);
        rS('glbuffers').set((renderer.getDebugSum('buffer_size') / (1024*1024)).toFixed(2));
        rS('features').set(renderer.getDebugSum('features'));
        rS().update();
    }

    requestAnimationFrame(frame);
}

// Cross-browser compatibility for requestAnimationFrame
(function requestAnimationFrameCompatibility () {
    if (window.requestAnimationFrame == undefined) {
        window.requestAnimationFrame = (function () {
            return (
                window.requestAnimationFrame       ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                window.oRequestAnimationFrame      ||
                window.msRequestAnimationFrame     ||
                function (callback) {
                   window.setTimeout(callback, 1000 / 60);
                }
            );
        })();
    }
}());

}());

</script>
</body>
</html>
