<!doctype html>
<!--
Tangram: real-time WebGL rendering for OpenStreetMap

http://github.com/bcamper/tangram
http://mapzen.com
-->
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Vector map</title>
<style>

body {
    margin: 0px;
    border: 0px;
    padding: 0px;
}

#map {
    background: rgba(0, 0, 0, 0);
}

<!-- For canvas feature picking demo -->
.label {
    width: 200px;
    margin-left: -100px;
    position: absolute;
    z-index: 10;
    text-align: center;
}

.labelInner {
    padding: 2px;
    background: white;
    opacity: 0.75;
}

</style>
<link rel="stylesheet" href="lib/leaflet-0.8-dev.css" />
</head>

<body>

<div id="map"></div>

<script src="lib/leaflet-0.8-dev.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="lib/rstats.js"></script>
<script src="lib/rstats.extras.js"></script>
<script src="dist/vector-map.debug.js"></script>

<script>

(function(){

var tile_source = 'mapzen'; // default source, can be overriden by URL

var tile_sources = {
    'mapzen': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-dev': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://vector.dev.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-local': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://localhost:8080/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-mvt': {
        source: {
            type: 'MapboxTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.mapbox'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-topojson': {
        source: {
            type: 'TopoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapzen-canvas': {
        source: {
            type:'GeoJSONTileSource',
            url: 'http://vector.mapzen.com/osm/all/{z}/{x}/{y}.json'
        },
        layers: 'demos/canvas_layers.js',
        styles: 'demos/canvas_styles.js',
        renderer: 'CanvasRenderer'
    },
    'osm': {
        source: {
            type: 'GeoJSONTileSource',
            url: 'http://tile.openstreetmap.us/vectiles-all/{z}/{x}/{y}.json'
        },
        layers: 'demos/gl_layers_json.js',
        styles: 'demos/gl_styles.js'
    },
    'mapbox': {
        source: {
            type: 'MapboxTileSource',
            url: 'http://{s:[a,b,c,d]}.tiles.mapbox.com/v3/mapbox.mapbox-streets-v4/{z}/{x}/{y}.vector.pbf',
            max_zoom: 14
        },
        layers: 'demos/gl_layers_mvt.js',
        styles: 'demos/gl_styles.js'
    }
};

var locations = {
    'London': [51.508, -0.105, 15],
    'New York': [40.70531887544228, -74.00976419448853, 16],
    'Seattle': [47.609722, -122.333056, 15]
};

var osm_debug = false;


/*** URL parsing ***/

// URL hash pattern is one of:
// #[source]
// #[lat],[lng],[zoom]
// #[source],[lat],[lng],[zoom]
// #[source],[location name]
var url_hash = window.location.hash.slice(1, window.location.hash.length).split(',');

// Get tile source from URL
if (url_hash.length >= 1 && tile_sources[url_hash[0]] != null) {
    tile_source = url_hash[0];
}

// Get location from URL
var map_start_location = locations['New York'];
if (url_hash.length == 3) {
    map_start_location = url_hash.slice(0, 3);
}
if (url_hash.length > 3) {
    map_start_location = url_hash.slice(1, 4);
}
else if (url_hash.length == 2) {
    map_start_location = locations[url_hash[1]];
}


/***** GUI/debug controls *****/

var gl_controls = {
    projection: {
        projection: 'PROJECTION_PERSPECTIVE',
        options: {
            'None': '',
            'Perspective': 'PROJECTION_PERSPECTIVE',
            'Isometric': 'PROJECTION_ISOMETRIC',
            'Pop-Up': 'PROJECTION_POPUP'
        }
    },
    lighting_style: {
        lighting_style: 'LIGHTING_POINT',
        options: {
            'None': '',
            'Gradient': 'LIGHTING_POINT',
            'Flat': 'LIGHTING_DIRECTION',
            'Night': 'LIGHTING_NIGHT'
        }
    },
    lighting_mode: {
        lighting_mode: 'LIGHTING_PIXEL',
        options: {
            'Per-Vertex': 'LIGHTING_VERTEX',
            'Per-Pixel': 'LIGHTING_PIXEL'
        }
    },
    effect: {
        effect: '',
        options: {
            'None': '',
            'Elevator': 'ANIMATION_ELEVATOR',
            'Wave': 'ANIMATION_WAVE',
            'Water animation': 'EFFECT_NOISE_ANIMATED',
            'Spotlight': 'EFFECT_SPOTLIGHT',
            'Color bleed': 'EFFECT_COLOR_BLEED'
        },
        animated: [
            'ANIMATION_ELEVATOR',
            'ANIMATION_WAVE',
            'EFFECT_NOISE_ANIMATED',
            'EFFECT_COLOR_BLEED'
        ]
    }
};
window.gl_controls = gl_controls;

// UI settings on URL hash
if (url_hash.length > 4) {
    var url_ui = url_hash.slice(4);

    // Match defined values to those passed on URL
    for (var g in gl_controls) {
        for (var p in gl_controls[g].options) {
            if (url_ui.indexOf(gl_controls[g].options[p]) > -1) {
                gl_controls[g][g] = gl_controls[g].options[p];
            }
        }
    }
}

var gui = new dat.GUI({ autoPlace: true });
gui.domElement.parentNode.style.zIndex = 5;
// document.body.insertBefore(gui.domElement, document.body.firstChild);
window.gui = gui;

// GUI for GL rendering options
Object.keys(gl_controls).forEach(function(key) {
    gl_controls[key].control = gui.add(gl_controls[key], key, gl_controls[key].options);
    gl_controls[key].control.onChange(function(value) {
        setGLProgramDefines();
    });
});

function setGLProgramDefines () {
    var animated = false;

    Object.keys(gl_controls).forEach(function(key) {
        setGLProgramDefinesForOptionSet(gl_controls[key][key], gl_controls[key].options);

        // Animated?
        if (gl_controls[key].animated && gl_controls[key].animated.indexOf(gl_controls[key][key]) > -1) {
            animated = true;
        }
    });
    // layer.renderer.animated = animated; // TODO: cleanup, this is handled by renderer now by examining active modes

    if (layer.renderer.compileShaders) {
        layer.renderer.compileShaders();
    }
    layer.renderer.dirty = true;
}

function setGLProgramDefinesForOptionSet (current_value, options) {
    for (var i in options) {
        Tangram.GL.Program.defines[options[i]] = ((options[i] == current_value) && options[i] != '');
    }
}

// Render/GL stats: http://spite.github.io/rstats/
// Activate with 'rstats' anywhere in options list in URL
if (url_ui && url_ui.indexOf('rstats') >= 0) {
    var glS = new glStats();
    glS.fractions = []; // turn this off till we need it

    var rS = new rStats({
        values: {
            frame: { caption: 'Total frame time (ms)', over: 5 },
            raf: { caption: 'Time since last rAF (ms)' },
            fps: { caption: 'Framerate (FPS)', below: 30 },
            rendertiles: { caption: 'Rendered tiles' },
            features: { caption: '# of geo features' },
            glbuffers: { caption: 'GL buffers (MB)' }
        },
        CSSPath : 'lib/',
        plugins: [glS]
    });

    // Move it to the bottom-left so it doesn't obscure zoom controls
    var rSDOM = document.querySelector('.rs-base');
    rSDOM.style.bottom = '0px';
    rSDOM.style.top = 'inherit';
}


/*** Map ***/

var map = L.map('map', {
    maxZoom: 20,
    inertia: false,
    keyboard: false
});
map.attributionControl.setPrefix('');

// Update URL hash on move
map.on('moveend', function () {
    var map_latlng = map.getCenter();
    var url_options = [tile_source, map_latlng.lat, map_latlng.lng, map.getZoom()];
    if (rS) {
        url_options.push('rstats');
    }
    window.location.hash = url_options.join(',');
});

map.setView(map_start_location.slice(0, 2), map_start_location[2]);

// Resize map to window
function resizeMap () {
    document.getElementById('map').style.width = window.innerWidth + 'px';
    document.getElementById('map').style.height = window.innerHeight + 'px';
    map.invalidateSize(false);
}
window.addEventListener('resize', resizeMap);
resizeMap();


/*** Map layer ***/

var layer = Tangram.leafletLayer({
    vectorRenderer: tile_sources[tile_source].renderer,
    vectorTileSource: tile_sources[tile_source].source,
    vectorLayers: tile_sources[tile_source].layers,
    vectorStyles: tile_sources[tile_source].styles,
    numWorkers: 2,
    // debug: true,
    attribution: 'Map data &copy; OpenStreetMap contributors | <a href="https://github.com/bcamper/tangram">Source Code</a>',
    unloadInvisibleTiles: false,
    updateWhenIdle: false
});

// For easier debugging access
window.layer = layer;
window.renderer = layer.renderer;
window.tiles = layer.renderer.tiles;

// GUI for layers
var layer_gui = gui.addFolder('Layers');
// layer_gui.open();
var layer_controls = {};
layer.renderer.layers.forEach(function(l) {
    if (layer.renderer.styles.layers[l.name] == null) {
        return;
    }

    layer_controls[l.name] = !(layer.renderer.styles.layers[l.name].visible == false);
    var control = layer_gui.add(layer_controls, l.name);

    control.onChange(function(value) {
        layer.renderer.styles.layers[l.name].visible = value;
        layer.renderer.rebuildTiles();
    });
});


/***** Render loop *****/

window.addEventListener('load', function () {
    layer.addTo(map);
    setGLProgramDefines();

    if (osm_debug == true) {
        window.osm_layer =
            L.tileLayer(
                'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { opacity: 0.5 })
            .bringToFront()
            .addTo(map);
    }

    frame();
});

function frame () {
    if (rS != null) { // rstats
        rS('frame').start();
        // rS('raf').tick();
        rS('fps').frame();

        if (renderer.dirty) {
            glS.start();
        }
    }

    layer.render();

    if (rS != null) { // rstats
        rS('frame').end();
        rS('rendertiles').set(renderer.renderable_tiles_count);
        rS('glbuffers').set((renderer.getDebugSum('buffer_size') / (1024*1024)).toFixed(2));
        rS('features').set(renderer.getDebugSum('features'));
        rS().update();
    }

    requestAnimationFrame(frame);
}

// Cross-browser compatibility for requestAnimationFrame
(function requestAnimationFrameCompatibility () {
    if (window.requestAnimationFrame == undefined) {
        window.requestAnimationFrame = (function () {
            return (
                window.requestAnimationFrame       ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                window.oRequestAnimationFrame      ||
                window.msRequestAnimationFrame     ||
                function (callback) {
                   window.setTimeout(callback, 1000 / 60);
                }
            );
        })();
    }
}());

}());

</script>
</body>
</html>
