<!doctype html>
<!--
Canvas Vector Map

Demo of client-side map rendering, using GeoJSON vector tiles as the remote source,
and the HTML Canvas API as the rendering engine. Uses Leaflet for standard slippy map functionality.

Brett Camper
-->
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Canvas vector map</title>
<style>

body {
    margin: 0px;
    border: 0px;
    padding: 0px;
}

.label {
    width: 200px;
    margin-left: -100px;
    position: absolute;
    z-index: 1;
    text-align: center;
}

.labelInner {
    padding: 2px;
    background: white;
    opacity: 0.75;
}

</style>
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.css" />
</head>

<body>

<div id="map"></div>
<script src="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.js"></script>

<script>

var tiles = {};

// Makeshift style-sheet
var styles = {
    water: {
        color: {
            default: [25, 150, 220]
        }
    },
    land: {
        color: {
            default: [32, 200, 125]
        }
    },
    buildings: {
        color: {
            default: [150, 150, 150]
        },
        border: [75, 75, 75],
        // dash: {
        //     default: [4, 2]
        // }
    },
    roads: {
        color: {
            'highway': [0, 0, 0],
            'major_road': [100, 100, 100],
            'minor_road': [150, 150, 150],
            'path': [255, 255, 255],
            'rail': [0, 0, 0]
        },
        size: {
            'highway': 5,
            'major_road': 2.5,
            'minor_road': 1.5,
            'path': 0.5,
            'rail': 0.5
        },
        dash: {
            // 'rail': [4, 2]
        }
    }
};

// Point
function Point (x, y)
{
    return {
        x: x,
        y: y
    };
}

Point.copy = function (p)
{
    if (p == null) {
        return null;
    }
    return { x: p.x, y: p.y };
};

// Projection constants
var tile_size = Point(256, 256);
var half_circumference_meters = 20037508.34;
var map_origin_meters = Point(-half_circumference_meters, half_circumference_meters);
var min_zoom_meters_per_pixel = 156543.0339;
var meters_per_pixel = [];
var max_zoom = 18;
for (var z=1; z <= max_zoom; z++) {
    meters_per_pixel[z] = min_zoom_meters_per_pixel / Math.pow(2, z);
}

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
function metersForTile (tile)
{
    return Point(
        (tile.x * tile_size.x * meters_per_pixel[tile.z]) + map_origin_meters.x,
        ((tile.y * tile_size.y * meters_per_pixel[tile.z]) * -1) + map_origin_meters.y
    );
}

// Convert mercator meters to lat-lng
function metersToLatLng (meters)
{
    var c = Point.copy(meters);

    c.x /= half_circumference_meters;
    c.y /= half_circumference_meters;

    c.y = (2 * Math.atan(Math.exp(c.y * Math.PI)) - (Math.PI / 2)) / Math.PI;

    c.x *= 180;
    c.y *= 180;

    return c;
}

// Run a transform function on each cooordinate in a GeoJSON geometry
function transformGeometry (geometry, transform)
{
    if (geometry.type == 'Point') {
        return transform(geometry.coordinates);
    }
    else if (geometry.type == 'LineString' || geometry.type == 'MultiPoint') {
        return geometry.coordinates.map(transform);
    }
    else if (geometry.type == 'Polygon' || geometry.type == 'MultiLineString') {
        return geometry.coordinates.map(function (coordinates) {
            return coordinates.map(transform);
        });
    }
    else if (geometry.type == 'MultiPolygon') {
        return geometry.coordinates.map(function (polygon) {
            return polygon.map(function (coordinates) {
                return coordinates.map(transform);
            });
        });
    }
    // TODO: support GeometryCollection
    return {};
}

// Renderers
var canvas_renderer = new CanvasRenderer();
var gl_renderer = new GLRenderer();

var renderers = [];
// renderers.push(canvas_renderer);
renderers.push(gl_renderer);

// Leaflet map
function resizeMap () {
    document.getElementById('map').style.width = window.innerWidth + 'px';
    document.getElementById('map').style.height = window.innerHeight + 'px';
}
window.addEventListener('resize', resizeMap);
resizeMap();

var map = L.map('map', { inertia: false });
map.attributionControl.setPrefix('');

// Get location from URL or use default
var locations = {
    'London': [51.508, -0.105],
    'New York': [40.7180764, -73.9790335]
};
var map_default_location = locations['London'];
var map_default_zoom = 15;
var url_latlng = window.location.hash.slice(1, window.location.hash.length).split(',');
if (url_latlng.length == 3) {
    map.setView([url_latlng[0], url_latlng[1]], url_latlng[2]);
}
else {
    map.setView(map_default_location, map_default_zoom);
}

map.on('moveend', function () {
    var map_latlng = map.getCenter();
    window.location.hash = [map_latlng.lat, map_latlng.lng, map.getZoom()].join(',');
});

var layer = L.tileLayer.canvas({
    async: true,
    maxZoom: max_zoom,
    attribution: '<a href="https://github.com/bcamper/canvas-map">Source Code</a>'
});

layer.on('tileunload', function (event) {
    var canvas = event.tile;
    var key = canvas.getAttribute('data-tile-key');
    delete tiles[key];
});

layer.drawTile = function(canvas, tilePoint, zoom) {
    var context = canvas.getContext('2d');
    canvas.style.background = 'rgb(200, 200, 200)';

    // Load tile
    var tile_url = 'http://tile.openstreetmap.us/vectiles-all/' + zoom + '/' + tilePoint.x + '/' + tilePoint.y + '.json';
    var req = new XMLHttpRequest();
    req.onload = function () {
        var tile = JSON.parse(req.response);
        tile.key = [tilePoint.x, tilePoint.y, zoom].join('/');
        canvas.setAttribute('data-tile-key', tile.key); // tile info for debugging

        // Calculate tile bounds
        // NB: This is a huge/fast hack since we only do projection at the tile corners and then linearly interpolate the main
        //     geometry to pixels within the tile. This isn't really visible at high zoom levels, but causes serious warping at lower zooms.
        tile.min = metersToLatLng(metersForTile({ x: tilePoint.x, y: tilePoint.y, z: zoom }));
        tile.max = metersToLatLng(metersForTile({ x: tilePoint.x + 1, y: tilePoint.y + 1, z: zoom }));

        renderTile(tile, context);
        layer.tileDrawn(canvas);
    };
    req.open('GET', tile_url, true /* async flag */);
    req.send();
}

layer.addTo(map);

</script>
</body>
</html>
