# Halftone shader adapted from: http://webstaff.itn.liu.se/~stegu/webglshadertutorial/shadertutorial.html
halftone:
    extends: polygons
    shaders:
        uniforms:
            # halftone_colored: false # boolean to flip colored dots on and off
        transforms:
            globals: |
                // uniform bool halftone_colored;

                const float dot_frequency = 100.4748637184972;

                // Antialiasing
                float aastep(float threshold, float value) {
                    const float scale = 2.;
                    const float y_rot = 0.;
                    float afwidth = dot_frequency * (1.0/200.0) / scale / cos(y_rot);
                    return smoothstep(threshold-afwidth, threshold+afwidth, value);
                }

            fragment: |
                // Distance to nearest point in a grid of
                // (frequency x frequency) points over the unit square
                // Scale dot size for a subset of zoom
                const float max_scale_zoom = 19.;
                const float min_scale_zoom = 17.;
                const float scale_zoom_factor = .25;
                float zoom_frequency = dot_frequency;
                zoom_frequency *= 1. + ((max_scale_zoom - clamp(u_map_zoom, min_scale_zoom, max_scale_zoom)) * scale_zoom_factor);

                // Sample based on screenspace
                const float pixel_scale = 695.; // arbitrary pixel_scale based on playing w/values
                vec2 st = gl_FragCoord.xy / pixel_scale;

                // But peg to map center so dots on ground plane stay in place as we move
                // (there's what looks like some floating point precision crawl, but it's not too bad)
                const float dot_wrap = 1000.;
                st += mod(u_map_center / u_meters_per_pixel, dot_wrap) / pixel_scale;

                // Rotate dot & find nearest dot distance
                vec2 st2 = mat2(0.707, -0.707, 0.707, 0.707) * st;
                vec2 nearest = 2.0 * fract(zoom_frequency * st2) - 1.0;
                float dist = length(nearest);

                // Modulate the size of the dots
                float radius = clamp(sqrt(1.0 - color.g), 0.001, 1.); // use green channel, clamp to avoid giant dot

                // Color mix
                const vec3 white = vec3(1.0, 1.0, 1.0);
                const vec3 black = vec3(0.0, 0.0, 0.0);
                // color = mix(black + (color * float(halftone_colored)), white, aastep(radius, dist));
                color = mix(black, white, aastep(radius, dist));

