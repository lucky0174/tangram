!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Tangram=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var Point = _dereq_('./point.js');
var Geo = _dereq_('./geo.js');
var VectorRenderer = _dereq_('./vector_renderer.js');

VectorRenderer.CanvasRenderer = CanvasRenderer;
CanvasRenderer.prototype = Object.create(VectorRenderer.prototype);

function CanvasRenderer (tile_source, layers, styles, options)
{
    VectorRenderer.call(this, 'CanvasRenderer', tile_source, layers, styles, options);

    // Selection info shown on hover
    this.selection_info = document.createElement('div');
    this.selection_info.setAttribute('class', 'label');
    this.selection_info.style.display = 'none';

    // For drawing multipolygons w/canvas composite operations
    this.cutout_context = document.createElement('canvas').getContext('2d');
}

// CanvasRenderer.prototype.addTile = function CanvasRendererAddTile (tile, tileDiv)
CanvasRenderer.prototype._tileWorkerCompleted = function (tile)
{
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    canvas.style.width = Geo.tile_size + 'px';
    canvas.style.width = Geo.tile_size + 'px';
    canvas.width = Math.round(Geo.tile_size * this.device_pixel_ratio);
    canvas.height = Math.round(Geo.tile_size * this.device_pixel_ratio);
    canvas.style.background = this.colorToString(this.styles.default);

    this.renderTile(tile, context);

    var tileDiv = document.querySelector("div[data-tile-key='" + tile.key + "']");
    tileDiv.appendChild(canvas);
};

// Scale a GeoJSON coordinate (2-element array) from [min, max] to tile pixels
// returns a copy of geometry.coordinates transformed into Points
CanvasRenderer.prototype.scaleGeometryToPixels = function scaleGeometryToPixels (geometry)
{
    var renderer = this;
    return Geo.transformGeometry(geometry, function (coordinates) {
        return Point(
            // Math.round((coordinates[0] - min.x) * Geo.tile_size / (max.x - min.x)), // rounding removes seams but causes aliasing
            // Math.round((coordinates[1] - min.y) * Geo.tile_size / (max.y - min.y))
            coordinates[0] * Geo.tile_size * renderer.device_pixel_ratio / VectorRenderer.tile_scale,
            coordinates[1] * Geo.tile_size * renderer.device_pixel_ratio / VectorRenderer.tile_scale * -1 // adjust for flipped y-coord
        );
    });
};

// Renders a line given as an array of Points
// line = [Point, Point, ...]
CanvasRenderer.prototype.renderLine = function renderLine (line, style, context)
{
    var segments = line;
    var color = style.color;
    var width = style.width;
    var dash = style.dash;

    var c = context;
    c.beginPath();
    c.strokeStyle = this.colorToString(color);
    c.lineCap = 'round';
    c.lineWidth = width;
    if (c.setLineDash) {
        if (dash) {
            c.setLineDash(dash.map(function (d) { return d * width; }));
        }
        else {
            c.setLineDash([]);
        }
    }

    for (var r=0; r < segments.length - 1; r ++) {
        var segment = [
            segments[r].x, segments[r].y,
            segments[r + 1].x, segments[r + 1].y
        ];

        c.moveTo(segment[0], segment[1]);
        c.lineTo(segment[2], segment[3]);
    };

    c.closePath();
    c.stroke();
};

// Renders a polygon given as an array of Points
// polygon = [Point, Point, ...]
CanvasRenderer.prototype.renderPolygon = function renderPolygon (polygon, style, context)
{
    var segments = polygon;
    var color = style.color;
    var width = style.width;
    var outline_color = style.outline && style.outline.color;
    var outline_width = style.outline && style.outline.width;
    var outline_dash = style.outline && style.outline.dash;

    var c = context;
    c.beginPath();
    c.fillStyle = this.colorToString(color);
    c.moveTo(segments[0].x, segments[0].y);

    for (var r=1; r < segments.length; r ++) {
        c.lineTo(segments[r].x, segments[r].y);
    };

    c.closePath();
    c.fill();

    // Outline
    if (outline_color && outline_width) {
        c.strokeStyle = this.colorToString(outline_color);
        c.lineCap = 'round';
        c.lineWidth = outline_width;
        if (c.setLineDash) {
            if (outline_dash) {
                c.setLineDash(outline_dash.map(function (d) { return d * outline_width; }));
            }
            else {
                c.setLineDash([]);
            }
        }
        c.stroke();
    }
};

// Renders a point given as a Point object
CanvasRenderer.prototype.renderPoint = function renderPoint (point, style, context)
{
    var color = style.color;
    var size = style.size;
    var outline_color = style.outline && style.outline.color;
    var outline_width = style.outline && style.outline.width;
    var outline_dash = style.outline && style.outline.dash;

    var c = context;
    c.fillStyle = this.colorToString(color);

    c.beginPath();
    c.arc(point.x, point.y, size, 0, 2 * Math.PI);
    c.closePath();
    c.fill();

    // Outline
    if (outline_color && outline_width) {
        c.strokeStyle = this.colorToString(outline_color);
        c.lineWidth = outline_width;
        if (c.setLineDash) {
            if (outline_dash) {
                c.setLineDash(outline_dash.map(function (d) { return d * outline_width; }));
            }
            else {
                c.setLineDash([]);
            }
        }
        c.stroke();
    }
};

CanvasRenderer.prototype.renderFeature = function renderFeature (feature, style, context)
{
    var g, h, polys;
    var geometry = feature.geometry;

    if (geometry.type == 'LineString') {
        this.renderLine(geometry.pixels, style, context);
    }
    else if (geometry.type == 'MultiLineString') {
        for (g=0; g < geometry.pixels.length; g++) {
            this.renderLine(geometry.pixels[g], style, context);
        }
    }
    else if (geometry.type == 'Polygon' || geometry.type == 'MultiPolygon') {
        if (geometry.type == 'Polygon') {
            polys = [geometry.pixels]; // treat Polygon as a degenerate MultiPolygon to avoid duplicating code
        }
        else {
            polys = geometry.pixels;
        }

        for (g=0; g < polys.length; g++) {
            // Polygons with holes:
            // Render to a separate canvas, using composite operations to cut holes out of polygon, then copy back to the main canvas
            if (polys[g].length > 1) {
                if (this.cutout_context.canvas.width != context.canvas.width || this.cutout_context.canvas.height != context.canvas.height) {
                    this.cutout_context.canvas.width = context.canvas.width;
                    this.cutout_context.canvas.height = context.canvas.height;
                }
                this.cutout_context.clearRect(0, 0, this.cutout_context.canvas.width, this.cutout_context.canvas.height);

                this.cutout_context.globalCompositeOperation = 'source-over';
                this.renderPolygon(polys[g][0], style, this.cutout_context);

                this.cutout_context.globalCompositeOperation = 'destination-out';
                for (h=1; h < polys[g].length; h++) {
                    this.renderPolygon(polys[g][h], style, this.cutout_context);
                }
                context.drawImage(this.cutout_context.canvas, 0, 0);

                // After compositing back to main canvas, draw outlines on holes
                if (style.outline && style.outline.color) {
                    for (h=1; h < polys[g].length; h++) {
                        this.renderLine(polys[g][h], style.outline, context);
                    }
                }
            }
            // Regular closed polygons
            else {
                this.renderPolygon(polys[g][0], style, context);
            }
        }
    }
    else if (geometry.type == 'Point') {
        this.renderPoint(geometry.pixels, style, context);
    }
    else if (geometry.type == 'MultiPoint') {
        for (g=0; g < geometry.pixels.length; g++) {
            this.renderPoint(geometry.pixels[g], style, context);
        }
    }
};

// Render a GeoJSON tile onto canvas
CanvasRenderer.prototype.renderTile = function renderTile (tile, context)
{
    var renderer = this;
    var style;

    // Selection rendering - off-screen canvas to render a collision map for feature selection
    var selection = { colors: {} };
    var selection_canvas = document.createElement('canvas');
    selection_canvas.style.width = Geo.tile_size + 'px';
    selection_canvas.style.width = Geo.tile_size + 'px';
    selection_canvas.width = Math.round(Geo.tile_size * this.device_pixel_ratio);
    selection_canvas.height = Math.round(Geo.tile_size * this.device_pixel_ratio);

    var selection_context = selection_canvas.getContext('2d');
    var selection_color;
    var selection_count = 0;

    // Render layers
    for (var t in renderer.layers) {
        var layer = renderer.layers[t];
        tile.layers[layer.name].features.forEach(function(feature) {
            // Scale local coords to tile pixels
            feature.geometry.pixels = this.scaleGeometryToPixels(feature.geometry, renderer.tile_min, renderer.tile_max);
            style = VectorRenderer.parseStyleForFeature(feature, this.styles[layer.name], tile);

            // Draw visible geometry
            if (layer.visible != false) {
                this.renderFeature(feature, style, context);
            }

            // Draw mask for interactivity
            // TODO: move selection filter logic to stylesheet
            // TODO: only alter styles that are explicitly different, don't manually copy style values by property name
            if (layer.selection == true && feature.properties.name != null && feature.properties.name != '') {
                selection_color = this.generateColor(selection.colors);
                selection_color.properties = feature.properties;
                selection_count++;
                this.renderFeature(feature, { color: selection_color.color, width: style.width, size: style.size }, selection_context);
            }
            else {
                // If this geometry isn't interactive, mask it out so geometry under it doesn't appear to pop through
                this.renderFeature(feature, { color: [0, 0, 0], width: style.width, size: style.size }, selection_context);
            }

        }, this);
    }

    // Selection events
    var selection_info = this.selection_info;
    if (selection_count > 0) {
        this.tiles[tile.key].selection = selection;

        selection.pixels = new Uint32Array(selection_context.getImageData(0, 0, selection_canvas.width, selection_canvas.height).data.buffer);

        // TODO: fire events on selection to enable custom behavior
        context.canvas.onmousemove = function (event) {
            var hit = { x: event.offsetX, y: event.offsetY }; // layerX/Y
            var off = (hit.y * renderer.device_pixel_ratio) * (Geo.tile_size * renderer.device_pixel_ratio) + (hit.x * renderer.device_pixel_ratio);
            var color = selection.pixels[off];
            var feature = selection.colors[color];
            if (feature != null) {
                context.canvas.style.cursor = 'crosshair';
                selection_info.style.left = (hit.x + 5) + 'px';
                selection_info.style.top = (hit.y + 5) + 'px';
                selection_info.innerHTML = '<span class="labelInner">' + feature.properties.name + /*' [' + feature.properties.kind + ']*/'</span>';
                selection_info.style.display = 'block';
                context.canvas.parentNode.appendChild(selection_info);
            }
            else {
                context.canvas.style.cursor = null;
                selection_info.style.display = 'none';
                if (selection_info.parentNode == context.canvas.parentNode) {
                    context.canvas.parentNode.removeChild(selection_info);
                }
            }
        };
    }
    else {
        context.canvas.onmousemove = function (event) {
            context.canvas.style.cursor = null;
            selection_info.style.display = 'none';
            if (selection_info.parentNode == context.canvas.parentNode) {
                context.canvas.parentNode.removeChild(selection_info);
            }
        };
    }
};

/* Color helpers */

// Transform color components in 0-1 range to html RGB string for canvas
CanvasRenderer.prototype.colorToString = function (color)
{
    return 'rgb(' + color.map(function(c) { return ~~(c * 256); }).join(',') + ')';
};

// Generates a random color not yet present in the provided hash of colors
CanvasRenderer.prototype.generateColor = function generateColor (color_map)
{
    var r, g, b, ir, ig, ib, key;
    color_map = color_map || {};
    while (true) {
        r = Math.random();
        g = Math.random();
        b = Math.random();

        ir = ~~(r * 256);
        ig = ~~(g * 256);
        ib = ~~(b * 256);
        key = (ir + (ig << 8) + (ib << 16) + (255 << 24)) >>> 0; // need unsigned right shift to convert to positive #

        if (color_map[key] === undefined) {
            color_map[key] = { color: [r, g, b] };
            break;
        }
    }
    return color_map[key];
};

if (module !== undefined) {
    module.exports = CanvasRenderer;
}

},{"./geo.js":2,"./point.js":8,"./vector_renderer.js":12}],2:[function(_dereq_,module,exports){
// Miscellaneous geo functions
var Point = _dereq_('./point.js');

var Geo = {};

// Projection constants
Geo.tile_size = 256;
Geo.half_circumference_meters = 20037508.342789244;
Geo.map_origin_meters = Point(-Geo.half_circumference_meters, Geo.half_circumference_meters);
Geo.min_zoom_meters_per_pixel = Geo.half_circumference_meters * 2 / Geo.tile_size; // min zoom draws world as 2 tiles wide
Geo.meters_per_pixel = [];
Geo.max_zoom = 20;
for (var z=0; z <= Geo.max_zoom; z++) {
    Geo.meters_per_pixel[z] = Geo.min_zoom_meters_per_pixel / Math.pow(2, z);
}

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
Geo.metersForTile = function (tile)
{
    return Point(
        (tile.x * Geo.tile_size * Geo.meters_per_pixel[tile.z]) + Geo.map_origin_meters.x,
        ((tile.y * Geo.tile_size * Geo.meters_per_pixel[tile.z]) * -1) + Geo.map_origin_meters.y
    );
};

// Convert mercator meters to lat-lng
Geo.metersToLatLng = function (meters)
{
    var c = Point.copy(meters);

    c.x /= Geo.half_circumference_meters;
    c.y /= Geo.half_circumference_meters;

    c.y = (2 * Math.atan(Math.exp(c.y * Math.PI)) - (Math.PI / 2)) / Math.PI;

    c.x *= 180;
    c.y *= 180;

    return c;
};

// Convert lat-lng to mercator meters
Geo.latLngToMeters = function(latlng)
{
    var c = Point.copy(latlng);

    // Latitude
    c.y = Math.log(Math.tan((c.y + 90) * Math.PI / 360)) / (Math.PI / 180);
    c.y = c.y * Geo.half_circumference_meters / 180;

    // Longitude
    c.x = c.x * Geo.half_circumference_meters / 180;

    return c;
};

// Run a transform function on each cooordinate in a GeoJSON geometry
Geo.transformGeometry = function (geometry, transform)
{
    if (geometry.type == 'Point') {
        return transform(geometry.coordinates);
    }
    else if (geometry.type == 'LineString' || geometry.type == 'MultiPoint') {
        return geometry.coordinates.map(transform);
    }
    else if (geometry.type == 'Polygon' || geometry.type == 'MultiLineString') {
        return geometry.coordinates.map(function (coordinates) {
            return coordinates.map(transform);
        });
    }
    else if (geometry.type == 'MultiPolygon') {
        return geometry.coordinates.map(function (polygon) {
            return polygon.map(function (coordinates) {
                return coordinates.map(transform);
            });
        });
    }
    // TODO: support GeometryCollection
    return {};
};

Geo.boxIntersect = function (b1, b2)
{
    return !(
        b2.sw.x > b1.ne.x ||
        b2.ne.x < b1.sw.x ||
        b2.sw.y > b1.ne.y ||
        b2.ne.y < b1.sw.y
    );
};

// Split the lines of a feature wherever two points are farther apart than a given tolerance
Geo.splitFeatureLines  = function (feature, tolerance) {
    var tolerance = tolerance || 0.001;
    var tolerance_sq = tolerance * tolerance;
    var geom = feature.geometry;
    var lines;

    if (geom.type == 'MultiLineString') {
        lines = geom.coordinates;
    }
    else if (geom.type =='LineString') {
        lines = [geom.coordinates];
    }
    else {
        return feature;
    }

    var split_lines = [];

    for (var s=0; s < lines.length; s++) {
        var seg = lines[s];
        var split_seg = [];
        var last_coord = null;
        var keep;

        for (var c=0; c < seg.length; c++) {
            var coord = seg[c];
            keep = true;

            if (last_coord != null) {
                var dist = (coord[0] - last_coord[0]) * (coord[0] - last_coord[0]) + (coord[1] - last_coord[1]) * (coord[1] - last_coord[1]);
                if (dist > tolerance_sq) {
                    // console.log("split lines at (" + coord[0] + ", " + coord[1] + "), " + Math.sqrt(dist) + " apart");
                    keep = false;
                }
            }

            if (keep == false) {
                split_lines.push(split_seg);
                split_seg = [];
            }
            split_seg.push(coord);

            last_coord = coord;
        }

        split_lines.push(split_seg);
        split_seg = [];
    }

    if (split_lines.length == 1) {
        geom.type = 'LineString';
        geom.coordinates = split_lines[0];
    }
    else {
        geom.type = 'MultiLineString';
        geom.coordinates = split_lines;
    }

    return feature;
};

if (module !== undefined) {
    module.exports = Geo;
}

},{"./point.js":8}],3:[function(_dereq_,module,exports){
// WebGL management and rendering functions
var GL = {};

// Setup a WebGL context
// If no canvas element is provided, one is created and added to the document body
GL.getContext = function getContext (canvas)
{
    var canvas = canvas;
    var fullscreen = false;
    if (canvas == null) {
        canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.zIndex = -1;
        document.body.appendChild(canvas);
        fullscreen = true;
    }

    gl = canvas.getContext('experimental-webgl', { /*preserveDrawingBuffer: true*/ }); // preserveDrawingBuffer needed for gl.readPixels (could be used for feature selection)
    if (!gl) {
        alert("Couldn't create WebGL context. Your browser probably doesn't support WebGL or it's turned off?");
        throw "Couldn't create WebGL context";
    }

    GL.resizeCanvas(gl, window.innerWidth, window.innerHeight);
    if (fullscreen == true) {
        window.addEventListener('resize', function () {
            GL.resizeCanvas(gl, window.innerWidth, window.innerHeight);
        });
    }

    GL.VertexArrayObject.init(gl); // TODO: this pattern doesn't support multiple active GL contexts, should that even be supported?

    return gl;
};

GL.resizeCanvas = function (gl, width, height)
{
    var device_pixel_ratio = window.devicePixelRatio || 1;
    gl.canvas.style.width = width + 'px';
    gl.canvas.style.height = height + 'px';
    gl.canvas.width = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.canvas.height = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};

// Compile & link a WebGL program from provided vertex and shader source elements
GL.createProgramFromElements = function GLcreateProgramFromElements (gl, vertex_shader_id, fragment_shader_id)
{
    var vertex_shader_source = document.getElementById(vertex_shader_id).textContent;
    var fragment_shader_source = document.getElementById(fragment_shader_id).textContent;
    var program = gl.createProgram();
    return GL.updateProgram(gl, program, vertex_shader_source, fragment_shader_source);
};

// Compile & link a WebGL program from provided vertex and shader source URLs
// NOTE: loads via synchronous XHR for simplicity, could be made async
GL.createProgramFromURLs = function GLcreateProgramFromURLs (gl, vertex_shader_url, fragment_shader_url)
{
    var program = gl.createProgram();
    return GL.updateProgramFromURLs(gl, program, vertex_shader_url, fragment_shader_url);
};

GL.updateProgramFromURLs = function GLUpdateProgramFromURLs (gl, program, vertex_shader_url, fragment_shader_url)
{
    var vertex_shader_source, fragment_shader_source;
    var req = new XMLHttpRequest();

    req.onload = function () { vertex_shader_source = req.response; };
    req.open('GET', vertex_shader_url + '?' + (+new Date()), false /* async flag */);
    req.send();

    req.onload = function () { fragment_shader_source = req.response; };
    req.open('GET', fragment_shader_url + '?' + (+new Date()), false /* async flag */);
    req.send();

    return GL.updateProgram(gl, program, vertex_shader_source, fragment_shader_source);
};

// Compile & link a WebGL program from provided vertex and fragment shader sources
// update a program if one is passed in. Create one if not. Alert and don't update anything if the shaders don't compile.
GL.updateProgram = function GLupdateProgram (gl, program, vertex_shader_source, fragment_shader_source)
{
    try {
        var vertex_shader = GL.createShader(gl, vertex_shader_source, gl.VERTEX_SHADER);
        var fragment_shader = GL.createShader(gl, '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment_shader_source, gl.FRAGMENT_SHADER);
    }
    catch(err)
    {
        alert(err);
        return program;
    }

    gl.useProgram(null);
    if (program != null) {
        var old_shaders = gl.getAttachedShaders(program);
        for(var i = 0; i < old_shaders.length; i++) {
            gl.detachShader(program, old_shaders[i]);
        }
    } else {
        program = gl.createProgram();
    }

    if (vertex_shader == null || fragment_shader == null) {
        return program;
    }

    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);

    gl.deleteShader(vertex_shader);
    gl.deleteShader(fragment_shader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var program_error =
            "WebGL program error:\n" +
            "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
            "ERROR: " + gl.getError() + "\n\n" +
            "--- Vertex Shader ---\n" + vertex_shader_source + "\n\n" +
            "--- Fragment Shader ---\n" + fragment_shader_source;
        throw program_error;
    }

    return program;
};

// Compile a vertex or fragment shader from provided source
GL.createShader = function GLcreateShader (gl, source, type)
{
    var shader = gl.createShader(type);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var shader_error =
            "WebGL shader error:\n" +
            (type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" +
            gl.getShaderInfoLog(shader);
        throw shader_error;
    }

    return shader;
};

// Thin GL program layer to cache uniform locations/values, do compile-time pre-processing (injecting #defines into shaders), etc.
GL.Program = function (gl, vertex_shader_source, fragment_shader_source, options)
{
    options = options || {};

    this.gl = gl;
    this.program = null;
    this.defines = options.defines || {}; // key/values inserted into shaders at compile-time
    this.uniforms = {}; // program locations of uniforms, set/updated at compile-time
    this.attribs = {}; // program locations of vertex attributes
    this.vertex_shader_source = vertex_shader_source;
    this.fragment_shader_source = fragment_shader_source;
    this.compile();
};

// Creates a program that will refresh from source URLs each time it is compiled
GL.Program.createProgramFromURLs = function (gl, vertex_shader_url, fragment_shader_url, options)
{
    var program = Object.create(GL.Program.prototype);

    program.vertex_shader_url = vertex_shader_url;
    program.fragment_shader_url = fragment_shader_url;

    program.updateVertexShaderSource = function () {
        var source;
        var req = new XMLHttpRequest();
        req.onload = function () { source = req.response; };
        req.open('GET', this.vertex_shader_url + '?' + (+new Date()), false /* async flag */);
        req.send();
        return source;
    };

    program.updateFragmentShaderSource = function () {
        var source;
        var req = new XMLHttpRequest();
        req.onload = function () { source = req.response; };
        req.open('GET', this.fragment_shader_url + '?' + (+new Date()), false /* async flag */);
        req.send();
        return source;
    };

    GL.Program.call(program, gl, null, null, options);
    return program;
};

// Global defines applied to all programs (duplicate properties for a specific program will take precedence)
GL.Program.defines = {};

GL.Program.prototype.compile = function ()
{
    // Optionally update sources
    if (typeof this.updateVertexShaderSource == 'function') {
        this.vertex_shader_source = this.updateVertexShaderSource();
    }
    if (typeof this.updateFragmentShaderSource == 'function') {
        this.fragment_shader_source = this.updateFragmentShaderSource();
    }

    // Inject defines (global, then program-specific)
    var defines = {};
    for (var d in GL.Program.defines) {
        defines[d] = GL.Program.defines[d];
    }
    for (var d in this.defines) {
        defines[d] = this.defines[d];
    }

    var define_str = "";
    for (var d in defines) {
        if (defines[d] == false) {
            continue;
        }
        else if (typeof defines[d] == 'boolean' && defines[d] == true) {
            define_str += "#define " + d + "\n";
        }
        else {
            define_str += "#define " + d + " " + defines[d] + "\n";
        }
    }
    this.processed_vertex_shader_source = define_str + this.vertex_shader_source;
    this.processed_fragment_shader_source = define_str + this.fragment_shader_source;

    // Compile & set uniforms to cached values
    this.program = GL.updateProgram(this.gl, this.program, this.processed_vertex_shader_source, this.processed_fragment_shader_source);
    this.gl.useProgram(this.program);
    this.refreshUniforms();
    this.refreshAttributes();
};

// ex: program.uniform('3f', 'position', x, y, z);
GL.Program.prototype.uniform = function (method, name) // method-appropriate arguments follow
{
    var uniform = (this.uniforms[name] = this.uniforms[name] || {});
    uniform.name = name;
    uniform.location = uniform.location || this.gl.getUniformLocation(this.program, name);
    uniform.method = 'uniform' + method;
    uniform.values = Array.prototype.slice.call(arguments, 2);
    this.updateUniform(name);
};

// Set a single uniform
GL.Program.prototype.updateUniform = function (name)
{
    var uniform = this.uniforms[name];
    if (uniform == null || uniform.location == null) {
        return;
    }
    this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.values)); // call appropriate GL uniform method and pass through arguments
};

// Refresh uniform locations and set to last cached values
GL.Program.prototype.refreshUniforms = function ()
{
    for (var u in this.uniforms) {
        this.uniforms[u].location = this.gl.getUniformLocation(this.program, u);
        this.updateUniform(u);
    }
};

GL.Program.prototype.refreshAttributes = function ()
{
    // var len = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
    // for (var i=0; i < len; i++) {
    //     var a = this.gl.getActiveAttrib(this.program, i);
    //     console.log(a);
    // }
    this.attribs = {};
};

// Get the location of a vertex attribute
GL.Program.prototype.attribute = function (name)
{
    var attrib = (this.attribs[name] = this.attribs[name] || {});
    if (attrib.location != null) {
        return attrib;
    }

    attrib.name = name;
    attrib.location = this.gl.getAttribLocation(this.program, name);

    // var info = this.gl.getActiveAttrib(this.program, attrib.location);
    // attrib.type = info.type;
    // attrib.size = info.size;

    return attrib;
};

// Triangulation using libtess.js port of gluTesselator
// https://github.com/brendankenny/libtess.js
try {
    GL.tesselator = (function initTesselator() {
        // Called for each vertex of tesselator output
        function vertexCallback(data, polyVertArray) {
            polyVertArray.push([data[0], data[1]]);
        }

        // Called when segments intersect and must be split
        function combineCallback(coords, data, weight) {
            return coords;
        }

        // Called when a vertex starts or stops a boundary edge of a polygon
        function edgeCallback(flag) {
            // No-op callback to force simple triangle primitives (no triangle strips or fans).
            // See: http://www.glprogramming.com/red/chapter11.html
            // "Since edge flags make no sense in a triangle fan or triangle strip, if there is a callback
            // associated with GLU_TESS_EDGE_FLAG that enables edge flags, the GLU_TESS_BEGIN callback is
            // called only with GL_TRIANGLES."
            // console.log('GL.tesselator: edge flag: ' + flag);
        }

        var tesselator = new libtess.GluTesselator();
        tesselator.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
        tesselator.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combineCallback);
        tesselator.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);

        // Brendan Kenny:
        // libtess will take 3d verts and flatten to a plane for tesselation
        // since only doing 2d tesselation here, provide z=1 normal to skip
        // iterating over verts only to get the same answer.
        // comment out to test normal-generation code
        tesselator.gluTessNormal(0, 0, 1);

        return tesselator;
    })();

    GL.triangulatePolygon = function GLTriangulate (contours)
    {
        var triangleVerts = [];
        GL.tesselator.gluTessBeginPolygon(triangleVerts);

        for (var i = 0; i < contours.length; i++) {
            GL.tesselator.gluTessBeginContour();
            var contour = contours[i];
            for (var j = 0; j < contour.length; j ++) {
                var coords = [contour[j][0], contour[j][1], 0];
                GL.tesselator.gluTessVertex(coords, coords);
            }
            GL.tesselator.gluTessEndContour();
        }

        GL.tesselator.gluTessEndPolygon();
        return triangleVerts;
    };
}
catch (e) {
    // console.log("libtess not defined!");
    // skip if libtess not defined
}

// Add one or more vertices to an array (destined to be used as a GL buffer), 'striping' each vertex with constant data
// Used for adding values that are often constant per geometry or polygon, like colors, normals (for polys sitting flat on map), layer and material info, etc.
GL.addVertices = function (vertices, vertex_data, vertex_constants)
{
    if (vertices != null && vertices.length > 0) {
        // Array of vertices
        if (typeof vertices[0] == 'object') {
            for (var v=0; v < vertices.length; v++) {
                vertex_data.push.apply(vertex_data, vertices[v]);
                if (vertex_constants) {
                    vertex_data.push.apply(vertex_data, vertex_constants);
                }
            }
        }
        // Single vertex
        else {
            vertex_data.push.apply(vertex_data, vertices);
            if (vertex_constants) {
                vertex_data.push.apply(vertex_data, vertex_constants);
            }
        }
    }
    return vertex_data;
};

// Creates a Vertex Array Object if the extension is available, or falls back on standard attribute calls
GL.VertexArrayObject = {};
GL.VertexArrayObject.disabled = false; // set to true to disable VAOs even if extension is available
GL.VertexArrayObject.bound_vao = null; // currently bound VAO

GL.VertexArrayObject.init = function (gl)
{
    if (GL.VertexArrayObject.ext == null) {
        if (GL.VertexArrayObject.disabled != true) {
            GL.VertexArrayObject.ext = gl.getExtension("OES_vertex_array_object");
        }

        if (GL.VertexArrayObject.ext != null) {
            console.log("Vertex Array Object extension available");
        }
        else if (GL.VertexArrayObject.disabled != true) {
            console.log("Vertex Array Object extension NOT available");
        }
        else {
            console.log("Vertex Array Object extension force disabled");
        }
    }
};

GL.VertexArrayObject.create = function (setup, teardown)
{
    var vao = {};
    vao.setup = setup;
    vao.teardown = teardown;

    var ext = GL.VertexArrayObject.ext;
    if (ext != null) {
        vao._vao = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vao._vao);
        vao.setup();
        ext.bindVertexArrayOES(null);
        if (typeof vao.teardown == 'function') {
            vao.teardown();
        }
    }
    else {
        vao.setup();
    }

    return vao;
};

GL.VertexArrayObject.bind = function (vao)
{
    var ext = GL.VertexArrayObject.ext;
    if (vao != null) {
        if (ext != null && vao._vao != null) {
            ext.bindVertexArrayOES(vao._vao);
            GL.VertexArrayObject.bound_vao = vao;
        }
        else {
            vao.setup();
        }
    }
    else {
        if (ext != null) {
            ext.bindVertexArrayOES(null);
        }
        else if (GL.VertexArrayObject.bound_vao != null && typeof GL.VertexArrayObject.bound_vao.teardown == 'function') {
            GL.VertexArrayObject.bound_vao.teardown();
        }
        GL.VertexArrayObject.bound_vao = null;
    }
};

if (module !== undefined) {
    module.exports = GL;
}

},{}],4:[function(_dereq_,module,exports){
var Vector = _dereq_('./vector.js');
var Point = _dereq_('./point.js');
var GL = _dereq_('./gl.js');

var GLBuilders = {};

GLBuilders.debug = false;

// Tesselate a flat 2D polygon with fixed height and add to GL vertex buffer
GLBuilders.buildPolygons = function GLBuildersBuildPolygons (polygons, z, vertex_data, options)
{
    options = options || {};

    var vertex_constants = [z, 0, 0, 1]; // provided z, and upwards-facing normal
    if (options.vertex_constants) {
        vertex_constants.push.apply(vertex_constants, options.vertex_constants);
    }

    var num_polygons = polygons.length;
    for (var p=0; p < num_polygons; p++) {
        var vertices = GL.triangulatePolygon(polygons[p]);
        GL.addVertices(vertices, vertex_data, vertex_constants);
    }

    return vertex_data;
};

// Tesselate and extrude a flat 2D polygon into a simple 3D model with fixed height and add to GL vertex buffer
GLBuilders.buildExtrudedPolygons = function GLBuildersBuildExtrudedPolygon (polygons, z, height, min_height, vertex_data, options)
{
    options = options || {};
    var min_z = z + (min_height || 0);
    var max_z = z + height;

    // Top
    GLBuilders.buildPolygons(polygons, max_z, vertex_data, { vertex_constants: options.vertex_constants });

    // Walls
    var wall_vertex_constants = [null, null, null]; // normals will be calculated below
    if (options.vertex_constants) {
        wall_vertex_constants.push.apply(wall_vertex_constants, options.vertex_constants);
    }

    var num_polygons = polygons.length;
    for (var p=0; p < num_polygons; p++) {
        var polygon = polygons[p];

        for (var q=0; q < polygon.length; q++) {
            var contour = polygon[q];

            for (var w=0; w < contour.length - 1; w++) {
                var wall_vertices = [];

                // Two triangles for the quad formed by each vertex pair, going from bottom to top height
                wall_vertices.push(
                    // Triangle
                    [contour[w+1][0], contour[w+1][1], max_z],
                    [contour[w+1][0], contour[w+1][1], min_z],
                    [contour[w][0], contour[w][1], min_z],
                    // Triangle
                    [contour[w][0], contour[w][1], min_z],
                    [contour[w][0], contour[w][1], max_z],
                    [contour[w+1][0], contour[w+1][1], max_z]
                );

                // Calc the normal of the wall from up vector and one segment of the wall triangles
                var normal = Vector.cross(
                    [0, 0, 1],
                    Vector.normalize([contour[w+1][0] - contour[w][0], contour[w+1][1] - contour[w][1], 0])
                );

                wall_vertex_constants[0] = normal[0];
                wall_vertex_constants[1] = normal[1];
                wall_vertex_constants[2] = normal[2];

                GL.addVertices(wall_vertices, vertex_data, wall_vertex_constants);
            }
        }
    }

    return vertex_data;
};

// Build tessellated triangles for a polyline
// Basically following the method described here for miter joints:
// http://artgrammer.blogspot.co.uk/2011/07/drawing-polylines-by-tessellation.html
GLBuilders.buildPolylines = function GLBuildersBuildPolylines (lines, z, width, vertex_data, options)
{
    options = options || {};
    options.closed_polygon = options.closed_polygon || false;
    options.remove_tile_edges = options.remove_tile_edges || false;

    var vertex_constants = [z, 0, 0, 1]; // provided z, and upwards-facing normal
    if (options.vertex_constants) {
        vertex_constants.push.apply(vertex_constants, options.vertex_constants);
    }

    // Line center - debugging
    if (GLBuilders.debug && options.vertex_lines) {
        var num_lines = lines.length;
        for (var ln=0; ln < num_lines; ln++) {
            var line = lines[ln];

            for (var p=0; p < line.length - 1; p++) {
                // Point A to B
                var pa = line[p];
                var pb = line[p+1];

                options.vertex_lines.push(
                    pa[0], pa[1], z + 0.001, 0, 0, 1, 1.0, 0, 0,
                    pb[0], pb[1], z + 0.001, 0, 0, 1, 1.0, 0, 0
                );
            }
        };
    }

    // Build triangles
    var vertices = [];
    var num_lines = lines.length;
    for (var ln=0; ln < num_lines; ln++) {
        var line = lines[ln];
        // Multiple line segments
        if (line.length > 2) {
            // Build anchors for line segments:
            // anchors are 3 points, each connecting 2 line segments that share a joint (start point, joint point, end point)

            var anchors = [];

            if (line.length > 3) {
                // Find midpoints of each line segment
                // For closed polygons, calculate all midpoints since segments will wrap around to first midpoint
                var mid = [];
                var p, pmax;
                if (options.closed_polygon == true) {
                    p = 0; // start on first point
                    pmax = line.length - 1;
                }
                // For open polygons, skip first midpoint and use line start instead
                else {
                    p = 1; // start on second point
                    pmax = line.length - 2;
                    mid.push(line[0]); // use line start instead of first midpoint
                }

                // Calc midpoints
                for (; p < pmax; p++) {
                    var pa = line[p];
                    var pb = line[p+1];
                    mid.push([(pa[0] + pb[0]) / 2, (pa[1] + pb[1]) / 2]);
                }

                // Same closed/open polygon logic as above: keep last midpoint for closed, skip for open
                var mmax;
                if (options.closed_polygon == true) {
                    mmax = mid.length;
                }
                else {
                    mid.push(line[line.length-1]); // use line end instead of last midpoint
                    mmax = mid.length - 1;
                }

                // Make anchors by connecting midpoints to line joints
                for (p=0; p < mmax; p++)  {
                    anchors.push([mid[p], line[(p+1) % line.length], mid[(p+1) % mid.length]]);
                }
            }
            else {
                // Degenerate case, a 3-point line is just a single anchor
                anchors = [[line[0], line[1], line[2]]];
            }

            for (var p=0; p < anchors.length; p++) {
                if (!options.remove_tile_edges) {
                    buildAnchor(anchors[p][0], anchors[p][1], anchors[p][2]);
                    // buildSegment(anchors[p][0], anchors[p][1]); // use these to draw extruded segments w/o join, for debugging
                    // buildSegment(anchors[p][1], anchors[p][2]);
                }
                else {
                    var edge1 = GLBuilders.isOnTileEdge(anchors[p][0], anchors[p][1]);
                    var edge2 = GLBuilders.isOnTileEdge(anchors[p][1], anchors[p][2]);
                    if (!edge1 && !edge2) {
                        buildAnchor(anchors[p][0], anchors[p][1], anchors[p][2]);
                    }
                    else if (!edge1) {
                        buildSegment(anchors[p][0], anchors[p][1]);
                    }
                    else if (!edge2) {
                        buildSegment(anchors[p][1], anchors[p][2]);
                    }
                }
            }
        }
        // Single 2-point segment
        else if (line.length == 2) {
            buildSegment(line[0], line[1]); // TODO: replace buildSegment with a degenerate form of buildAnchor? buildSegment is still useful for debugging
        }
    };

    GL.addVertices(vertices, vertex_data, vertex_constants);

    // Build triangles for a single line segment, extruded by the provided width
    function buildSegment (pa, pb) {
        var slope = Vector.normalize([(pb[1] - pa[1]) * -1, pb[0] - pa[0]]);

        var pa_outer = [pa[0] + slope[0] * width/2, pa[1] + slope[1] * width/2];
        var pa_inner = [pa[0] - slope[0] * width/2, pa[1] - slope[1] * width/2];

        var pb_outer = [pb[0] + slope[0] * width/2, pb[1] + slope[1] * width/2];
        var pb_inner = [pb[0] - slope[0] * width/2, pb[1] - slope[1] * width/2];

        vertices.push(
            pb_inner, pb_outer, pa_inner,
            pa_inner, pb_outer, pa_outer
        );
    }

    // Build triangles for a 3-point 'anchor' shape, consisting of two line segments with a joint
    // TODO: move these functions out of closures?
    function buildAnchor (pa, joint, pb) {
        // Inner and outer line segments for [pa, joint] and [joint, pb]
        var pa_slope = Vector.normalize([(joint[1] - pa[1]) * -1, joint[0] - pa[0]]);
        var pa_outer = [
            [pa[0] + pa_slope[0] * width/2, pa[1] + pa_slope[1] * width/2],
            [joint[0] + pa_slope[0] * width/2, joint[1] + pa_slope[1] * width/2]
        ];
        var pa_inner = [
            [pa[0] - pa_slope[0] * width/2, pa[1] - pa_slope[1] * width/2],
            [joint[0] - pa_slope[0] * width/2, joint[1] - pa_slope[1] * width/2]
        ];

        var pb_slope = Vector.normalize([(pb[1] - joint[1]) * -1, pb[0] - joint[0]]);
        var pb_outer = [
            [joint[0] + pb_slope[0] * width/2, joint[1] + pb_slope[1] * width/2],
            [pb[0] + pb_slope[0] * width/2, pb[1] + pb_slope[1] * width/2]
        ];
        var pb_inner = [
            [joint[0] - pb_slope[0] * width/2, joint[1] - pb_slope[1] * width/2],
            [pb[0] - pb_slope[0] * width/2, pb[1] - pb_slope[1] * width/2]
        ];

        // Miter join - solve for the intersection between the two outer line segments
        var intersection = Vector.lineIntersection(pa_outer[0], pa_outer[1], pb_outer[0], pb_outer[1]);
        var line_debug = null;
        if (intersection != null) {
            var intersect_outer = intersection;

            // Cap the intersection point to a reasonable distance (as join angle becomes sharper, miter joint distance would approach infinity)
            var len_sq = Vector.lengthSq([intersect_outer[0] - joint[0], intersect_outer[1] - joint[1]]);
            var miter_len_max = 3; // multiplier on line width for max distance miter join can be from joint
            if (len_sq > (width * width * miter_len_max * miter_len_max)) {
                line_debug = 'distance';
                intersect_outer = Vector.normalize([intersect_outer[0] - joint[0], intersect_outer[1] - joint[1]]);
                intersect_outer = [
                    joint[0] + intersect_outer[0] * miter_len_max,
                    joint[1] + intersect_outer[1] * miter_len_max
                ]
            }

            var intersect_inner = [
                (joint[0] - intersect_outer[0]) + joint[0],
                (joint[1] - intersect_outer[1]) + joint[1]
            ];

            vertices.push(
                intersect_inner, intersect_outer, pa_inner[0],
                pa_inner[0], intersect_outer, pa_outer[0],

                pb_inner[1], pb_outer[1], intersect_inner,
                intersect_inner, pb_outer[1], intersect_outer
            );
        }
        else {
            // Line segments are parallel, use the first outer line segment as join instead
            line_debug = 'parallel';
            pa_inner[1] = pb_inner[0];
            pa_outer[1] = pb_outer[0];

            vertices.push(
                pa_inner[1], pa_outer[1], pa_inner[0],
                pa_inner[0], pa_outer[1], pa_outer[0],

                pb_inner[1], pb_outer[1], pb_inner[0],
                pb_inner[0], pb_outer[1], pb_outer[0]
            );
        }

        // Extruded inner/outer edges - debugging
        if (GLBuilders.debug && options.vertex_lines) {
            options.vertex_lines.push(
                pa_inner[0][0], pa_inner[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pa_inner[1][0], pa_inner[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,

                pb_inner[0][0], pb_inner[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pb_inner[1][0], pb_inner[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,

                pa_outer[0][0], pa_outer[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pa_outer[1][0], pa_outer[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,

                pb_outer[0][0], pb_outer[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pb_outer[1][0], pb_outer[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,

                pa_inner[0][0], pa_inner[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pa_outer[0][0], pa_outer[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,

                pa_inner[1][0], pa_inner[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pa_outer[1][0], pa_outer[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,

                pb_inner[0][0], pb_inner[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pb_outer[0][0], pb_outer[0][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,

                pb_inner[1][0], pb_inner[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0,
                pb_outer[1][0], pb_outer[1][1], z + 0.001, 0, 0, 1, 0, 1.0, 0
            );
        }

        if (GLBuilders.debug && line_debug && options.vertex_lines) {
            var dcolor;
            if (line_debug == 'parallel') {
                // console.log("!!! lines are parallel !!!");
                dcolor = [0, 1, 0];
            }
            else if (line_debug == 'distance') {
                // console.log("!!! miter intersection point exceeded allowed distance from joint !!!");
                dcolor = [1, 0, 0];
            }
            // console.log('OSM id: ' + feature.id); // TODO: if this function is moved out of a closure, this feature debug info won't be available
            // console.log([pa, joint, pb]);
            // console.log(feature);
            options.vertex_lines.push(
                pa[0], pa[1], z + 0.002,
                0, 0, 1, dcolor[0], dcolor[1], dcolor[2],
                joint[0], joint[1], z + 0.002,
                0, 0, 1, dcolor[0], dcolor[1], dcolor[2],
                joint[0], joint[1], z + 0.002,
                0, 0, 1, dcolor[0], dcolor[1], dcolor[2],
                pb[0], pb[1], z + 0.002,
                0, 0, 1, dcolor[0], dcolor[1], dcolor[2]
            );

            var num_lines = lines.length;
            for (var ln=0; ln < num_lines; ln++) {
                var line2 = lines[ln];

                for (var p=0; p < line2.length - 1; p++) {
                    // Point A to B
                    var pa = line2[p];
                    var pb = line2[p+1];

                    options.vertex_lines.push(
                        pa[0], pa[1], z + 0.0005,
                        0, 0, 1, 0, 0, 1.0,
                        pb[0], pb[1], z + 0.0005,
                        0, 0, 1, 0, 0, 1.0
                    );
                }
            };
        }
    }

    return vertex_data;
};

// Build a quad centered on a point
GLBuilders.buildQuads = function GLBuildersBuildQuads (points, width, height, addGeometry, options)
{
    var options = options || {};

    var num_points = points.length;
    for (var p=0; p < num_points; p++) {
        var point = points[p];

        var positions = [
            [point[0] - width/2, point[1] - height/2],
            [point[0] + width/2, point[1] - height/2],
            [point[0] + width/2, point[1] + height/2],

            [point[0] - width/2, point[1] - height/2],
            [point[0] + width/2, point[1] + height/2],
            [point[0] - width/2, point[1] + height/2],
        ];

        if (options.texcoords == true) {
            var texcoords = [
                [-1, -1],
                [1, -1],
                [1, 1],

                [-1, -1],
                [1, 1],
                [-1, 1]
            ];
        }

        var vertices = {
            positions: positions,
            texcoords: (options.texcoords && texcoords)
        };
        addGeometry(vertices);
    }
};

// Build native GL lines for a polyline
GLBuilders.buildLines = function GLBuildersBuildLines (lines, feature, layer, style, tile, z, vertex_data, options)
{
    options = options || {};

    var color = style.color;
    var width = style.width;

    var num_lines = lines.length;
    for (var ln=0; ln < num_lines; ln++) {
        var line = lines[ln];

        for (var p=0; p < line.length - 1; p++) {
            // Point A to B
            var pa = line[p];
            var pb = line[p+1];

            vertex_data.push(
                // Point A
                pa[0], pa[1], z,
                0, 0, 1, // flat surfaces point straight up
                color[0], color[1], color[2],
                // Point B
                pb[0], pb[1], z,
                0, 0, 1, // flat surfaces point straight up
                color[0], color[1], color[2]
            );
        }
    };

    return vertex_data;
};

/* Utility functions */

// Tests if a line segment (from point A to B) is nearly coincident with the edge of a tile
GLBuilders.isOnTileEdge = function (pa, pb, options)
{
    options = options || {};

    var tolerance_function = options.tolerance_function || GLBuilders.valuesWithinTolerance;
    var tolerance = options.tolerance || 1; // tweak this adjust if catching too few/many line segments near tile edges
    var tile_min = GLBuilders.tile_bounds[0];
    var tile_max = GLBuilders.tile_bounds[1];
    var edge = null;

    if (tolerance_function(pa[0], tile_min.x, tolerance) && tolerance_function(pb[0], tile_min.x, tolerance)) {
        edge = 'left';
    }
    else if (tolerance_function(pa[0], tile_max.x, tolerance) && tolerance_function(pb[0], tile_max.x, tolerance)) {
        edge = 'right';
    }
    else if (tolerance_function(pa[1], tile_min.y, tolerance) && tolerance_function(pb[1], tile_min.y, tolerance)) {
        edge = 'top';
    }
    else if (tolerance_function(pa[1], tile_max.y, tolerance) && tolerance_function(pb[1], tile_max.y, tolerance)) {
        edge = 'bottom';
    }
    return edge;
};

GLBuilders.setTileScale = function (scale)
{
    GLBuilders.tile_bounds = [
        Point(0, 0),
        Point(scale, -scale) // TODO: correct for flipped y-axis?
    ];
};

GLBuilders.valuesWithinTolerance = function (a, b, tolerance)
{
    tolerance = tolerance || 1;
    return (Math.abs(a - b) < tolerance);
};

// Build a zigzag line pattern for testing joins and caps
GLBuilders.buildZigzagLineTestPattern = function ()
{
    var min = Point(0, 0); // tile.min;
    var max = Point(4096, 4096); // tile.max;
    var g = {
        id: 123,
        geometry: {
            type: 'LineString',
            coordinates: [
                [min.x * 0.75 + max.x * 0.25, min.y * 0.75 + max.y * 0.25],
                [min.x * 0.75 + max.x * 0.25, min.y * 0.5 + max.y * 0.5],
                [min.x * 0.25 + max.x * 0.75, min.y * 0.75 + max.y * 0.25],
                [min.x * 0.25 + max.x * 0.75, min.y * 0.25 + max.y * 0.75],
                [min.x * 0.4 + max.x * 0.6, min.y * 0.5 + max.y * 0.5],
                [min.x * 0.5 + max.x * 0.5, min.y * 0.25 + max.y * 0.75],
                [min.x * 0.75 + max.x * 0.25, min.y * 0.25 + max.y * 0.75],
                [min.x * 0.75 + max.x * 0.25, min.y * 0.4 + max.y * 0.6]
            ]
        },
        properties: {
            kind: 'debug'
        }
    };
    // console.log(g.geometry.coordinates);
    return g;
};

if (module !== undefined) {
    module.exports = GLBuilders;
}

},{"./gl.js":3,"./point.js":8,"./vector.js":11}],5:[function(_dereq_,module,exports){
/*** Manage rendering for primitives ***/
var GL = _dereq_('./gl.js');

// Attribs are an array, in layout order, of: name, size, type, normalized
// ex: { name: 'position', size: 3, type: gl.FLOAT, normalized: false }
function GLGeometry (gl, gl_program, vertex_data, attribs, options)
{
    options = options || {};

    this.gl = gl;
    this.gl_program = gl_program;
    this.attribs = attribs;
    this.vertex_data = vertex_data; // Float32Array
    this.buffer = this.gl.createBuffer();
    this.draw_mode = options.draw_mode || this.gl.TRIANGLES;
    this.data_usage = options.data_usage || this.gl.STATIC_DRAW;

    // Calc vertex stride
    this.vertex_stride = 0;
    for (var a=0; a < this.attribs.length; a++) {
        var attrib = this.attribs[a];

        attrib.location = this.gl_program.attribute(attrib.name).location;
        attrib.byte_size = attrib.size;

        switch (attrib.type) {
            case this.gl.FLOAT:
            case this.gl.INT:
            case this.gl.UNSIGNED_INT:
                attrib.byte_size *= 4;
                break;
            case this.gl.SHORT:
            case this.gl.UNSIGNED_SHORT:
                attrib.byte_size *= 2;
                break;
        }

        attrib.offset = this.vertex_stride;
        this.vertex_stride += attrib.byte_size;
    }

    this.vertex_count = this.vertex_data.byteLength / this.vertex_stride;

    this.vao = GL.VertexArrayObject.create(function() {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.setup();
    }.bind(this));

    this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertex_data, this.data_usage);
}

GLGeometry.prototype.setup = function ()
{
    for (var a=0; a < this.attribs.length; a++) {
        var attrib = this.attribs[a];
        this.gl.enableVertexAttribArray(attrib.location);
        this.gl.vertexAttribPointer(attrib.location, attrib.size, attrib.type, attrib.normalized, this.vertex_stride, attrib.offset);
    }
};

GLGeometry.prototype.render = function ()
{
    this.gl.useProgram(this.gl_program.program);
    GL.VertexArrayObject.bind(this.vao);

    if (typeof this._render == 'function') {
        this._render();
    }

    // TODO: support element array mode
    this.gl.drawArrays(this.draw_mode, 0, this.vertex_count);
    GL.VertexArrayObject.bind(null);
};

GLGeometry.prototype.destroy = function ()
{
    console.log("GLGeometry.destroy: delete buffer of size " + this.vertex_data.byteLength);
    this.gl.deleteBuffer(this.buffer);
    delete this.vertex_data;
};

// Draws a set of triangles
GLTriangles.prototype = Object.create(GLGeometry.prototype);

function GLTriangles (gl, gl_program, vertex_data)
{
    GLGeometry.call(this, gl, gl_program, vertex_data, [
        { name: 'position', size: 3, type: gl.FLOAT, normalized: false },
        { name: 'normal', size: 3, type: gl.FLOAT, normalized: false },
        { name: 'color', size: 3, type: gl.FLOAT, normalized: false },
        { name: 'layer', size: 1, type: gl.FLOAT, normalized: false }
    ]);
    this.geometry_count = this.vertex_count / 3;
}

// Draws a set of points as quads, intended to be rendered as distance fields
GLPolyPoints.prototype = Object.create(GLGeometry.prototype);

function GLPolyPoints (gl, gl_program, vertex_data)
{
    GLGeometry.call(this, gl, gl_program, vertex_data, [
        { name: 'position', size: 3, type: gl.FLOAT, normalized: false },
        { name: 'texcoord', size: 2, type: gl.FLOAT, normalized: false },
        { name: 'color', size: 3, type: gl.FLOAT, normalized: false },
        { name: 'layer', size: 1, type: gl.FLOAT, normalized: false }
    ]);
    this.geometry_count = this.vertex_count / 3;
}

// Draws a set of lines
// Shares all characteristics with triangles except for draw mode
GLLines.prototype = Object.create(GLTriangles.prototype);

function GLLines (gl, gl_program, vertex_data, options)
{
    options = options || {};
    GLTriangles.call(this, gl, program, vertex_data);
    this.draw_mode = this.gl.LINES;
    this.line_width = options.line_width || 2;
    this.geometry_count = this.vertex_count / 2;
}

GLLines.prototype._render = function ()
{
    this.gl.lineWidth(this.line_width);
    if (typeof GLTriangles.prototype._render == 'function') {
        GLTriangles.prototype._render.call(this);
    }
};

if (module !== undefined) {
    module.exports = {
        GLGeometry: GLGeometry,
        GLTriangles: GLTriangles,
        GLPolyPoints: GLPolyPoints,
        GLLines: GLLines
    };
}

},{"./gl.js":3}],6:[function(_dereq_,module,exports){
var Point = _dereq_('./point.js');
var Geo = _dereq_('./geo.js');
var VectorRenderer = _dereq_('./vector_renderer.js');

var GL = _dereq_('./gl.js');
var GLBuilders = _dereq_('./gl_builders.js');
var GLGeometry = _dereq_('./gl_geom.js').GLGeometry;
var GLTriangles = _dereq_('./gl_geom.js').GLTriangles;
var GLPolyPoints = _dereq_('./gl_geom.js').GLPolyPoints;
var GLLines = _dereq_('./gl_geom.js').GLLines;

VectorRenderer.GLRenderer = GLRenderer;
GLRenderer.prototype = Object.create(VectorRenderer.prototype);
GLRenderer.debug = false;

GLRenderer.shader_sources = _dereq_('./shaders/gl_shaders.js');

function GLRenderer (tile_source, layers, styles, options)
{
    var options = options || {};

    VectorRenderer.call(this, 'GLRenderer', tile_source, layers, styles, options);

    GLBuilders.setTileScale(VectorRenderer.tile_scale);
    GL.Program.defines.TILE_SCALE = VectorRenderer.tile_scale + '.0';

    this.container = options.container;
    this.continuous_animation = false; // request redraw every frame
}

GLRenderer.prototype._init = function GLRendererInit ()
{
    this.container = this.container || document.body;
    this.canvas = document.createElement('canvas');
    this.canvas.style.position = 'absolute';
    this.canvas.style.top = 0;
    this.canvas.style.left = 0;
    this.canvas.style.zIndex = -1;
    this.container.appendChild(this.canvas);

    this.gl = GL.getContext(this.canvas);

    var renderer = this;

    this.render_modes = {
        'polygons': {
            gl_program: new GL.Program(this.gl, GLRenderer.shader_sources['polygon_vertex'], GLRenderer.shader_sources['polygon_fragment']),
            makeGLGeometry: function (vertex_data) {
                return new GLTriangles(renderer.gl, this.gl_program, vertex_data);
            }
        },
        'polygons_noise': {
            gl_program: new GL.Program(this.gl, GLRenderer.shader_sources['polygon_vertex'], GLRenderer.shader_sources['polygon_fragment'], { defines: { 'EFFECT_NOISE_TEXTURE': true, 'EFFECT_NOISE_ANIMATABLE': true } }),
            makeGLGeometry: function (vertex_data) {
                return new GLTriangles(renderer.gl, this.gl_program, vertex_data);
            }
        },
        'points': {
            // TODO: replace relative shader paths with a better auto-pathing system
            // gl_program: new GL.Program.createProgramFromURLs(this.gl, VectorRenderer.library_base_url + '../shaders/point_vertex.glsl', VectorRenderer.library_base_url + '../shaders/point_fragment.glsl', { defines: { 'EFFECT_SCREEN_COLOR': true } }),
            gl_program: new GL.Program(this.gl, GLRenderer.shader_sources['point_vertex'], GLRenderer.shader_sources['point_fragment'], { defines: { 'EFFECT_SCREEN_COLOR': true } }),
            makeGLGeometry: function (vertex_data) {
                return new GLPolyPoints(renderer.gl, this.gl_program, vertex_data);
            }
        }
    };

    this.resizeMap(this.container.clientWidth, this.container.clientHeight);

    // this.zoom_step = 0.02; // for fractional zoom user adjustment
    this.start_time = +new Date();
    this.last_render_count = null;
    this.initInputHandlers();
};

// Determine a Z value that will stack features in a "painter's algorithm" style, first by layer, then by draw order within layer
// Features are assumed to be already sorted in desired draw order by the layer pre-processor
GLRenderer.calculateZ = function (layer, tile, layer_offset, feature_offset)
{
    // var layer_offset = layer_offset || 0;
    // var feature_offset = feature_offset || 0;
    var z = 0; // TODO: made this a no-op until revisiting where it should live - one-time calc here, in vertex layout/shader, etc.
    return z;
};

// Process geometry for tile - called by web worker
GLRenderer.addTile = function (tile, layers, styles)
{
    var layer, style, feature, z, mode;
    var vertex_data = {};

    // Join line test pattern
    // if (GLRenderer.debug) {
    //     tile.layers['roads'].features.push(GLRenderer.buildZigzagLineTestPattern());
    // }

    // Build raw geometry arrays
    tile.debug.features = 0;
    for (var ln=0; ln < layers.length; ln++) {
        layer = layers[ln];

        // Skip layers with no styles defined
        if (styles[layer.name] == null) {
            continue;
        }

        if (tile.layers[layer.name] != null) {
            var num_features = tile.layers[layer.name].features.length;

            // Rendering reverse order aka top to bottom
            for (var f = num_features-1; f >= 0; f--) {
                feature = tile.layers[layer.name].features[f];
                z = GLRenderer.calculateZ(layer, tile);
                style = VectorRenderer.parseStyleForFeature(feature, styles[layer.name], tile);

                // Skip feature?
                if (style == null) {
                    continue;
                }

                // First feature in this render mode?
                mode = style.render_mode;
                if (vertex_data[mode] == null) {
                    vertex_data[mode] = [];
                }

                // DEBUGGING line/tile intersections returned as points
                // #mapzen,40.74733011589617,-73.97535145282747,17
                // if (feature.id == 157964813 && feature.geometry.type == 'Point') {
                //     style.color = [1, 1, 0];
                //     style.size = Style.width.pixels(10, tile);
                // }

                var vertex_constants = [
                    style.color[0], style.color[1], style.color[2],
                    ln
                    // TODO: add material info, etc.
                ];

                if (style.outline.color) {
                    var outline_vertex_constants = [
                        style.outline.color[0], style.outline.color[1], style.outline.color[2],
                        ln - 0.5 // outlines sit between layers, underneath current layer but above the one below
                    ];
                }

                var points = null,
                    lines = null,
                    polygons = null;

                if (feature.geometry.type == 'Polygon') {
                    polygons = [feature.geometry.coordinates];
                }
                else if (feature.geometry.type == 'MultiPolygon') {
                    polygons = feature.geometry.coordinates;
                }
                else if (feature.geometry.type == 'LineString') {
                    lines = [feature.geometry.coordinates];
                }
                else if (feature.geometry.type == 'MultiLineString') {
                    lines = feature.geometry.coordinates;
                }
                else if (feature.geometry.type == 'Point') {
                    points = [feature.geometry.coordinates];
                }
                else if (feature.geometry.type == 'MultiPoint') {
                    points = feature.geometry.coordinates;
                }

                if (polygons != null) {
                    // Extruded polygons (e.g. 3D buildings)
                    if (style.extrude && style.height) {
                        GLBuilders.buildExtrudedPolygons(polygons, z, style.height, style.min_height, vertex_data[mode], { vertex_constants: vertex_constants });
                    }
                    // Regular polygons
                    else {
                        GLBuilders.buildPolygons(polygons, z, vertex_data[mode], { vertex_constants: vertex_constants });

                        // var polygon_vertex_constants = [z, 0, 0, 1].concat(vertex_constants); // upwards-facing normal
                        // GLBuilders.buildPolygons2(
                        //     polygons,
                        //     function (vertices) {
                        //         GL.addVertices(vertices.positions, vertex_data[mode], polygon_vertex_constants);
                        //     }
                        // );
                    }

                    // Polygon outlines
                    if (style.outline.color && style.outline.width) {
                        for (var mpc=0; mpc < polygons.length; mpc++) {
                            GLBuilders.buildPolylines(polygons[mpc], GLRenderer.calculateZ(layer, tile, -0.5), style.outline.width, vertex_data[mode], { closed_polygon: true, remove_tile_edges: true, vertex_constants: outline_vertex_constants });
                        }
                    }
                }

                if (lines != null) {
                    GLBuilders.buildPolylines(lines, z, style.width, vertex_data[mode], { vertex_constants: vertex_constants });

                    // Line outlines
                    if (style.outline.color && style.outline.width) {
                        GLBuilders.buildPolylines(lines, GLRenderer.calculateZ(layer, tile, -0.5), style.width + 2 * style.outline.width, vertex_data[mode], { vertex_constants: outline_vertex_constants });
                    }
                }

                if (points != null) {
                    // console.log(JSON.stringify(feature));
                    // NOTE: adding to z to experiment with "floating" POIs
                    var point_vertex_constants = [z + 1, 0, 0, 1].concat(vertex_constants); // upwards-facing normal
                    GLBuilders.buildQuads(
                        points, style.size * 2, style.size * 2,
                        function (vertices) {
                            var vs = vertices.positions;

                            // Alternate vertex layout for 'points' shader
                            if (mode == 'points') {
                                point_vertex_constants = vertex_constants;

                                for (var v in vertices.positions) {
                                    vs[v] = vertices.positions[v].concat(z+ 1, vertices.texcoords[v]);
                                }
                            }

                            // GL.addVertices(vertices.positions, vertex_data[mode], point_vertex_constants);
                            GL.addVertices(vs, vertex_data[mode], point_vertex_constants);
                        },
                        { texcoords: (mode == 'points') }
                    );
                }

                tile.debug.features++;
            }
        }
    }

    tile.vertex_data = {};
    for (var s in vertex_data) {
        tile.vertex_data[s] = new Float32Array(vertex_data[s]);
    }

    return tile;
};

// Called on main thread when a web worker completes processing for a single tile
GLRenderer.prototype._tileWorkerCompleted = function (tile)
{
    var vertex_data = tile.vertex_data;

    // Create GL geometry objects
    tile.gl_geometry = {};

    for (var s in vertex_data) {
        tile.gl_geometry[s] = this.render_modes[s].makeGLGeometry(vertex_data[s]);
    }

    tile.debug.geometries = 0;
    tile.debug.buffer_size = 0;
    for (var p in tile.gl_geometry) {
        tile.debug.geometries += tile.gl_geometry[p].geometry_count;
        tile.debug.buffer_size += tile.gl_geometry[p].vertex_data.byteLength;
    }

    tile.debug.geom_ratio = (tile.debug.geometries / tile.debug.features).toFixed(1);

    // Selection - experimental/future
    // var gl_renderer = this;
    // var pixel = new Uint8Array(4);
    // tileDiv.onmousemove = function (event) {
    //     // console.log(event.offsetX + ', ' + event.offsetY + ' | ' + parseInt(tileDiv.style.left) + ', ' + parseInt
    //     var p = Point(
    //         event.offsetX + parseInt(tileDiv.style.left),
    //         event.offsetY + parseInt(tileDiv.style.top)
    //     );
    //     gl_renderer.gl.readPixels(p.x, p.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    //     console.log(p.x + ', ' + p.y + ': (' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ', ' + pixel[3] + ')')
    // };

    delete tile.vertex_data; // TODO: might want to preserve this for rebuilding geometries when styles/etc. change?
};

GLRenderer.prototype.removeTile = function GLRendererRemoveTile (key)
{
    if (this.map_zooming == true) {
        return; // short circuit tile removal, GL renderer will sweep out tiles by zoom level when zoom ends
    }

    var tile = this.tiles[key];

    if (tile != null && tile.gl_geometry != null) {
        for (var p in tile.gl_geometry) {
            tile.gl_geometry[p].destroy();
        }
        tile.gl_geometry = null;
    }
    VectorRenderer.prototype.removeTile.apply(this, arguments);
};

GLRenderer.prototype.preserve_tiles_within_zoom = 2;
GLRenderer.prototype.setZoom = function (zoom)
{
    // Schedule GL tiles for removal on zoom
    console.log("renderer.map_last_zoom: " + this.map_last_zoom);

    this.map_zooming = false;
    this.zoom = zoom;
    var below = this.zoom;
    var above = this.zoom;
    if (Math.abs(this.zoom - this.map_last_zoom) <= this.preserve_tiles_within_zoom) {
        if (this.zoom > this.map_last_zoom) {
            below = this.zoom - this.preserve_tiles_within_zoom;
        }
        else {
            above = this.zoom + this.preserve_tiles_within_zoom;
        }
    }
    this.removeTilesOutsideZoomRange(below, above);
    this.map_last_zoom = this.zoom;
    this.dirty = true; // calling because this is a full override of the parent class
};

GLRenderer.prototype.removeTilesOutsideZoomRange = function (below, above)
{
    below = Math.min(below, this.tile_source.max_zoom || below);
    above = Math.min(above, this.tile_source.max_zoom || above);

    console.log("removeTilesOutsideZoomRange [" + below + ", " + above + "])");
    var remove_tiles = [];
    for (var t in this.tiles) {
        var tile = this.tiles[t];
        if (tile.coords.z < below || tile.coords.z > above) {
            remove_tiles.push(t);
        }
    }
    for (var r=0; r < remove_tiles.length; r++) {
        var key = remove_tiles[r];
        console.log("removed " + key + " (outside range [" + below + ", " + above + "])");
        this.removeTile(key);
    }
};

// Overrides base class method (a no op)
GLRenderer.prototype.resizeMap = function (width, height)
{
    VectorRenderer.prototype.resizeMap.apply(this, arguments);

    this.css_size = { width: width, height: height };
    this.device_size = { width: Math.round(this.css_size.width * this.device_pixel_ratio), height: Math.round(this.css_size.height * this.device_pixel_ratio) };

    this.canvas.style.width = this.css_size.width + 'px';
    this.canvas.style.height = this.css_size.height + 'px';
    this.canvas.width = this.device_size.width;
    this.canvas.height = this.device_size.height;
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
};

GLRenderer.prototype._render = function GLRendererRender ()
{
    var gl = this.gl;

    this.input();

    // Reset frame state
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);

    // Render tiles grouped by renderg mode (GL program)
    var render_count = 0;
    for (var mode in this.render_modes) {
        var gl_program = this.render_modes[mode].gl_program;

        gl.useProgram(gl_program.program);

        // TODO: set these once per program, don't set when they haven't changed
        gl_program.uniform('2f', 'resolution', this.css_size.width, this.css_size.height);
        gl_program.uniform('1f', 'time', ((+new Date()) - this.start_time) / 1000);

        var center = Geo.latLngToMeters(Point(this.center.lng, this.center.lat));
        gl_program.uniform('2f', 'map_center', center.x, center.y);
        gl_program.uniform('1f', 'map_zoom', this.zoom); // Math.floor(this.zoom) + (Math.log((this.zoom % 1) + 1) / Math.LN2 // scale fractional zoom by log
        gl_program.uniform('1f', 'num_layers', this.layers.length);

        var meters_per_pixel = Geo.min_zoom_meters_per_pixel / Math.pow(2, this.zoom);
        var meter_zoom = Point(this.css_size.width / 2 * meters_per_pixel, this.css_size.height / 2 * meters_per_pixel);
        gl_program.uniform('2f', 'meter_zoom', meter_zoom.x, meter_zoom.y);

        // TODO: make a list of renderable tiles once per frame, outside this loop
        // Render tile GL geometries
        var capped_zoom = Math.min(~~this.zoom, this.tile_source.max_zoom || ~~this.zoom);
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (tile.loaded == true &&
                tile.visible == true &&
                Math.min(tile.coords.z, this.tile_source.max_zoom || tile.coords.z) == capped_zoom) {

                if (tile.gl_geometry[mode] != null) {
                    gl_program.uniform('2f', 'tile_min', tile.min.x, tile.min.y);
                    gl_program.uniform('2f', 'tile_max', tile.max.x, tile.max.y);

                    tile.gl_geometry[mode].render();
                    render_count += tile.gl_geometry[mode].geometry_count;
                }
            }
        }
    }

    if (render_count != this.last_render_count) {
        console.log("rendered " + render_count + " primitives");
    }
    this.last_render_count = render_count;

    if (this.continuous_animation == true) {
        this.dirty = true;
    }

    return true;
};

// Sum of a debug property across tiles
GLRenderer.prototype.getDebugSum = function (prop, filter)
{
    var sum = 0;
    for (var t in this.tiles) {
        if (this.tiles[t].debug[prop] != null && (typeof filter != 'function' || filter(this.tiles[t]) == true)) {
            sum += this.tiles[t].debug[prop];
        }
    }
    return sum;
};

// Average of a debug property across tiles
GLRenderer.prototype.getDebugAverage = function (prop, filter)
{
    return this.getDebugSum(prop, filter) / Object.keys(this.tiles).length;
};

// User input
// TODO: restore fractional zoom support once leaflet animation refactor pull request is merged

GLRenderer.prototype.initInputHandlers = function GLRendererInitInputHandlers ()
{
    var gl_renderer = this;
    gl_renderer.key = null;

    document.addEventListener('keydown', function (event) {
        if (event.keyCode == 37) {
            gl_renderer.key = 'left';
        }
        else if (event.keyCode == 39) {
            gl_renderer.key = 'right';
        }
        else if (event.keyCode == 38) {
            gl_renderer.key = 'up';
        }
        else if (event.keyCode == 40) {
            gl_renderer.key = 'down';
        }
        else if (event.keyCode == 83) { // s
            console.log("reloading shaders");
            for (var mode in this.render_modes) {
                this.render_modes[mode].gl_program.compile();
            }
            gl_renderer.dirty = true;
        }
    });

    document.addEventListener('keyup', function (event) {
        gl_renderer.key = null;
    });
};

GLRenderer.prototype.input = function GLRendererInput ()
{
    // // Fractional zoom scaling
    // if (this.key == 'up') {
    //     this.setZoom(this.zoom + this.zoom_step);
    // }
    // else if (this.key == 'down') {
    //     this.setZoom(this.zoom - this.zoom_step);
    // }
};

if (module !== undefined) {
    module.exports = GLRenderer;
}

},{"./geo.js":2,"./gl.js":3,"./gl_builders.js":4,"./gl_geom.js":5,"./point.js":8,"./shaders/gl_shaders.js":9,"./vector_renderer.js":12}],7:[function(_dereq_,module,exports){
var VectorRenderer = _dereq_('./vector_renderer.js');
var GLRenderer = _dereq_('./gl_renderer.js');
var CanvasRenderer = _dereq_('./canvas_renderer.js');

var LeafletLayer = L.GridLayer.extend({

    options: {
        vectorRenderer: 'canvas'
    },

    initialize: function (options) {
        L.setOptions(this, options);
        this.options.vectorRenderer = this.options.vectorRenderer || 'GLRenderer';
        this._renderer = VectorRenderer.create(this.options.vectorRenderer, this.options.vectorTileSource, this.options.vectorLayers, this.options.vectorStyles, { num_workers: this.options.numWorkers });
        this._renderer.debug = this.options.debug;
        this._renderer.continuous_animation = false; // set to true for animatinos, etc. (eventually will be automated)

        this.GL = _dereq_('./gl.js');
    },

    // Finish initializing renderer and setup events when layer is added to map
    onAdd: function (map) {
        var layer = this;

        layer.on('tileunload', function (event) {
            var tile = event.tile;
            var key = tile.getAttribute('data-tile-key');
            layer._renderer.removeTile(key);
        });

        layer._map.on('resize', function () {
            var size = layer._map.getSize();
            layer._renderer.resizeMap(size.x, size.y);
            layer.updateBounds();
        });

        layer._map.on('move', function () {
            var center = layer._map.getCenter();
            layer._renderer.setCenter(center.lng, center.lat);
            layer.updateBounds();
        });

        layer._map.on('zoomstart', function () {
            console.log("map.zoomstart " + layer._map.getZoom());
            layer._renderer.startZoom();
        });

        layer._map.on('zoomend', function () {
            console.log("map.zoomend " + layer._map.getZoom());
            layer._renderer.setZoom(layer._map.getZoom());
        });

        // Canvas element will be inserted after map container (leaflet transforms shouldn't be applied to the GL canvas)
        // TODO: find a better way to deal with this? right now GL map only renders correctly as the bottom layer
        layer._renderer.container = layer._map.getContainer();

        var center = layer._map.getCenter();
        layer._renderer.setCenter(center.lng, center.lat);
        layer._renderer.setZoom(layer._map.getZoom());
        layer.updateBounds();

        L.GridLayer.prototype.onAdd.apply(this, arguments);
        layer._renderer.init();
    },

    onRemove: function (map) {
        L.GridLayer.prototype.onRemove.apply(this, arguments);
        // TODO: remove event handlers, destroy map
    },

    createTile: function (coords, done) {
        var div = document.createElement('div');
        this._renderer.loadTile(coords, div, done);
        return div;
    },

    updateBounds: function () {
        var layer = this;
        var bounds = layer._map.getBounds();
        layer._renderer.setBounds(bounds.getSouthWest(), bounds.getNorthEast());
    },

    render: function () {
        this._renderer.render();
    }

});

var leafletLayer = function (options) {
    return new LeafletLayer(options);
};

if (module !== undefined) {
    module.exports = {
        LeafletLayer: LeafletLayer,
        leafletLayer: leafletLayer
    }
}

},{"./canvas_renderer.js":1,"./gl.js":3,"./gl_renderer.js":6,"./vector_renderer.js":12}],8:[function(_dereq_,module,exports){
// Point
function Point (x, y)
{
    return { x: x, y: y };
}

Point.copy = function (p)
{
    if (p == null) {
        return null;
    }
    return { x: p.x, y: p.y };
};

if (module !== undefined) {
    module.exports = Point;
}

},{}],9:[function(_dereq_,module,exports){
// Generated from GLSL files, don't edit!
var shader_sources = {};

shader_sources['point_fragment'] =
"uniform vec2 resolution;\n" +
"\n" +
"varying vec3 fcolor;\n" +
"varying vec2 ftexcoord;\n" +
"\n" +
"void main (void) {\n" +
"    vec4 color = vec4(fcolor, 1.);\n" +
"\n" +
"    // if (length(ftexcoord.xy) > 10.) {\n" +
"    //     // color = vec4(0., 0., 0., 0.);\n" +
"    //     discard;\n" +
"    // }\n" +
"\n" +
"    float len = length(ftexcoord);\n" +
"    if (len > 1.) {\n" +
"        discard;\n" +
"    }\n" +
"    color.rgb *= (1. - smoothstep(.25, 1., len)) + 0.5;\n" +
"    // color.a = (1. - smoothstep(2.5, 10., len)) + 0.25;\n" +
"\n" +
"    #if defined(EFFECT_SCREEN_COLOR)\n" +
"        // Mutate colors by screen position\n" +
"        color.rgb += vec3(gl_FragCoord.x / resolution.x, 0.0, gl_FragCoord.y / resolution.y);\n" +
"    #endif\n" +
"\n" +
"    gl_FragColor = color;\n" +
"}\n" +
"";

shader_sources['point_vertex'] =
"uniform vec2 map_center;\n" +
"uniform float map_zoom;\n" +
"uniform vec2 meter_zoom;\n" +
"uniform vec2 tile_min;\n" +
"uniform vec2 tile_max;\n" +
"uniform float num_layers;\n" +
"// uniform float time;\n" +
"\n" +
"attribute vec3 position;\n" +
"// attribute vec3 normal;\n" +
"attribute vec2 texcoord;\n" +
"attribute vec3 color;\n" +
"attribute float layer;\n" +
"\n" +
"varying vec3 fcolor;\n" +
"varying vec2 ftexcoord;\n" +
"\n" +
"// vec3 light = normalize(vec3(0.2, 0.7, -0.5)); // vec3(0.1, 0.2, -0.4)\n" +
"// const float ambient = 0.45;\n" +
"\n" +
"void main() {\n" +
"    vec3 vposition = position;\n" +
"    // vec3 vnormal = normal;\n" +
"    // vec2 vtexcoord = texcoord;\n" +
"\n" +
"    // Calc position of vertex in meters, relative to center of screen\n" +
"    vposition.y *= -1.0; // adjust for flipped y-coords\n" +
"    vposition.xy *= (tile_max - tile_min) / TILE_SCALE; // adjust for vertex location within tile (scaled from local coords to meters)\n" +
"    vposition.xy += tile_min.xy - map_center; // adjust for corner of tile relative to map center\n" +
"    vposition.xy /= meter_zoom; // adjust for zoom in meters to get clip space coords\n" +
"\n" +
"    // Shading & texture\n" +
"    fcolor = color;\n" +
"    ftexcoord = texcoord;\n" +
"\n" +
"    // #if defined(PROJECTION_PERSPECTIVE)\n" +
"    //     // Perspective-style projection\n" +
"    //     vec2 perspective_offset = vec2(-0.25, -0.25);\n" +
"    //     vec2 perspective_factor = vec2(0.8, 0.8); // vec2(-0.25, 0.75);\n" +
"    //     vposition.xy += vposition.z * perspective_factor * (vposition.xy - perspective_offset) / meter_zoom.xy; // perspective from offset center screen\n" +
"    // #elif defined(PROJECTION_ISOMETRIC) || defined(PROJECTION_POPUP)\n" +
"    //     // Pop-up effect - 3d in center of viewport, fading to 2d at edges\n" +
"    //     #if defined(PROJECTION_POPUP)\n" +
"    //         if (vposition.z > 1.0) {\n" +
"    //             float cd = distance(vposition.xy * (resolution.xy / resolution.yy), vec2(0.0, 0.0));\n" +
"    //             const float popup_fade_inner = 0.5;\n" +
"    //             const float popup_fade_outer = 0.75;\n" +
"    //             if (cd > popup_fade_inner) {\n" +
"    //                 vposition.z *= 1.0 - smoothstep(popup_fade_inner, popup_fade_outer, cd);\n" +
"    //             }\n" +
"    //             const float zoom_boost_start = 15.0;\n" +
"    //             const float zoom_boost_end = 17.0;\n" +
"    //             const float zoom_boost_magnitude = 0.75;\n" +
"    //             vposition.z *= 1.0 + (1.0 - smoothstep(zoom_boost_start, zoom_boost_end, map_zoom)) * zoom_boost_magnitude;\n" +
"    //         }\n" +
"    //     #endif\n" +
"\n" +
"    //     // Isometric-style projection\n" +
"    //     vposition.y += vposition.z / meter_zoom.y; // z coordinate is a simple translation up along y axis, ala isometric\n" +
"    //     // vposition.y += vposition.z * 0.5; // closer to Ultima 7-style axonometric\n" +
"    //     // vposition.x -= vposition.z * 0.5;\n" +
"    // #endif\n" +
"\n" +
"    // Reverse and scale to 0-1 for GL depth buffer\n" +
"    // Layers are force-ordered (higher layers guaranteed to render on top of lower), then by height/depth\n" +
"    float z_layer_scale = 4096.;\n" +
"    float z_layer_range = (num_layers + 1.) * z_layer_scale;\n" +
"    float z_layer = (layer + 1.) * z_layer_scale;\n" +
"    // float z_layer = (layer + 1.);\n" +
"\n" +
"    vposition.z = z_layer + clamp(vposition.z, 1., z_layer_scale);\n" +
"    vposition.z = (z_layer_range - vposition.z) / z_layer_range;\n" +
"\n" +
"    gl_Position = vec4(vposition, 1.0);\n" +
"}\n" +
"";

shader_sources['polygon_fragment'] =
"uniform vec2 resolution;\n" +
"uniform float time;\n" +
"\n" +
"varying vec3 fcolor;\n" +
"\n" +
"#if defined(EFFECT_NOISE_TEXTURE)\n" +
"    varying vec3 fposition;\n" +
"\n" +
"    // http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n" +
"    // float rand (vec2 co) {\n" +
"    //    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n" +
"    // }\n" +
"\n" +
"    // Noise functions from: https://github.com/ashima/webgl-noise\n" +
"    vec3 mod289(vec3 x) {\n" +
"        return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"    }\n" +
"\n" +
"    vec4 mod289(vec4 x) {\n" +
"        return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"    }\n" +
"\n" +
"    vec4 permute(vec4 x) {\n" +
"        return mod289(((x*34.0)+1.0)*x);\n" +
"    }\n" +
"\n" +
"    vec4 taylorInvSqrt(vec4 r) {\n" +
"        return 1.79284291400159 - 0.85373472095314 * r;\n" +
"    }\n" +
"\n" +
"    vec3 fade(vec3 t) {\n" +
"        return t*t*t*(t*(t*6.0-15.0)+10.0);\n" +
"    }\n" +
"\n" +
"    float snoise(vec3 v) {\n" +
"        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n" +
"        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n" +
"\n" +
"        // First corner\n" +
"        vec3 i  = floor(v + dot(v, C.yyy) );\n" +
"        vec3 x0 =   v - i + dot(i, C.xxx) ;\n" +
"\n" +
"        // Other corners\n" +
"        vec3 g = step(x0.yzx, x0.xyz);\n" +
"        vec3 l = 1.0 - g;\n" +
"        vec3 i1 = min( g.xyz, l.zxy );\n" +
"        vec3 i2 = max( g.xyz, l.zxy );\n" +
"\n" +
"        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n" +
"        //   x1 = x0 - i1  + 1.0 * C.xxx;\n" +
"        //   x2 = x0 - i2  + 2.0 * C.xxx;\n" +
"        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n" +
"        vec3 x1 = x0 - i1 + C.xxx;\n" +
"        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n" +
"        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n" +
"\n" +
"        // Permutations\n" +
"        i = mod289(i);\n" +
"        vec4 p = permute( permute( permute(\n" +
"        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n" +
"        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n" +
"        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n" +
"\n" +
"        // Gradients: 7x7 points over a square, mapped onto an octahedron.\n" +
"        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n" +
"        float n_ = 0.142857142857; // 1.0/7.0\n" +
"        vec3  ns = n_ * D.wyz - D.xzx;\n" +
"\n" +
"        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n" +
"\n" +
"        vec4 x_ = floor(j * ns.z);\n" +
"        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n" +
"\n" +
"        vec4 x = x_ *ns.x + ns.yyyy;\n" +
"        vec4 y = y_ *ns.x + ns.yyyy;\n" +
"        vec4 h = 1.0 - abs(x) - abs(y);\n" +
"\n" +
"        vec4 b0 = vec4( x.xy, y.xy );\n" +
"        vec4 b1 = vec4( x.zw, y.zw );\n" +
"\n" +
"        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n" +
"        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n" +
"        vec4 s0 = floor(b0)*2.0 + 1.0;\n" +
"        vec4 s1 = floor(b1)*2.0 + 1.0;\n" +
"        vec4 sh = -step(h, vec4(0.0));\n" +
"\n" +
"        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n" +
"        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n" +
"\n" +
"        vec3 p0 = vec3(a0.xy,h.x);\n" +
"        vec3 p1 = vec3(a0.zw,h.y);\n" +
"        vec3 p2 = vec3(a1.xy,h.z);\n" +
"        vec3 p3 = vec3(a1.zw,h.w);\n" +
"\n" +
"        //Normalise gradients\n" +
"        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n" +
"        p0 *= norm.x;\n" +
"        p1 *= norm.y;\n" +
"        p2 *= norm.z;\n" +
"        p3 *= norm.w;\n" +
"\n" +
"        // Mix final noise value\n" +
"        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n" +
"        m = m * m;\n" +
"        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n" +
"    }\n" +
"\n" +
"    // Classic Perlin noise\n" +
"    float cnoise(vec3 P) {\n" +
"        vec3 Pi0 = floor(P); // Integer part for indexing\n" +
"        vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n" +
"        Pi0 = mod289(Pi0);\n" +
"        Pi1 = mod289(Pi1);\n" +
"        vec3 Pf0 = fract(P); // Fractional part for interpolation\n" +
"        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n" +
"        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n" +
"        vec4 iy = vec4(Pi0.yy, Pi1.yy);\n" +
"        vec4 iz0 = Pi0.zzzz;\n" +
"        vec4 iz1 = Pi1.zzzz;\n" +
"\n" +
"        vec4 ixy = permute(permute(ix) + iy);\n" +
"        vec4 ixy0 = permute(ixy + iz0);\n" +
"        vec4 ixy1 = permute(ixy + iz1);\n" +
"\n" +
"        vec4 gx0 = ixy0 * (1.0 / 7.0);\n" +
"        vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n" +
"        gx0 = fract(gx0);\n" +
"        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n" +
"        vec4 sz0 = step(gz0, vec4(0.0));\n" +
"        gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n" +
"        gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n" +
"\n" +
"        vec4 gx1 = ixy1 * (1.0 / 7.0);\n" +
"        vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n" +
"        gx1 = fract(gx1);\n" +
"        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n" +
"        vec4 sz1 = step(gz1, vec4(0.0));\n" +
"        gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n" +
"        gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n" +
"\n" +
"        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n" +
"        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n" +
"        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n" +
"        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n" +
"        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n" +
"        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n" +
"        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n" +
"        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n" +
"\n" +
"        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n" +
"        g000 *= norm0.x;\n" +
"        g010 *= norm0.y;\n" +
"        g100 *= norm0.z;\n" +
"        g110 *= norm0.w;\n" +
"        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n" +
"        g001 *= norm1.x;\n" +
"        g011 *= norm1.y;\n" +
"        g101 *= norm1.z;\n" +
"        g111 *= norm1.w;\n" +
"\n" +
"        float n000 = dot(g000, Pf0);\n" +
"        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n" +
"        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n" +
"        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n" +
"        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n" +
"        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n" +
"        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n" +
"        float n111 = dot(g111, Pf1);\n" +
"\n" +
"        vec3 fade_xyz = fade(Pf0);\n" +
"        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n" +
"        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n" +
"        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n" +
"        return 2.2 * n_xyz;\n" +
"    }\n" +
"\n" +
"    // Classic Perlin noise, periodic variant\n" +
"    float pnoise(vec3 P, vec3 rep) {\n" +
"        vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n" +
"        vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n" +
"        Pi0 = mod289(Pi0);\n" +
"        Pi1 = mod289(Pi1);\n" +
"        vec3 Pf0 = fract(P); // Fractional part for interpolation\n" +
"        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n" +
"        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n" +
"        vec4 iy = vec4(Pi0.yy, Pi1.yy);\n" +
"        vec4 iz0 = Pi0.zzzz;\n" +
"        vec4 iz1 = Pi1.zzzz;\n" +
"\n" +
"        vec4 ixy = permute(permute(ix) + iy);\n" +
"        vec4 ixy0 = permute(ixy + iz0);\n" +
"        vec4 ixy1 = permute(ixy + iz1);\n" +
"\n" +
"        vec4 gx0 = ixy0 * (1.0 / 7.0);\n" +
"        vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n" +
"        gx0 = fract(gx0);\n" +
"        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n" +
"        vec4 sz0 = step(gz0, vec4(0.0));\n" +
"        gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n" +
"        gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n" +
"\n" +
"        vec4 gx1 = ixy1 * (1.0 / 7.0);\n" +
"        vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n" +
"        gx1 = fract(gx1);\n" +
"        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n" +
"        vec4 sz1 = step(gz1, vec4(0.0));\n" +
"        gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n" +
"        gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n" +
"\n" +
"        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n" +
"        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n" +
"        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n" +
"        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n" +
"        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n" +
"        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n" +
"        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n" +
"        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n" +
"\n" +
"        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n" +
"        g000 *= norm0.x;\n" +
"        g010 *= norm0.y;\n" +
"        g100 *= norm0.z;\n" +
"        g110 *= norm0.w;\n" +
"        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n" +
"        g001 *= norm1.x;\n" +
"        g011 *= norm1.y;\n" +
"        g101 *= norm1.z;\n" +
"        g111 *= norm1.w;\n" +
"\n" +
"        float n000 = dot(g000, Pf0);\n" +
"        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n" +
"        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n" +
"        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n" +
"        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n" +
"        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n" +
"        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n" +
"        float n111 = dot(g111, Pf1);\n" +
"\n" +
"        vec3 fade_xyz = fade(Pf0);\n" +
"        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n" +
"        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n" +
"        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n" +
"        return 2.2 * n_xyz;\n" +
"    }\n" +
"#endif\n" +
"\n" +
"void main (void) {\n" +
"\n" +
"    #if defined(EFFECT_SPOTLIGHT)\n" +
"    // Spotlight effect\n" +
"        vec2 position = gl_FragCoord.xy / resolution.xy;    // scale coords to [0.0, 1.0]\n" +
"        position = position * 2.0 - 1.0;                    // scale coords to [-1.0, 1.0]\n" +
"        position.y *= resolution.y / resolution.x;          // correct aspect ratio\n" +
"\n" +
"        vec3 color = fcolor * max(1.0 - distance(position, vec2(0.0, 0.0)), 0.2);\n" +
"        // vec3 color = fcolor * (1.0 - dot(normalize(vec3(rand(gl_FragCoord.xy * 0.01) * 10.0, 0.0, -1.0)), vec3(0, 0, 1.0)));\n" +
"    #else\n" +
"        vec3 color = fcolor;\n" +
"    #endif\n" +
"\n" +
"    #if defined(EFFECT_COLOR_BLEED)\n" +
"        // Mutate colors by screen position or time\n" +
"        color += vec3(gl_FragCoord.x / resolution.x, 0.0, gl_FragCoord.y / resolution.y);\n" +
"        color.r += sin(time / 3.0);\n" +
"    #endif\n" +
"\n" +
"    // Mutate color by 3d noise\n" +
"    #if defined (EFFECT_NOISE_TEXTURE)\n" +
"        #if defined(EFFECT_NOISE_ANIMATABLE) && defined(EFFECT_NOISE_ANIMATED)\n" +
"            color *= (abs(cnoise((fposition + vec3(time * 5., time * 7.5, time * 10.)) / 10.0)) / 4.0) + 0.75;\n" +
"        #endif\n" +
"        #ifndef EFFECT_NOISE_ANIMATABLE\n" +
"            color *= (abs(cnoise(fposition / 10.0)) / 4.0) + 0.75;\n" +
"        #endif\n" +
"    #endif\n" +
"\n" +
"    gl_FragColor = vec4(color, 1.0);\n" +
"    // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" +
"}\n" +
"";

shader_sources['polygon_vertex'] =
"// #define PROJECTION_PERSPECTIVE\n" +
"// #define PROJECTION_ISOMETRIC\n" +
"// #define PROJECTION_POPUP\n" +
"\n" +
"// #define LIGHTING_POINT\n" +
"// #define LIGHTING_DIRECTION\n" +
"\n" +
"// #define ANIMATION_ELEVATOR\n" +
"// #define ANIMATION_WAVE\n" +
"\n" +
"uniform vec2 resolution;\n" +
"uniform vec2 map_center;\n" +
"uniform float map_zoom;\n" +
"uniform vec2 meter_zoom;\n" +
"uniform vec2 tile_min;\n" +
"uniform vec2 tile_max;\n" +
"uniform float num_layers;\n" +
"uniform float time;\n" +
"\n" +
"attribute vec3 position;\n" +
"attribute vec3 normal;\n" +
"attribute vec3 color;\n" +
"attribute float layer;\n" +
"\n" +
"varying vec3 fcolor;\n" +
"\n" +
"#if defined(EFFECT_NOISE_TEXTURE)\n" +
"    varying vec3 fposition;\n" +
"#endif\n" +
"\n" +
"vec3 light = normalize(vec3(0.2, 0.7, -0.5)); // vec3(0.1, 0.2, -0.4)\n" +
"const float ambient = 0.45;\n" +
"\n" +
"// Project lat-lng to mercator\n" +
"// vec2 latLngToMeters (vec2 coordinate) {\n" +
"//     const float pi = 3.1415926;\n" +
"//     const float half_circumference_meters = 20037508.342789244;\n" +
"//     vec2 projected;\n" +
"\n" +
"//     // Latitude\n" +
"//     projected.y = log(tan((coordinate.y + 90.0) * pi / 360.0)) / (pi / 180.0);\n" +
"//     projected.y = projected.y * half_circumference_meters / 180.0;\n" +
"\n" +
"//     // Longitude\n" +
"//     projected.x = coordinate.x * half_circumference_meters / 180.0;\n" +
"\n" +
"//     return projected;\n" +
"// }\n" +
"\n" +
"void main() {\n" +
"    vec3 vposition = position;\n" +
"    vec3 vnormal = normal;\n" +
"\n" +
"    // Calc position of vertex in meters, relative to center of screen\n" +
"    vposition.y *= -1.0; // adjust for flipped y-coords\n" +
"    // vposition.y += TILE_SCALE; // alternate, to also adjust for force-positive y coords in tile\n" +
"    vposition.xy *= (tile_max - tile_min) / TILE_SCALE; // adjust for vertex location within tile (scaled from local coords to meters)\n" +
"\n" +
"    // Vertex displacement + procedural effects\n" +
"    #if defined(ANIMATION_ELEVATOR) || defined(ANIMATION_WAVE) || defined(EFFECT_NOISE_TEXTURE)\n" +
"        vec3 vposition_world = vposition + vec3(tile_min, 0.); // need vertex in world coords (before map center transform), hack to get around precision issues (see below)\n" +
"\n" +
"        #if defined(EFFECT_NOISE_TEXTURE)\n" +
"            fposition = vposition_world;\n" +
"        #endif\n" +
"\n" +
"        if (vposition_world.z > 1.0) {\n" +
"            // vposition.x += sin(vposition_world.z + time) * 10.0 * sin(position.x); // swaying buildings\n" +
"            // vposition.y += cos(vposition_world.z + time) * 10.0;\n" +
"\n" +
"            #if defined(ANIMATION_ELEVATOR)\n" +
"                // vposition.z *= (sin(vposition_world.z / 25.0 * time) + 1.0) / 2.0 + 0.1; // evelator buildings\n" +
"                vposition.z *= max((sin(vposition_world.z + time) + 1.0) / 2.0, 0.05); // evelator buildings\n" +
"            #elif defined(ANIMATION_WAVE)\n" +
"                vposition.z *= max((sin(vposition_world.x / 100.0 + time) + 1.0) / 2.0, 0.05); // wave\n" +
"            #endif\n" +
"        }\n" +
"    #endif\n" +
"\n" +
"    // NOTE: due to unresolved floating point precision issues, tile and map center adjustment need to happen in ONE operation, or artifcats are introduced\n" +
"    vposition.xy += tile_min.xy - map_center; // adjust for corner of tile relative to map center\n" +
"    vposition.xy /= meter_zoom; // adjust for zoom in meters to get clip space coords\n" +
"\n" +
"    // Shading\n" +
"    fcolor = color;\n" +
"    // fcolor += vec3(sin(position.z + time), 0.0, 0.0); // color change on height + time\n" +
"\n" +
"    #if defined(LIGHTING_POINT) || defined(LIGHTING_NIGHT)\n" +
"        // Gouraud shading\n" +
"        light = vec3(-0.25, -0.25, 0.50); // vec3(0.1, 0.1, 0.35); // point light location\n" +
"\n" +
"        #if defined(LIGHTING_NIGHT)\n" +
"            // \"Night\" effect by flipping vertex z\n" +
"            light = normalize(vec3(vposition.x, vposition.y, vposition.z) - light); // light angle from light point to vertex\n" +
"            fcolor *= dot(vnormal, light * -1.0); // + ambient + clamp(vposition.z * 2.0 / meter_zoom.x, 0.0, 0.25);\n" +
"        #else\n" +
"            // Point light-based gradient\n" +
"            light = normalize(vec3(vposition.x, vposition.y, -vposition.z) - light); // light angle from light point to vertex\n" +
"            fcolor *= dot(vnormal, light * -1.0) + ambient + clamp(vposition.z * 2.0 / meter_zoom.x, 0.0, 0.25);\n" +
"        #endif\n" +
"\n" +
"    #elif defined(LIGHTING_DIRECTION)\n" +
"        // Flat shading\n" +
"        light = normalize(vec3(0.2, 0.7, -0.5));\n" +
"        // light = normalize(vec3(-1., 0.7, -.0));\n" +
"        // light = normalize(vec3(-1., 0.7, -.75));\n" +
"        // fcolor *= max(dot(vnormal, light * -1.0), 0.1) + ambient;\n" +
"        fcolor *= dot(vnormal, light * -1.0) + ambient;\n" +
"    #endif\n" +
"\n" +
"    #if defined(PROJECTION_PERSPECTIVE)\n" +
"        // Perspective-style projection\n" +
"        vec2 perspective_offset = vec2(-0.25, -0.25);\n" +
"        vec2 perspective_factor = vec2(0.8, 0.8); // vec2(-0.25, 0.75);\n" +
"        vposition.xy += vposition.z * perspective_factor * (vposition.xy - perspective_offset) / meter_zoom.xy; // perspective from offset center screen\n" +
"    #elif defined(PROJECTION_ISOMETRIC) || defined(PROJECTION_POPUP)\n" +
"        // Pop-up effect - 3d in center of viewport, fading to 2d at edges\n" +
"        #if defined(PROJECTION_POPUP)\n" +
"            if (vposition.z > 1.0) {\n" +
"                float cd = distance(vposition.xy * (resolution.xy / resolution.yy), vec2(0.0, 0.0));\n" +
"                const float popup_fade_inner = 0.5;\n" +
"                const float popup_fade_outer = 0.75;\n" +
"                if (cd > popup_fade_inner) {\n" +
"                    vposition.z *= 1.0 - smoothstep(popup_fade_inner, popup_fade_outer, cd);\n" +
"                }\n" +
"                const float zoom_boost_start = 15.0;\n" +
"                const float zoom_boost_end = 17.0;\n" +
"                const float zoom_boost_magnitude = 0.75;\n" +
"                vposition.z *= 1.0 + (1.0 - smoothstep(zoom_boost_start, zoom_boost_end, map_zoom)) * zoom_boost_magnitude;\n" +
"            }\n" +
"        #endif\n" +
"\n" +
"        // Isometric-style projection\n" +
"        vposition.y += vposition.z / meter_zoom.y; // z coordinate is a simple translation up along y axis, ala isometric\n" +
"        // vposition.y += vposition.z * 0.5; // closer to Ultima 7-style axonometric\n" +
"        // vposition.x -= vposition.z * 0.5;\n" +
"    #endif\n" +
"\n" +
"    // Rotation test\n" +
"    // float theta = 0;\n" +
"    // const float pi = 3.1415926;\n" +
"    // vec2 pr;\n" +
"    // pr.x = vposition.x * cos(theta * pi / 180.0) + vposition.y * -sin(theta * pi / 180.0);\n" +
"    // pr.y = vposition.x * sin(theta * pi / 180.0) + vposition.y * cos(theta * pi / 180.0);\n" +
"    // vposition.xy = pr;\n" +
"\n" +
"    // vposition.y *= max(abs(sin(vposition.x)), 0.1); // hourglass effect\n" +
"    // vposition.y *= abs(max(sin(vposition.x), 0.1)); // funnel effect\n" +
"\n" +
"    // Reverse and scale to 0-1 for GL depth buffer\n" +
"    // Layers are force-ordered (higher layers guaranteed to render on top of lower), then by height/depth\n" +
"    float z_layer_scale = 4096.;\n" +
"    float z_layer_range = (num_layers + 1.) * z_layer_scale;\n" +
"    float z_layer = (layer + 1.) * z_layer_scale;\n" +
"\n" +
"    vposition.z = z_layer + clamp(vposition.z, 1., z_layer_scale);\n" +
"    vposition.z = (z_layer_range - vposition.z) / z_layer_range;\n" +
"\n" +
"    gl_Position = vec4(vposition, 1.0);\n" +
"}\n" +
"";

if (module.exports !== undefined) { module.exports = shader_sources; }


},{}],10:[function(_dereq_,module,exports){
/*** Style helpers ***/

var Style = {};

Style.color = {
    pseudoRandomGrayscale: function (f) { var c = Math.max((parseInt(f.id, 16) % 100) / 100, 0.4); return [0.7 * c, 0.7 * c, 0.7 * c]; }, // pseudo-random grayscale by geometry id
    pseudoRandomColor: function (f) { return [0.7 * (parseInt(f.id, 16) / 100 % 1), 0.7 * (parseInt(f.id, 16) / 10000 % 1), 0.7 * (parseInt(f.id, 16) / 1000000 % 1)]; }, // pseudo-random color by geometry id
    randomColor: function (f) { return [0.7 * Math.random(), 0.7 * Math.random(), 0.7 * Math.random()]; } // random color
};

Style.width = {
    pixels: function (p) { return function (f, t) { return (typeof p == 'function' ? p(f, t) : p) * t.units_per_pixel; }; }, // local tile units for a given pixel width
    meters: function (p) { return function (f, t) { return (typeof p == 'function' ? p(f, t) : p) * t.units_per_meter; }; }  // local tile units for a given meter width
};

if (module !== undefined) {
    module.exports = Style;
}

},{}],11:[function(_dereq_,module,exports){
/*** Vector functions - vectors provided as [x, y, z] arrays ***/

var Vector = {};

// Vector length squared
Vector.lengthSq = function (v)
{
    if (v.length == 2) {
        return (v[0]*v[0] + v[1]*v[1]);
    }
    else {
        return (v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
    }
};

// Vector length
Vector.length = function (v)
{
    return Math.sqrt(Vector.lengthSq(v));
};

// Normalize a vector
Vector.normalize = function (v)
{
    var d;
    if (v.length == 2) {
        d = v[0]*v[0] + v[1]*v[1];
        d = Math.sqrt(d);

        if (d != 0) {
            return [v[0] / d, v[1] / d];
        }
        return [0, 0];
    }
    else {
        var d = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
        d = Math.sqrt(d);

        if (d != 0) {
            return [v[0] / d, v[1] / d, v[2] / d];
        }
        return [0, 0, 0];
    }
};

// Cross product of two vectors
Vector.cross  = function (v1, v2)
{
    return [
        (v1[1] * v2[2]) - (v1[2] * v2[1]),
        (v1[2] * v2[0]) - (v1[0] * v2[2]),
        (v1[0] * v2[1]) - (v1[1] * v2[0])
    ];
};

// Find the intersection of two lines specified as segments from points (p1, p2) and (p3, p4)
// http://en.wikipedia.org/wiki/Line-line_intersection
// http://en.wikipedia.org/wiki/Cramer's_rule
Vector.lineIntersection = function (p1, p2, p3, p4, parallel_tolerance)
{
    var parallel_tolerance = parallel_tolerance || 0.01;

    // a1*x + b1*y = c1 for line (x1, y1) to (x2, y2)
    // a2*x + b2*y = c2 for line (x3, y3) to (x4, y4)
    var a1 = p1[1] - p2[1]; // y1 - y2
    var b1 = p1[0] - p2[0]; // x1 - x2
    var a2 = p3[1] - p4[1]; // y3 - y4
    var b2 = p3[0] - p4[0]; // x3 - x4
    var c1 = (p1[0] * p2[1]) - (p1[1] * p2[0]); // x1*y2 - y1*x2
    var c2 = (p3[0] * p4[1]) - (p3[1] * p4[0]); // x3*y4 - y3*x4
    var denom = (b1 * a2) - (a1 * b2);

    if (Math.abs(denom) > parallel_tolerance) {
        return [
            ((c1 * b2) - (b1 * c2)) / denom,
            ((c1 * a2) - (a1 * c2)) / denom
        ];
    }
    return null; // return null if lines are (close to) parallel
};

if (module !== undefined) {
    module.exports = Vector;
}

},{}],12:[function(_dereq_,module,exports){
var Point = _dereq_('./point.js');
var Geo = _dereq_('./geo.js');
var Style = _dereq_('./style.js');

// Get base URL from which the library was loaded
// Used to load additional resources like shaders, textures, etc. in cases where library was loaded from a relative path
(function() {
    try {
        VectorRenderer.library_base_url = '';
        var scripts = document.getElementsByTagName('script'); // document.querySelectorAll('script[src*=".js"]');
        for (var s=0; s < scripts.length; s++) {
            // var base_match = scripts[s].src.match(/(.*)vector-map.(debug|min).js/); // should match debug or minified versions
            // if (base_match != null && base_match.length > 1) {
            //     VectorRenderer.library_base_url = base_match[1];
            //     break;
            // }
            var match = scripts[s].src.indexOf('vector-map.debug.js');
            if (match == -1) {
                match = scripts[s].src.indexOf('vector-map.min.js');
            }
            if (match >= 0) {
                VectorRenderer.library_base_url = scripts[s].src.substr(0, match);
                break;
            }
        }
    }
    catch (e) {
        // skip in web worker
    }
}());

VectorRenderer.tile_scale = 4096; // coordinates are locally scaled to the range [0, tile_scale]
VectorRenderer.units_per_meter = [];
VectorRenderer.units_per_pixel = [];
(function() {
    for (var z=0; z <= Geo.max_zoom; z++) {
        VectorRenderer.units_per_meter[z] = VectorRenderer.tile_scale / (Geo.tile_size * Geo.meters_per_pixel[z]);
        VectorRenderer.units_per_pixel[z] = VectorRenderer.tile_scale / Geo.tile_size;
    }
}());

// Layers & styles: pass an object directly, or a URL as string to load remotely
function VectorRenderer (type, tile_source, layers, styles, options)
{
    var options = options || {};
    this.type = type;
    this.tile_source = tile_source;
    this.tiles = {};
    this.num_workers = options.num_workers || 1;

    this.layer_source = VectorRenderer.urlForPath(layers); // TODO: fix this for layers provided as objects, this assumes a URL is passed
    if (typeof(layers) == 'string') {
        this.layers = VectorRenderer.loadLayers(layers);
    }
    else {
        this.layers = layers;
    }

    this.style_source = VectorRenderer.urlForPath(styles); // TODO: fix this for styles provided as objects, this assumes a URL is passed
    if (typeof(styles) == 'string') {
        this.styles = VectorRenderer.loadStyles(styles);
    }
    else {
        this.styles = styles;
    }

    this.createWorkers();

    this.zoom = null;
    this.center = null;
    this.device_pixel_ratio = window.devicePixelRatio || 1;
    this.dirty = true; // request a redraw
    this.initialized = false;
}

VectorRenderer.create = function (type, tile_source, layers, styles, options)
{
    return new VectorRenderer[type](tile_source, layers, styles, options);
};

VectorRenderer.prototype.init = function ()
{
    // Child class-specific initialization (e.g. GL context creation)
    if (typeof(this._init) == 'function') {
        this._init.apply(this, arguments);
    }

    var renderer = this;
    this.workers.forEach(function(worker) {
        worker.addEventListener('message', renderer.tileWorkerCompleted.bind(renderer));
    });

    this.initialized = true;
};

// Web workers handle heavy duty geometry processing
VectorRenderer.prototype.createWorkers = function ()
{
    var renderer = this;
    var url = VectorRenderer.library_base_url + 'vector-map-worker.min.js';

    // To allow workers to be loaded cross-domain, first load worker source via XHR, then create a local URL via a blob
    var req = new XMLHttpRequest();
    req.onload = function () {
        var worker_local_url = window.URL.createObjectURL(new Blob([req.response], { type: 'application/javascript' }));

        renderer.workers = [];
        for (var w=0; w < renderer.num_workers; w++) {
            renderer.workers.push(new Worker(worker_local_url));
        }
    };
    req.open('GET', url, false /* async flag */);
    req.send();

    // Alternate for debugging - tradtional method of loading from remote URL instead of XHR-to-local-blob
    // renderer.workers = [];
    // for (var w=0; w < renderer.num_workers; w++) {
    //     renderer.workers.push(new Worker(url));
    // }

    this.next_worker = 0;
};

VectorRenderer.prototype.setCenter = function (lng, lat)
{
    this.center = { lng: lng, lat: lat };
    this.dirty = true;
};

VectorRenderer.prototype.setZoom = function (zoom)
{
    this.map_last_zoom = this.zoom;
    this.zoom = zoom;
    this.map_zooming = false;
    this.dirty = true;
};

VectorRenderer.prototype.startZoom = function ()
{
    this.map_last_zoom = this.zoom;
    this.map_zooming = true;
};

VectorRenderer.prototype.setBounds = function (sw, ne)
{
    this.bounds = {
        sw: { lng: sw.lng, lat: sw.lat },
        ne: { lng: ne.lng, lat: ne.lat }
    };

    var buffer = 200 * Geo.meters_per_pixel[~~this.zoom]; // pixels -> meters
    this.buffered_meter_bounds = {
        sw: Geo.latLngToMeters(Point(this.bounds.sw.lng, this.bounds.sw.lat)),
        ne: Geo.latLngToMeters(Point(this.bounds.ne.lng, this.bounds.ne.lat))
    };
    this.buffered_meter_bounds.sw.x -= buffer;
    this.buffered_meter_bounds.sw.y -= buffer;
    this.buffered_meter_bounds.ne.x += buffer;
    this.buffered_meter_bounds.ne.y += buffer;

    // console.log("set renderer bounds to " + JSON.stringify(this.bounds));

    // Mark tiles as visible/invisible
    for (var t in this.tiles) {
        this.updateVisibilityForTile(this.tiles[t]);
    }

    this.dirty = true;
};

VectorRenderer.prototype.updateVisibilityForTile = function (tile)
{
    tile.visible = Geo.boxIntersect(tile.bounds, this.buffered_meter_bounds);
    return tile.visible;
};

VectorRenderer.prototype.resizeMap = function (width, height)
{
    this.dirty = true;
};

VectorRenderer.prototype.requestRedraw = function ()
{
    this.dirty = true;
};

VectorRenderer.prototype.render = function ()
{
    if (this.dirty == false || this.initialized == false) {
        return false;
    }
    this.dirty = false; // subclasses can set this back to true when animation is needed

    // Child class-specific rendering (e.g. GL draw calls)
    if (typeof(this._render) == 'function') {
        this._render.apply(this, arguments);
    }

    // console.log("render map");
    return true;
};

VectorRenderer.prototype.loadTile = function (coords, div, callback)
{
    // Overzoom?
    if (coords.z > this.tile_source.max_zoom) {
        var zgap = coords.z - this.tile_source.max_zoom;
        // var original_tile = [coords.x, coords.y, coords.z].join('/');
        coords.x = ~~(coords.x / Math.pow(2, zgap));
        coords.y = ~~(coords.y / Math.pow(2, zgap));
        coords.display_z = coords.z; // z without overzoom
        coords.z -= zgap;
        // console.log("adjusted for overzoom, tile " + original_tile + " -> " + [coords.x, coords.y, coords.z].join('/'));
    }

    // Start tracking new tile set if no other tiles already loading
    if (this.tile_set_loading == null) {
        this.tile_set_loading = +new Date();
        console.log("tile set load START");
    }

    var key = [coords.x, coords.y, coords.z].join('/');

    // Already loading/loaded?
    if (this.tiles[key]) {
        // if (this.tiles[key].loaded == true) {
        //     console.log("use loaded tile " + key + " from cache");
        // }
        // if (this.tiles[key].loading == true) {
        //     console.log("already loading tile " + key + ", skip");
        // }

        if (callback) {
            callback(null, div);
        }
        return;
    }

    var tile = this.tiles[key] = {};
    tile.key = key;
    tile.coords = coords;
    tile.min = Geo.metersForTile(tile.coords);
    tile.max = Geo.metersForTile({ x: tile.coords.x + 1, y: tile.coords.y + 1, z: tile.coords.z });
    tile.bounds = { sw: { x: tile.min.x, y: tile.max.y }, ne: { x: tile.max.x, y: tile.min.y } };
    tile.units_per_meter = VectorRenderer.units_per_meter[tile.coords.z];
    tile.units_per_pixel = VectorRenderer.units_per_pixel[tile.coords.z];
    tile.debug = {};
    tile.loading = true;
    tile.loaded = false;
    this.updateVisibilityForTile(tile);

    this.workers[this.next_worker].postMessage({
        type: 'loadTile',
        tile: tile,
        renderer_type: this.type,
        tile_source: this.tile_source,
        layer_source: this.layer_source,
        style_source: this.style_source
    });
    tile.worker = this.workers[this.next_worker];
    this.next_worker = (this.next_worker + 1) % this.workers.length;

    // Debug info
    div.setAttribute('data-tile-key', tile.key);
    div.style.width = '256px';
    div.style.height = '256px';

    if (this.debug) {
        var debug_overlay = document.createElement('div');
        debug_overlay.textContent = tile.key;
        debug_overlay.style.position = 'absolute';
        debug_overlay.style.left = 0;
        debug_overlay.style.top = 0;
        debug_overlay.style.color = 'white';
        debug_overlay.style.fontSize = '16px';
        // debug_overlay.style.textOutline = '1px #000000';
        div.appendChild(debug_overlay);

        div.style.borderStyle = 'solid';
        div.style.borderColor = 'white';
        div.style.borderWidth = '1px';
    }

    if (callback) {
        callback(null, div);
    }
};

// Called on main thread when a web worker completes processing for a single tile
VectorRenderer.prototype.tileWorkerCompleted = function (event)
{
    if (event.data.type != 'loadTileCompleted') {
        return;
    }

    var tile = event.data.tile;

    // Removed this tile during load?
    if (this.tiles[tile.key] == null) {
        console.log("discarded tile " + tile.key + " in VectorRenderer.tileWorkerCompleted because previously removed");
        return;
    }

    this.tiles[tile.key] = tile; // TODO: OK to just wipe out the tile here? or could pass back a list of properties to replace? feeling the lack of underscore here...

    // Child class-specific tile processing
    if (typeof(this._tileWorkerCompleted) == 'function') {
        this._tileWorkerCompleted(tile);
    }

    delete tile.layers; // delete the source data in the tile to save memory

    // No more tiles actively loading?
    if (this.tile_set_loading != null) {
        var end_tile_set = true;
        for (var t in this.tiles) {
            if (this.tiles[t].loading == true) {
                end_tile_set = false;
                break;
            }
        }

        if (end_tile_set == true) {
            this.last_tile_set_load = (+new Date()) - this.tile_set_loading;
            this.tile_set_loading = null;
            console.log("tile set load FINISHED in: " + this.last_tile_set_load);
        }
    }

    this.dirty = true;
    this.printDebugForTile(tile);
};

VectorRenderer.prototype.removeTile = function (key)
{
    console.log("tile unload for " + key);
    var tile = this.tiles[key];
    if (tile != null && tile.loading == true) {
        console.log("cancel tile load for " + key);

        // Web worker will cancel XHR requests
        if (tile.worker != null) {
            tile.worker.postMessage({
                type: 'removeTile',
                key: tile.key
            });
        }
    }

    delete this.tiles[key];
    this.dirty = true;
};

VectorRenderer.prototype.printDebugForTile = function (tile)
{
    console.log(
        "debug for " + tile.key + ': [ ' +
        Object.keys(tile.debug).map(function (t) { return t + ': ' + tile.debug[t]; }).join(', ') + ' ]'
    );
};


/*** Class methods (stateless) ***/

// Simplistic detection of relative paths, append base if necessary
VectorRenderer.urlForPath = function (path) {
    var protocol = path.toLowerCase().substr(0, 4);
    if (!(protocol == 'http' || protocol == 'file')) {
        path = window.location.origin + window.location.pathname + path;
    }
    return path;
};

VectorRenderer.loadLayers = function (url)
{
    var layers;
    var req = new XMLHttpRequest();
    req.onload = function () { eval('layers = ' + req.response); }; // TODO: security!
    req.open('GET', url, false /* async flag */);
    req.send();
    return layers;
};

VectorRenderer.loadStyles = function (url)
{
    var styles;
    var req = new XMLHttpRequest();
    req.onload = function () { eval('styles = ' + req.response); }; // TODO: security!
    req.open('GET', url, false /* async flag */);
    req.send();
    return styles;
};

// Processes the tile response to create layers as defined by this renderer
// Can include post-processing to partially filter or re-arrange data, e.g. only including POIs that have names
VectorRenderer.processLayersForTile = function (layers, tile)
{
    var tile_layers = {};
    for (var t=0; t < layers.length; t++) {
        layers[t].number = t;

        if (layers[t] != null) {
            // Just pass through data untouched if no data transform function defined
            if (layers[t].data == null) {
                tile_layers[layers[t].name] = tile.layers[layers[t].name];
            }
            // Pass through data but with different layer name in tile source data
            else if (typeof layers[t].data == 'string') {
                tile_layers[layers[t].name] = tile.layers[layers[t].data];
            }
            // Apply the transform function for post-processing
            else if (typeof layers[t].data == 'function') {
                tile_layers[layers[t].name] = layers[t].data(tile.layers);
            }
        }

        // Handle cases where no data was found in tile or returned by post-processor
        tile_layers[layers[t].name] = tile_layers[layers[t].name] || { type: 'FeatureCollection', features: [] };
    }
    tile.layers = tile_layers;
    return tile_layers;
};


/*** Style parsing & defaults ***/

// Determine final style properties (color, width, etc.)
VectorRenderer.style_defaults = {
    color: [1.0, 0, 0],
    width: Style.width.pixels(5),
    size: Style.width.pixels(5),
    extrude: false,
    height: 20,
    min_height: 0,
    outline: {
        // color: [1.0, 0, 0],
        // width: 1,
        // dash: null
    },
    // render_mode: {
    //     name: 'polygons'
    // }
    render_mode: 'polygons'
};

VectorRenderer.parseStyleForFeature = function (feature, layer_style, tile)
{
    var layer_style = layer_style || {};
    var style = {};

    // Test whether features should be rendered at all
    if (typeof layer_style.filter == 'function') {
        if (layer_style.filter(feature, tile) == false) {
            return null;
        }
    }

    // Parse styles
    style.color = (layer_style.color && (layer_style.color[feature.properties.kind] || layer_style.color.default)) || VectorRenderer.style_defaults.color;
    if (typeof style.color == 'function') {
        style.color = style.color(feature, tile);
    }

    style.width = (layer_style.width && (layer_style.width[feature.properties.kind] || layer_style.width.default)) || VectorRenderer.style_defaults.width;
    if (typeof style.width == 'function') {
        style.width = style.width(feature, tile);
    }

    style.size = (layer_style.size && (layer_style.size[feature.properties.kind] || layer_style.size.default)) || VectorRenderer.style_defaults.size;
    if (typeof style.size == 'function') {
        style.size = style.size(feature, tile);
    }

    style.extrude = (layer_style.extrude && (layer_style.extrude[feature.properties.kind] || layer_style.extrude.default)) || VectorRenderer.style_defaults.extrude;
    if (typeof style.extrude == 'function') {
        style.extrude = style.extrude(feature, tile); // returning a boolean will extrude with the feature's height, a number will override the feature height (see below)
    }

    style.height = (feature.properties && feature.properties.height) || VectorRenderer.style_defaults.height;
    style.min_height = (feature.properties && feature.properties.min_height) || VectorRenderer.style_defaults.min_height;

    // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
    if (style.extrude) {
        if (typeof style.extrude == 'number') {
            style.height = style.extrude;
        }
        else if (typeof style.extrude == 'object' && style.extrude.length >= 2) {
            style.min_height = style.extrude[0];
            style.height = style.extrude[1];
        }
    }

    style.outline = {};
    layer_style.outline = layer_style.outline || {};
    style.outline.color = (layer_style.outline.color && (layer_style.outline.color[feature.properties.kind] || layer_style.outline.color.default)) || VectorRenderer.style_defaults.outline.color;
    if (typeof style.outline.color == 'function') {
        style.outline.color = style.outline.color(feature, tile);
    }

    style.outline.width = (layer_style.outline.width && (layer_style.outline.width[feature.properties.kind] || layer_style.outline.width.default)) || VectorRenderer.style_defaults.outline.width;
    if (typeof style.outline.width == 'function') {
        style.outline.width = style.outline.width(feature, tile);
    }

    style.outline.dash = (layer_style.outline.dash && (layer_style.outline.dash[feature.properties.kind] || layer_style.outline.dash.default)) || VectorRenderer.style_defaults.outline.dash;
    if (typeof style.outline.dash == 'function') {
        style.outline.dash = style.outline.dash(feature, tile);
    }

    style.render_mode = layer_style.render_mode || VectorRenderer.style_defaults.render_mode;
    // style.render_mode = {};
    // style.render_mode.name = (layer_style.render_mode && layer_style.render_mode.name) || VectorRenderer.style_defaults.render_mode.name;

    return style;
};

if (module !== undefined) {
    module.exports = VectorRenderer;
}

},{"./geo.js":2,"./point.js":8,"./style.js":10}]},{},[7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9jYW52YXNfcmVuZGVyZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvZ2VvLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL2dsLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL2dsX2J1aWxkZXJzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL2dsX2dlb20uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvZ2xfcmVuZGVyZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvbGVhZmxldF92ZWN0b3JfdGlsZV9sYXllci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9wb2ludC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zaGFkZXJzL2dsX3NoYWRlcnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3R5bGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvdmVjdG9yLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3ZlY3Rvcl9yZW5kZXJlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50LmpzJyk7XG52YXIgR2VvID0gcmVxdWlyZSgnLi9nZW8uanMnKTtcbnZhciBWZWN0b3JSZW5kZXJlciA9IHJlcXVpcmUoJy4vdmVjdG9yX3JlbmRlcmVyLmpzJyk7XG5cblZlY3RvclJlbmRlcmVyLkNhbnZhc1JlbmRlcmVyID0gQ2FudmFzUmVuZGVyZXI7XG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFZlY3RvclJlbmRlcmVyLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyICh0aWxlX3NvdXJjZSwgbGF5ZXJzLCBzdHlsZXMsIG9wdGlvbnMpXG57XG4gICAgVmVjdG9yUmVuZGVyZXIuY2FsbCh0aGlzLCAnQ2FudmFzUmVuZGVyZXInLCB0aWxlX3NvdXJjZSwgbGF5ZXJzLCBzdHlsZXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2VsZWN0aW9uIGluZm8gc2hvd24gb24gaG92ZXJcbiAgICB0aGlzLnNlbGVjdGlvbl9pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5zZWxlY3Rpb25faW5mby5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2xhYmVsJyk7XG4gICAgdGhpcy5zZWxlY3Rpb25faW5mby5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgLy8gRm9yIGRyYXdpbmcgbXVsdGlwb2x5Z29ucyB3L2NhbnZhcyBjb21wb3NpdGUgb3BlcmF0aW9uc1xuICAgIHRoaXMuY3V0b3V0X2NvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xufVxuXG4vLyBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuYWRkVGlsZSA9IGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyQWRkVGlsZSAodGlsZSwgdGlsZURpdilcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fdGlsZVdvcmtlckNvbXBsZXRlZCA9IGZ1bmN0aW9uICh0aWxlKVxue1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gR2VvLnRpbGVfc2l6ZSArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gR2VvLnRpbGVfc2l6ZSArICdweCc7XG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZChHZW8udGlsZV9zaXplICogdGhpcy5kZXZpY2VfcGl4ZWxfcmF0aW8pO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKEdlby50aWxlX3NpemUgKiB0aGlzLmRldmljZV9waXhlbF9yYXRpbyk7XG4gICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSB0aGlzLmNvbG9yVG9TdHJpbmcodGhpcy5zdHlsZXMuZGVmYXVsdCk7XG5cbiAgICB0aGlzLnJlbmRlclRpbGUodGlsZSwgY29udGV4dCk7XG5cbiAgICB2YXIgdGlsZURpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJkaXZbZGF0YS10aWxlLWtleT0nXCIgKyB0aWxlLmtleSArIFwiJ11cIik7XG4gICAgdGlsZURpdi5hcHBlbmRDaGlsZChjYW52YXMpO1xufTtcblxuLy8gU2NhbGUgYSBHZW9KU09OIGNvb3JkaW5hdGUgKDItZWxlbWVudCBhcnJheSkgZnJvbSBbbWluLCBtYXhdIHRvIHRpbGUgcGl4ZWxzXG4vLyByZXR1cm5zIGEgY29weSBvZiBnZW9tZXRyeS5jb29yZGluYXRlcyB0cmFuc2Zvcm1lZCBpbnRvIFBvaW50c1xuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnNjYWxlR2VvbWV0cnlUb1BpeGVscyA9IGZ1bmN0aW9uIHNjYWxlR2VvbWV0cnlUb1BpeGVscyAoZ2VvbWV0cnkpXG57XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICByZXR1cm4gR2VvLnRyYW5zZm9ybUdlb21ldHJ5KGdlb21ldHJ5LCBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50KFxuICAgICAgICAgICAgLy8gTWF0aC5yb3VuZCgoY29vcmRpbmF0ZXNbMF0gLSBtaW4ueCkgKiBHZW8udGlsZV9zaXplIC8gKG1heC54IC0gbWluLngpKSwgLy8gcm91bmRpbmcgcmVtb3ZlcyBzZWFtcyBidXQgY2F1c2VzIGFsaWFzaW5nXG4gICAgICAgICAgICAvLyBNYXRoLnJvdW5kKChjb29yZGluYXRlc1sxXSAtIG1pbi55KSAqIEdlby50aWxlX3NpemUgLyAobWF4LnkgLSBtaW4ueSkpXG4gICAgICAgICAgICBjb29yZGluYXRlc1swXSAqIEdlby50aWxlX3NpemUgKiByZW5kZXJlci5kZXZpY2VfcGl4ZWxfcmF0aW8gLyBWZWN0b3JSZW5kZXJlci50aWxlX3NjYWxlLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXNbMV0gKiBHZW8udGlsZV9zaXplICogcmVuZGVyZXIuZGV2aWNlX3BpeGVsX3JhdGlvIC8gVmVjdG9yUmVuZGVyZXIudGlsZV9zY2FsZSAqIC0xIC8vIGFkanVzdCBmb3IgZmxpcHBlZCB5LWNvb3JkXG4gICAgICAgICk7XG4gICAgfSk7XG59O1xuXG4vLyBSZW5kZXJzIGEgbGluZSBnaXZlbiBhcyBhbiBhcnJheSBvZiBQb2ludHNcbi8vIGxpbmUgPSBbUG9pbnQsIFBvaW50LCAuLi5dXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyTGluZSA9IGZ1bmN0aW9uIHJlbmRlckxpbmUgKGxpbmUsIHN0eWxlLCBjb250ZXh0KVxue1xuICAgIHZhciBzZWdtZW50cyA9IGxpbmU7XG4gICAgdmFyIGNvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGRhc2ggPSBzdHlsZS5kYXNoO1xuXG4gICAgdmFyIGMgPSBjb250ZXh0O1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3JUb1N0cmluZyhjb2xvcik7XG4gICAgYy5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICBjLmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIGlmIChjLnNldExpbmVEYXNoKSB7XG4gICAgICAgIGlmIChkYXNoKSB7XG4gICAgICAgICAgICBjLnNldExpbmVEYXNoKGRhc2gubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkICogd2lkdGg7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGMuc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcj0wOyByIDwgc2VnbWVudHMubGVuZ3RoIC0gMTsgciArKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IFtcbiAgICAgICAgICAgIHNlZ21lbnRzW3JdLngsIHNlZ21lbnRzW3JdLnksXG4gICAgICAgICAgICBzZWdtZW50c1tyICsgMV0ueCwgc2VnbWVudHNbciArIDFdLnlcbiAgICAgICAgXTtcblxuICAgICAgICBjLm1vdmVUbyhzZWdtZW50WzBdLCBzZWdtZW50WzFdKTtcbiAgICAgICAgYy5saW5lVG8oc2VnbWVudFsyXSwgc2VnbWVudFszXSk7XG4gICAgfTtcblxuICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgYy5zdHJva2UoKTtcbn07XG5cbi8vIFJlbmRlcnMgYSBwb2x5Z29uIGdpdmVuIGFzIGFuIGFycmF5IG9mIFBvaW50c1xuLy8gcG9seWdvbiA9IFtQb2ludCwgUG9pbnQsIC4uLl1cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJQb2x5Z29uID0gZnVuY3Rpb24gcmVuZGVyUG9seWdvbiAocG9seWdvbiwgc3R5bGUsIGNvbnRleHQpXG57XG4gICAgdmFyIHNlZ21lbnRzID0gcG9seWdvbjtcbiAgICB2YXIgY29sb3IgPSBzdHlsZS5jb2xvcjtcbiAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICB2YXIgb3V0bGluZV9jb2xvciA9IHN0eWxlLm91dGxpbmUgJiYgc3R5bGUub3V0bGluZS5jb2xvcjtcbiAgICB2YXIgb3V0bGluZV93aWR0aCA9IHN0eWxlLm91dGxpbmUgJiYgc3R5bGUub3V0bGluZS53aWR0aDtcbiAgICB2YXIgb3V0bGluZV9kYXNoID0gc3R5bGUub3V0bGluZSAmJiBzdHlsZS5vdXRsaW5lLmRhc2g7XG5cbiAgICB2YXIgYyA9IGNvbnRleHQ7XG4gICAgYy5iZWdpblBhdGgoKTtcbiAgICBjLmZpbGxTdHlsZSA9IHRoaXMuY29sb3JUb1N0cmluZyhjb2xvcik7XG4gICAgYy5tb3ZlVG8oc2VnbWVudHNbMF0ueCwgc2VnbWVudHNbMF0ueSk7XG5cbiAgICBmb3IgKHZhciByPTE7IHIgPCBzZWdtZW50cy5sZW5ndGg7IHIgKyspIHtcbiAgICAgICAgYy5saW5lVG8oc2VnbWVudHNbcl0ueCwgc2VnbWVudHNbcl0ueSk7XG4gICAgfTtcblxuICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgYy5maWxsKCk7XG5cbiAgICAvLyBPdXRsaW5lXG4gICAgaWYgKG91dGxpbmVfY29sb3IgJiYgb3V0bGluZV93aWR0aCkge1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvclRvU3RyaW5nKG91dGxpbmVfY29sb3IpO1xuICAgICAgICBjLmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgICBjLmxpbmVXaWR0aCA9IG91dGxpbmVfd2lkdGg7XG4gICAgICAgIGlmIChjLnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAob3V0bGluZV9kYXNoKSB7XG4gICAgICAgICAgICAgICAgYy5zZXRMaW5lRGFzaChvdXRsaW5lX2Rhc2gubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkICogb3V0bGluZV93aWR0aDsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYy5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9XG59O1xuXG4vLyBSZW5kZXJzIGEgcG9pbnQgZ2l2ZW4gYXMgYSBQb2ludCBvYmplY3RcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJQb2ludCA9IGZ1bmN0aW9uIHJlbmRlclBvaW50IChwb2ludCwgc3R5bGUsIGNvbnRleHQpXG57XG4gICAgdmFyIGNvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgdmFyIHNpemUgPSBzdHlsZS5zaXplO1xuICAgIHZhciBvdXRsaW5lX2NvbG9yID0gc3R5bGUub3V0bGluZSAmJiBzdHlsZS5vdXRsaW5lLmNvbG9yO1xuICAgIHZhciBvdXRsaW5lX3dpZHRoID0gc3R5bGUub3V0bGluZSAmJiBzdHlsZS5vdXRsaW5lLndpZHRoO1xuICAgIHZhciBvdXRsaW5lX2Rhc2ggPSBzdHlsZS5vdXRsaW5lICYmIHN0eWxlLm91dGxpbmUuZGFzaDtcblxuICAgIHZhciBjID0gY29udGV4dDtcbiAgICBjLmZpbGxTdHlsZSA9IHRoaXMuY29sb3JUb1N0cmluZyhjb2xvcik7XG5cbiAgICBjLmJlZ2luUGF0aCgpO1xuICAgIGMuYXJjKHBvaW50LngsIHBvaW50LnksIHNpemUsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICBjLmNsb3NlUGF0aCgpO1xuICAgIGMuZmlsbCgpO1xuXG4gICAgLy8gT3V0bGluZVxuICAgIGlmIChvdXRsaW5lX2NvbG9yICYmIG91dGxpbmVfd2lkdGgpIHtcbiAgICAgICAgYy5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3JUb1N0cmluZyhvdXRsaW5lX2NvbG9yKTtcbiAgICAgICAgYy5saW5lV2lkdGggPSBvdXRsaW5lX3dpZHRoO1xuICAgICAgICBpZiAoYy5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgICAgaWYgKG91dGxpbmVfZGFzaCkge1xuICAgICAgICAgICAgICAgIGMuc2V0TGluZURhc2gob3V0bGluZV9kYXNoLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCAqIG91dGxpbmVfd2lkdGg7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGMuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfVxufTtcblxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZlYXR1cmUgPSBmdW5jdGlvbiByZW5kZXJGZWF0dXJlIChmZWF0dXJlLCBzdHlsZSwgY29udGV4dClcbntcbiAgICB2YXIgZywgaCwgcG9seXM7XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeTtcblxuICAgIGlmIChnZW9tZXRyeS50eXBlID09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICB0aGlzLnJlbmRlckxpbmUoZ2VvbWV0cnkucGl4ZWxzLCBzdHlsZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgZm9yIChnPTA7IGcgPCBnZW9tZXRyeS5waXhlbHMubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTGluZShnZW9tZXRyeS5waXhlbHNbZ10sIHN0eWxlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgcG9seXMgPSBbZ2VvbWV0cnkucGl4ZWxzXTsgLy8gdHJlYXQgUG9seWdvbiBhcyBhIGRlZ2VuZXJhdGUgTXVsdGlQb2x5Z29uIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGNvZGVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvbHlzID0gZ2VvbWV0cnkucGl4ZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChnPTA7IGcgPCBwb2x5cy5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgLy8gUG9seWdvbnMgd2l0aCBob2xlczpcbiAgICAgICAgICAgIC8vIFJlbmRlciB0byBhIHNlcGFyYXRlIGNhbnZhcywgdXNpbmcgY29tcG9zaXRlIG9wZXJhdGlvbnMgdG8gY3V0IGhvbGVzIG91dCBvZiBwb2x5Z29uLCB0aGVuIGNvcHkgYmFjayB0byB0aGUgbWFpbiBjYW52YXNcbiAgICAgICAgICAgIGlmIChwb2x5c1tnXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3V0b3V0X2NvbnRleHQuY2FudmFzLndpZHRoICE9IGNvbnRleHQuY2FudmFzLndpZHRoIHx8IHRoaXMuY3V0b3V0X2NvbnRleHQuY2FudmFzLmhlaWdodCAhPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXRvdXRfY29udGV4dC5jYW52YXMud2lkdGggPSBjb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXRvdXRfY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gY29udGV4dC5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1dG91dF9jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmN1dG91dF9jb250ZXh0LmNhbnZhcy53aWR0aCwgdGhpcy5jdXRvdXRfY29udGV4dC5jYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY3V0b3V0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvbHlnb24ocG9seXNbZ11bMF0sIHN0eWxlLCB0aGlzLmN1dG91dF9jb250ZXh0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY3V0b3V0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgICAgICAgICAgZm9yIChoPTE7IGggPCBwb2x5c1tnXS5sZW5ndGg7IGgrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvbHlnb24ocG9seXNbZ11baF0sIHN0eWxlLCB0aGlzLmN1dG91dF9jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jdXRvdXRfY29udGV4dC5jYW52YXMsIDAsIDApO1xuXG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgY29tcG9zaXRpbmcgYmFjayB0byBtYWluIGNhbnZhcywgZHJhdyBvdXRsaW5lcyBvbiBob2xlc1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5vdXRsaW5lICYmIHN0eWxlLm91dGxpbmUuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChoPTE7IGggPCBwb2x5c1tnXS5sZW5ndGg7IGgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaW5lKHBvbHlzW2ddW2hdLCBzdHlsZS5vdXRsaW5lLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgY2xvc2VkIHBvbHlnb25zXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvbHlnb24ocG9seXNbZ11bMF0sIHN0eWxlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09ICdQb2ludCcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJQb2ludChnZW9tZXRyeS5waXhlbHMsIHN0eWxlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgZm9yIChnPTA7IGcgPCBnZW9tZXRyeS5waXhlbHMubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUG9pbnQoZ2VvbWV0cnkucGl4ZWxzW2ddLCBzdHlsZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBSZW5kZXIgYSBHZW9KU09OIHRpbGUgb250byBjYW52YXNcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUaWxlID0gZnVuY3Rpb24gcmVuZGVyVGlsZSAodGlsZSwgY29udGV4dClcbntcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgIHZhciBzdHlsZTtcblxuICAgIC8vIFNlbGVjdGlvbiByZW5kZXJpbmcgLSBvZmYtc2NyZWVuIGNhbnZhcyB0byByZW5kZXIgYSBjb2xsaXNpb24gbWFwIGZvciBmZWF0dXJlIHNlbGVjdGlvblxuICAgIHZhciBzZWxlY3Rpb24gPSB7IGNvbG9yczoge30gfTtcbiAgICB2YXIgc2VsZWN0aW9uX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHNlbGVjdGlvbl9jYW52YXMuc3R5bGUud2lkdGggPSBHZW8udGlsZV9zaXplICsgJ3B4JztcbiAgICBzZWxlY3Rpb25fY2FudmFzLnN0eWxlLndpZHRoID0gR2VvLnRpbGVfc2l6ZSArICdweCc7XG4gICAgc2VsZWN0aW9uX2NhbnZhcy53aWR0aCA9IE1hdGgucm91bmQoR2VvLnRpbGVfc2l6ZSAqIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvKTtcbiAgICBzZWxlY3Rpb25fY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQoR2VvLnRpbGVfc2l6ZSAqIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvKTtcblxuICAgIHZhciBzZWxlY3Rpb25fY29udGV4dCA9IHNlbGVjdGlvbl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgc2VsZWN0aW9uX2NvbG9yO1xuICAgIHZhciBzZWxlY3Rpb25fY291bnQgPSAwO1xuXG4gICAgLy8gUmVuZGVyIGxheWVyc1xuICAgIGZvciAodmFyIHQgaW4gcmVuZGVyZXIubGF5ZXJzKSB7XG4gICAgICAgIHZhciBsYXllciA9IHJlbmRlcmVyLmxheWVyc1t0XTtcbiAgICAgICAgdGlsZS5sYXllcnNbbGF5ZXIubmFtZV0uZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICAvLyBTY2FsZSBsb2NhbCBjb29yZHMgdG8gdGlsZSBwaXhlbHNcbiAgICAgICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkucGl4ZWxzID0gdGhpcy5zY2FsZUdlb21ldHJ5VG9QaXhlbHMoZmVhdHVyZS5nZW9tZXRyeSwgcmVuZGVyZXIudGlsZV9taW4sIHJlbmRlcmVyLnRpbGVfbWF4KTtcbiAgICAgICAgICAgIHN0eWxlID0gVmVjdG9yUmVuZGVyZXIucGFyc2VTdHlsZUZvckZlYXR1cmUoZmVhdHVyZSwgdGhpcy5zdHlsZXNbbGF5ZXIubmFtZV0sIHRpbGUpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHZpc2libGUgZ2VvbWV0cnlcbiAgICAgICAgICAgIGlmIChsYXllci52aXNpYmxlICE9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGZWF0dXJlKGZlYXR1cmUsIHN0eWxlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRHJhdyBtYXNrIGZvciBpbnRlcmFjdGl2aXR5XG4gICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHNlbGVjdGlvbiBmaWx0ZXIgbG9naWMgdG8gc3R5bGVzaGVldFxuICAgICAgICAgICAgLy8gVE9ETzogb25seSBhbHRlciBzdHlsZXMgdGhhdCBhcmUgZXhwbGljaXRseSBkaWZmZXJlbnQsIGRvbid0IG1hbnVhbGx5IGNvcHkgc3R5bGUgdmFsdWVzIGJ5IHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIGlmIChsYXllci5zZWxlY3Rpb24gPT0gdHJ1ZSAmJiBmZWF0dXJlLnByb3BlcnRpZXMubmFtZSAhPSBudWxsICYmIGZlYXR1cmUucHJvcGVydGllcy5uYW1lICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uX2NvbG9yID0gdGhpcy5nZW5lcmF0ZUNvbG9yKHNlbGVjdGlvbi5jb2xvcnMpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9jb2xvci5wcm9wZXJ0aWVzID0gZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9jb3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZShmZWF0dXJlLCB7IGNvbG9yOiBzZWxlY3Rpb25fY29sb3IuY29sb3IsIHdpZHRoOiBzdHlsZS53aWR0aCwgc2l6ZTogc3R5bGUuc2l6ZSB9LCBzZWxlY3Rpb25fY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGdlb21ldHJ5IGlzbid0IGludGVyYWN0aXZlLCBtYXNrIGl0IG91dCBzbyBnZW9tZXRyeSB1bmRlciBpdCBkb2Vzbid0IGFwcGVhciB0byBwb3AgdGhyb3VnaFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZShmZWF0dXJlLCB7IGNvbG9yOiBbMCwgMCwgMF0sIHdpZHRoOiBzdHlsZS53aWR0aCwgc2l6ZTogc3R5bGUuc2l6ZSB9LCBzZWxlY3Rpb25fY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gU2VsZWN0aW9uIGV2ZW50c1xuICAgIHZhciBzZWxlY3Rpb25faW5mbyA9IHRoaXMuc2VsZWN0aW9uX2luZm87XG4gICAgaWYgKHNlbGVjdGlvbl9jb3VudCA+IDApIHtcbiAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0uc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXG4gICAgICAgIHNlbGVjdGlvbi5waXhlbHMgPSBuZXcgVWludDMyQXJyYXkoc2VsZWN0aW9uX2NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHNlbGVjdGlvbl9jYW52YXMud2lkdGgsIHNlbGVjdGlvbl9jYW52YXMuaGVpZ2h0KS5kYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gVE9ETzogZmlyZSBldmVudHMgb24gc2VsZWN0aW9uIHRvIGVuYWJsZSBjdXN0b20gYmVoYXZpb3JcbiAgICAgICAgY29udGV4dC5jYW52YXMub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoaXQgPSB7IHg6IGV2ZW50Lm9mZnNldFgsIHk6IGV2ZW50Lm9mZnNldFkgfTsgLy8gbGF5ZXJYL1lcbiAgICAgICAgICAgIHZhciBvZmYgPSAoaGl0LnkgKiByZW5kZXJlci5kZXZpY2VfcGl4ZWxfcmF0aW8pICogKEdlby50aWxlX3NpemUgKiByZW5kZXJlci5kZXZpY2VfcGl4ZWxfcmF0aW8pICsgKGhpdC54ICogcmVuZGVyZXIuZGV2aWNlX3BpeGVsX3JhdGlvKTtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHNlbGVjdGlvbi5waXhlbHNbb2ZmXTtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gc2VsZWN0aW9uLmNvbG9yc1tjb2xvcl07XG4gICAgICAgICAgICBpZiAoZmVhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uX2luZm8uc3R5bGUubGVmdCA9IChoaXQueCArIDUpICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25faW5mby5zdHlsZS50b3AgPSAoaGl0LnkgKyA1KSArICdweCc7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uX2luZm8uaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwibGFiZWxJbm5lclwiPicgKyBmZWF0dXJlLnByb3BlcnRpZXMubmFtZSArIC8qJyBbJyArIGZlYXR1cmUucHJvcGVydGllcy5raW5kICsgJ10qLyc8L3NwYW4+JztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25faW5mby5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHNlbGVjdGlvbl9pbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLnN0eWxlLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uX2luZm8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uX2luZm8ucGFyZW50Tm9kZSA9PSBjb250ZXh0LmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZWN0aW9uX2luZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQuY2FudmFzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgc2VsZWN0aW9uX2luZm8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25faW5mby5wYXJlbnROb2RlID09IGNvbnRleHQuY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGVjdGlvbl9pbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKiBDb2xvciBoZWxwZXJzICovXG5cbi8vIFRyYW5zZm9ybSBjb2xvciBjb21wb25lbnRzIGluIDAtMSByYW5nZSB0byBodG1sIFJHQiBzdHJpbmcgZm9yIGNhbnZhc1xuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbG9yVG9TdHJpbmcgPSBmdW5jdGlvbiAoY29sb3IpXG57XG4gICAgcmV0dXJuICdyZ2IoJyArIGNvbG9yLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiB+fihjICogMjU2KTsgfSkuam9pbignLCcpICsgJyknO1xufTtcblxuLy8gR2VuZXJhdGVzIGEgcmFuZG9tIGNvbG9yIG5vdCB5ZXQgcHJlc2VudCBpbiB0aGUgcHJvdmlkZWQgaGFzaCBvZiBjb2xvcnNcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUNvbG9yID0gZnVuY3Rpb24gZ2VuZXJhdGVDb2xvciAoY29sb3JfbWFwKVxue1xuICAgIHZhciByLCBnLCBiLCBpciwgaWcsIGliLCBrZXk7XG4gICAgY29sb3JfbWFwID0gY29sb3JfbWFwIHx8IHt9O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHIgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBnID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgYiA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgaXIgPSB+fihyICogMjU2KTtcbiAgICAgICAgaWcgPSB+fihnICogMjU2KTtcbiAgICAgICAgaWIgPSB+fihiICogMjU2KTtcbiAgICAgICAga2V5ID0gKGlyICsgKGlnIDw8IDgpICsgKGliIDw8IDE2KSArICgyNTUgPDwgMjQpKSA+Pj4gMDsgLy8gbmVlZCB1bnNpZ25lZCByaWdodCBzaGlmdCB0byBjb252ZXJ0IHRvIHBvc2l0aXZlICNcblxuICAgICAgICBpZiAoY29sb3JfbWFwW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29sb3JfbWFwW2tleV0gPSB7IGNvbG9yOiBbciwgZywgYl0gfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xvcl9tYXBba2V5XTtcbn07XG5cbmlmIChtb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FudmFzUmVuZGVyZXI7XG59XG4iLCIvLyBNaXNjZWxsYW5lb3VzIGdlbyBmdW5jdGlvbnNcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQuanMnKTtcblxudmFyIEdlbyA9IHt9O1xuXG4vLyBQcm9qZWN0aW9uIGNvbnN0YW50c1xuR2VvLnRpbGVfc2l6ZSA9IDI1Njtcbkdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzID0gMjAwMzc1MDguMzQyNzg5MjQ0O1xuR2VvLm1hcF9vcmlnaW5fbWV0ZXJzID0gUG9pbnQoLUdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzLCBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyk7XG5HZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCA9IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzICogMiAvIEdlby50aWxlX3NpemU7IC8vIG1pbiB6b29tIGRyYXdzIHdvcmxkIGFzIDIgdGlsZXMgd2lkZVxuR2VvLm1ldGVyc19wZXJfcGl4ZWwgPSBbXTtcbkdlby5tYXhfem9vbSA9IDIwO1xuZm9yICh2YXIgej0wOyB6IDw9IEdlby5tYXhfem9vbTsgeisrKSB7XG4gICAgR2VvLm1ldGVyc19wZXJfcGl4ZWxbel0gPSBHZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCAvIE1hdGgucG93KDIsIHopO1xufVxuXG4vLyBDb252ZXJ0IHRpbGUgbG9jYXRpb24gdG8gbWVyY2F0b3IgbWV0ZXJzIC0gbXVsdGlwbHkgYnkgcGl4ZWxzIHBlciB0aWxlLCB0aGVuIGJ5IG1ldGVycyBwZXIgcGl4ZWwsIGFkanVzdCBmb3IgbWFwIG9yaWdpblxuR2VvLm1ldGVyc0ZvclRpbGUgPSBmdW5jdGlvbiAodGlsZSlcbntcbiAgICByZXR1cm4gUG9pbnQoXG4gICAgICAgICh0aWxlLnggKiBHZW8udGlsZV9zaXplICogR2VvLm1ldGVyc19wZXJfcGl4ZWxbdGlsZS56XSkgKyBHZW8ubWFwX29yaWdpbl9tZXRlcnMueCxcbiAgICAgICAgKCh0aWxlLnkgKiBHZW8udGlsZV9zaXplICogR2VvLm1ldGVyc19wZXJfcGl4ZWxbdGlsZS56XSkgKiAtMSkgKyBHZW8ubWFwX29yaWdpbl9tZXRlcnMueVxuICAgICk7XG59O1xuXG4vLyBDb252ZXJ0IG1lcmNhdG9yIG1ldGVycyB0byBsYXQtbG5nXG5HZW8ubWV0ZXJzVG9MYXRMbmcgPSBmdW5jdGlvbiAobWV0ZXJzKVxue1xuICAgIHZhciBjID0gUG9pbnQuY29weShtZXRlcnMpO1xuXG4gICAgYy54IC89IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzO1xuICAgIGMueSAvPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcblxuICAgIGMueSA9ICgyICogTWF0aC5hdGFuKE1hdGguZXhwKGMueSAqIE1hdGguUEkpKSAtIChNYXRoLlBJIC8gMikpIC8gTWF0aC5QSTtcblxuICAgIGMueCAqPSAxODA7XG4gICAgYy55ICo9IDE4MDtcblxuICAgIHJldHVybiBjO1xufTtcblxuLy8gQ29udmVydCBsYXQtbG5nIHRvIG1lcmNhdG9yIG1ldGVyc1xuR2VvLmxhdExuZ1RvTWV0ZXJzID0gZnVuY3Rpb24obGF0bG5nKVxue1xuICAgIHZhciBjID0gUG9pbnQuY29weShsYXRsbmcpO1xuXG4gICAgLy8gTGF0aXR1ZGVcbiAgICBjLnkgPSBNYXRoLmxvZyhNYXRoLnRhbigoYy55ICsgOTApICogTWF0aC5QSSAvIDM2MCkpIC8gKE1hdGguUEkgLyAxODApO1xuICAgIGMueSA9IGMueSAqIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gMTgwO1xuXG4gICAgLy8gTG9uZ2l0dWRlXG4gICAgYy54ID0gYy54ICogR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyAxODA7XG5cbiAgICByZXR1cm4gYztcbn07XG5cbi8vIFJ1biBhIHRyYW5zZm9ybSBmdW5jdGlvbiBvbiBlYWNoIGNvb29yZGluYXRlIGluIGEgR2VvSlNPTiBnZW9tZXRyeVxuR2VvLnRyYW5zZm9ybUdlb21ldHJ5ID0gZnVuY3Rpb24gKGdlb21ldHJ5LCB0cmFuc2Zvcm0pXG57XG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT0gJ1BvaW50Jykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PSAnTGluZVN0cmluZycgfHwgZ2VvbWV0cnkudHlwZSA9PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5LmNvb3JkaW5hdGVzLm1hcCh0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeS5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXMubWFwKHRyYW5zZm9ybSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeS5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uLm1hcChmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXMubWFwKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAgcmV0dXJuIHt9O1xufTtcblxuR2VvLmJveEludGVyc2VjdCA9IGZ1bmN0aW9uIChiMSwgYjIpXG57XG4gICAgcmV0dXJuICEoXG4gICAgICAgIGIyLnN3LnggPiBiMS5uZS54IHx8XG4gICAgICAgIGIyLm5lLnggPCBiMS5zdy54IHx8XG4gICAgICAgIGIyLnN3LnkgPiBiMS5uZS55IHx8XG4gICAgICAgIGIyLm5lLnkgPCBiMS5zdy55XG4gICAgKTtcbn07XG5cbi8vIFNwbGl0IHRoZSBsaW5lcyBvZiBhIGZlYXR1cmUgd2hlcmV2ZXIgdHdvIHBvaW50cyBhcmUgZmFydGhlciBhcGFydCB0aGFuIGEgZ2l2ZW4gdG9sZXJhbmNlXG5HZW8uc3BsaXRGZWF0dXJlTGluZXMgID0gZnVuY3Rpb24gKGZlYXR1cmUsIHRvbGVyYW5jZSkge1xuICAgIHZhciB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMC4wMDE7XG4gICAgdmFyIHRvbGVyYW5jZV9zcSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcbiAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgdmFyIGxpbmVzO1xuXG4gICAgaWYgKGdlb20udHlwZSA9PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICBsaW5lcyA9IGdlb20uY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb20udHlwZSA9PSdMaW5lU3RyaW5nJykge1xuICAgICAgICBsaW5lcyA9IFtnZW9tLmNvb3JkaW5hdGVzXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cblxuICAgIHZhciBzcGxpdF9saW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgcz0wOyBzIDwgbGluZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgdmFyIHNlZyA9IGxpbmVzW3NdO1xuICAgICAgICB2YXIgc3BsaXRfc2VnID0gW107XG4gICAgICAgIHZhciBsYXN0X2Nvb3JkID0gbnVsbDtcbiAgICAgICAgdmFyIGtlZXA7XG5cbiAgICAgICAgZm9yICh2YXIgYz0wOyBjIDwgc2VnLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSBzZWdbY107XG4gICAgICAgICAgICBrZWVwID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGxhc3RfY29vcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gKGNvb3JkWzBdIC0gbGFzdF9jb29yZFswXSkgKiAoY29vcmRbMF0gLSBsYXN0X2Nvb3JkWzBdKSArIChjb29yZFsxXSAtIGxhc3RfY29vcmRbMV0pICogKGNvb3JkWzFdIC0gbGFzdF9jb29yZFsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiB0b2xlcmFuY2Vfc3EpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJzcGxpdCBsaW5lcyBhdCAoXCIgKyBjb29yZFswXSArIFwiLCBcIiArIGNvb3JkWzFdICsgXCIpLCBcIiArIE1hdGguc3FydChkaXN0KSArIFwiIGFwYXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2VlcCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHNwbGl0X2xpbmVzLnB1c2goc3BsaXRfc2VnKTtcbiAgICAgICAgICAgICAgICBzcGxpdF9zZWcgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGl0X3NlZy5wdXNoKGNvb3JkKTtcblxuICAgICAgICAgICAgbGFzdF9jb29yZCA9IGNvb3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BsaXRfbGluZXMucHVzaChzcGxpdF9zZWcpO1xuICAgICAgICBzcGxpdF9zZWcgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoc3BsaXRfbGluZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgZ2VvbS50eXBlID0gJ0xpbmVTdHJpbmcnO1xuICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gc3BsaXRfbGluZXNbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW9tLnR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgZ2VvbS5jb29yZGluYXRlcyA9IHNwbGl0X2xpbmVzO1xuICAgIH1cblxuICAgIHJldHVybiBmZWF0dXJlO1xufTtcblxuaWYgKG1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHZW87XG59XG4iLCIvLyBXZWJHTCBtYW5hZ2VtZW50IGFuZCByZW5kZXJpbmcgZnVuY3Rpb25zXG52YXIgR0wgPSB7fTtcblxuLy8gU2V0dXAgYSBXZWJHTCBjb250ZXh0XG4vLyBJZiBubyBjYW52YXMgZWxlbWVudCBpcyBwcm92aWRlZCwgb25lIGlzIGNyZWF0ZWQgYW5kIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBib2R5XG5HTC5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoY2FudmFzKVxue1xuICAgIHZhciBjYW52YXMgPSBjYW52YXM7XG4gICAgdmFyIGZ1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICBpZiAoY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAtMTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICBmdWxsc2NyZWVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCB7IC8qcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlKi8gfSk7IC8vIHByZXNlcnZlRHJhd2luZ0J1ZmZlciBuZWVkZWQgZm9yIGdsLnJlYWRQaXhlbHMgKGNvdWxkIGJlIHVzZWQgZm9yIGZlYXR1cmUgc2VsZWN0aW9uKVxuICAgIGlmICghZ2wpIHtcbiAgICAgICAgYWxlcnQoXCJDb3VsZG4ndCBjcmVhdGUgV2ViR0wgY29udGV4dC4gWW91ciBicm93c2VyIHByb2JhYmx5IGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTCBvciBpdCdzIHR1cm5lZCBvZmY/XCIpO1xuICAgICAgICB0aHJvdyBcIkNvdWxkbid0IGNyZWF0ZSBXZWJHTCBjb250ZXh0XCI7XG4gICAgfVxuXG4gICAgR0wucmVzaXplQ2FudmFzKGdsLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBpZiAoZnVsbHNjcmVlbiA9PSB0cnVlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBHTC5yZXNpemVDYW52YXMoZ2wsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBHTC5WZXJ0ZXhBcnJheU9iamVjdC5pbml0KGdsKTsgLy8gVE9ETzogdGhpcyBwYXR0ZXJuIGRvZXNuJ3Qgc3VwcG9ydCBtdWx0aXBsZSBhY3RpdmUgR0wgY29udGV4dHMsIHNob3VsZCB0aGF0IGV2ZW4gYmUgc3VwcG9ydGVkP1xuXG4gICAgcmV0dXJuIGdsO1xufTtcblxuR0wucmVzaXplQ2FudmFzID0gZnVuY3Rpb24gKGdsLCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIHZhciBkZXZpY2VfcGl4ZWxfcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIGdsLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBnbC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBnbC5jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5zdHlsZS53aWR0aCAqIGRldmljZV9waXhlbF9yYXRpbyk7XG4gICAgZ2wuY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQoZ2wuY2FudmFzLnN0eWxlLndpZHRoICogZGV2aWNlX3BpeGVsX3JhdGlvKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xufTtcblxuLy8gQ29tcGlsZSAmIGxpbmsgYSBXZWJHTCBwcm9ncmFtIGZyb20gcHJvdmlkZWQgdmVydGV4IGFuZCBzaGFkZXIgc291cmNlIGVsZW1lbnRzXG5HTC5jcmVhdGVQcm9ncmFtRnJvbUVsZW1lbnRzID0gZnVuY3Rpb24gR0xjcmVhdGVQcm9ncmFtRnJvbUVsZW1lbnRzIChnbCwgdmVydGV4X3NoYWRlcl9pZCwgZnJhZ21lbnRfc2hhZGVyX2lkKVxue1xuICAgIHZhciB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHZlcnRleF9zaGFkZXJfaWQpLnRleHRDb250ZW50O1xuICAgIHZhciBmcmFnbWVudF9zaGFkZXJfc291cmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZnJhZ21lbnRfc2hhZGVyX2lkKS50ZXh0Q29udGVudDtcbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICByZXR1cm4gR0wudXBkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSwgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGZyYWdtZW50X3NoYWRlcl9zb3VyY2UpO1xufTtcblxuLy8gQ29tcGlsZSAmIGxpbmsgYSBXZWJHTCBwcm9ncmFtIGZyb20gcHJvdmlkZWQgdmVydGV4IGFuZCBzaGFkZXIgc291cmNlIFVSTHNcbi8vIE5PVEU6IGxvYWRzIHZpYSBzeW5jaHJvbm91cyBYSFIgZm9yIHNpbXBsaWNpdHksIGNvdWxkIGJlIG1hZGUgYXN5bmNcbkdMLmNyZWF0ZVByb2dyYW1Gcm9tVVJMcyA9IGZ1bmN0aW9uIEdMY3JlYXRlUHJvZ3JhbUZyb21VUkxzIChnbCwgdmVydGV4X3NoYWRlcl91cmwsIGZyYWdtZW50X3NoYWRlcl91cmwpXG57XG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgcmV0dXJuIEdMLnVwZGF0ZVByb2dyYW1Gcm9tVVJMcyhnbCwgcHJvZ3JhbSwgdmVydGV4X3NoYWRlcl91cmwsIGZyYWdtZW50X3NoYWRlcl91cmwpO1xufTtcblxuR0wudXBkYXRlUHJvZ3JhbUZyb21VUkxzID0gZnVuY3Rpb24gR0xVcGRhdGVQcm9ncmFtRnJvbVVSTHMgKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyX3VybCwgZnJhZ21lbnRfc2hhZGVyX3VybClcbntcbiAgICB2YXIgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGZyYWdtZW50X3NoYWRlcl9zb3VyY2U7XG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgdmVydGV4X3NoYWRlcl9zb3VyY2UgPSByZXEucmVzcG9uc2U7IH07XG4gICAgcmVxLm9wZW4oJ0dFVCcsIHZlcnRleF9zaGFkZXJfdXJsICsgJz8nICsgKCtuZXcgRGF0ZSgpKSwgZmFsc2UgLyogYXN5bmMgZmxhZyAqLyk7XG4gICAgcmVxLnNlbmQoKTtcblxuICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IGZyYWdtZW50X3NoYWRlcl9zb3VyY2UgPSByZXEucmVzcG9uc2U7IH07XG4gICAgcmVxLm9wZW4oJ0dFVCcsIGZyYWdtZW50X3NoYWRlcl91cmwgKyAnPycgKyAoK25ldyBEYXRlKCkpLCBmYWxzZSAvKiBhc3luYyBmbGFnICovKTtcbiAgICByZXEuc2VuZCgpO1xuXG4gICAgcmV0dXJuIEdMLnVwZGF0ZVByb2dyYW0oZ2wsIHByb2dyYW0sIHZlcnRleF9zaGFkZXJfc291cmNlLCBmcmFnbWVudF9zaGFkZXJfc291cmNlKTtcbn07XG5cbi8vIENvbXBpbGUgJiBsaW5rIGEgV2ViR0wgcHJvZ3JhbSBmcm9tIHByb3ZpZGVkIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZXNcbi8vIHVwZGF0ZSBhIHByb2dyYW0gaWYgb25lIGlzIHBhc3NlZCBpbi4gQ3JlYXRlIG9uZSBpZiBub3QuIEFsZXJ0IGFuZCBkb24ndCB1cGRhdGUgYW55dGhpbmcgaWYgdGhlIHNoYWRlcnMgZG9uJ3QgY29tcGlsZS5cbkdMLnVwZGF0ZVByb2dyYW0gPSBmdW5jdGlvbiBHTHVwZGF0ZVByb2dyYW0gKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSwgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSlcbntcbiAgICB0cnkge1xuICAgICAgICB2YXIgdmVydGV4X3NoYWRlciA9IEdMLmNyZWF0ZVNoYWRlcihnbCwgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB2YXIgZnJhZ21lbnRfc2hhZGVyID0gR0wuY3JlYXRlU2hhZGVyKGdsLCAnI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbicgKyBmcmFnbWVudF9zaGFkZXJfc291cmNlLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIH1cbiAgICBjYXRjaChlcnIpXG4gICAge1xuICAgICAgICBhbGVydChlcnIpO1xuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xuICAgIGlmIChwcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG9sZF9zaGFkZXJzID0gZ2wuZ2V0QXR0YWNoZWRTaGFkZXJzKHByb2dyYW0pO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2xkX3NoYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdsLmRldGFjaFNoYWRlcihwcm9ncmFtLCBvbGRfc2hhZGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0ZXhfc2hhZGVyID09IG51bGwgfHwgZnJhZ21lbnRfc2hhZGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleF9zaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudF9zaGFkZXIpO1xuXG4gICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleF9zaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudF9zaGFkZXIpO1xuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgIHZhciBwcm9ncmFtX2Vycm9yID1cbiAgICAgICAgICAgIFwiV2ViR0wgcHJvZ3JhbSBlcnJvcjpcXG5cIiArXG4gICAgICAgICAgICBcIlZBTElEQVRFX1NUQVRVUzogXCIgKyBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykgKyBcIlxcblwiICtcbiAgICAgICAgICAgIFwiRVJST1I6IFwiICsgZ2wuZ2V0RXJyb3IoKSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgXCItLS0gVmVydGV4IFNoYWRlciAtLS1cXG5cIiArIHZlcnRleF9zaGFkZXJfc291cmNlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBcIi0tLSBGcmFnbWVudCBTaGFkZXIgLS0tXFxuXCIgKyBmcmFnbWVudF9zaGFkZXJfc291cmNlO1xuICAgICAgICB0aHJvdyBwcm9ncmFtX2Vycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xufTtcblxuLy8gQ29tcGlsZSBhIHZlcnRleCBvciBmcmFnbWVudCBzaGFkZXIgZnJvbSBwcm92aWRlZCBzb3VyY2VcbkdMLmNyZWF0ZVNoYWRlciA9IGZ1bmN0aW9uIEdMY3JlYXRlU2hhZGVyIChnbCwgc291cmNlLCB0eXBlKVxue1xuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIHZhciBzaGFkZXJfZXJyb3IgPVxuICAgICAgICAgICAgXCJXZWJHTCBzaGFkZXIgZXJyb3I6XFxuXCIgK1xuICAgICAgICAgICAgKHR5cGUgPT0gZ2wuVkVSVEVYX1NIQURFUiA/IFwiVkVSVEVYXCIgOiBcIkZSQUdNRU5UXCIpICsgXCIgU0hBREVSOlxcblwiICtcbiAgICAgICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgdGhyb3cgc2hhZGVyX2Vycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG59O1xuXG4vLyBUaGluIEdMIHByb2dyYW0gbGF5ZXIgdG8gY2FjaGUgdW5pZm9ybSBsb2NhdGlvbnMvdmFsdWVzLCBkbyBjb21waWxlLXRpbWUgcHJlLXByb2Nlc3NpbmcgKGluamVjdGluZyAjZGVmaW5lcyBpbnRvIHNoYWRlcnMpLCBldGMuXG5HTC5Qcm9ncmFtID0gZnVuY3Rpb24gKGdsLCB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSwgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSwgb3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMuZGVmaW5lcyA9IG9wdGlvbnMuZGVmaW5lcyB8fCB7fTsgLy8ga2V5L3ZhbHVlcyBpbnNlcnRlZCBpbnRvIHNoYWRlcnMgYXQgY29tcGlsZS10aW1lXG4gICAgdGhpcy51bmlmb3JtcyA9IHt9OyAvLyBwcm9ncmFtIGxvY2F0aW9ucyBvZiB1bmlmb3Jtcywgc2V0L3VwZGF0ZWQgYXQgY29tcGlsZS10aW1lXG4gICAgdGhpcy5hdHRyaWJzID0ge307IC8vIHByb2dyYW0gbG9jYXRpb25zIG9mIHZlcnRleCBhdHRyaWJ1dGVzXG4gICAgdGhpcy52ZXJ0ZXhfc2hhZGVyX3NvdXJjZSA9IHZlcnRleF9zaGFkZXJfc291cmNlO1xuICAgIHRoaXMuZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSA9IGZyYWdtZW50X3NoYWRlcl9zb3VyY2U7XG4gICAgdGhpcy5jb21waWxlKCk7XG59O1xuXG4vLyBDcmVhdGVzIGEgcHJvZ3JhbSB0aGF0IHdpbGwgcmVmcmVzaCBmcm9tIHNvdXJjZSBVUkxzIGVhY2ggdGltZSBpdCBpcyBjb21waWxlZFxuR0wuUHJvZ3JhbS5jcmVhdGVQcm9ncmFtRnJvbVVSTHMgPSBmdW5jdGlvbiAoZ2wsIHZlcnRleF9zaGFkZXJfdXJsLCBmcmFnbWVudF9zaGFkZXJfdXJsLCBvcHRpb25zKVxue1xuICAgIHZhciBwcm9ncmFtID0gT2JqZWN0LmNyZWF0ZShHTC5Qcm9ncmFtLnByb3RvdHlwZSk7XG5cbiAgICBwcm9ncmFtLnZlcnRleF9zaGFkZXJfdXJsID0gdmVydGV4X3NoYWRlcl91cmw7XG4gICAgcHJvZ3JhbS5mcmFnbWVudF9zaGFkZXJfdXJsID0gZnJhZ21lbnRfc2hhZGVyX3VybDtcblxuICAgIHByb2dyYW0udXBkYXRlVmVydGV4U2hhZGVyU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHNvdXJjZSA9IHJlcS5yZXNwb25zZTsgfTtcbiAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHRoaXMudmVydGV4X3NoYWRlcl91cmwgKyAnPycgKyAoK25ldyBEYXRlKCkpLCBmYWxzZSAvKiBhc3luYyBmbGFnICovKTtcbiAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuXG4gICAgcHJvZ3JhbS51cGRhdGVGcmFnbWVudFNoYWRlclNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkgeyBzb3VyY2UgPSByZXEucmVzcG9uc2U7IH07XG4gICAgICAgIHJlcS5vcGVuKCdHRVQnLCB0aGlzLmZyYWdtZW50X3NoYWRlcl91cmwgKyAnPycgKyAoK25ldyBEYXRlKCkpLCBmYWxzZSAvKiBhc3luYyBmbGFnICovKTtcbiAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuXG4gICAgR0wuUHJvZ3JhbS5jYWxsKHByb2dyYW0sIGdsLCBudWxsLCBudWxsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcHJvZ3JhbTtcbn07XG5cbi8vIEdsb2JhbCBkZWZpbmVzIGFwcGxpZWQgdG8gYWxsIHByb2dyYW1zIChkdXBsaWNhdGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBwcm9ncmFtIHdpbGwgdGFrZSBwcmVjZWRlbmNlKVxuR0wuUHJvZ3JhbS5kZWZpbmVzID0ge307XG5cbkdMLlByb2dyYW0ucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIE9wdGlvbmFsbHkgdXBkYXRlIHNvdXJjZXNcbiAgICBpZiAodHlwZW9mIHRoaXMudXBkYXRlVmVydGV4U2hhZGVyU291cmNlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfc2hhZGVyX3NvdXJjZSA9IHRoaXMudXBkYXRlVmVydGV4U2hhZGVyU291cmNlKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy51cGRhdGVGcmFnbWVudFNoYWRlclNvdXJjZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSA9IHRoaXMudXBkYXRlRnJhZ21lbnRTaGFkZXJTb3VyY2UoKTtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgZGVmaW5lcyAoZ2xvYmFsLCB0aGVuIHByb2dyYW0tc3BlY2lmaWMpXG4gICAgdmFyIGRlZmluZXMgPSB7fTtcbiAgICBmb3IgKHZhciBkIGluIEdMLlByb2dyYW0uZGVmaW5lcykge1xuICAgICAgICBkZWZpbmVzW2RdID0gR0wuUHJvZ3JhbS5kZWZpbmVzW2RdO1xuICAgIH1cbiAgICBmb3IgKHZhciBkIGluIHRoaXMuZGVmaW5lcykge1xuICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5kZWZpbmVzW2RdO1xuICAgIH1cblxuICAgIHZhciBkZWZpbmVfc3RyID0gXCJcIjtcbiAgICBmb3IgKHZhciBkIGluIGRlZmluZXMpIHtcbiAgICAgICAgaWYgKGRlZmluZXNbZF0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmVzW2RdID09ICdib29sZWFuJyAmJiBkZWZpbmVzW2RdID09IHRydWUpIHtcbiAgICAgICAgICAgIGRlZmluZV9zdHIgKz0gXCIjZGVmaW5lIFwiICsgZCArIFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVfc3RyICs9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIGRlZmluZXNbZF0gKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc2VkX3ZlcnRleF9zaGFkZXJfc291cmNlID0gZGVmaW5lX3N0ciArIHRoaXMudmVydGV4X3NoYWRlcl9zb3VyY2U7XG4gICAgdGhpcy5wcm9jZXNzZWRfZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSA9IGRlZmluZV9zdHIgKyB0aGlzLmZyYWdtZW50X3NoYWRlcl9zb3VyY2U7XG5cbiAgICAvLyBDb21waWxlICYgc2V0IHVuaWZvcm1zIHRvIGNhY2hlZCB2YWx1ZXNcbiAgICB0aGlzLnByb2dyYW0gPSBHTC51cGRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSwgdGhpcy5wcm9jZXNzZWRfdmVydGV4X3NoYWRlcl9zb3VyY2UsIHRoaXMucHJvY2Vzc2VkX2ZyYWdtZW50X3NoYWRlcl9zb3VyY2UpO1xuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIHRoaXMucmVmcmVzaFVuaWZvcm1zKCk7XG4gICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlcygpO1xufTtcblxuLy8gZXg6IHByb2dyYW0udW5pZm9ybSgnM2YnLCAncG9zaXRpb24nLCB4LCB5LCB6KTtcbkdMLlByb2dyYW0ucHJvdG90eXBlLnVuaWZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBuYW1lKSAvLyBtZXRob2QtYXBwcm9wcmlhdGUgYXJndW1lbnRzIGZvbGxvd1xue1xuICAgIHZhciB1bmlmb3JtID0gKHRoaXMudW5pZm9ybXNbbmFtZV0gPSB0aGlzLnVuaWZvcm1zW25hbWVdIHx8IHt9KTtcbiAgICB1bmlmb3JtLm5hbWUgPSBuYW1lO1xuICAgIHVuaWZvcm0ubG9jYXRpb24gPSB1bmlmb3JtLmxvY2F0aW9uIHx8IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XG4gICAgdW5pZm9ybS5tZXRob2QgPSAndW5pZm9ybScgKyBtZXRob2Q7XG4gICAgdW5pZm9ybS52YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHRoaXMudXBkYXRlVW5pZm9ybShuYW1lKTtcbn07XG5cbi8vIFNldCBhIHNpbmdsZSB1bmlmb3JtXG5HTC5Qcm9ncmFtLnByb3RvdHlwZS51cGRhdGVVbmlmb3JtID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgdmFyIHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW25hbWVdO1xuICAgIGlmICh1bmlmb3JtID09IG51bGwgfHwgdW5pZm9ybS5sb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nbFt1bmlmb3JtLm1ldGhvZF0uYXBwbHkodGhpcy5nbCwgW3VuaWZvcm0ubG9jYXRpb25dLmNvbmNhdCh1bmlmb3JtLnZhbHVlcykpOyAvLyBjYWxsIGFwcHJvcHJpYXRlIEdMIHVuaWZvcm0gbWV0aG9kIGFuZCBwYXNzIHRocm91Z2ggYXJndW1lbnRzXG59O1xuXG4vLyBSZWZyZXNoIHVuaWZvcm0gbG9jYXRpb25zIGFuZCBzZXQgdG8gbGFzdCBjYWNoZWQgdmFsdWVzXG5HTC5Qcm9ncmFtLnByb3RvdHlwZS5yZWZyZXNoVW5pZm9ybXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGZvciAodmFyIHUgaW4gdGhpcy51bmlmb3Jtcykge1xuICAgICAgICB0aGlzLnVuaWZvcm1zW3VdLmxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCB1KTtcbiAgICAgICAgdGhpcy51cGRhdGVVbmlmb3JtKHUpO1xuICAgIH1cbn07XG5cbkdMLlByb2dyYW0ucHJvdG90eXBlLnJlZnJlc2hBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyB2YXIgbGVuID0gdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gICAgLy8gZm9yICh2YXIgaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyAgICAgdmFyIGEgPSB0aGlzLmdsLmdldEFjdGl2ZUF0dHJpYih0aGlzLnByb2dyYW0sIGkpO1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhhKTtcbiAgICAvLyB9XG4gICAgdGhpcy5hdHRyaWJzID0ge307XG59O1xuXG4vLyBHZXQgdGhlIGxvY2F0aW9uIG9mIGEgdmVydGV4IGF0dHJpYnV0ZVxuR0wuUHJvZ3JhbS5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgdmFyIGF0dHJpYiA9ICh0aGlzLmF0dHJpYnNbbmFtZV0gPSB0aGlzLmF0dHJpYnNbbmFtZV0gfHwge30pO1xuICAgIGlmIChhdHRyaWIubG9jYXRpb24gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYXR0cmliO1xuICAgIH1cblxuICAgIGF0dHJpYi5uYW1lID0gbmFtZTtcbiAgICBhdHRyaWIubG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XG5cbiAgICAvLyB2YXIgaW5mbyA9IHRoaXMuZ2wuZ2V0QWN0aXZlQXR0cmliKHRoaXMucHJvZ3JhbSwgYXR0cmliLmxvY2F0aW9uKTtcbiAgICAvLyBhdHRyaWIudHlwZSA9IGluZm8udHlwZTtcbiAgICAvLyBhdHRyaWIuc2l6ZSA9IGluZm8uc2l6ZTtcblxuICAgIHJldHVybiBhdHRyaWI7XG59O1xuXG4vLyBUcmlhbmd1bGF0aW9uIHVzaW5nIGxpYnRlc3MuanMgcG9ydCBvZiBnbHVUZXNzZWxhdG9yXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYnJlbmRhbmtlbm55L2xpYnRlc3MuanNcbnRyeSB7XG4gICAgR0wudGVzc2VsYXRvciA9IChmdW5jdGlvbiBpbml0VGVzc2VsYXRvcigpIHtcbiAgICAgICAgLy8gQ2FsbGVkIGZvciBlYWNoIHZlcnRleCBvZiB0ZXNzZWxhdG9yIG91dHB1dFxuICAgICAgICBmdW5jdGlvbiB2ZXJ0ZXhDYWxsYmFjayhkYXRhLCBwb2x5VmVydEFycmF5KSB7XG4gICAgICAgICAgICBwb2x5VmVydEFycmF5LnB1c2goW2RhdGFbMF0sIGRhdGFbMV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHNlZ21lbnRzIGludGVyc2VjdCBhbmQgbXVzdCBiZSBzcGxpdFxuICAgICAgICBmdW5jdGlvbiBjb21iaW5lQ2FsbGJhY2soY29vcmRzLCBkYXRhLCB3ZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiBhIHZlcnRleCBzdGFydHMgb3Igc3RvcHMgYSBib3VuZGFyeSBlZGdlIG9mIGEgcG9seWdvblxuICAgICAgICBmdW5jdGlvbiBlZGdlQ2FsbGJhY2soZmxhZykge1xuICAgICAgICAgICAgLy8gTm8tb3AgY2FsbGJhY2sgdG8gZm9yY2Ugc2ltcGxlIHRyaWFuZ2xlIHByaW1pdGl2ZXMgKG5vIHRyaWFuZ2xlIHN0cmlwcyBvciBmYW5zKS5cbiAgICAgICAgICAgIC8vIFNlZTogaHR0cDovL3d3dy5nbHByb2dyYW1taW5nLmNvbS9yZWQvY2hhcHRlcjExLmh0bWxcbiAgICAgICAgICAgIC8vIFwiU2luY2UgZWRnZSBmbGFncyBtYWtlIG5vIHNlbnNlIGluIGEgdHJpYW5nbGUgZmFuIG9yIHRyaWFuZ2xlIHN0cmlwLCBpZiB0aGVyZSBpcyBhIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggR0xVX1RFU1NfRURHRV9GTEFHIHRoYXQgZW5hYmxlcyBlZGdlIGZsYWdzLCB0aGUgR0xVX1RFU1NfQkVHSU4gY2FsbGJhY2sgaXNcbiAgICAgICAgICAgIC8vIGNhbGxlZCBvbmx5IHdpdGggR0xfVFJJQU5HTEVTLlwiXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnR0wudGVzc2VsYXRvcjogZWRnZSBmbGFnOiAnICsgZmxhZyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGVzc2VsYXRvciA9IG5ldyBsaWJ0ZXNzLkdsdVRlc3NlbGF0b3IoKTtcbiAgICAgICAgdGVzc2VsYXRvci5nbHVUZXNzQ2FsbGJhY2sobGlidGVzcy5nbHVFbnVtLkdMVV9URVNTX1ZFUlRFWF9EQVRBLCB2ZXJ0ZXhDYWxsYmFjayk7XG4gICAgICAgIHRlc3NlbGF0b3IuZ2x1VGVzc0NhbGxiYWNrKGxpYnRlc3MuZ2x1RW51bS5HTFVfVEVTU19DT01CSU5FLCBjb21iaW5lQ2FsbGJhY2spO1xuICAgICAgICB0ZXNzZWxhdG9yLmdsdVRlc3NDYWxsYmFjayhsaWJ0ZXNzLmdsdUVudW0uR0xVX1RFU1NfRURHRV9GTEFHLCBlZGdlQ2FsbGJhY2spO1xuXG4gICAgICAgIC8vIEJyZW5kYW4gS2Vubnk6XG4gICAgICAgIC8vIGxpYnRlc3Mgd2lsbCB0YWtlIDNkIHZlcnRzIGFuZCBmbGF0dGVuIHRvIGEgcGxhbmUgZm9yIHRlc3NlbGF0aW9uXG4gICAgICAgIC8vIHNpbmNlIG9ubHkgZG9pbmcgMmQgdGVzc2VsYXRpb24gaGVyZSwgcHJvdmlkZSB6PTEgbm9ybWFsIHRvIHNraXBcbiAgICAgICAgLy8gaXRlcmF0aW5nIG92ZXIgdmVydHMgb25seSB0byBnZXQgdGhlIHNhbWUgYW5zd2VyLlxuICAgICAgICAvLyBjb21tZW50IG91dCB0byB0ZXN0IG5vcm1hbC1nZW5lcmF0aW9uIGNvZGVcbiAgICAgICAgdGVzc2VsYXRvci5nbHVUZXNzTm9ybWFsKDAsIDAsIDEpO1xuXG4gICAgICAgIHJldHVybiB0ZXNzZWxhdG9yO1xuICAgIH0pKCk7XG5cbiAgICBHTC50cmlhbmd1bGF0ZVBvbHlnb24gPSBmdW5jdGlvbiBHTFRyaWFuZ3VsYXRlIChjb250b3VycylcbiAgICB7XG4gICAgICAgIHZhciB0cmlhbmdsZVZlcnRzID0gW107XG4gICAgICAgIEdMLnRlc3NlbGF0b3IuZ2x1VGVzc0JlZ2luUG9seWdvbih0cmlhbmdsZVZlcnRzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRvdXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBHTC50ZXNzZWxhdG9yLmdsdVRlc3NCZWdpbkNvbnRvdXIoKTtcbiAgICAgICAgICAgIHZhciBjb250b3VyID0gY29udG91cnNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRvdXIubGVuZ3RoOyBqICsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFtjb250b3VyW2pdWzBdLCBjb250b3VyW2pdWzFdLCAwXTtcbiAgICAgICAgICAgICAgICBHTC50ZXNzZWxhdG9yLmdsdVRlc3NWZXJ0ZXgoY29vcmRzLCBjb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR0wudGVzc2VsYXRvci5nbHVUZXNzRW5kQ29udG91cigpO1xuICAgICAgICB9XG5cbiAgICAgICAgR0wudGVzc2VsYXRvci5nbHVUZXNzRW5kUG9seWdvbigpO1xuICAgICAgICByZXR1cm4gdHJpYW5nbGVWZXJ0cztcbiAgICB9O1xufVxuY2F0Y2ggKGUpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcImxpYnRlc3Mgbm90IGRlZmluZWQhXCIpO1xuICAgIC8vIHNraXAgaWYgbGlidGVzcyBub3QgZGVmaW5lZFxufVxuXG4vLyBBZGQgb25lIG9yIG1vcmUgdmVydGljZXMgdG8gYW4gYXJyYXkgKGRlc3RpbmVkIHRvIGJlIHVzZWQgYXMgYSBHTCBidWZmZXIpLCAnc3RyaXBpbmcnIGVhY2ggdmVydGV4IHdpdGggY29uc3RhbnQgZGF0YVxuLy8gVXNlZCBmb3IgYWRkaW5nIHZhbHVlcyB0aGF0IGFyZSBvZnRlbiBjb25zdGFudCBwZXIgZ2VvbWV0cnkgb3IgcG9seWdvbiwgbGlrZSBjb2xvcnMsIG5vcm1hbHMgKGZvciBwb2x5cyBzaXR0aW5nIGZsYXQgb24gbWFwKSwgbGF5ZXIgYW5kIG1hdGVyaWFsIGluZm8sIGV0Yy5cbkdMLmFkZFZlcnRpY2VzID0gZnVuY3Rpb24gKHZlcnRpY2VzLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X2NvbnN0YW50cylcbntcbiAgICBpZiAodmVydGljZXMgIT0gbnVsbCAmJiB2ZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEFycmF5IG9mIHZlcnRpY2VzXG4gICAgICAgIGlmICh0eXBlb2YgdmVydGljZXNbMF0gPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHY9MDsgdiA8IHZlcnRpY2VzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4X2RhdGEucHVzaC5hcHBseSh2ZXJ0ZXhfZGF0YSwgdmVydGljZXNbdl0pO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXhfY29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhLnB1c2guYXBwbHkodmVydGV4X2RhdGEsIHZlcnRleF9jb25zdGFudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5nbGUgdmVydGV4XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmVydGV4X2RhdGEucHVzaC5hcHBseSh2ZXJ0ZXhfZGF0YSwgdmVydGljZXMpO1xuICAgICAgICAgICAgaWYgKHZlcnRleF9jb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5wdXNoLmFwcGx5KHZlcnRleF9kYXRhLCB2ZXJ0ZXhfY29uc3RhbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmVydGV4X2RhdGE7XG59O1xuXG4vLyBDcmVhdGVzIGEgVmVydGV4IEFycmF5IE9iamVjdCBpZiB0aGUgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayBvbiBzdGFuZGFyZCBhdHRyaWJ1dGUgY2FsbHNcbkdMLlZlcnRleEFycmF5T2JqZWN0ID0ge307XG5HTC5WZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCA9IGZhbHNlOyAvLyBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIFZBT3MgZXZlbiBpZiBleHRlbnNpb24gaXMgYXZhaWxhYmxlXG5HTC5WZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gPSBudWxsOyAvLyBjdXJyZW50bHkgYm91bmQgVkFPXG5cbkdMLlZlcnRleEFycmF5T2JqZWN0LmluaXQgPSBmdW5jdGlvbiAoZ2wpXG57XG4gICAgaWYgKEdMLlZlcnRleEFycmF5T2JqZWN0LmV4dCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChHTC5WZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCAhPSB0cnVlKSB7XG4gICAgICAgICAgICBHTC5WZXJ0ZXhBcnJheU9iamVjdC5leHQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChHTC5WZXJ0ZXhBcnJheU9iamVjdC5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJWZXJ0ZXggQXJyYXkgT2JqZWN0IGV4dGVuc2lvbiBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoR0wuVmVydGV4QXJyYXlPYmplY3QuZGlzYWJsZWQgIT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJWZXJ0ZXggQXJyYXkgT2JqZWN0IGV4dGVuc2lvbiBOT1QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJWZXJ0ZXggQXJyYXkgT2JqZWN0IGV4dGVuc2lvbiBmb3JjZSBkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkdMLlZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChzZXR1cCwgdGVhcmRvd24pXG57XG4gICAgdmFyIHZhbyA9IHt9O1xuICAgIHZhby5zZXR1cCA9IHNldHVwO1xuICAgIHZhby50ZWFyZG93biA9IHRlYXJkb3duO1xuXG4gICAgdmFyIGV4dCA9IEdMLlZlcnRleEFycmF5T2JqZWN0LmV4dDtcbiAgICBpZiAoZXh0ICE9IG51bGwpIHtcbiAgICAgICAgdmFvLl92YW8gPSBleHQuY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcbiAgICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8uX3Zhbyk7XG4gICAgICAgIHZhby5zZXR1cCgpO1xuICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgICAgICBpZiAodHlwZW9mIHZhby50ZWFyZG93biA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YW8udGVhcmRvd24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFvLnNldHVwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbztcbn07XG5cbkdMLlZlcnRleEFycmF5T2JqZWN0LmJpbmQgPSBmdW5jdGlvbiAodmFvKVxue1xuICAgIHZhciBleHQgPSBHTC5WZXJ0ZXhBcnJheU9iamVjdC5leHQ7XG4gICAgaWYgKHZhbyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChleHQgIT0gbnVsbCAmJiB2YW8uX3ZhbyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHZhby5fdmFvKTtcbiAgICAgICAgICAgIEdMLlZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IHZhbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhby5zZXR1cCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoR0wuVmVydGV4QXJyYXlPYmplY3QuYm91bmRfdmFvICE9IG51bGwgJiYgdHlwZW9mIEdMLlZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3Zhby50ZWFyZG93biA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBHTC5WZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8udGVhcmRvd24oKTtcbiAgICAgICAgfVxuICAgICAgICBHTC5WZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gPSBudWxsO1xuICAgIH1cbn07XG5cbmlmIChtb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gR0w7XG59XG4iLCJ2YXIgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3IuanMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQuanMnKTtcbnZhciBHTCA9IHJlcXVpcmUoJy4vZ2wuanMnKTtcblxudmFyIEdMQnVpbGRlcnMgPSB7fTtcblxuR0xCdWlsZGVycy5kZWJ1ZyA9IGZhbHNlO1xuXG4vLyBUZXNzZWxhdGUgYSBmbGF0IDJEIHBvbHlnb24gd2l0aCBmaXhlZCBoZWlnaHQgYW5kIGFkZCB0byBHTCB2ZXJ0ZXggYnVmZmVyXG5HTEJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMgPSBmdW5jdGlvbiBHTEJ1aWxkZXJzQnVpbGRQb2x5Z29ucyAocG9seWdvbnMsIHosIHZlcnRleF9kYXRhLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHZlcnRleF9jb25zdGFudHMgPSBbeiwgMCwgMCwgMV07IC8vIHByb3ZpZGVkIHosIGFuZCB1cHdhcmRzLWZhY2luZyBub3JtYWxcbiAgICBpZiAob3B0aW9ucy52ZXJ0ZXhfY29uc3RhbnRzKSB7XG4gICAgICAgIHZlcnRleF9jb25zdGFudHMucHVzaC5hcHBseSh2ZXJ0ZXhfY29uc3RhbnRzLCBvcHRpb25zLnZlcnRleF9jb25zdGFudHMpO1xuICAgIH1cblxuICAgIHZhciBudW1fcG9seWdvbnMgPSBwb2x5Z29ucy5sZW5ndGg7XG4gICAgZm9yICh2YXIgcD0wOyBwIDwgbnVtX3BvbHlnb25zOyBwKyspIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gR0wudHJpYW5ndWxhdGVQb2x5Z29uKHBvbHlnb25zW3BdKTtcbiAgICAgICAgR0wuYWRkVmVydGljZXModmVydGljZXMsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVydGV4X2RhdGE7XG59O1xuXG4vLyBUZXNzZWxhdGUgYW5kIGV4dHJ1ZGUgYSBmbGF0IDJEIHBvbHlnb24gaW50byBhIHNpbXBsZSAzRCBtb2RlbCB3aXRoIGZpeGVkIGhlaWdodCBhbmQgYWRkIHRvIEdMIHZlcnRleCBidWZmZXJcbkdMQnVpbGRlcnMuYnVpbGRFeHRydWRlZFBvbHlnb25zID0gZnVuY3Rpb24gR0xCdWlsZGVyc0J1aWxkRXh0cnVkZWRQb2x5Z29uIChwb2x5Z29ucywgeiwgaGVpZ2h0LCBtaW5faGVpZ2h0LCB2ZXJ0ZXhfZGF0YSwgb3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbWluX3ogPSB6ICsgKG1pbl9oZWlnaHQgfHwgMCk7XG4gICAgdmFyIG1heF96ID0geiArIGhlaWdodDtcblxuICAgIC8vIFRvcFxuICAgIEdMQnVpbGRlcnMuYnVpbGRQb2x5Z29ucyhwb2x5Z29ucywgbWF4X3osIHZlcnRleF9kYXRhLCB7IHZlcnRleF9jb25zdGFudHM6IG9wdGlvbnMudmVydGV4X2NvbnN0YW50cyB9KTtcblxuICAgIC8vIFdhbGxzXG4gICAgdmFyIHdhbGxfdmVydGV4X2NvbnN0YW50cyA9IFtudWxsLCBudWxsLCBudWxsXTsgLy8gbm9ybWFscyB3aWxsIGJlIGNhbGN1bGF0ZWQgYmVsb3dcbiAgICBpZiAob3B0aW9ucy52ZXJ0ZXhfY29uc3RhbnRzKSB7XG4gICAgICAgIHdhbGxfdmVydGV4X2NvbnN0YW50cy5wdXNoLmFwcGx5KHdhbGxfdmVydGV4X2NvbnN0YW50cywgb3B0aW9ucy52ZXJ0ZXhfY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgbnVtX3BvbHlnb25zID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2x5Z29uczsgcCsrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbcF07XG5cbiAgICAgICAgZm9yICh2YXIgcT0wOyBxIDwgcG9seWdvbi5sZW5ndGg7IHErKykge1xuICAgICAgICAgICAgdmFyIGNvbnRvdXIgPSBwb2x5Z29uW3FdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB3PTA7IHcgPCBjb250b3VyLmxlbmd0aCAtIDE7IHcrKykge1xuICAgICAgICAgICAgICAgIHZhciB3YWxsX3ZlcnRpY2VzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBUd28gdHJpYW5nbGVzIGZvciB0aGUgcXVhZCBmb3JtZWQgYnkgZWFjaCB2ZXJ0ZXggcGFpciwgZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wIGhlaWdodFxuICAgICAgICAgICAgICAgIHdhbGxfdmVydGljZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdysxXVswXSwgY29udG91clt3KzFdWzFdLCBtYXhfel0sXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3crMV1bMF0sIGNvbnRvdXJbdysxXVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWF4X3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3KzFdWzBdLCBjb250b3VyW3crMV1bMV0sIG1heF96XVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjIHRoZSBub3JtYWwgb2YgdGhlIHdhbGwgZnJvbSB1cCB2ZWN0b3IgYW5kIG9uZSBzZWdtZW50IG9mIHRoZSB3YWxsIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBWZWN0b3IuY3Jvc3MoXG4gICAgICAgICAgICAgICAgICAgIFswLCAwLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yLm5vcm1hbGl6ZShbY29udG91clt3KzFdWzBdIC0gY29udG91clt3XVswXSwgY29udG91clt3KzFdWzFdIC0gY29udG91clt3XVsxXSwgMF0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHdhbGxfdmVydGV4X2NvbnN0YW50c1swXSA9IG5vcm1hbFswXTtcbiAgICAgICAgICAgICAgICB3YWxsX3ZlcnRleF9jb25zdGFudHNbMV0gPSBub3JtYWxbMV07XG4gICAgICAgICAgICAgICAgd2FsbF92ZXJ0ZXhfY29uc3RhbnRzWzJdID0gbm9ybWFsWzJdO1xuXG4gICAgICAgICAgICAgICAgR0wuYWRkVmVydGljZXMod2FsbF92ZXJ0aWNlcywgdmVydGV4X2RhdGEsIHdhbGxfdmVydGV4X2NvbnN0YW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmVydGV4X2RhdGE7XG59O1xuXG4vLyBCdWlsZCB0ZXNzZWxsYXRlZCB0cmlhbmdsZXMgZm9yIGEgcG9seWxpbmVcbi8vIEJhc2ljYWxseSBmb2xsb3dpbmcgdGhlIG1ldGhvZCBkZXNjcmliZWQgaGVyZSBmb3IgbWl0ZXIgam9pbnRzOlxuLy8gaHR0cDovL2FydGdyYW1tZXIuYmxvZ3Nwb3QuY28udWsvMjAxMS8wNy9kcmF3aW5nLXBvbHlsaW5lcy1ieS10ZXNzZWxsYXRpb24uaHRtbFxuR0xCdWlsZGVycy5idWlsZFBvbHlsaW5lcyA9IGZ1bmN0aW9uIEdMQnVpbGRlcnNCdWlsZFBvbHlsaW5lcyAobGluZXMsIHosIHdpZHRoLCB2ZXJ0ZXhfZGF0YSwgb3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNsb3NlZF9wb2x5Z29uID0gb3B0aW9ucy5jbG9zZWRfcG9seWdvbiB8fCBmYWxzZTtcbiAgICBvcHRpb25zLnJlbW92ZV90aWxlX2VkZ2VzID0gb3B0aW9ucy5yZW1vdmVfdGlsZV9lZGdlcyB8fCBmYWxzZTtcblxuICAgIHZhciB2ZXJ0ZXhfY29uc3RhbnRzID0gW3osIDAsIDAsIDFdOyAvLyBwcm92aWRlZCB6LCBhbmQgdXB3YXJkcy1mYWNpbmcgbm9ybWFsXG4gICAgaWYgKG9wdGlvbnMudmVydGV4X2NvbnN0YW50cykge1xuICAgICAgICB2ZXJ0ZXhfY29uc3RhbnRzLnB1c2guYXBwbHkodmVydGV4X2NvbnN0YW50cywgb3B0aW9ucy52ZXJ0ZXhfY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICAvLyBMaW5lIGNlbnRlciAtIGRlYnVnZ2luZ1xuICAgIGlmIChHTEJ1aWxkZXJzLmRlYnVnICYmIG9wdGlvbnMudmVydGV4X2xpbmVzKSB7XG4gICAgICAgIHZhciBudW1fbGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGxuPTA7IGxuIDwgbnVtX2xpbmVzOyBsbisrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xuXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgcD0wOyBwIDwgbGluZS5sZW5ndGggLSAxOyBwKyspIHtcbiAgICAgICAgICAgICAgICAvLyBQb2ludCBBIHRvIEJcbiAgICAgICAgICAgICAgICB2YXIgcGEgPSBsaW5lW3BdO1xuICAgICAgICAgICAgICAgIHZhciBwYiA9IGxpbmVbcCsxXTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMudmVydGV4X2xpbmVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHBhWzBdLCBwYVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAxLjAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIHBiWzBdLCBwYlsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAxLjAsIDAsIDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRyaWFuZ2xlc1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBudW1fbGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgbG49MDsgbG4gPCBudW1fbGluZXM7IGxuKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsbl07XG4gICAgICAgIC8vIE11bHRpcGxlIGxpbmUgc2VnbWVudHNcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgLy8gQnVpbGQgYW5jaG9ycyBmb3IgbGluZSBzZWdtZW50czpcbiAgICAgICAgICAgIC8vIGFuY2hvcnMgYXJlIDMgcG9pbnRzLCBlYWNoIGNvbm5lY3RpbmcgMiBsaW5lIHNlZ21lbnRzIHRoYXQgc2hhcmUgYSBqb2ludCAoc3RhcnQgcG9pbnQsIGpvaW50IHBvaW50LCBlbmQgcG9pbnQpXG5cbiAgICAgICAgICAgIHZhciBhbmNob3JzID0gW107XG5cbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIG1pZHBvaW50cyBvZiBlYWNoIGxpbmUgc2VnbWVudFxuICAgICAgICAgICAgICAgIC8vIEZvciBjbG9zZWQgcG9seWdvbnMsIGNhbGN1bGF0ZSBhbGwgbWlkcG9pbnRzIHNpbmNlIHNlZ21lbnRzIHdpbGwgd3JhcCBhcm91bmQgdG8gZmlyc3QgbWlkcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgbWlkID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHAsIHBtYXg7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VkX3BvbHlnb24gPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gMDsgLy8gc3RhcnQgb24gZmlyc3QgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgcG1heCA9IGxpbmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIG9wZW4gcG9seWdvbnMsIHNraXAgZmlyc3QgbWlkcG9pbnQgYW5kIHVzZSBsaW5lIHN0YXJ0IGluc3RlYWRcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IDE7IC8vIHN0YXJ0IG9uIHNlY29uZCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBwbWF4ID0gbGluZS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgICAgICBtaWQucHVzaChsaW5lWzBdKTsgLy8gdXNlIGxpbmUgc3RhcnQgaW5zdGVhZCBvZiBmaXJzdCBtaWRwb2ludFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhbGMgbWlkcG9pbnRzXG4gICAgICAgICAgICAgICAgZm9yICg7IHAgPCBwbWF4OyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhID0gbGluZVtwXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBiID0gbGluZVtwKzFdO1xuICAgICAgICAgICAgICAgICAgICBtaWQucHVzaChbKHBhWzBdICsgcGJbMF0pIC8gMiwgKHBhWzFdICsgcGJbMV0pIC8gMl0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNhbWUgY2xvc2VkL29wZW4gcG9seWdvbiBsb2dpYyBhcyBhYm92ZToga2VlcCBsYXN0IG1pZHBvaW50IGZvciBjbG9zZWQsIHNraXAgZm9yIG9wZW5cbiAgICAgICAgICAgICAgICB2YXIgbW1heDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZWRfcG9seWdvbiA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1tYXggPSBtaWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWlkLnB1c2gobGluZVtsaW5lLmxlbmd0aC0xXSk7IC8vIHVzZSBsaW5lIGVuZCBpbnN0ZWFkIG9mIGxhc3QgbWlkcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgbW1heCA9IG1pZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYW5jaG9ycyBieSBjb25uZWN0aW5nIG1pZHBvaW50cyB0byBsaW5lIGpvaW50c1xuICAgICAgICAgICAgICAgIGZvciAocD0wOyBwIDwgbW1heDsgcCsrKSAge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3JzLnB1c2goW21pZFtwXSwgbGluZVsocCsxKSAlIGxpbmUubGVuZ3RoXSwgbWlkWyhwKzEpICUgbWlkLmxlbmd0aF1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWdlbmVyYXRlIGNhc2UsIGEgMy1wb2ludCBsaW5lIGlzIGp1c3QgYSBzaW5nbGUgYW5jaG9yXG4gICAgICAgICAgICAgICAgYW5jaG9ycyA9IFtbbGluZVswXSwgbGluZVsxXSwgbGluZVsyXV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBwPTA7IHAgPCBhbmNob3JzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnJlbW92ZV90aWxlX2VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkQW5jaG9yKGFuY2hvcnNbcF1bMF0sIGFuY2hvcnNbcF1bMV0sIGFuY2hvcnNbcF1bMl0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBidWlsZFNlZ21lbnQoYW5jaG9yc1twXVswXSwgYW5jaG9yc1twXVsxXSk7IC8vIHVzZSB0aGVzZSB0byBkcmF3IGV4dHJ1ZGVkIHNlZ21lbnRzIHcvbyBqb2luLCBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkU2VnbWVudChhbmNob3JzW3BdWzFdLCBhbmNob3JzW3BdWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlMSA9IEdMQnVpbGRlcnMuaXNPblRpbGVFZGdlKGFuY2hvcnNbcF1bMF0sIGFuY2hvcnNbcF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZTIgPSBHTEJ1aWxkZXJzLmlzT25UaWxlRWRnZShhbmNob3JzW3BdWzFdLCBhbmNob3JzW3BdWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGdlMSAmJiAhZWRnZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQW5jaG9yKGFuY2hvcnNbcF1bMF0sIGFuY2hvcnNbcF1bMV0sIGFuY2hvcnNbcF1bMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlZGdlMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRTZWdtZW50KGFuY2hvcnNbcF1bMF0sIGFuY2hvcnNbcF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlZGdlMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRTZWdtZW50KGFuY2hvcnNbcF1bMV0sIGFuY2hvcnNbcF1bMl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmdsZSAyLXBvaW50IHNlZ21lbnRcbiAgICAgICAgZWxzZSBpZiAobGluZS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgYnVpbGRTZWdtZW50KGxpbmVbMF0sIGxpbmVbMV0pOyAvLyBUT0RPOiByZXBsYWNlIGJ1aWxkU2VnbWVudCB3aXRoIGEgZGVnZW5lcmF0ZSBmb3JtIG9mIGJ1aWxkQW5jaG9yPyBidWlsZFNlZ21lbnQgaXMgc3RpbGwgdXNlZnVsIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBHTC5hZGRWZXJ0aWNlcyh2ZXJ0aWNlcywgdmVydGV4X2RhdGEsIHZlcnRleF9jb25zdGFudHMpO1xuXG4gICAgLy8gQnVpbGQgdHJpYW5nbGVzIGZvciBhIHNpbmdsZSBsaW5lIHNlZ21lbnQsIGV4dHJ1ZGVkIGJ5IHRoZSBwcm92aWRlZCB3aWR0aFxuICAgIGZ1bmN0aW9uIGJ1aWxkU2VnbWVudCAocGEsIHBiKSB7XG4gICAgICAgIHZhciBzbG9wZSA9IFZlY3Rvci5ub3JtYWxpemUoWyhwYlsxXSAtIHBhWzFdKSAqIC0xLCBwYlswXSAtIHBhWzBdXSk7XG5cbiAgICAgICAgdmFyIHBhX291dGVyID0gW3BhWzBdICsgc2xvcGVbMF0gKiB3aWR0aC8yLCBwYVsxXSArIHNsb3BlWzFdICogd2lkdGgvMl07XG4gICAgICAgIHZhciBwYV9pbm5lciA9IFtwYVswXSAtIHNsb3BlWzBdICogd2lkdGgvMiwgcGFbMV0gLSBzbG9wZVsxXSAqIHdpZHRoLzJdO1xuXG4gICAgICAgIHZhciBwYl9vdXRlciA9IFtwYlswXSArIHNsb3BlWzBdICogd2lkdGgvMiwgcGJbMV0gKyBzbG9wZVsxXSAqIHdpZHRoLzJdO1xuICAgICAgICB2YXIgcGJfaW5uZXIgPSBbcGJbMF0gLSBzbG9wZVswXSAqIHdpZHRoLzIsIHBiWzFdIC0gc2xvcGVbMV0gKiB3aWR0aC8yXTtcblxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgcGJfaW5uZXIsIHBiX291dGVyLCBwYV9pbm5lcixcbiAgICAgICAgICAgIHBhX2lubmVyLCBwYl9vdXRlciwgcGFfb3V0ZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0cmlhbmdsZXMgZm9yIGEgMy1wb2ludCAnYW5jaG9yJyBzaGFwZSwgY29uc2lzdGluZyBvZiB0d28gbGluZSBzZWdtZW50cyB3aXRoIGEgam9pbnRcbiAgICAvLyBUT0RPOiBtb3ZlIHRoZXNlIGZ1bmN0aW9ucyBvdXQgb2YgY2xvc3VyZXM/XG4gICAgZnVuY3Rpb24gYnVpbGRBbmNob3IgKHBhLCBqb2ludCwgcGIpIHtcbiAgICAgICAgLy8gSW5uZXIgYW5kIG91dGVyIGxpbmUgc2VnbWVudHMgZm9yIFtwYSwgam9pbnRdIGFuZCBbam9pbnQsIHBiXVxuICAgICAgICB2YXIgcGFfc2xvcGUgPSBWZWN0b3Iubm9ybWFsaXplKFsoam9pbnRbMV0gLSBwYVsxXSkgKiAtMSwgam9pbnRbMF0gLSBwYVswXV0pO1xuICAgICAgICB2YXIgcGFfb3V0ZXIgPSBbXG4gICAgICAgICAgICBbcGFbMF0gKyBwYV9zbG9wZVswXSAqIHdpZHRoLzIsIHBhWzFdICsgcGFfc2xvcGVbMV0gKiB3aWR0aC8yXSxcbiAgICAgICAgICAgIFtqb2ludFswXSArIHBhX3Nsb3BlWzBdICogd2lkdGgvMiwgam9pbnRbMV0gKyBwYV9zbG9wZVsxXSAqIHdpZHRoLzJdXG4gICAgICAgIF07XG4gICAgICAgIHZhciBwYV9pbm5lciA9IFtcbiAgICAgICAgICAgIFtwYVswXSAtIHBhX3Nsb3BlWzBdICogd2lkdGgvMiwgcGFbMV0gLSBwYV9zbG9wZVsxXSAqIHdpZHRoLzJdLFxuICAgICAgICAgICAgW2pvaW50WzBdIC0gcGFfc2xvcGVbMF0gKiB3aWR0aC8yLCBqb2ludFsxXSAtIHBhX3Nsb3BlWzFdICogd2lkdGgvMl1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgcGJfc2xvcGUgPSBWZWN0b3Iubm9ybWFsaXplKFsocGJbMV0gLSBqb2ludFsxXSkgKiAtMSwgcGJbMF0gLSBqb2ludFswXV0pO1xuICAgICAgICB2YXIgcGJfb3V0ZXIgPSBbXG4gICAgICAgICAgICBbam9pbnRbMF0gKyBwYl9zbG9wZVswXSAqIHdpZHRoLzIsIGpvaW50WzFdICsgcGJfc2xvcGVbMV0gKiB3aWR0aC8yXSxcbiAgICAgICAgICAgIFtwYlswXSArIHBiX3Nsb3BlWzBdICogd2lkdGgvMiwgcGJbMV0gKyBwYl9zbG9wZVsxXSAqIHdpZHRoLzJdXG4gICAgICAgIF07XG4gICAgICAgIHZhciBwYl9pbm5lciA9IFtcbiAgICAgICAgICAgIFtqb2ludFswXSAtIHBiX3Nsb3BlWzBdICogd2lkdGgvMiwgam9pbnRbMV0gLSBwYl9zbG9wZVsxXSAqIHdpZHRoLzJdLFxuICAgICAgICAgICAgW3BiWzBdIC0gcGJfc2xvcGVbMF0gKiB3aWR0aC8yLCBwYlsxXSAtIHBiX3Nsb3BlWzFdICogd2lkdGgvMl1cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBNaXRlciBqb2luIC0gc29sdmUgZm9yIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgdHdvIG91dGVyIGxpbmUgc2VnbWVudHNcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IFZlY3Rvci5saW5lSW50ZXJzZWN0aW9uKHBhX291dGVyWzBdLCBwYV9vdXRlclsxXSwgcGJfb3V0ZXJbMF0sIHBiX291dGVyWzFdKTtcbiAgICAgICAgdmFyIGxpbmVfZGVidWcgPSBudWxsO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rfb3V0ZXIgPSBpbnRlcnNlY3Rpb247XG5cbiAgICAgICAgICAgIC8vIENhcCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IHRvIGEgcmVhc29uYWJsZSBkaXN0YW5jZSAoYXMgam9pbiBhbmdsZSBiZWNvbWVzIHNoYXJwZXIsIG1pdGVyIGpvaW50IGRpc3RhbmNlIHdvdWxkIGFwcHJvYWNoIGluZmluaXR5KVxuICAgICAgICAgICAgdmFyIGxlbl9zcSA9IFZlY3Rvci5sZW5ndGhTcShbaW50ZXJzZWN0X291dGVyWzBdIC0gam9pbnRbMF0sIGludGVyc2VjdF9vdXRlclsxXSAtIGpvaW50WzFdXSk7XG4gICAgICAgICAgICB2YXIgbWl0ZXJfbGVuX21heCA9IDM7IC8vIG11bHRpcGxpZXIgb24gbGluZSB3aWR0aCBmb3IgbWF4IGRpc3RhbmNlIG1pdGVyIGpvaW4gY2FuIGJlIGZyb20gam9pbnRcbiAgICAgICAgICAgIGlmIChsZW5fc3EgPiAod2lkdGggKiB3aWR0aCAqIG1pdGVyX2xlbl9tYXggKiBtaXRlcl9sZW5fbWF4KSkge1xuICAgICAgICAgICAgICAgIGxpbmVfZGVidWcgPSAnZGlzdGFuY2UnO1xuICAgICAgICAgICAgICAgIGludGVyc2VjdF9vdXRlciA9IFZlY3Rvci5ub3JtYWxpemUoW2ludGVyc2VjdF9vdXRlclswXSAtIGpvaW50WzBdLCBpbnRlcnNlY3Rfb3V0ZXJbMV0gLSBqb2ludFsxXV0pO1xuICAgICAgICAgICAgICAgIGludGVyc2VjdF9vdXRlciA9IFtcbiAgICAgICAgICAgICAgICAgICAgam9pbnRbMF0gKyBpbnRlcnNlY3Rfb3V0ZXJbMF0gKiBtaXRlcl9sZW5fbWF4LFxuICAgICAgICAgICAgICAgICAgICBqb2ludFsxXSArIGludGVyc2VjdF9vdXRlclsxXSAqIG1pdGVyX2xlbl9tYXhcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RfaW5uZXIgPSBbXG4gICAgICAgICAgICAgICAgKGpvaW50WzBdIC0gaW50ZXJzZWN0X291dGVyWzBdKSArIGpvaW50WzBdLFxuICAgICAgICAgICAgICAgIChqb2ludFsxXSAtIGludGVyc2VjdF9vdXRlclsxXSkgKyBqb2ludFsxXVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RfaW5uZXIsIGludGVyc2VjdF9vdXRlciwgcGFfaW5uZXJbMF0sXG4gICAgICAgICAgICAgICAgcGFfaW5uZXJbMF0sIGludGVyc2VjdF9vdXRlciwgcGFfb3V0ZXJbMF0sXG5cbiAgICAgICAgICAgICAgICBwYl9pbm5lclsxXSwgcGJfb3V0ZXJbMV0sIGludGVyc2VjdF9pbm5lcixcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RfaW5uZXIsIHBiX291dGVyWzFdLCBpbnRlcnNlY3Rfb3V0ZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBMaW5lIHNlZ21lbnRzIGFyZSBwYXJhbGxlbCwgdXNlIHRoZSBmaXJzdCBvdXRlciBsaW5lIHNlZ21lbnQgYXMgam9pbiBpbnN0ZWFkXG4gICAgICAgICAgICBsaW5lX2RlYnVnID0gJ3BhcmFsbGVsJztcbiAgICAgICAgICAgIHBhX2lubmVyWzFdID0gcGJfaW5uZXJbMF07XG4gICAgICAgICAgICBwYV9vdXRlclsxXSA9IHBiX291dGVyWzBdO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIHBhX2lubmVyWzFdLCBwYV9vdXRlclsxXSwgcGFfaW5uZXJbMF0sXG4gICAgICAgICAgICAgICAgcGFfaW5uZXJbMF0sIHBhX291dGVyWzFdLCBwYV9vdXRlclswXSxcblxuICAgICAgICAgICAgICAgIHBiX2lubmVyWzFdLCBwYl9vdXRlclsxXSwgcGJfaW5uZXJbMF0sXG4gICAgICAgICAgICAgICAgcGJfaW5uZXJbMF0sIHBiX291dGVyWzFdLCBwYl9vdXRlclswXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJ1ZGVkIGlubmVyL291dGVyIGVkZ2VzIC0gZGVidWdnaW5nXG4gICAgICAgIGlmIChHTEJ1aWxkZXJzLmRlYnVnICYmIG9wdGlvbnMudmVydGV4X2xpbmVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnZlcnRleF9saW5lcy5wdXNoKFxuICAgICAgICAgICAgICAgIHBhX2lubmVyWzBdWzBdLCBwYV9pbm5lclswXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGFfaW5uZXJbMV1bMF0sIHBhX2lubmVyWzFdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMCxcblxuICAgICAgICAgICAgICAgIHBiX2lubmVyWzBdWzBdLCBwYl9pbm5lclswXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGJfaW5uZXJbMV1bMF0sIHBiX2lubmVyWzFdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMCxcblxuICAgICAgICAgICAgICAgIHBhX291dGVyWzBdWzBdLCBwYV9vdXRlclswXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGFfb3V0ZXJbMV1bMF0sIHBhX291dGVyWzFdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMCxcblxuICAgICAgICAgICAgICAgIHBiX291dGVyWzBdWzBdLCBwYl9vdXRlclswXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGJfb3V0ZXJbMV1bMF0sIHBiX291dGVyWzFdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMCxcblxuICAgICAgICAgICAgICAgIHBhX2lubmVyWzBdWzBdLCBwYV9pbm5lclswXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGFfb3V0ZXJbMF1bMF0sIHBhX291dGVyWzBdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMCxcblxuICAgICAgICAgICAgICAgIHBhX2lubmVyWzFdWzBdLCBwYV9pbm5lclsxXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGFfb3V0ZXJbMV1bMF0sIHBhX291dGVyWzFdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMCxcblxuICAgICAgICAgICAgICAgIHBiX2lubmVyWzBdWzBdLCBwYl9pbm5lclswXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGJfb3V0ZXJbMF1bMF0sIHBiX291dGVyWzBdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMCxcblxuICAgICAgICAgICAgICAgIHBiX2lubmVyWzFdWzBdLCBwYl9pbm5lclsxXVsxXSwgeiArIDAuMDAxLCAwLCAwLCAxLCAwLCAxLjAsIDAsXG4gICAgICAgICAgICAgICAgcGJfb3V0ZXJbMV1bMF0sIHBiX291dGVyWzFdWzFdLCB6ICsgMC4wMDEsIDAsIDAsIDEsIDAsIDEuMCwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChHTEJ1aWxkZXJzLmRlYnVnICYmIGxpbmVfZGVidWcgJiYgb3B0aW9ucy52ZXJ0ZXhfbGluZXMpIHtcbiAgICAgICAgICAgIHZhciBkY29sb3I7XG4gICAgICAgICAgICBpZiAobGluZV9kZWJ1ZyA9PSAncGFyYWxsZWwnKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIhISEgbGluZXMgYXJlIHBhcmFsbGVsICEhIVwiKTtcbiAgICAgICAgICAgICAgICBkY29sb3IgPSBbMCwgMSwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lX2RlYnVnID09ICdkaXN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiEhISBtaXRlciBpbnRlcnNlY3Rpb24gcG9pbnQgZXhjZWVkZWQgYWxsb3dlZCBkaXN0YW5jZSBmcm9tIGpvaW50ICEhIVwiKTtcbiAgICAgICAgICAgICAgICBkY29sb3IgPSBbMSwgMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnT1NNIGlkOiAnICsgZmVhdHVyZS5pZCk7IC8vIFRPRE86IGlmIHRoaXMgZnVuY3Rpb24gaXMgbW92ZWQgb3V0IG9mIGEgY2xvc3VyZSwgdGhpcyBmZWF0dXJlIGRlYnVnIGluZm8gd29uJ3QgYmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhbcGEsIGpvaW50LCBwYl0pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZmVhdHVyZSk7XG4gICAgICAgICAgICBvcHRpb25zLnZlcnRleF9saW5lcy5wdXNoKFxuICAgICAgICAgICAgICAgIHBhWzBdLCBwYVsxXSwgeiArIDAuMDAyLFxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIGRjb2xvclswXSwgZGNvbG9yWzFdLCBkY29sb3JbMl0sXG4gICAgICAgICAgICAgICAgam9pbnRbMF0sIGpvaW50WzFdLCB6ICsgMC4wMDIsXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgZGNvbG9yWzBdLCBkY29sb3JbMV0sIGRjb2xvclsyXSxcbiAgICAgICAgICAgICAgICBqb2ludFswXSwgam9pbnRbMV0sIHogKyAwLjAwMixcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCBkY29sb3JbMF0sIGRjb2xvclsxXSwgZGNvbG9yWzJdLFxuICAgICAgICAgICAgICAgIHBiWzBdLCBwYlsxXSwgeiArIDAuMDAyLFxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIGRjb2xvclswXSwgZGNvbG9yWzFdLCBkY29sb3JbMl1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBudW1fbGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBsbj0wOyBsbiA8IG51bV9saW5lczsgbG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lMiA9IGxpbmVzW2xuXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHA9MDsgcCA8IGxpbmUyLmxlbmd0aCAtIDE7IHArKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBQb2ludCBBIHRvIEJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhID0gbGluZTJbcF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYiA9IGxpbmUyW3ArMV07XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52ZXJ0ZXhfbGluZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhWzBdLCBwYVsxXSwgeiArIDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsIDAsIDEuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBiWzBdLCBwYlsxXSwgeiArIDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsIDAsIDEuMFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmVydGV4X2RhdGE7XG59O1xuXG4vLyBCdWlsZCBhIHF1YWQgY2VudGVyZWQgb24gYSBwb2ludFxuR0xCdWlsZGVycy5idWlsZFF1YWRzID0gZnVuY3Rpb24gR0xCdWlsZGVyc0J1aWxkUXVhZHMgKHBvaW50cywgd2lkdGgsIGhlaWdodCwgYWRkR2VvbWV0cnksIG9wdGlvbnMpXG57XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2ludHM7IHArKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbcF07XG5cbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtcbiAgICAgICAgICAgIFtwb2ludFswXSAtIHdpZHRoLzIsIHBvaW50WzFdIC0gaGVpZ2h0LzJdLFxuICAgICAgICAgICAgW3BvaW50WzBdICsgd2lkdGgvMiwgcG9pbnRbMV0gLSBoZWlnaHQvMl0sXG4gICAgICAgICAgICBbcG9pbnRbMF0gKyB3aWR0aC8yLCBwb2ludFsxXSArIGhlaWdodC8yXSxcblxuICAgICAgICAgICAgW3BvaW50WzBdIC0gd2lkdGgvMiwgcG9pbnRbMV0gLSBoZWlnaHQvMl0sXG4gICAgICAgICAgICBbcG9pbnRbMF0gKyB3aWR0aC8yLCBwb2ludFsxXSArIGhlaWdodC8yXSxcbiAgICAgICAgICAgIFtwb2ludFswXSAtIHdpZHRoLzIsIHBvaW50WzFdICsgaGVpZ2h0LzJdLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnRleGNvb3JkcyA9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdGV4Y29vcmRzID0gW1xuICAgICAgICAgICAgICAgIFstMSwgLTFdLFxuICAgICAgICAgICAgICAgIFsxLCAtMV0sXG4gICAgICAgICAgICAgICAgWzEsIDFdLFxuXG4gICAgICAgICAgICAgICAgWy0xLCAtMV0sXG4gICAgICAgICAgICAgICAgWzEsIDFdLFxuICAgICAgICAgICAgICAgIFstMSwgMV1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGljZXMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9ucyxcbiAgICAgICAgICAgIHRleGNvb3JkczogKG9wdGlvbnMudGV4Y29vcmRzICYmIHRleGNvb3JkcylcbiAgICAgICAgfTtcbiAgICAgICAgYWRkR2VvbWV0cnkodmVydGljZXMpO1xuICAgIH1cbn07XG5cbi8vIEJ1aWxkIG5hdGl2ZSBHTCBsaW5lcyBmb3IgYSBwb2x5bGluZVxuR0xCdWlsZGVycy5idWlsZExpbmVzID0gZnVuY3Rpb24gR0xCdWlsZGVyc0J1aWxkTGluZXMgKGxpbmVzLCBmZWF0dXJlLCBsYXllciwgc3R5bGUsIHRpbGUsIHosIHZlcnRleF9kYXRhLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG5cbiAgICB2YXIgbnVtX2xpbmVzID0gbGluZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGxuPTA7IGxuIDwgbnVtX2xpbmVzOyBsbisrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbbG5dO1xuXG4gICAgICAgIGZvciAodmFyIHA9MDsgcCA8IGxpbmUubGVuZ3RoIC0gMTsgcCsrKSB7XG4gICAgICAgICAgICAvLyBQb2ludCBBIHRvIEJcbiAgICAgICAgICAgIHZhciBwYSA9IGxpbmVbcF07XG4gICAgICAgICAgICB2YXIgcGIgPSBsaW5lW3ArMV07XG5cbiAgICAgICAgICAgIHZlcnRleF9kYXRhLnB1c2goXG4gICAgICAgICAgICAgICAgLy8gUG9pbnQgQVxuICAgICAgICAgICAgICAgIHBhWzBdLCBwYVsxXSwgeixcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAvLyBmbGF0IHN1cmZhY2VzIHBvaW50IHN0cmFpZ2h0IHVwXG4gICAgICAgICAgICAgICAgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSxcbiAgICAgICAgICAgICAgICAvLyBQb2ludCBCXG4gICAgICAgICAgICAgICAgcGJbMF0sIHBiWzFdLCB6LFxuICAgICAgICAgICAgICAgIDAsIDAsIDEsIC8vIGZsYXQgc3VyZmFjZXMgcG9pbnQgc3RyYWlnaHQgdXBcbiAgICAgICAgICAgICAgICBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB2ZXJ0ZXhfZGF0YTtcbn07XG5cbi8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbi8vIFRlc3RzIGlmIGEgbGluZSBzZWdtZW50IChmcm9tIHBvaW50IEEgdG8gQikgaXMgbmVhcmx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZWRnZSBvZiBhIHRpbGVcbkdMQnVpbGRlcnMuaXNPblRpbGVFZGdlID0gZnVuY3Rpb24gKHBhLCBwYiwgb3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciB0b2xlcmFuY2VfZnVuY3Rpb24gPSBvcHRpb25zLnRvbGVyYW5jZV9mdW5jdGlvbiB8fCBHTEJ1aWxkZXJzLnZhbHVlc1dpdGhpblRvbGVyYW5jZTtcbiAgICB2YXIgdG9sZXJhbmNlID0gb3B0aW9ucy50b2xlcmFuY2UgfHwgMTsgLy8gdHdlYWsgdGhpcyBhZGp1c3QgaWYgY2F0Y2hpbmcgdG9vIGZldy9tYW55IGxpbmUgc2VnbWVudHMgbmVhciB0aWxlIGVkZ2VzXG4gICAgdmFyIHRpbGVfbWluID0gR0xCdWlsZGVycy50aWxlX2JvdW5kc1swXTtcbiAgICB2YXIgdGlsZV9tYXggPSBHTEJ1aWxkZXJzLnRpbGVfYm91bmRzWzFdO1xuICAgIHZhciBlZGdlID0gbnVsbDtcblxuICAgIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMF0sIHRpbGVfbWluLngsIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzBdLCB0aWxlX21pbi54LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAnbGVmdCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVswXSwgdGlsZV9tYXgueCwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMF0sIHRpbGVfbWF4LngsIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgZWRnZSA9ICdyaWdodCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVsxXSwgdGlsZV9taW4ueSwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMV0sIHRpbGVfbWluLnksIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgZWRnZSA9ICd0b3AnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMV0sIHRpbGVfbWF4LnksIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzFdLCB0aWxlX21heC55LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAnYm90dG9tJztcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2U7XG59O1xuXG5HTEJ1aWxkZXJzLnNldFRpbGVTY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSlcbntcbiAgICBHTEJ1aWxkZXJzLnRpbGVfYm91bmRzID0gW1xuICAgICAgICBQb2ludCgwLCAwKSxcbiAgICAgICAgUG9pbnQoc2NhbGUsIC1zY2FsZSkgLy8gVE9ETzogY29ycmVjdCBmb3IgZmxpcHBlZCB5LWF4aXM/XG4gICAgXTtcbn07XG5cbkdMQnVpbGRlcnMudmFsdWVzV2l0aGluVG9sZXJhbmNlID0gZnVuY3Rpb24gKGEsIGIsIHRvbGVyYW5jZSlcbntcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEgLSBiKSA8IHRvbGVyYW5jZSk7XG59O1xuXG4vLyBCdWlsZCBhIHppZ3phZyBsaW5lIHBhdHRlcm4gZm9yIHRlc3Rpbmcgam9pbnMgYW5kIGNhcHNcbkdMQnVpbGRlcnMuYnVpbGRaaWd6YWdMaW5lVGVzdFBhdHRlcm4gPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBtaW4gPSBQb2ludCgwLCAwKTsgLy8gdGlsZS5taW47XG4gICAgdmFyIG1heCA9IFBvaW50KDQwOTYsIDQwOTYpOyAvLyB0aWxlLm1heDtcbiAgICB2YXIgZyA9IHtcbiAgICAgICAgaWQ6IDEyMyxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC43NSArIG1heC54ICogMC4yNSwgbWluLnkgKiAwLjc1ICsgbWF4LnkgKiAwLjI1XSxcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjc1ICsgbWF4LnggKiAwLjI1LCBtaW4ueSAqIDAuNSArIG1heC55ICogMC41XSxcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjI1ICsgbWF4LnggKiAwLjc1LCBtaW4ueSAqIDAuNzUgKyBtYXgueSAqIDAuMjVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuMjUgKyBtYXgueCAqIDAuNzUsIG1pbi55ICogMC4yNSArIG1heC55ICogMC43NV0sXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC40ICsgbWF4LnggKiAwLjYsIG1pbi55ICogMC41ICsgbWF4LnkgKiAwLjVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuNSArIG1heC54ICogMC41LCBtaW4ueSAqIDAuMjUgKyBtYXgueSAqIDAuNzVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuNzUgKyBtYXgueCAqIDAuMjUsIG1pbi55ICogMC4yNSArIG1heC55ICogMC43NV0sXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC43NSArIG1heC54ICogMC4yNSwgbWluLnkgKiAwLjQgKyBtYXgueSAqIDAuNl1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAga2luZDogJ2RlYnVnJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBjb25zb2xlLmxvZyhnLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICByZXR1cm4gZztcbn07XG5cbmlmIChtb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gR0xCdWlsZGVycztcbn1cbiIsIi8qKiogTWFuYWdlIHJlbmRlcmluZyBmb3IgcHJpbWl0aXZlcyAqKiovXG52YXIgR0wgPSByZXF1aXJlKCcuL2dsLmpzJyk7XG5cbi8vIEF0dHJpYnMgYXJlIGFuIGFycmF5LCBpbiBsYXlvdXQgb3JkZXIsIG9mOiBuYW1lLCBzaXplLCB0eXBlLCBub3JtYWxpemVkXG4vLyBleDogeyBuYW1lOiAncG9zaXRpb24nLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfVxuZnVuY3Rpb24gR0xHZW9tZXRyeSAoZ2wsIGdsX3Byb2dyYW0sIHZlcnRleF9kYXRhLCBhdHRyaWJzLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuZ2xfcHJvZ3JhbSA9IGdsX3Byb2dyYW07XG4gICAgdGhpcy5hdHRyaWJzID0gYXR0cmlicztcbiAgICB0aGlzLnZlcnRleF9kYXRhID0gdmVydGV4X2RhdGE7IC8vIEZsb2F0MzJBcnJheVxuICAgIHRoaXMuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmRyYXdfbW9kZSA9IG9wdGlvbnMuZHJhd19tb2RlIHx8IHRoaXMuZ2wuVFJJQU5HTEVTO1xuICAgIHRoaXMuZGF0YV91c2FnZSA9IG9wdGlvbnMuZGF0YV91c2FnZSB8fCB0aGlzLmdsLlNUQVRJQ19EUkFXO1xuXG4gICAgLy8gQ2FsYyB2ZXJ0ZXggc3RyaWRlXG4gICAgdGhpcy52ZXJ0ZXhfc3RyaWRlID0gMDtcbiAgICBmb3IgKHZhciBhPTA7IGEgPCB0aGlzLmF0dHJpYnMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYiA9IHRoaXMuYXR0cmlic1thXTtcblxuICAgICAgICBhdHRyaWIubG9jYXRpb24gPSB0aGlzLmdsX3Byb2dyYW0uYXR0cmlidXRlKGF0dHJpYi5uYW1lKS5sb2NhdGlvbjtcbiAgICAgICAgYXR0cmliLmJ5dGVfc2l6ZSA9IGF0dHJpYi5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoYXR0cmliLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5nbC5GTE9BVDpcbiAgICAgICAgICAgIGNhc2UgdGhpcy5nbC5JTlQ6XG4gICAgICAgICAgICBjYXNlIHRoaXMuZ2wuVU5TSUdORURfSU5UOlxuICAgICAgICAgICAgICAgIGF0dHJpYi5ieXRlX3NpemUgKj0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5nbC5TSE9SVDpcbiAgICAgICAgICAgIGNhc2UgdGhpcy5nbC5VTlNJR05FRF9TSE9SVDpcbiAgICAgICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplICo9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWIub2Zmc2V0ID0gdGhpcy52ZXJ0ZXhfc3RyaWRlO1xuICAgICAgICB0aGlzLnZlcnRleF9zdHJpZGUgKz0gYXR0cmliLmJ5dGVfc2l6ZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRleF9jb3VudCA9IHRoaXMudmVydGV4X2RhdGEuYnl0ZUxlbmd0aCAvIHRoaXMudmVydGV4X3N0cmlkZTtcblxuICAgIHRoaXMudmFvID0gR0wuVmVydGV4QXJyYXlPYmplY3QuY3JlYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXR1cCgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4X2RhdGEsIHRoaXMuZGF0YV91c2FnZSk7XG59XG5cbkdMR2VvbWV0cnkucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKClcbntcbiAgICBmb3IgKHZhciBhPTA7IGEgPCB0aGlzLmF0dHJpYnMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYiA9IHRoaXMuYXR0cmlic1thXTtcbiAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWIubG9jYXRpb24pO1xuICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmliLmxvY2F0aW9uLCBhdHRyaWIuc2l6ZSwgYXR0cmliLnR5cGUsIGF0dHJpYi5ub3JtYWxpemVkLCB0aGlzLnZlcnRleF9zdHJpZGUsIGF0dHJpYi5vZmZzZXQpO1xuICAgIH1cbn07XG5cbkdMR2VvbWV0cnkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMuZ2xfcHJvZ3JhbS5wcm9ncmFtKTtcbiAgICBHTC5WZXJ0ZXhBcnJheU9iamVjdC5iaW5kKHRoaXMudmFvKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5fcmVuZGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc3VwcG9ydCBlbGVtZW50IGFycmF5IG1vZGVcbiAgICB0aGlzLmdsLmRyYXdBcnJheXModGhpcy5kcmF3X21vZGUsIDAsIHRoaXMudmVydGV4X2NvdW50KTtcbiAgICBHTC5WZXJ0ZXhBcnJheU9iamVjdC5iaW5kKG51bGwpO1xufTtcblxuR0xHZW9tZXRyeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc29sZS5sb2coXCJHTEdlb21ldHJ5LmRlc3Ryb3k6IGRlbGV0ZSBidWZmZXIgb2Ygc2l6ZSBcIiArIHRoaXMudmVydGV4X2RhdGEuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIGRlbGV0ZSB0aGlzLnZlcnRleF9kYXRhO1xufTtcblxuLy8gRHJhd3MgYSBzZXQgb2YgdHJpYW5nbGVzXG5HTFRyaWFuZ2xlcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdMR2VvbWV0cnkucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gR0xUcmlhbmdsZXMgKGdsLCBnbF9wcm9ncmFtLCB2ZXJ0ZXhfZGF0YSlcbntcbiAgICBHTEdlb21ldHJ5LmNhbGwodGhpcywgZ2wsIGdsX3Byb2dyYW0sIHZlcnRleF9kYXRhLCBbXG4gICAgICAgIHsgbmFtZTogJ3Bvc2l0aW9uJywgc2l6ZTogMywgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0sXG4gICAgICAgIHsgbmFtZTogJ25vcm1hbCcsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICB7IG5hbWU6ICdjb2xvcicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICB7IG5hbWU6ICdsYXllcicsIHNpemU6IDEsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XG4gICAgXSk7XG4gICAgdGhpcy5nZW9tZXRyeV9jb3VudCA9IHRoaXMudmVydGV4X2NvdW50IC8gMztcbn1cblxuLy8gRHJhd3MgYSBzZXQgb2YgcG9pbnRzIGFzIHF1YWRzLCBpbnRlbmRlZCB0byBiZSByZW5kZXJlZCBhcyBkaXN0YW5jZSBmaWVsZHNcbkdMUG9seVBvaW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdMR2VvbWV0cnkucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gR0xQb2x5UG9pbnRzIChnbCwgZ2xfcHJvZ3JhbSwgdmVydGV4X2RhdGEpXG57XG4gICAgR0xHZW9tZXRyeS5jYWxsKHRoaXMsIGdsLCBnbF9wcm9ncmFtLCB2ZXJ0ZXhfZGF0YSwgW1xuICAgICAgICB7IG5hbWU6ICdwb3NpdGlvbicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICB7IG5hbWU6ICd0ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICB7IG5hbWU6ICdjb2xvcicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICB7IG5hbWU6ICdsYXllcicsIHNpemU6IDEsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XG4gICAgXSk7XG4gICAgdGhpcy5nZW9tZXRyeV9jb3VudCA9IHRoaXMudmVydGV4X2NvdW50IC8gMztcbn1cblxuLy8gRHJhd3MgYSBzZXQgb2YgbGluZXNcbi8vIFNoYXJlcyBhbGwgY2hhcmFjdGVyaXN0aWNzIHdpdGggdHJpYW5nbGVzIGV4Y2VwdCBmb3IgZHJhdyBtb2RlXG5HTExpbmVzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR0xUcmlhbmdsZXMucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gR0xMaW5lcyAoZ2wsIGdsX3Byb2dyYW0sIHZlcnRleF9kYXRhLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEdMVHJpYW5nbGVzLmNhbGwodGhpcywgZ2wsIHByb2dyYW0sIHZlcnRleF9kYXRhKTtcbiAgICB0aGlzLmRyYXdfbW9kZSA9IHRoaXMuZ2wuTElORVM7XG4gICAgdGhpcy5saW5lX3dpZHRoID0gb3B0aW9ucy5saW5lX3dpZHRoIHx8IDI7XG4gICAgdGhpcy5nZW9tZXRyeV9jb3VudCA9IHRoaXMudmVydGV4X2NvdW50IC8gMjtcbn1cblxuR0xMaW5lcy5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5nbC5saW5lV2lkdGgodGhpcy5saW5lX3dpZHRoKTtcbiAgICBpZiAodHlwZW9mIEdMVHJpYW5nbGVzLnByb3RvdHlwZS5fcmVuZGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgR0xUcmlhbmdsZXMucHJvdG90eXBlLl9yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICB9XG59O1xuXG5pZiAobW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgR0xHZW9tZXRyeTogR0xHZW9tZXRyeSxcbiAgICAgICAgR0xUcmlhbmdsZXM6IEdMVHJpYW5nbGVzLFxuICAgICAgICBHTFBvbHlQb2ludHM6IEdMUG9seVBvaW50cyxcbiAgICAgICAgR0xMaW5lczogR0xMaW5lc1xuICAgIH07XG59XG4iLCJ2YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50LmpzJyk7XG52YXIgR2VvID0gcmVxdWlyZSgnLi9nZW8uanMnKTtcbnZhciBWZWN0b3JSZW5kZXJlciA9IHJlcXVpcmUoJy4vdmVjdG9yX3JlbmRlcmVyLmpzJyk7XG5cbnZhciBHTCA9IHJlcXVpcmUoJy4vZ2wuanMnKTtcbnZhciBHTEJ1aWxkZXJzID0gcmVxdWlyZSgnLi9nbF9idWlsZGVycy5qcycpO1xudmFyIEdMR2VvbWV0cnkgPSByZXF1aXJlKCcuL2dsX2dlb20uanMnKS5HTEdlb21ldHJ5O1xudmFyIEdMVHJpYW5nbGVzID0gcmVxdWlyZSgnLi9nbF9nZW9tLmpzJykuR0xUcmlhbmdsZXM7XG52YXIgR0xQb2x5UG9pbnRzID0gcmVxdWlyZSgnLi9nbF9nZW9tLmpzJykuR0xQb2x5UG9pbnRzO1xudmFyIEdMTGluZXMgPSByZXF1aXJlKCcuL2dsX2dlb20uanMnKS5HTExpbmVzO1xuXG5WZWN0b3JSZW5kZXJlci5HTFJlbmRlcmVyID0gR0xSZW5kZXJlcjtcbkdMUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShWZWN0b3JSZW5kZXJlci5wcm90b3R5cGUpO1xuR0xSZW5kZXJlci5kZWJ1ZyA9IGZhbHNlO1xuXG5HTFJlbmRlcmVyLnNoYWRlcl9zb3VyY2VzID0gcmVxdWlyZSgnLi9zaGFkZXJzL2dsX3NoYWRlcnMuanMnKTtcblxuZnVuY3Rpb24gR0xSZW5kZXJlciAodGlsZV9zb3VyY2UsIGxheWVycywgc3R5bGVzLCBvcHRpb25zKVxue1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIFZlY3RvclJlbmRlcmVyLmNhbGwodGhpcywgJ0dMUmVuZGVyZXInLCB0aWxlX3NvdXJjZSwgbGF5ZXJzLCBzdHlsZXMsIG9wdGlvbnMpO1xuXG4gICAgR0xCdWlsZGVycy5zZXRUaWxlU2NhbGUoVmVjdG9yUmVuZGVyZXIudGlsZV9zY2FsZSk7XG4gICAgR0wuUHJvZ3JhbS5kZWZpbmVzLlRJTEVfU0NBTEUgPSBWZWN0b3JSZW5kZXJlci50aWxlX3NjYWxlICsgJy4wJztcblxuICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5jb250aW51b3VzX2FuaW1hdGlvbiA9IGZhbHNlOyAvLyByZXF1ZXN0IHJlZHJhdyBldmVyeSBmcmFtZVxufVxuXG5HTFJlbmRlcmVyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIEdMUmVuZGVyZXJJbml0ICgpXG57XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUuekluZGV4ID0gLTE7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgdGhpcy5nbCA9IEdMLmdldENvbnRleHQodGhpcy5jYW52YXMpO1xuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICAgIHRoaXMucmVuZGVyX21vZGVzID0ge1xuICAgICAgICAncG9seWdvbnMnOiB7XG4gICAgICAgICAgICBnbF9wcm9ncmFtOiBuZXcgR0wuUHJvZ3JhbSh0aGlzLmdsLCBHTFJlbmRlcmVyLnNoYWRlcl9zb3VyY2VzWydwb2x5Z29uX3ZlcnRleCddLCBHTFJlbmRlcmVyLnNoYWRlcl9zb3VyY2VzWydwb2x5Z29uX2ZyYWdtZW50J10pLFxuICAgICAgICAgICAgbWFrZUdMR2VvbWV0cnk6IGZ1bmN0aW9uICh2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR0xUcmlhbmdsZXMocmVuZGVyZXIuZ2wsIHRoaXMuZ2xfcHJvZ3JhbSwgdmVydGV4X2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAncG9seWdvbnNfbm9pc2UnOiB7XG4gICAgICAgICAgICBnbF9wcm9ncmFtOiBuZXcgR0wuUHJvZ3JhbSh0aGlzLmdsLCBHTFJlbmRlcmVyLnNoYWRlcl9zb3VyY2VzWydwb2x5Z29uX3ZlcnRleCddLCBHTFJlbmRlcmVyLnNoYWRlcl9zb3VyY2VzWydwb2x5Z29uX2ZyYWdtZW50J10sIHsgZGVmaW5lczogeyAnRUZGRUNUX05PSVNFX1RFWFRVUkUnOiB0cnVlLCAnRUZGRUNUX05PSVNFX0FOSU1BVEFCTEUnOiB0cnVlIH0gfSksXG4gICAgICAgICAgICBtYWtlR0xHZW9tZXRyeTogZnVuY3Rpb24gKHZlcnRleF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHTFRyaWFuZ2xlcyhyZW5kZXJlci5nbCwgdGhpcy5nbF9wcm9ncmFtLCB2ZXJ0ZXhfZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdwb2ludHMnOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHJlbGF0aXZlIHNoYWRlciBwYXRocyB3aXRoIGEgYmV0dGVyIGF1dG8tcGF0aGluZyBzeXN0ZW1cbiAgICAgICAgICAgIC8vIGdsX3Byb2dyYW06IG5ldyBHTC5Qcm9ncmFtLmNyZWF0ZVByb2dyYW1Gcm9tVVJMcyh0aGlzLmdsLCBWZWN0b3JSZW5kZXJlci5saWJyYXJ5X2Jhc2VfdXJsICsgJy4uL3NoYWRlcnMvcG9pbnRfdmVydGV4Lmdsc2wnLCBWZWN0b3JSZW5kZXJlci5saWJyYXJ5X2Jhc2VfdXJsICsgJy4uL3NoYWRlcnMvcG9pbnRfZnJhZ21lbnQuZ2xzbCcsIHsgZGVmaW5lczogeyAnRUZGRUNUX1NDUkVFTl9DT0xPUic6IHRydWUgfSB9KSxcbiAgICAgICAgICAgIGdsX3Byb2dyYW06IG5ldyBHTC5Qcm9ncmFtKHRoaXMuZ2wsIEdMUmVuZGVyZXIuc2hhZGVyX3NvdXJjZXNbJ3BvaW50X3ZlcnRleCddLCBHTFJlbmRlcmVyLnNoYWRlcl9zb3VyY2VzWydwb2ludF9mcmFnbWVudCddLCB7IGRlZmluZXM6IHsgJ0VGRkVDVF9TQ1JFRU5fQ09MT1InOiB0cnVlIH0gfSksXG4gICAgICAgICAgICBtYWtlR0xHZW9tZXRyeTogZnVuY3Rpb24gKHZlcnRleF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHTFBvbHlQb2ludHMocmVuZGVyZXIuZ2wsIHRoaXMuZ2xfcHJvZ3JhbSwgdmVydGV4X2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVzaXplTWFwKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLCB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xuXG4gICAgLy8gdGhpcy56b29tX3N0ZXAgPSAwLjAyOyAvLyBmb3IgZnJhY3Rpb25hbCB6b29tIHVzZXIgYWRqdXN0bWVudFxuICAgIHRoaXMuc3RhcnRfdGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIHRoaXMubGFzdF9yZW5kZXJfY291bnQgPSBudWxsO1xuICAgIHRoaXMuaW5pdElucHV0SGFuZGxlcnMoKTtcbn07XG5cbi8vIERldGVybWluZSBhIFogdmFsdWUgdGhhdCB3aWxsIHN0YWNrIGZlYXR1cmVzIGluIGEgXCJwYWludGVyJ3MgYWxnb3JpdGhtXCIgc3R5bGUsIGZpcnN0IGJ5IGxheWVyLCB0aGVuIGJ5IGRyYXcgb3JkZXIgd2l0aGluIGxheWVyXG4vLyBGZWF0dXJlcyBhcmUgYXNzdW1lZCB0byBiZSBhbHJlYWR5IHNvcnRlZCBpbiBkZXNpcmVkIGRyYXcgb3JkZXIgYnkgdGhlIGxheWVyIHByZS1wcm9jZXNzb3JcbkdMUmVuZGVyZXIuY2FsY3VsYXRlWiA9IGZ1bmN0aW9uIChsYXllciwgdGlsZSwgbGF5ZXJfb2Zmc2V0LCBmZWF0dXJlX29mZnNldClcbntcbiAgICAvLyB2YXIgbGF5ZXJfb2Zmc2V0ID0gbGF5ZXJfb2Zmc2V0IHx8IDA7XG4gICAgLy8gdmFyIGZlYXR1cmVfb2Zmc2V0ID0gZmVhdHVyZV9vZmZzZXQgfHwgMDtcbiAgICB2YXIgeiA9IDA7IC8vIFRPRE86IG1hZGUgdGhpcyBhIG5vLW9wIHVudGlsIHJldmlzaXRpbmcgd2hlcmUgaXQgc2hvdWxkIGxpdmUgLSBvbmUtdGltZSBjYWxjIGhlcmUsIGluIHZlcnRleCBsYXlvdXQvc2hhZGVyLCBldGMuXG4gICAgcmV0dXJuIHo7XG59O1xuXG4vLyBQcm9jZXNzIGdlb21ldHJ5IGZvciB0aWxlIC0gY2FsbGVkIGJ5IHdlYiB3b3JrZXJcbkdMUmVuZGVyZXIuYWRkVGlsZSA9IGZ1bmN0aW9uICh0aWxlLCBsYXllcnMsIHN0eWxlcylcbntcbiAgICB2YXIgbGF5ZXIsIHN0eWxlLCBmZWF0dXJlLCB6LCBtb2RlO1xuICAgIHZhciB2ZXJ0ZXhfZGF0YSA9IHt9O1xuXG4gICAgLy8gSm9pbiBsaW5lIHRlc3QgcGF0dGVyblxuICAgIC8vIGlmIChHTFJlbmRlcmVyLmRlYnVnKSB7XG4gICAgLy8gICAgIHRpbGUubGF5ZXJzWydyb2FkcyddLmZlYXR1cmVzLnB1c2goR0xSZW5kZXJlci5idWlsZFppZ3phZ0xpbmVUZXN0UGF0dGVybigpKTtcbiAgICAvLyB9XG5cbiAgICAvLyBCdWlsZCByYXcgZ2VvbWV0cnkgYXJyYXlzXG4gICAgdGlsZS5kZWJ1Zy5mZWF0dXJlcyA9IDA7XG4gICAgZm9yICh2YXIgbG49MDsgbG4gPCBsYXllcnMubGVuZ3RoOyBsbisrKSB7XG4gICAgICAgIGxheWVyID0gbGF5ZXJzW2xuXTtcblxuICAgICAgICAvLyBTa2lwIGxheWVycyB3aXRoIG5vIHN0eWxlcyBkZWZpbmVkXG4gICAgICAgIGlmIChzdHlsZXNbbGF5ZXIubmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGlsZS5sYXllcnNbbGF5ZXIubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG51bV9mZWF0dXJlcyA9IHRpbGUubGF5ZXJzW2xheWVyLm5hbWVdLmZlYXR1cmVzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gUmVuZGVyaW5nIHJldmVyc2Ugb3JkZXIgYWthIHRvcCB0byBib3R0b21cbiAgICAgICAgICAgIGZvciAodmFyIGYgPSBudW1fZmVhdHVyZXMtMTsgZiA+PSAwOyBmLS0pIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlID0gdGlsZS5sYXllcnNbbGF5ZXIubmFtZV0uZmVhdHVyZXNbZl07XG4gICAgICAgICAgICAgICAgeiA9IEdMUmVuZGVyZXIuY2FsY3VsYXRlWihsYXllciwgdGlsZSk7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBWZWN0b3JSZW5kZXJlci5wYXJzZVN0eWxlRm9yRmVhdHVyZShmZWF0dXJlLCBzdHlsZXNbbGF5ZXIubmFtZV0sIHRpbGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBmZWF0dXJlP1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGZlYXR1cmUgaW4gdGhpcyByZW5kZXIgbW9kZT9cbiAgICAgICAgICAgICAgICBtb2RlID0gc3R5bGUucmVuZGVyX21vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnRleF9kYXRhW21vZGVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X2RhdGFbbW9kZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBERUJVR0dJTkcgbGluZS90aWxlIGludGVyc2VjdGlvbnMgcmV0dXJuZWQgYXMgcG9pbnRzXG4gICAgICAgICAgICAgICAgLy8gI21hcHplbiw0MC43NDczMzAxMTU4OTYxNywtNzMuOTc1MzUxNDUyODI3NDcsMTdcbiAgICAgICAgICAgICAgICAvLyBpZiAoZmVhdHVyZS5pZCA9PSAxNTc5NjQ4MTMgJiYgZmVhdHVyZS5nZW9tZXRyeS50eXBlID09ICdQb2ludCcpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgc3R5bGUuY29sb3IgPSBbMSwgMSwgMF07XG4gICAgICAgICAgICAgICAgLy8gICAgIHN0eWxlLnNpemUgPSBTdHlsZS53aWR0aC5waXhlbHMoMTAsIHRpbGUpO1xuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhfY29uc3RhbnRzID0gW1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5jb2xvclswXSwgc3R5bGUuY29sb3JbMV0sIHN0eWxlLmNvbG9yWzJdLFxuICAgICAgICAgICAgICAgICAgICBsblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgbWF0ZXJpYWwgaW5mbywgZXRjLlxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUub3V0bGluZS5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0bGluZV92ZXJ0ZXhfY29uc3RhbnRzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jb2xvclswXSwgc3R5bGUub3V0bGluZS5jb2xvclsxXSwgc3R5bGUub3V0bGluZS5jb2xvclsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxuIC0gMC41IC8vIG91dGxpbmVzIHNpdCBiZXR3ZWVuIGxheWVycywgdW5kZXJuZWF0aCBjdXJyZW50IGxheWVyIGJ1dCBhYm92ZSB0aGUgb25lIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbnMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbnMgPSBbZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29ucyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBbZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFtmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJ1ZGVkIHBvbHlnb25zIChlLmcuIDNEIGJ1aWxkaW5ncylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUgJiYgc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHTEJ1aWxkZXJzLmJ1aWxkRXh0cnVkZWRQb2x5Z29ucyhwb2x5Z29ucywgeiwgc3R5bGUuaGVpZ2h0LCBzdHlsZS5taW5faGVpZ2h0LCB2ZXJ0ZXhfZGF0YVttb2RlXSwgeyB2ZXJ0ZXhfY29uc3RhbnRzOiB2ZXJ0ZXhfY29uc3RhbnRzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgcG9seWdvbnNcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHTEJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHosIHZlcnRleF9kYXRhW21vZGVdLCB7IHZlcnRleF9jb25zdGFudHM6IHZlcnRleF9jb25zdGFudHMgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBwb2x5Z29uX3ZlcnRleF9jb25zdGFudHMgPSBbeiwgMCwgMCwgMV0uY29uY2F0KHZlcnRleF9jb25zdGFudHMpOyAvLyB1cHdhcmRzLWZhY2luZyBub3JtYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdMQnVpbGRlcnMuYnVpbGRQb2x5Z29uczIoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgcG9seWdvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgZnVuY3Rpb24gKHZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIEdMLmFkZFZlcnRpY2VzKHZlcnRpY2VzLnBvc2l0aW9ucywgdmVydGV4X2RhdGFbbW9kZV0sIHBvbHlnb25fdmVydGV4X2NvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBvbHlnb24gb3V0bGluZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLm91dGxpbmUuY29sb3IgJiYgc3R5bGUub3V0bGluZS53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbXBjPTA7IG1wYyA8IHBvbHlnb25zLmxlbmd0aDsgbXBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHTEJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzKHBvbHlnb25zW21wY10sIEdMUmVuZGVyZXIuY2FsY3VsYXRlWihsYXllciwgdGlsZSwgLTAuNSksIHN0eWxlLm91dGxpbmUud2lkdGgsIHZlcnRleF9kYXRhW21vZGVdLCB7IGNsb3NlZF9wb2x5Z29uOiB0cnVlLCByZW1vdmVfdGlsZV9lZGdlczogdHJ1ZSwgdmVydGV4X2NvbnN0YW50czogb3V0bGluZV92ZXJ0ZXhfY29uc3RhbnRzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgR0xCdWlsZGVycy5idWlsZFBvbHlsaW5lcyhsaW5lcywgeiwgc3R5bGUud2lkdGgsIHZlcnRleF9kYXRhW21vZGVdLCB7IHZlcnRleF9jb25zdGFudHM6IHZlcnRleF9jb25zdGFudHMgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBvdXRsaW5lc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUub3V0bGluZS5jb2xvciAmJiBzdHlsZS5vdXRsaW5lLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHTEJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzKGxpbmVzLCBHTFJlbmRlcmVyLmNhbGN1bGF0ZVoobGF5ZXIsIHRpbGUsIC0wLjUpLCBzdHlsZS53aWR0aCArIDIgKiBzdHlsZS5vdXRsaW5lLndpZHRoLCB2ZXJ0ZXhfZGF0YVttb2RlXSwgeyB2ZXJ0ZXhfY29uc3RhbnRzOiBvdXRsaW5lX3ZlcnRleF9jb25zdGFudHMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZmVhdHVyZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBhZGRpbmcgdG8geiB0byBleHBlcmltZW50IHdpdGggXCJmbG9hdGluZ1wiIFBPSXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50X3ZlcnRleF9jb25zdGFudHMgPSBbeiArIDEsIDAsIDAsIDFdLmNvbmNhdCh2ZXJ0ZXhfY29uc3RhbnRzKTsgLy8gdXB3YXJkcy1mYWNpbmcgbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgIEdMQnVpbGRlcnMuYnVpbGRRdWFkcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc3R5bGUuc2l6ZSAqIDIsIHN0eWxlLnNpemUgKiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZlcnRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZzID0gdmVydGljZXMucG9zaXRpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWx0ZXJuYXRlIHZlcnRleCBsYXlvdXQgZm9yICdwb2ludHMnIHNoYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09ICdwb2ludHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50X3ZlcnRleF9jb25zdGFudHMgPSB2ZXJ0ZXhfY29uc3RhbnRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHYgaW4gdmVydGljZXMucG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2c1t2XSA9IHZlcnRpY2VzLnBvc2l0aW9uc1t2XS5jb25jYXQoeisgMSwgdmVydGljZXMudGV4Y29vcmRzW3ZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdMLmFkZFZlcnRpY2VzKHZlcnRpY2VzLnBvc2l0aW9ucywgdmVydGV4X2RhdGFbbW9kZV0sIHBvaW50X3ZlcnRleF9jb25zdGFudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdMLmFkZFZlcnRpY2VzKHZzLCB2ZXJ0ZXhfZGF0YVttb2RlXSwgcG9pbnRfdmVydGV4X2NvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXhjb29yZHM6IChtb2RlID09ICdwb2ludHMnKSB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGlsZS5kZWJ1Zy5mZWF0dXJlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGlsZS52ZXJ0ZXhfZGF0YSA9IHt9O1xuICAgIGZvciAodmFyIHMgaW4gdmVydGV4X2RhdGEpIHtcbiAgICAgICAgdGlsZS52ZXJ0ZXhfZGF0YVtzXSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4X2RhdGFbc10pO1xuICAgIH1cblxuICAgIHJldHVybiB0aWxlO1xufTtcblxuLy8gQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gYSB3ZWIgd29ya2VyIGNvbXBsZXRlcyBwcm9jZXNzaW5nIGZvciBhIHNpbmdsZSB0aWxlXG5HTFJlbmRlcmVyLnByb3RvdHlwZS5fdGlsZVdvcmtlckNvbXBsZXRlZCA9IGZ1bmN0aW9uICh0aWxlKVxue1xuICAgIHZhciB2ZXJ0ZXhfZGF0YSA9IHRpbGUudmVydGV4X2RhdGE7XG5cbiAgICAvLyBDcmVhdGUgR0wgZ2VvbWV0cnkgb2JqZWN0c1xuICAgIHRpbGUuZ2xfZ2VvbWV0cnkgPSB7fTtcblxuICAgIGZvciAodmFyIHMgaW4gdmVydGV4X2RhdGEpIHtcbiAgICAgICAgdGlsZS5nbF9nZW9tZXRyeVtzXSA9IHRoaXMucmVuZGVyX21vZGVzW3NdLm1ha2VHTEdlb21ldHJ5KHZlcnRleF9kYXRhW3NdKTtcbiAgICB9XG5cbiAgICB0aWxlLmRlYnVnLmdlb21ldHJpZXMgPSAwO1xuICAgIHRpbGUuZGVidWcuYnVmZmVyX3NpemUgPSAwO1xuICAgIGZvciAodmFyIHAgaW4gdGlsZS5nbF9nZW9tZXRyeSkge1xuICAgICAgICB0aWxlLmRlYnVnLmdlb21ldHJpZXMgKz0gdGlsZS5nbF9nZW9tZXRyeVtwXS5nZW9tZXRyeV9jb3VudDtcbiAgICAgICAgdGlsZS5kZWJ1Zy5idWZmZXJfc2l6ZSArPSB0aWxlLmdsX2dlb21ldHJ5W3BdLnZlcnRleF9kYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgdGlsZS5kZWJ1Zy5nZW9tX3JhdGlvID0gKHRpbGUuZGVidWcuZ2VvbWV0cmllcyAvIHRpbGUuZGVidWcuZmVhdHVyZXMpLnRvRml4ZWQoMSk7XG5cbiAgICAvLyBTZWxlY3Rpb24gLSBleHBlcmltZW50YWwvZnV0dXJlXG4gICAgLy8gdmFyIGdsX3JlbmRlcmVyID0gdGhpcztcbiAgICAvLyB2YXIgcGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAvLyB0aWxlRGl2Lm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50Lm9mZnNldFggKyAnLCAnICsgZXZlbnQub2Zmc2V0WSArICcgfCAnICsgcGFyc2VJbnQodGlsZURpdi5zdHlsZS5sZWZ0KSArICcsICcgKyBwYXJzZUludFxuICAgIC8vICAgICB2YXIgcCA9IFBvaW50KFxuICAgIC8vICAgICAgICAgZXZlbnQub2Zmc2V0WCArIHBhcnNlSW50KHRpbGVEaXYuc3R5bGUubGVmdCksXG4gICAgLy8gICAgICAgICBldmVudC5vZmZzZXRZICsgcGFyc2VJbnQodGlsZURpdi5zdHlsZS50b3ApXG4gICAgLy8gICAgICk7XG4gICAgLy8gICAgIGdsX3JlbmRlcmVyLmdsLnJlYWRQaXhlbHMocC54LCBwLnksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVsKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2cocC54ICsgJywgJyArIHAueSArICc6ICgnICsgcGl4ZWxbMF0gKyAnLCAnICsgcGl4ZWxbMV0gKyAnLCAnICsgcGl4ZWxbMl0gKyAnLCAnICsgcGl4ZWxbM10gKyAnKScpXG4gICAgLy8gfTtcblxuICAgIGRlbGV0ZSB0aWxlLnZlcnRleF9kYXRhOyAvLyBUT0RPOiBtaWdodCB3YW50IHRvIHByZXNlcnZlIHRoaXMgZm9yIHJlYnVpbGRpbmcgZ2VvbWV0cmllcyB3aGVuIHN0eWxlcy9ldGMuIGNoYW5nZT9cbn07XG5cbkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVRpbGUgPSBmdW5jdGlvbiBHTFJlbmRlcmVyUmVtb3ZlVGlsZSAoa2V5KVxue1xuICAgIGlmICh0aGlzLm1hcF96b29taW5nID09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBzaG9ydCBjaXJjdWl0IHRpbGUgcmVtb3ZhbCwgR0wgcmVuZGVyZXIgd2lsbCBzd2VlcCBvdXQgdGlsZXMgYnkgem9vbSBsZXZlbCB3aGVuIHpvb20gZW5kc1xuICAgIH1cblxuICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1trZXldO1xuXG4gICAgaWYgKHRpbGUgIT0gbnVsbCAmJiB0aWxlLmdsX2dlb21ldHJ5ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB0aWxlLmdsX2dlb21ldHJ5KSB7XG4gICAgICAgICAgICB0aWxlLmdsX2dlb21ldHJ5W3BdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlLmdsX2dlb21ldHJ5ID0gbnVsbDtcbiAgICB9XG4gICAgVmVjdG9yUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVRpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbkdMUmVuZGVyZXIucHJvdG90eXBlLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tID0gMjtcbkdMUmVuZGVyZXIucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbiAoem9vbSlcbntcbiAgICAvLyBTY2hlZHVsZSBHTCB0aWxlcyBmb3IgcmVtb3ZhbCBvbiB6b29tXG4gICAgY29uc29sZS5sb2coXCJyZW5kZXJlci5tYXBfbGFzdF96b29tOiBcIiArIHRoaXMubWFwX2xhc3Rfem9vbSk7XG5cbiAgICB0aGlzLm1hcF96b29taW5nID0gZmFsc2U7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB2YXIgYmVsb3cgPSB0aGlzLnpvb207XG4gICAgdmFyIGFib3ZlID0gdGhpcy56b29tO1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnpvb20gLSB0aGlzLm1hcF9sYXN0X3pvb20pIDw9IHRoaXMucHJlc2VydmVfdGlsZXNfd2l0aGluX3pvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuem9vbSA+IHRoaXMubWFwX2xhc3Rfem9vbSkge1xuICAgICAgICAgICAgYmVsb3cgPSB0aGlzLnpvb20gLSB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJvdmUgPSB0aGlzLnpvb20gKyB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGlsZXNPdXRzaWRlWm9vbVJhbmdlKGJlbG93LCBhYm92ZSk7XG4gICAgdGhpcy5tYXBfbGFzdF96b29tID0gdGhpcy56b29tO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlOyAvLyBjYWxsaW5nIGJlY2F1c2UgdGhpcyBpcyBhIGZ1bGwgb3ZlcnJpZGUgb2YgdGhlIHBhcmVudCBjbGFzc1xufTtcblxuR0xSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlVGlsZXNPdXRzaWRlWm9vbVJhbmdlID0gZnVuY3Rpb24gKGJlbG93LCBhYm92ZSlcbntcbiAgICBiZWxvdyA9IE1hdGgubWluKGJlbG93LCB0aGlzLnRpbGVfc291cmNlLm1heF96b29tIHx8IGJlbG93KTtcbiAgICBhYm92ZSA9IE1hdGgubWluKGFib3ZlLCB0aGlzLnRpbGVfc291cmNlLm1heF96b29tIHx8IGFib3ZlKTtcblxuICAgIGNvbnNvbGUubG9nKFwicmVtb3ZlVGlsZXNPdXRzaWRlWm9vbVJhbmdlIFtcIiArIGJlbG93ICsgXCIsIFwiICsgYWJvdmUgKyBcIl0pXCIpO1xuICAgIHZhciByZW1vdmVfdGlsZXMgPSBbXTtcbiAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW3RdO1xuICAgICAgICBpZiAodGlsZS5jb29yZHMueiA8IGJlbG93IHx8IHRpbGUuY29vcmRzLnogPiBhYm92ZSkge1xuICAgICAgICAgICAgcmVtb3ZlX3RpbGVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgcj0wOyByIDwgcmVtb3ZlX3RpbGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciBrZXkgPSByZW1vdmVfdGlsZXNbcl07XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVtb3ZlZCBcIiArIGtleSArIFwiIChvdXRzaWRlIHJhbmdlIFtcIiArIGJlbG93ICsgXCIsIFwiICsgYWJvdmUgKyBcIl0pXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZVRpbGUoa2V5KTtcbiAgICB9XG59O1xuXG4vLyBPdmVycmlkZXMgYmFzZSBjbGFzcyBtZXRob2QgKGEgbm8gb3ApXG5HTFJlbmRlcmVyLnByb3RvdHlwZS5yZXNpemVNYXAgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbntcbiAgICBWZWN0b3JSZW5kZXJlci5wcm90b3R5cGUucmVzaXplTWFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmNzc19zaXplID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgdGhpcy5kZXZpY2Vfc2l6ZSA9IHsgd2lkdGg6IE1hdGgucm91bmQodGhpcy5jc3Nfc2l6ZS53aWR0aCAqIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvKSwgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuY3NzX3NpemUuaGVpZ2h0ICogdGhpcy5kZXZpY2VfcGl4ZWxfcmF0aW8pIH07XG5cbiAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMuY3NzX3NpemUud2lkdGggKyAncHgnO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuY3NzX3NpemUuaGVpZ2h0ICsgJ3B4JztcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuZGV2aWNlX3NpemUud2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5kZXZpY2Vfc2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbn07XG5cbkdMUmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiBHTFJlbmRlcmVyUmVuZGVyICgpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMuaW5wdXQoKTtcblxuICAgIC8vIFJlc2V0IGZyYW1lIHN0YXRlXG4gICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGVwdGhGdW5jKGdsLkxFU1MpO1xuICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuXG4gICAgLy8gUmVuZGVyIHRpbGVzIGdyb3VwZWQgYnkgcmVuZGVyZyBtb2RlIChHTCBwcm9ncmFtKVxuICAgIHZhciByZW5kZXJfY291bnQgPSAwO1xuICAgIGZvciAodmFyIG1vZGUgaW4gdGhpcy5yZW5kZXJfbW9kZXMpIHtcbiAgICAgICAgdmFyIGdsX3Byb2dyYW0gPSB0aGlzLnJlbmRlcl9tb2Rlc1ttb2RlXS5nbF9wcm9ncmFtO1xuXG4gICAgICAgIGdsLnVzZVByb2dyYW0oZ2xfcHJvZ3JhbS5wcm9ncmFtKTtcblxuICAgICAgICAvLyBUT0RPOiBzZXQgdGhlc2Ugb25jZSBwZXIgcHJvZ3JhbSwgZG9uJ3Qgc2V0IHdoZW4gdGhleSBoYXZlbid0IGNoYW5nZWRcbiAgICAgICAgZ2xfcHJvZ3JhbS51bmlmb3JtKCcyZicsICdyZXNvbHV0aW9uJywgdGhpcy5jc3Nfc2l6ZS53aWR0aCwgdGhpcy5jc3Nfc2l6ZS5oZWlnaHQpO1xuICAgICAgICBnbF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3RpbWUnLCAoKCtuZXcgRGF0ZSgpKSAtIHRoaXMuc3RhcnRfdGltZSkgLyAxMDAwKTtcblxuICAgICAgICB2YXIgY2VudGVyID0gR2VvLmxhdExuZ1RvTWV0ZXJzKFBvaW50KHRoaXMuY2VudGVyLmxuZywgdGhpcy5jZW50ZXIubGF0KSk7XG4gICAgICAgIGdsX3Byb2dyYW0udW5pZm9ybSgnMmYnLCAnbWFwX2NlbnRlcicsIGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICAgIGdsX3Byb2dyYW0udW5pZm9ybSgnMWYnLCAnbWFwX3pvb20nLCB0aGlzLnpvb20pOyAvLyBNYXRoLmZsb29yKHRoaXMuem9vbSkgKyAoTWF0aC5sb2coKHRoaXMuem9vbSAlIDEpICsgMSkgLyBNYXRoLkxOMiAvLyBzY2FsZSBmcmFjdGlvbmFsIHpvb20gYnkgbG9nXG4gICAgICAgIGdsX3Byb2dyYW0udW5pZm9ybSgnMWYnLCAnbnVtX2xheWVycycsIHRoaXMubGF5ZXJzLmxlbmd0aCk7XG5cbiAgICAgICAgdmFyIG1ldGVyc19wZXJfcGl4ZWwgPSBHZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCAvIE1hdGgucG93KDIsIHRoaXMuem9vbSk7XG4gICAgICAgIHZhciBtZXRlcl96b29tID0gUG9pbnQodGhpcy5jc3Nfc2l6ZS53aWR0aCAvIDIgKiBtZXRlcnNfcGVyX3BpeGVsLCB0aGlzLmNzc19zaXplLmhlaWdodCAvIDIgKiBtZXRlcnNfcGVyX3BpeGVsKTtcbiAgICAgICAgZ2xfcHJvZ3JhbS51bmlmb3JtKCcyZicsICdtZXRlcl96b29tJywgbWV0ZXJfem9vbS54LCBtZXRlcl96b29tLnkpO1xuXG4gICAgICAgIC8vIFRPRE86IG1ha2UgYSBsaXN0IG9mIHJlbmRlcmFibGUgdGlsZXMgb25jZSBwZXIgZnJhbWUsIG91dHNpZGUgdGhpcyBsb29wXG4gICAgICAgIC8vIFJlbmRlciB0aWxlIEdMIGdlb21ldHJpZXNcbiAgICAgICAgdmFyIGNhcHBlZF96b29tID0gTWF0aC5taW4ofn50aGlzLnpvb20sIHRoaXMudGlsZV9zb3VyY2UubWF4X3pvb20gfHwgfn50aGlzLnpvb20pO1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1t0XTtcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRlZCA9PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgdGlsZS52aXNpYmxlID09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBNYXRoLm1pbih0aWxlLmNvb3Jkcy56LCB0aGlzLnRpbGVfc291cmNlLm1heF96b29tIHx8IHRpbGUuY29vcmRzLnopID09IGNhcHBlZF96b29tKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGlsZS5nbF9nZW9tZXRyeVttb2RlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsX3Byb2dyYW0udW5pZm9ybSgnMmYnLCAndGlsZV9taW4nLCB0aWxlLm1pbi54LCB0aWxlLm1pbi55KTtcbiAgICAgICAgICAgICAgICAgICAgZ2xfcHJvZ3JhbS51bmlmb3JtKCcyZicsICd0aWxlX21heCcsIHRpbGUubWF4LngsIHRpbGUubWF4LnkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRpbGUuZ2xfZ2VvbWV0cnlbbW9kZV0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcl9jb3VudCArPSB0aWxlLmdsX2dlb21ldHJ5W21vZGVdLmdlb21ldHJ5X2NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXJfY291bnQgIT0gdGhpcy5sYXN0X3JlbmRlcl9jb3VudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlbmRlcmVkIFwiICsgcmVuZGVyX2NvdW50ICsgXCIgcHJpbWl0aXZlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0X3JlbmRlcl9jb3VudCA9IHJlbmRlcl9jb3VudDtcblxuICAgIGlmICh0aGlzLmNvbnRpbnVvdXNfYW5pbWF0aW9uID09IHRydWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBTdW0gb2YgYSBkZWJ1ZyBwcm9wZXJ0eSBhY3Jvc3MgdGlsZXNcbkdMUmVuZGVyZXIucHJvdG90eXBlLmdldERlYnVnU3VtID0gZnVuY3Rpb24gKHByb3AsIGZpbHRlcilcbntcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGlsZXNbdF0uZGVidWdbcHJvcF0gIT0gbnVsbCAmJiAodHlwZW9mIGZpbHRlciAhPSAnZnVuY3Rpb24nIHx8IGZpbHRlcih0aGlzLnRpbGVzW3RdKSA9PSB0cnVlKSkge1xuICAgICAgICAgICAgc3VtICs9IHRoaXMudGlsZXNbdF0uZGVidWdbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIEF2ZXJhZ2Ugb2YgYSBkZWJ1ZyBwcm9wZXJ0eSBhY3Jvc3MgdGlsZXNcbkdMUmVuZGVyZXIucHJvdG90eXBlLmdldERlYnVnQXZlcmFnZSA9IGZ1bmN0aW9uIChwcm9wLCBmaWx0ZXIpXG57XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVidWdTdW0ocHJvcCwgZmlsdGVyKSAvIE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLmxlbmd0aDtcbn07XG5cbi8vIFVzZXIgaW5wdXRcbi8vIFRPRE86IHJlc3RvcmUgZnJhY3Rpb25hbCB6b29tIHN1cHBvcnQgb25jZSBsZWFmbGV0IGFuaW1hdGlvbiByZWZhY3RvciBwdWxsIHJlcXVlc3QgaXMgbWVyZ2VkXG5cbkdMUmVuZGVyZXIucHJvdG90eXBlLmluaXRJbnB1dEhhbmRsZXJzID0gZnVuY3Rpb24gR0xSZW5kZXJlckluaXRJbnB1dEhhbmRsZXJzICgpXG57XG4gICAgdmFyIGdsX3JlbmRlcmVyID0gdGhpcztcbiAgICBnbF9yZW5kZXJlci5rZXkgPSBudWxsO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNykge1xuICAgICAgICAgICAgZ2xfcmVuZGVyZXIua2V5ID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzkpIHtcbiAgICAgICAgICAgIGdsX3JlbmRlcmVyLmtleSA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOCkge1xuICAgICAgICAgICAgZ2xfcmVuZGVyZXIua2V5ID0gJ3VwJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDQwKSB7XG4gICAgICAgICAgICBnbF9yZW5kZXJlci5rZXkgPSAnZG93bic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSA4MykgeyAvLyBzXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlbG9hZGluZyBzaGFkZXJzXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgbW9kZSBpbiB0aGlzLnJlbmRlcl9tb2Rlcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX21vZGVzW21vZGVdLmdsX3Byb2dyYW0uY29tcGlsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xfcmVuZGVyZXIuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBnbF9yZW5kZXJlci5rZXkgPSBudWxsO1xuICAgIH0pO1xufTtcblxuR0xSZW5kZXJlci5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbiBHTFJlbmRlcmVySW5wdXQgKClcbntcbiAgICAvLyAvLyBGcmFjdGlvbmFsIHpvb20gc2NhbGluZ1xuICAgIC8vIGlmICh0aGlzLmtleSA9PSAndXAnKSB7XG4gICAgLy8gICAgIHRoaXMuc2V0Wm9vbSh0aGlzLnpvb20gKyB0aGlzLnpvb21fc3RlcCk7XG4gICAgLy8gfVxuICAgIC8vIGVsc2UgaWYgKHRoaXMua2V5ID09ICdkb3duJykge1xuICAgIC8vICAgICB0aGlzLnNldFpvb20odGhpcy56b29tIC0gdGhpcy56b29tX3N0ZXApO1xuICAgIC8vIH1cbn07XG5cbmlmIChtb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gR0xSZW5kZXJlcjtcbn1cbiIsInZhciBWZWN0b3JSZW5kZXJlciA9IHJlcXVpcmUoJy4vdmVjdG9yX3JlbmRlcmVyLmpzJyk7XG52YXIgR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4vZ2xfcmVuZGVyZXIuanMnKTtcbnZhciBDYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4vY2FudmFzX3JlbmRlcmVyLmpzJyk7XG5cbnZhciBMZWFmbGV0TGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICB2ZWN0b3JSZW5kZXJlcjogJ2NhbnZhcydcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVjdG9yUmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMudmVjdG9yUmVuZGVyZXIgfHwgJ0dMUmVuZGVyZXInO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IFZlY3RvclJlbmRlcmVyLmNyZWF0ZSh0aGlzLm9wdGlvbnMudmVjdG9yUmVuZGVyZXIsIHRoaXMub3B0aW9ucy52ZWN0b3JUaWxlU291cmNlLCB0aGlzLm9wdGlvbnMudmVjdG9yTGF5ZXJzLCB0aGlzLm9wdGlvbnMudmVjdG9yU3R5bGVzLCB7IG51bV93b3JrZXJzOiB0aGlzLm9wdGlvbnMubnVtV29ya2VycyB9KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGVidWcgPSB0aGlzLm9wdGlvbnMuZGVidWc7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbnRpbnVvdXNfYW5pbWF0aW9uID0gZmFsc2U7IC8vIHNldCB0byB0cnVlIGZvciBhbmltYXRpbm9zLCBldGMuIChldmVudHVhbGx5IHdpbGwgYmUgYXV0b21hdGVkKVxuXG4gICAgICAgIHRoaXMuR0wgPSByZXF1aXJlKCcuL2dsLmpzJyk7XG4gICAgfSxcblxuICAgIC8vIEZpbmlzaCBpbml0aWFsaXppbmcgcmVuZGVyZXIgYW5kIHNldHVwIGV2ZW50cyB3aGVuIGxheWVyIGlzIGFkZGVkIHRvIG1hcFxuICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXM7XG5cbiAgICAgICAgbGF5ZXIub24oJ3RpbGV1bmxvYWQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gZXZlbnQudGlsZTtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aWxlLmdldEF0dHJpYnV0ZSgnZGF0YS10aWxlLWtleScpO1xuICAgICAgICAgICAgbGF5ZXIuX3JlbmRlcmVyLnJlbW92ZVRpbGUoa2V5KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGF5ZXIuX21hcC5vbigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNpemUgPSBsYXllci5fbWFwLmdldFNpemUoKTtcbiAgICAgICAgICAgIGxheWVyLl9yZW5kZXJlci5yZXNpemVNYXAoc2l6ZS54LCBzaXplLnkpO1xuICAgICAgICAgICAgbGF5ZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheWVyLl9tYXAub24oJ21vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gbGF5ZXIuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIGxheWVyLl9yZW5kZXJlci5zZXRDZW50ZXIoY2VudGVyLmxuZywgY2VudGVyLmxhdCk7XG4gICAgICAgICAgICBsYXllci51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGF5ZXIuX21hcC5vbignem9vbXN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtYXAuem9vbXN0YXJ0IFwiICsgbGF5ZXIuX21hcC5nZXRab29tKCkpO1xuICAgICAgICAgICAgbGF5ZXIuX3JlbmRlcmVyLnN0YXJ0Wm9vbSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsYXllci5fbWFwLm9uKCd6b29tZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtYXAuem9vbWVuZCBcIiArIGxheWVyLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgIGxheWVyLl9yZW5kZXJlci5zZXRab29tKGxheWVyLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FudmFzIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZCBhZnRlciBtYXAgY29udGFpbmVyIChsZWFmbGV0IHRyYW5zZm9ybXMgc2hvdWxkbid0IGJlIGFwcGxpZWQgdG8gdGhlIEdMIGNhbnZhcylcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXM/IHJpZ2h0IG5vdyBHTCBtYXAgb25seSByZW5kZXJzIGNvcnJlY3RseSBhcyB0aGUgYm90dG9tIGxheWVyXG4gICAgICAgIGxheWVyLl9yZW5kZXJlci5jb250YWluZXIgPSBsYXllci5fbWFwLmdldENvbnRhaW5lcigpO1xuXG4gICAgICAgIHZhciBjZW50ZXIgPSBsYXllci5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICBsYXllci5fcmVuZGVyZXIuc2V0Q2VudGVyKGNlbnRlci5sbmcsIGNlbnRlci5sYXQpO1xuICAgICAgICBsYXllci5fcmVuZGVyZXIuc2V0Wm9vbShsYXllci5fbWFwLmdldFpvb20oKSk7XG4gICAgICAgIGxheWVyLnVwZGF0ZUJvdW5kcygpO1xuXG4gICAgICAgIEwuR3JpZExheWVyLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBsYXllci5fcmVuZGVyZXIuaW5pdCgpO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBMLkdyaWRMYXllci5wcm90b3R5cGUub25SZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGV2ZW50IGhhbmRsZXJzLCBkZXN0cm95IG1hcFxuICAgIH0sXG5cbiAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIubG9hZFRpbGUoY29vcmRzLCBkaXYsIGRvbmUpO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICB1cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcztcbiAgICAgICAgdmFyIGJvdW5kcyA9IGxheWVyLl9tYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIGxheWVyLl9yZW5kZXJlci5zZXRCb3VuZHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfVxuXG59KTtcblxudmFyIGxlYWZsZXRMYXllciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBMZWFmbGV0TGF5ZXIob3B0aW9ucyk7XG59O1xuXG5pZiAobW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgTGVhZmxldExheWVyOiBMZWFmbGV0TGF5ZXIsXG4gICAgICAgIGxlYWZsZXRMYXllcjogbGVhZmxldExheWVyXG4gICAgfVxufVxuIiwiLy8gUG9pbnRcbmZ1bmN0aW9uIFBvaW50ICh4LCB5KVxue1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cblxuUG9pbnQuY29weSA9IGZ1bmN0aW9uIChwKVxue1xuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHg6IHAueCwgeTogcC55IH07XG59O1xuXG5pZiAobW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xufVxuIiwiLy8gR2VuZXJhdGVkIGZyb20gR0xTTCBmaWxlcywgZG9uJ3QgZWRpdCFcbnZhciBzaGFkZXJfc291cmNlcyA9IHt9O1xuXG5zaGFkZXJfc291cmNlc1sncG9pbnRfZnJhZ21lbnQnXSA9XG5cInVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzMgZmNvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWMyIGZ0ZXhjb29yZDtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgdmVjNCBjb2xvciA9IHZlYzQoZmNvbG9yLCAxLik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBpZiAobGVuZ3RoKGZ0ZXhjb29yZC54eSkgPiAxMC4pIHtcXG5cIiArXG5cIiAgICAvLyAgICAgLy8gY29sb3IgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcXG5cIiArXG5cIiAgICAvLyAgICAgZGlzY2FyZDtcXG5cIiArXG5cIiAgICAvLyB9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBsZW4gPSBsZW5ndGgoZnRleGNvb3JkKTtcXG5cIiArXG5cIiAgICBpZiAobGVuID4gMS4pIHtcXG5cIiArXG5cIiAgICAgICAgZGlzY2FyZDtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIgICAgY29sb3IucmdiICo9ICgxLiAtIHNtb290aHN0ZXAoLjI1LCAxLiwgbGVuKSkgKyAwLjU7XFxuXCIgK1xuXCIgICAgLy8gY29sb3IuYSA9ICgxLiAtIHNtb290aHN0ZXAoMi41LCAxMC4sIGxlbikpICsgMC4yNTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZiBkZWZpbmVkKEVGRkVDVF9TQ1JFRU5fQ09MT1IpXFxuXCIgK1xuXCIgICAgICAgIC8vIE11dGF0ZSBjb2xvcnMgYnkgc2NyZWVuIHBvc2l0aW9uXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yLnJnYiArPSB2ZWMzKGdsX0ZyYWdDb29yZC54IC8gcmVzb2x1dGlvbi54LCAwLjAsIGdsX0ZyYWdDb29yZC55IC8gcmVzb2x1dGlvbi55KTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlcl9zb3VyY2VzWydwb2ludF92ZXJ0ZXgnXSA9XG5cInVuaWZvcm0gdmVjMiBtYXBfY2VudGVyO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCBtYXBfem9vbTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMiBtZXRlcl96b29tO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHRpbGVfbWluO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHRpbGVfbWF4O1xcblwiICtcblwidW5pZm9ybSBmbG9hdCBudW1fbGF5ZXJzO1xcblwiICtcblwiLy8gdW5pZm9ybSBmbG9hdCB0aW1lO1xcblwiICtcblwiXFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5cIiArXG5cIi8vIGF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMyIHRleGNvb3JkO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzMgY29sb3I7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgZmxvYXQgbGF5ZXI7XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjMyBmY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzIgZnRleGNvb3JkO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyB2ZWMzIGxpZ2h0ID0gbm9ybWFsaXplKHZlYzMoMC4yLCAwLjcsIC0wLjUpKTsgLy8gdmVjMygwLjEsIDAuMiwgLTAuNClcXG5cIiArXG5cIi8vIGNvbnN0IGZsb2F0IGFtYmllbnQgPSAwLjQ1O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuXCIgICAgdmVjMyB2cG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIiAgICAvLyB2ZWMzIHZub3JtYWwgPSBub3JtYWw7XFxuXCIgK1xuXCIgICAgLy8gdmVjMiB2dGV4Y29vcmQgPSB0ZXhjb29yZDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENhbGMgcG9zaXRpb24gb2YgdmVydGV4IGluIG1ldGVycywgcmVsYXRpdmUgdG8gY2VudGVyIG9mIHNjcmVlblxcblwiICtcblwiICAgIHZwb3NpdGlvbi55ICo9IC0xLjA7IC8vIGFkanVzdCBmb3IgZmxpcHBlZCB5LWNvb3Jkc1xcblwiICtcblwiICAgIHZwb3NpdGlvbi54eSAqPSAodGlsZV9tYXggLSB0aWxlX21pbikgLyBUSUxFX1NDQUxFOyAvLyBhZGp1c3QgZm9yIHZlcnRleCBsb2NhdGlvbiB3aXRoaW4gdGlsZSAoc2NhbGVkIGZyb20gbG9jYWwgY29vcmRzIHRvIG1ldGVycylcXG5cIiArXG5cIiAgICB2cG9zaXRpb24ueHkgKz0gdGlsZV9taW4ueHkgLSBtYXBfY2VudGVyOyAvLyBhZGp1c3QgZm9yIGNvcm5lciBvZiB0aWxlIHJlbGF0aXZlIHRvIG1hcCBjZW50ZXJcXG5cIiArXG5cIiAgICB2cG9zaXRpb24ueHkgLz0gbWV0ZXJfem9vbTsgLy8gYWRqdXN0IGZvciB6b29tIGluIG1ldGVycyB0byBnZXQgY2xpcCBzcGFjZSBjb29yZHNcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNoYWRpbmcgJiB0ZXh0dXJlXFxuXCIgK1xuXCIgICAgZmNvbG9yID0gY29sb3I7XFxuXCIgK1xuXCIgICAgZnRleGNvb3JkID0gdGV4Y29vcmQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyAjaWYgZGVmaW5lZChQUk9KRUNUSU9OX1BFUlNQRUNUSVZFKVxcblwiICtcblwiICAgIC8vICAgICAvLyBQZXJzcGVjdGl2ZS1zdHlsZSBwcm9qZWN0aW9uXFxuXCIgK1xuXCIgICAgLy8gICAgIHZlYzIgcGVyc3BlY3RpdmVfb2Zmc2V0ID0gdmVjMigtMC4yNSwgLTAuMjUpO1xcblwiICtcblwiICAgIC8vICAgICB2ZWMyIHBlcnNwZWN0aXZlX2ZhY3RvciA9IHZlYzIoMC44LCAwLjgpOyAvLyB2ZWMyKC0wLjI1LCAwLjc1KTtcXG5cIiArXG5cIiAgICAvLyAgICAgdnBvc2l0aW9uLnh5ICs9IHZwb3NpdGlvbi56ICogcGVyc3BlY3RpdmVfZmFjdG9yICogKHZwb3NpdGlvbi54eSAtIHBlcnNwZWN0aXZlX29mZnNldCkgLyBtZXRlcl96b29tLnh5OyAvLyBwZXJzcGVjdGl2ZSBmcm9tIG9mZnNldCBjZW50ZXIgc2NyZWVuXFxuXCIgK1xuXCIgICAgLy8gI2VsaWYgZGVmaW5lZChQUk9KRUNUSU9OX0lTT01FVFJJQykgfHwgZGVmaW5lZChQUk9KRUNUSU9OX1BPUFVQKVxcblwiICtcblwiICAgIC8vICAgICAvLyBQb3AtdXAgZWZmZWN0IC0gM2QgaW4gY2VudGVyIG9mIHZpZXdwb3J0LCBmYWRpbmcgdG8gMmQgYXQgZWRnZXNcXG5cIiArXG5cIiAgICAvLyAgICAgI2lmIGRlZmluZWQoUFJPSkVDVElPTl9QT1BVUClcXG5cIiArXG5cIiAgICAvLyAgICAgICAgIGlmICh2cG9zaXRpb24ueiA+IDEuMCkge1xcblwiICtcblwiICAgIC8vICAgICAgICAgICAgIGZsb2F0IGNkID0gZGlzdGFuY2UodnBvc2l0aW9uLnh5ICogKHJlc29sdXRpb24ueHkgLyByZXNvbHV0aW9uLnl5KSwgdmVjMigwLjAsIDAuMCkpO1xcblwiICtcblwiICAgIC8vICAgICAgICAgICAgIGNvbnN0IGZsb2F0IHBvcHVwX2ZhZGVfaW5uZXIgPSAwLjU7XFxuXCIgK1xuXCIgICAgLy8gICAgICAgICAgICAgY29uc3QgZmxvYXQgcG9wdXBfZmFkZV9vdXRlciA9IDAuNzU7XFxuXCIgK1xuXCIgICAgLy8gICAgICAgICAgICAgaWYgKGNkID4gcG9wdXBfZmFkZV9pbm5lcikge1xcblwiICtcblwiICAgIC8vICAgICAgICAgICAgICAgICB2cG9zaXRpb24ueiAqPSAxLjAgLSBzbW9vdGhzdGVwKHBvcHVwX2ZhZGVfaW5uZXIsIHBvcHVwX2ZhZGVfb3V0ZXIsIGNkKTtcXG5cIiArXG5cIiAgICAvLyAgICAgICAgICAgICB9XFxuXCIgK1xuXCIgICAgLy8gICAgICAgICAgICAgY29uc3QgZmxvYXQgem9vbV9ib29zdF9zdGFydCA9IDE1LjA7XFxuXCIgK1xuXCIgICAgLy8gICAgICAgICAgICAgY29uc3QgZmxvYXQgem9vbV9ib29zdF9lbmQgPSAxNy4wO1xcblwiICtcblwiICAgIC8vICAgICAgICAgICAgIGNvbnN0IGZsb2F0IHpvb21fYm9vc3RfbWFnbml0dWRlID0gMC43NTtcXG5cIiArXG5cIiAgICAvLyAgICAgICAgICAgICB2cG9zaXRpb24ueiAqPSAxLjAgKyAoMS4wIC0gc21vb3Roc3RlcCh6b29tX2Jvb3N0X3N0YXJ0LCB6b29tX2Jvb3N0X2VuZCwgbWFwX3pvb20pKSAqIHpvb21fYm9vc3RfbWFnbml0dWRlO1xcblwiICtcblwiICAgIC8vICAgICAgICAgfVxcblwiICtcblwiICAgIC8vICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vICAgICAvLyBJc29tZXRyaWMtc3R5bGUgcHJvamVjdGlvblxcblwiICtcblwiICAgIC8vICAgICB2cG9zaXRpb24ueSArPSB2cG9zaXRpb24ueiAvIG1ldGVyX3pvb20ueTsgLy8geiBjb29yZGluYXRlIGlzIGEgc2ltcGxlIHRyYW5zbGF0aW9uIHVwIGFsb25nIHkgYXhpcywgYWxhIGlzb21ldHJpY1xcblwiICtcblwiICAgIC8vICAgICAvLyB2cG9zaXRpb24ueSArPSB2cG9zaXRpb24ueiAqIDAuNTsgLy8gY2xvc2VyIHRvIFVsdGltYSA3LXN0eWxlIGF4b25vbWV0cmljXFxuXCIgK1xuXCIgICAgLy8gICAgIC8vIHZwb3NpdGlvbi54IC09IHZwb3NpdGlvbi56ICogMC41O1xcblwiICtcblwiICAgIC8vICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gUmV2ZXJzZSBhbmQgc2NhbGUgdG8gMC0xIGZvciBHTCBkZXB0aCBidWZmZXJcXG5cIiArXG5cIiAgICAvLyBMYXllcnMgYXJlIGZvcmNlLW9yZGVyZWQgKGhpZ2hlciBsYXllcnMgZ3VhcmFudGVlZCB0byByZW5kZXIgb24gdG9wIG9mIGxvd2VyKSwgdGhlbiBieSBoZWlnaHQvZGVwdGhcXG5cIiArXG5cIiAgICBmbG9hdCB6X2xheWVyX3NjYWxlID0gNDA5Ni47XFxuXCIgK1xuXCIgICAgZmxvYXQgel9sYXllcl9yYW5nZSA9IChudW1fbGF5ZXJzICsgMS4pICogel9sYXllcl9zY2FsZTtcXG5cIiArXG5cIiAgICBmbG9hdCB6X2xheWVyID0gKGxheWVyICsgMS4pICogel9sYXllcl9zY2FsZTtcXG5cIiArXG5cIiAgICAvLyBmbG9hdCB6X2xheWVyID0gKGxheWVyICsgMS4pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdnBvc2l0aW9uLnogPSB6X2xheWVyICsgY2xhbXAodnBvc2l0aW9uLnosIDEuLCB6X2xheWVyX3NjYWxlKTtcXG5cIiArXG5cIiAgICB2cG9zaXRpb24ueiA9ICh6X2xheWVyX3JhbmdlIC0gdnBvc2l0aW9uLnopIC8gel9sYXllcl9yYW5nZTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2cG9zaXRpb24sIDEuMCk7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyX3NvdXJjZXNbJ3BvbHlnb25fZnJhZ21lbnQnXSA9XG5cInVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB0aW1lO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzMgZmNvbG9yO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChFRkZFQ1RfTk9JU0VfVEVYVFVSRSlcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzMgZnBvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MjAwMjI0L3JhbmRvbS1ub2lzZS1mdW5jdGlvbnMtZm9yLWdsc2xcXG5cIiArXG5cIiAgICAvLyBmbG9hdCByYW5kICh2ZWMyIGNvKSB7XFxuXCIgK1xuXCIgICAgLy8gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XFxuXCIgK1xuXCIgICAgLy8gfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTm9pc2UgZnVuY3Rpb25zIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG5cIiArXG5cIiAgICB2ZWMzIG1vZDI4OSh2ZWMzIHgpIHtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2ZWM0IG1vZDI4OSh2ZWM0IHgpIHtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2ZWM0IHBlcm11dGUodmVjNCB4KSB7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcikge1xcblwiICtcblwiICAgICAgICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZlYzMgZmFkZSh2ZWMzIHQpIHtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuIHQqdCp0Kih0Kih0KjYuMC0xNS4wKSsxMC4wKTtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBzbm9pc2UodmVjMyB2KSB7XFxuXCIgK1xuXCIgICAgICAgIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcXG5cIiArXG5cIiAgICAgICAgY29uc3QgdmVjNCAgRCA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMi4wKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBGaXJzdCBjb3JuZXJcXG5cIiArXG5cIiAgICAgICAgdmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gT3RoZXIgY29ybmVyc1xcblwiICtcblwiICAgICAgICB2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBsID0gMS4wIC0gZztcXG5cIiArXG5cIiAgICAgICAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vICAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4O1xcblwiICtcblwiICAgICAgICAvLyAgIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eDtcXG5cIiArXG5cIiAgICAgICAgLy8gICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHg7XFxuXCIgK1xuXCIgICAgICAgIC8vICAgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEMueHh4O1xcblwiICtcblwiICAgICAgICB2ZWMzIHgxID0geDAgLSBpMSArIEMueHh4O1xcblwiICtcblwiICAgICAgICB2ZWMzIHgyID0geDAgLSBpMiArIEMueXl5OyAvLyAyLjAqQy54ID0gMS8zID0gQy55XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgeDMgPSB4MCAtIEQueXl5OyAgICAgIC8vIC0xLjArMy4wKkMueCA9IC0wLjUgPSAtRC55XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gUGVybXV0YXRpb25zXFxuXCIgK1xuXCIgICAgICAgIGkgPSBtb2QyODkoaSk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgcCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoXFxuXCIgK1xuXCIgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcXG5cIiArXG5cIiAgICAgICAgKyBpLnkgKyB2ZWM0KDAuMCwgaTEueSwgaTIueSwgMS4wICkpXFxuXCIgK1xuXCIgICAgICAgICsgaS54ICsgdmVjNCgwLjAsIGkxLngsIGkyLngsIDEuMCApKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBHcmFkaWVudHM6IDd4NyBwb2ludHMgb3ZlciBhIHNxdWFyZSwgbWFwcGVkIG9udG8gYW4gb2N0YWhlZHJvbi5cXG5cIiArXG5cIiAgICAgICAgLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQ5ICg0OSo2ID0gMjk0KVxcblwiICtcblwiICAgICAgICBmbG9hdCBuXyA9IDAuMTQyODU3MTQyODU3OyAvLyAxLjAvNy4wXFxuXCIgK1xuXCIgICAgICAgIHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKiBucy56KTsgIC8vICBtb2QocCw3KjcpXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCB5XyA9IGZsb29yKGogLSA3LjAgKiB4XyApOyAgICAvLyBtb2QoaixOKVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCB5ID0geV8gKm5zLnggKyBucy55eXl5O1xcblwiICtcblwiICAgICAgICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjNCBiMCA9IHZlYzQoIHgueHksIHkueHkgKTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvL3ZlYzQgczAgPSB2ZWM0KGxlc3NUaGFuKGIwLDAuMCkpKjIuMCAtIDEuMDtcXG5cIiArXG5cIiAgICAgICAgLy92ZWM0IHMxID0gdmVjNChsZXNzVGhhbihiMSwwLjApKSoyLjAgLSAxLjA7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xcblwiICtcblwiICAgICAgICB2ZWM0IHMxID0gZmxvb3IoYjEpKjIuMCArIDEuMDtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBzaCA9IC1zdGVwKGgsIHZlYzQoMC4wKSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXkgO1xcblwiICtcblwiICAgICAgICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjMyBwMCA9IHZlYzMoYTAueHksaC54KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBwMyA9IHZlYzMoYTEuencsaC53KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvL05vcm1hbGlzZSBncmFkaWVudHNcXG5cIiArXG5cIiAgICAgICAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XFxuXCIgK1xuXCIgICAgICAgIHAwICo9IG5vcm0ueDtcXG5cIiArXG5cIiAgICAgICAgcDEgKj0gbm9ybS55O1xcblwiICtcblwiICAgICAgICBwMiAqPSBub3JtLno7XFxuXCIgK1xuXCIgICAgICAgIHAzICo9IG5vcm0udztcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcXG5cIiArXG5cIiAgICAgICAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XFxuXCIgK1xuXCIgICAgICAgIG0gPSBtICogbTtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSwgZG90KHAyLHgyKSwgZG90KHAzLHgzKSApICk7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ2xhc3NpYyBQZXJsaW4gbm9pc2VcXG5cIiArXG5cIiAgICBmbG9hdCBjbm9pc2UodmVjMyBQKSB7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgUGkwID0gZmxvb3IoUCk7IC8vIEludGVnZXIgcGFydCBmb3IgaW5kZXhpbmdcXG5cIiArXG5cIiAgICAgICAgdmVjMyBQaTEgPSBQaTAgKyB2ZWMzKDEuMCk7IC8vIEludGVnZXIgcGFydCArIDFcXG5cIiArXG5cIiAgICAgICAgUGkwID0gbW9kMjg5KFBpMCk7XFxuXCIgK1xuXCIgICAgICAgIFBpMSA9IG1vZDI4OShQaTEpO1xcblwiICtcblwiICAgICAgICB2ZWMzIFBmMCA9IGZyYWN0KFApOyAvLyBGcmFjdGlvbmFsIHBhcnQgZm9yIGludGVycG9sYXRpb25cXG5cIiArXG5cIiAgICAgICAgdmVjMyBQZjEgPSBQZjAgLSB2ZWMzKDEuMCk7IC8vIEZyYWN0aW9uYWwgcGFydCAtIDEuMFxcblwiICtcblwiICAgICAgICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgaXkgPSB2ZWM0KFBpMC55eSwgUGkxLnl5KTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBpejAgPSBQaTAuenp6ejtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICB2ZWM0IGl4eSA9IHBlcm11dGUocGVybXV0ZShpeCkgKyBpeSk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgaXh5MCA9IHBlcm11dGUoaXh5ICsgaXowKTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBpeHkxID0gcGVybXV0ZShpeHkgKyBpejEpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZ3gwID0gaXh5MCAqICgxLjAgLyA3LjApO1xcblwiICtcblwiICAgICAgICB2ZWM0IGd5MCA9IGZyYWN0KGZsb29yKGd4MCkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XFxuXCIgK1xuXCIgICAgICAgIGd4MCA9IGZyYWN0KGd4MCk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZ3owID0gdmVjNCgwLjUpIC0gYWJzKGd4MCkgLSBhYnMoZ3kwKTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBzejAgPSBzdGVwKGd6MCwgdmVjNCgwLjApKTtcXG5cIiArXG5cIiAgICAgICAgZ3gwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3gwKSAtIDAuNSk7XFxuXCIgK1xuXCIgICAgICAgIGd5MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd5MCkgLSAwLjUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZ3gxID0gaXh5MSAqICgxLjAgLyA3LjApO1xcblwiICtcblwiICAgICAgICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XFxuXCIgK1xuXCIgICAgICAgIGd4MSA9IGZyYWN0KGd4MSk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBzejEgPSBzdGVwKGd6MSwgdmVjNCgwLjApKTtcXG5cIiArXG5cIiAgICAgICAgZ3gxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3gxKSAtIDAuNSk7XFxuXCIgK1xuXCIgICAgICAgIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzMgZzAwMCA9IHZlYzMoZ3gwLngsZ3kwLngsZ3owLngpO1xcblwiICtcblwiICAgICAgICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LGd5MC55LGd6MC55KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBnMDEwID0gdmVjMyhneDAueixneTAueixnejAueik7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgZzExMCA9IHZlYzMoZ3gwLncsZ3kwLncsZ3owLncpO1xcblwiICtcblwiICAgICAgICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LGd5MS54LGd6MS54KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBnMTAxID0gdmVjMyhneDEueSxneTEueSxnejEueSk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgZzAxMSA9IHZlYzMoZ3gxLnosZ3kxLnosZ3oxLnopO1xcblwiICtcblwiICAgICAgICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LGd5MS53LGd6MS53KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICB2ZWM0IG5vcm0wID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAwLCBnMDAwKSwgZG90KGcwMTAsIGcwMTApLCBkb3QoZzEwMCwgZzEwMCksIGRvdChnMTEwLCBnMTEwKSkpO1xcblwiICtcblwiICAgICAgICBnMDAwICo9IG5vcm0wLng7XFxuXCIgK1xuXCIgICAgICAgIGcwMTAgKj0gbm9ybTAueTtcXG5cIiArXG5cIiAgICAgICAgZzEwMCAqPSBub3JtMC56O1xcblwiICtcblwiICAgICAgICBnMTEwICo9IG5vcm0wLnc7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgbm9ybTEgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDEsIGcwMDEpLCBkb3QoZzAxMSwgZzAxMSksIGRvdChnMTAxLCBnMTAxKSwgZG90KGcxMTEsIGcxMTEpKSk7XFxuXCIgK1xuXCIgICAgICAgIGcwMDEgKj0gbm9ybTEueDtcXG5cIiArXG5cIiAgICAgICAgZzAxMSAqPSBub3JtMS55O1xcblwiICtcblwiICAgICAgICBnMTAxICo9IG5vcm0xLno7XFxuXCIgK1xuXCIgICAgICAgIGcxMTEgKj0gbm9ybTEudztcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICBmbG9hdCBuMDAwID0gZG90KGcwMDAsIFBmMCk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4xMDAgPSBkb3QoZzEwMCwgdmVjMyhQZjEueCwgUGYwLnl6KSk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4wMTAgPSBkb3QoZzAxMCwgdmVjMyhQZjAueCwgUGYxLnksIFBmMC56KSk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4xMTAgPSBkb3QoZzExMCwgdmVjMyhQZjEueHksIFBmMC56KSk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4wMDEgPSBkb3QoZzAwMSwgdmVjMyhQZjAueHksIFBmMS56KSk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4xMDEgPSBkb3QoZzEwMSwgdmVjMyhQZjEueCwgUGYwLnksIFBmMS56KSk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4wMTEgPSBkb3QoZzAxMSwgdmVjMyhQZjAueCwgUGYxLnl6KSk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4xMTEgPSBkb3QoZzExMSwgUGYxKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICB2ZWMzIGZhZGVfeHl6ID0gZmFkZShQZjApO1xcblwiICtcblwiICAgICAgICB2ZWM0IG5feiA9IG1peCh2ZWM0KG4wMDAsIG4xMDAsIG4wMTAsIG4xMTApLCB2ZWM0KG4wMDEsIG4xMDEsIG4wMTEsIG4xMTEpLCBmYWRlX3h5ei56KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMiBuX3l6ID0gbWl4KG5fei54eSwgbl96Lnp3LCBmYWRlX3h5ei55KTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbl94eXogPSBtaXgobl95ei54LCBuX3l6LnksIGZhZGVfeHl6LngpO1xcblwiICtcblwiICAgICAgICByZXR1cm4gMi4yICogbl94eXo7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ2xhc3NpYyBQZXJsaW4gbm9pc2UsIHBlcmlvZGljIHZhcmlhbnRcXG5cIiArXG5cIiAgICBmbG9hdCBwbm9pc2UodmVjMyBQLCB2ZWMzIHJlcCkge1xcblwiICtcblwiICAgICAgICB2ZWMzIFBpMCA9IG1vZChmbG9vcihQKSwgcmVwKTsgLy8gSW50ZWdlciBwYXJ0LCBtb2R1bG8gcGVyaW9kXFxuXCIgK1xuXCIgICAgICAgIHZlYzMgUGkxID0gbW9kKFBpMCArIHZlYzMoMS4wKSwgcmVwKTsgLy8gSW50ZWdlciBwYXJ0ICsgMSwgbW9kIHBlcmlvZFxcblwiICtcblwiICAgICAgICBQaTAgPSBtb2QyODkoUGkwKTtcXG5cIiArXG5cIiAgICAgICAgUGkxID0gbW9kMjg5KFBpMSk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgUGYwID0gZnJhY3QoUCk7IC8vIEZyYWN0aW9uYWwgcGFydCBmb3IgaW50ZXJwb2xhdGlvblxcblwiICtcblwiICAgICAgICB2ZWMzIFBmMSA9IFBmMCAtIHZlYzMoMS4wKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IC0gMS4wXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgaXggPSB2ZWM0KFBpMC54LCBQaTEueCwgUGkwLngsIFBpMS54KTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBpeSA9IHZlYzQoUGkwLnl5LCBQaTEueXkpO1xcblwiICtcblwiICAgICAgICB2ZWM0IGl6MCA9IFBpMC56enp6O1xcblwiICtcblwiICAgICAgICB2ZWM0IGl6MSA9IFBpMS56enp6O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgaXh5ID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBpeHkwID0gcGVybXV0ZShpeHkgKyBpejApO1xcblwiICtcblwiICAgICAgICB2ZWM0IGl4eTEgPSBwZXJtdXRlKGl4eSArIGl6MSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjNCBneDAgPSBpeHkwICogKDEuMCAvIDcuMCk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcXG5cIiArXG5cIiAgICAgICAgZ3gwID0gZnJhY3QoZ3gwKTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBnejAgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xcblwiICtcblwiICAgICAgICB2ZWM0IHN6MCA9IHN0ZXAoZ3owLCB2ZWM0KDAuMCkpO1xcblwiICtcblwiICAgICAgICBneDAgLT0gc3owICogKHN0ZXAoMC4wLCBneDApIC0gMC41KTtcXG5cIiArXG5cIiAgICAgICAgZ3kwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3kwKSAtIDAuNSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjNCBneDEgPSBpeHkxICogKDEuMCAvIDcuMCk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZ3kxID0gZnJhY3QoZmxvb3IoZ3gxKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcXG5cIiArXG5cIiAgICAgICAgZ3gxID0gZnJhY3QoZ3gxKTtcXG5cIiArXG5cIiAgICAgICAgdmVjNCBnejEgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gxKSAtIGFicyhneTEpO1xcblwiICtcblwiICAgICAgICB2ZWM0IHN6MSA9IHN0ZXAoZ3oxLCB2ZWM0KDAuMCkpO1xcblwiICtcblwiICAgICAgICBneDEgLT0gc3oxICogKHN0ZXAoMC4wLCBneDEpIC0gMC41KTtcXG5cIiArXG5cIiAgICAgICAgZ3kxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3kxKSAtIDAuNSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjMyBnMDAwID0gdmVjMyhneDAueCxneTAueCxnejAueCk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgZzEwMCA9IHZlYzMoZ3gwLnksZ3kwLnksZ3owLnkpO1xcblwiICtcblwiICAgICAgICB2ZWMzIGcwMTAgPSB2ZWMzKGd4MC56LGd5MC56LGd6MC56KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBnMTEwID0gdmVjMyhneDAudyxneTAudyxnejAudyk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgZzAwMSA9IHZlYzMoZ3gxLngsZ3kxLngsZ3oxLngpO1xcblwiICtcblwiICAgICAgICB2ZWMzIGcxMDEgPSB2ZWMzKGd4MS55LGd5MS55LGd6MS55KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBnMDExID0gdmVjMyhneDEueixneTEueixnejEueik7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgZzExMSA9IHZlYzMoZ3gxLncsZ3kxLncsZ3oxLncpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgbm9ybTAgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDAsIGcwMDApLCBkb3QoZzAxMCwgZzAxMCksIGRvdChnMTAwLCBnMTAwKSwgZG90KGcxMTAsIGcxMTApKSk7XFxuXCIgK1xuXCIgICAgICAgIGcwMDAgKj0gbm9ybTAueDtcXG5cIiArXG5cIiAgICAgICAgZzAxMCAqPSBub3JtMC55O1xcblwiICtcblwiICAgICAgICBnMTAwICo9IG5vcm0wLno7XFxuXCIgK1xuXCIgICAgICAgIGcxMTAgKj0gbm9ybTAudztcXG5cIiArXG5cIiAgICAgICAgdmVjNCBub3JtMSA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMSwgZzAwMSksIGRvdChnMDExLCBnMDExKSwgZG90KGcxMDEsIGcxMDEpLCBkb3QoZzExMSwgZzExMSkpKTtcXG5cIiArXG5cIiAgICAgICAgZzAwMSAqPSBub3JtMS54O1xcblwiICtcblwiICAgICAgICBnMDExICo9IG5vcm0xLnk7XFxuXCIgK1xuXCIgICAgICAgIGcxMDEgKj0gbm9ybTEuejtcXG5cIiArXG5cIiAgICAgICAgZzExMSAqPSBub3JtMS53O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG4wMDAgPSBkb3QoZzAwMCwgUGYwKTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbjEwMCA9IGRvdChnMTAwLCB2ZWMzKFBmMS54LCBQZjAueXopKTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbjAxMCA9IGRvdChnMDEwLCB2ZWMzKFBmMC54LCBQZjEueSwgUGYwLnopKTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbjExMCA9IGRvdChnMTEwLCB2ZWMzKFBmMS54eSwgUGYwLnopKTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbjAwMSA9IGRvdChnMDAxLCB2ZWMzKFBmMC54eSwgUGYxLnopKTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbjEwMSA9IGRvdChnMTAxLCB2ZWMzKFBmMS54LCBQZjAueSwgUGYxLnopKTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbjAxMSA9IGRvdChnMDExLCB2ZWMzKFBmMC54LCBQZjEueXopKTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbjExMSA9IGRvdChnMTExLCBQZjEpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZlYzMgZmFkZV94eXogPSBmYWRlKFBmMCk7XFxuXCIgK1xuXCIgICAgICAgIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcblwiICtcblwiICAgICAgICB2ZWMyIG5feXogPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xcblwiICtcblwiICAgICAgICBmbG9hdCBuX3h5eiA9IG1peChuX3l6LngsIG5feXoueSwgZmFkZV94eXoueCk7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybiAyLjIgKiBuX3h5ejtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChFRkZFQ1RfU1BPVExJR0hUKVxcblwiICtcblwiICAgIC8vIFNwb3RsaWdodCBlZmZlY3RcXG5cIiArXG5cIiAgICAgICAgdmVjMiBwb3NpdGlvbiA9IGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb24ueHk7ICAgIC8vIHNjYWxlIGNvb3JkcyB0byBbMC4wLCAxLjBdXFxuXCIgK1xuXCIgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKiAyLjAgLSAxLjA7ICAgICAgICAgICAgICAgICAgICAvLyBzY2FsZSBjb29yZHMgdG8gWy0xLjAsIDEuMF1cXG5cIiArXG5cIiAgICAgICAgcG9zaXRpb24ueSAqPSByZXNvbHV0aW9uLnkgLyByZXNvbHV0aW9uLng7ICAgICAgICAgIC8vIGNvcnJlY3QgYXNwZWN0IHJhdGlvXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgdmVjMyBjb2xvciA9IGZjb2xvciAqIG1heCgxLjAgLSBkaXN0YW5jZShwb3NpdGlvbiwgdmVjMigwLjAsIDAuMCkpLCAwLjIpO1xcblwiICtcblwiICAgICAgICAvLyB2ZWMzIGNvbG9yID0gZmNvbG9yICogKDEuMCAtIGRvdChub3JtYWxpemUodmVjMyhyYW5kKGdsX0ZyYWdDb29yZC54eSAqIDAuMDEpICogMTAuMCwgMC4wLCAtMS4wKSksIHZlYzMoMCwgMCwgMS4wKSkpO1xcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIHZlYzMgY29sb3IgPSBmY29sb3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChFRkZFQ1RfQ09MT1JfQkxFRUQpXFxuXCIgK1xuXCIgICAgICAgIC8vIE11dGF0ZSBjb2xvcnMgYnkgc2NyZWVuIHBvc2l0aW9uIG9yIHRpbWVcXG5cIiArXG5cIiAgICAgICAgY29sb3IgKz0gdmVjMyhnbF9GcmFnQ29vcmQueCAvIHJlc29sdXRpb24ueCwgMC4wLCBnbF9GcmFnQ29vcmQueSAvIHJlc29sdXRpb24ueSk7XFxuXCIgK1xuXCIgICAgICAgIGNvbG9yLnIgKz0gc2luKHRpbWUgLyAzLjApO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTXV0YXRlIGNvbG9yIGJ5IDNkIG5vaXNlXFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQgKEVGRkVDVF9OT0lTRV9URVhUVVJFKVxcblwiICtcblwiICAgICAgICAjaWYgZGVmaW5lZChFRkZFQ1RfTk9JU0VfQU5JTUFUQUJMRSkgJiYgZGVmaW5lZChFRkZFQ1RfTk9JU0VfQU5JTUFURUQpXFxuXCIgK1xuXCIgICAgICAgICAgICBjb2xvciAqPSAoYWJzKGNub2lzZSgoZnBvc2l0aW9uICsgdmVjMyh0aW1lICogNS4sIHRpbWUgKiA3LjUsIHRpbWUgKiAxMC4pKSAvIDEwLjApKSAvIDQuMCkgKyAwLjc1O1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2lmbmRlZiBFRkZFQ1RfTk9JU0VfQU5JTUFUQUJMRVxcblwiICtcblwiICAgICAgICAgICAgY29sb3IgKj0gKGFicyhjbm9pc2UoZnBvc2l0aW9uIC8gMTAuMCkpIC8gNC4wKSArIDAuNzU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG5cIiArXG5cIiAgICAvLyBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyX3NvdXJjZXNbJ3BvbHlnb25fdmVydGV4J10gPVxuXCIvLyAjZGVmaW5lIFBST0pFQ1RJT05fUEVSU1BFQ1RJVkVcXG5cIiArXG5cIi8vICNkZWZpbmUgUFJPSkVDVElPTl9JU09NRVRSSUNcXG5cIiArXG5cIi8vICNkZWZpbmUgUFJPSkVDVElPTl9QT1BVUFxcblwiICtcblwiXFxuXCIgK1xuXCIvLyAjZGVmaW5lIExJR0hUSU5HX1BPSU5UXFxuXCIgK1xuXCIvLyAjZGVmaW5lIExJR0hUSU5HX0RJUkVDVElPTlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyAjZGVmaW5lIEFOSU1BVElPTl9FTEVWQVRPUlxcblwiICtcblwiLy8gI2RlZmluZSBBTklNQVRJT05fV0FWRVxcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMiBtYXBfY2VudGVyO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCBtYXBfem9vbTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMiBtZXRlcl96b29tO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHRpbGVfbWluO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHRpbGVfbWF4O1xcblwiICtcblwidW5pZm9ybSBmbG9hdCBudW1fbGF5ZXJzO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB0aW1lO1xcblwiICtcblwiXFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcblwiICtcblwiYXR0cmlidXRlIGZsb2F0IGxheWVyO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzMgZmNvbG9yO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChFRkZFQ1RfTk9JU0VfVEVYVFVSRSlcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzMgZnBvc2l0aW9uO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cInZlYzMgbGlnaHQgPSBub3JtYWxpemUodmVjMygwLjIsIDAuNywgLTAuNSkpOyAvLyB2ZWMzKDAuMSwgMC4yLCAtMC40KVxcblwiICtcblwiY29uc3QgZmxvYXQgYW1iaWVudCA9IDAuNDU7XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIFByb2plY3QgbGF0LWxuZyB0byBtZXJjYXRvclxcblwiICtcblwiLy8gdmVjMiBsYXRMbmdUb01ldGVycyAodmVjMiBjb29yZGluYXRlKSB7XFxuXCIgK1xuXCIvLyAgICAgY29uc3QgZmxvYXQgcGkgPSAzLjE0MTU5MjY7XFxuXCIgK1xuXCIvLyAgICAgY29uc3QgZmxvYXQgaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyA9IDIwMDM3NTA4LjM0Mjc4OTI0NDtcXG5cIiArXG5cIi8vICAgICB2ZWMyIHByb2plY3RlZDtcXG5cIiArXG5cIlxcblwiICtcblwiLy8gICAgIC8vIExhdGl0dWRlXFxuXCIgK1xuXCIvLyAgICAgcHJvamVjdGVkLnkgPSBsb2codGFuKChjb29yZGluYXRlLnkgKyA5MC4wKSAqIHBpIC8gMzYwLjApKSAvIChwaSAvIDE4MC4wKTtcXG5cIiArXG5cIi8vICAgICBwcm9qZWN0ZWQueSA9IHByb2plY3RlZC55ICogaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAvIDE4MC4wO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyAgICAgLy8gTG9uZ2l0dWRlXFxuXCIgK1xuXCIvLyAgICAgcHJvamVjdGVkLnggPSBjb29yZGluYXRlLnggKiBoYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gMTgwLjA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vICAgICByZXR1cm4gcHJvamVjdGVkO1xcblwiICtcblwiLy8gfVxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuXCIgICAgdmVjMyB2cG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIiAgICB2ZWMzIHZub3JtYWwgPSBub3JtYWw7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDYWxjIHBvc2l0aW9uIG9mIHZlcnRleCBpbiBtZXRlcnMsIHJlbGF0aXZlIHRvIGNlbnRlciBvZiBzY3JlZW5cXG5cIiArXG5cIiAgICB2cG9zaXRpb24ueSAqPSAtMS4wOyAvLyBhZGp1c3QgZm9yIGZsaXBwZWQgeS1jb29yZHNcXG5cIiArXG5cIiAgICAvLyB2cG9zaXRpb24ueSArPSBUSUxFX1NDQUxFOyAvLyBhbHRlcm5hdGUsIHRvIGFsc28gYWRqdXN0IGZvciBmb3JjZS1wb3NpdGl2ZSB5IGNvb3JkcyBpbiB0aWxlXFxuXCIgK1xuXCIgICAgdnBvc2l0aW9uLnh5ICo9ICh0aWxlX21heCAtIHRpbGVfbWluKSAvIFRJTEVfU0NBTEU7IC8vIGFkanVzdCBmb3IgdmVydGV4IGxvY2F0aW9uIHdpdGhpbiB0aWxlIChzY2FsZWQgZnJvbSBsb2NhbCBjb29yZHMgdG8gbWV0ZXJzKVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gVmVydGV4IGRpc3BsYWNlbWVudCArIHByb2NlZHVyYWwgZWZmZWN0c1xcblwiICtcblwiICAgICNpZiBkZWZpbmVkKEFOSU1BVElPTl9FTEVWQVRPUikgfHwgZGVmaW5lZChBTklNQVRJT05fV0FWRSkgfHwgZGVmaW5lZChFRkZFQ1RfTk9JU0VfVEVYVFVSRSlcXG5cIiArXG5cIiAgICAgICAgdmVjMyB2cG9zaXRpb25fd29ybGQgPSB2cG9zaXRpb24gKyB2ZWMzKHRpbGVfbWluLCAwLik7IC8vIG5lZWQgdmVydGV4IGluIHdvcmxkIGNvb3JkcyAoYmVmb3JlIG1hcCBjZW50ZXIgdHJhbnNmb3JtKSwgaGFjayB0byBnZXQgYXJvdW5kIHByZWNpc2lvbiBpc3N1ZXMgKHNlZSBiZWxvdylcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWYgZGVmaW5lZChFRkZFQ1RfTk9JU0VfVEVYVFVSRSlcXG5cIiArXG5cIiAgICAgICAgICAgIGZwb3NpdGlvbiA9IHZwb3NpdGlvbl93b3JsZDtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgaWYgKHZwb3NpdGlvbl93b3JsZC56ID4gMS4wKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICAvLyB2cG9zaXRpb24ueCArPSBzaW4odnBvc2l0aW9uX3dvcmxkLnogKyB0aW1lKSAqIDEwLjAgKiBzaW4ocG9zaXRpb24ueCk7IC8vIHN3YXlpbmcgYnVpbGRpbmdzXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyB2cG9zaXRpb24ueSArPSBjb3ModnBvc2l0aW9uX3dvcmxkLnogKyB0aW1lKSAqIDEwLjA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgICAgICNpZiBkZWZpbmVkKEFOSU1BVElPTl9FTEVWQVRPUilcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyB2cG9zaXRpb24ueiAqPSAoc2luKHZwb3NpdGlvbl93b3JsZC56IC8gMjUuMCAqIHRpbWUpICsgMS4wKSAvIDIuMCArIDAuMTsgLy8gZXZlbGF0b3IgYnVpbGRpbmdzXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgdnBvc2l0aW9uLnogKj0gbWF4KChzaW4odnBvc2l0aW9uX3dvcmxkLnogKyB0aW1lKSArIDEuMCkgLyAyLjAsIDAuMDUpOyAvLyBldmVsYXRvciBidWlsZGluZ3NcXG5cIiArXG5cIiAgICAgICAgICAgICNlbGlmIGRlZmluZWQoQU5JTUFUSU9OX1dBVkUpXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgdnBvc2l0aW9uLnogKj0gbWF4KChzaW4odnBvc2l0aW9uX3dvcmxkLnggLyAxMDAuMCArIHRpbWUpICsgMS4wKSAvIDIuMCwgMC4wNSk7IC8vIHdhdmVcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBOT1RFOiBkdWUgdG8gdW5yZXNvbHZlZCBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gaXNzdWVzLCB0aWxlIGFuZCBtYXAgY2VudGVyIGFkanVzdG1lbnQgbmVlZCB0byBoYXBwZW4gaW4gT05FIG9wZXJhdGlvbiwgb3IgYXJ0aWZjYXRzIGFyZSBpbnRyb2R1Y2VkXFxuXCIgK1xuXCIgICAgdnBvc2l0aW9uLnh5ICs9IHRpbGVfbWluLnh5IC0gbWFwX2NlbnRlcjsgLy8gYWRqdXN0IGZvciBjb3JuZXIgb2YgdGlsZSByZWxhdGl2ZSB0byBtYXAgY2VudGVyXFxuXCIgK1xuXCIgICAgdnBvc2l0aW9uLnh5IC89IG1ldGVyX3pvb207IC8vIGFkanVzdCBmb3Igem9vbSBpbiBtZXRlcnMgdG8gZ2V0IGNsaXAgc3BhY2UgY29vcmRzXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTaGFkaW5nXFxuXCIgK1xuXCIgICAgZmNvbG9yID0gY29sb3I7XFxuXCIgK1xuXCIgICAgLy8gZmNvbG9yICs9IHZlYzMoc2luKHBvc2l0aW9uLnogKyB0aW1lKSwgMC4wLCAwLjApOyAvLyBjb2xvciBjaGFuZ2Ugb24gaGVpZ2h0ICsgdGltZVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoTElHSFRJTkdfUE9JTlQpIHx8IGRlZmluZWQoTElHSFRJTkdfTklHSFQpXFxuXCIgK1xuXCIgICAgICAgIC8vIEdvdXJhdWQgc2hhZGluZ1xcblwiICtcblwiICAgICAgICBsaWdodCA9IHZlYzMoLTAuMjUsIC0wLjI1LCAwLjUwKTsgLy8gdmVjMygwLjEsIDAuMSwgMC4zNSk7IC8vIHBvaW50IGxpZ2h0IGxvY2F0aW9uXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmIGRlZmluZWQoTElHSFRJTkdfTklHSFQpXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBcXFwiTmlnaHRcXFwiIGVmZmVjdCBieSBmbGlwcGluZyB2ZXJ0ZXggelxcblwiICtcblwiICAgICAgICAgICAgbGlnaHQgPSBub3JtYWxpemUodmVjMyh2cG9zaXRpb24ueCwgdnBvc2l0aW9uLnksIHZwb3NpdGlvbi56KSAtIGxpZ2h0KTsgLy8gbGlnaHQgYW5nbGUgZnJvbSBsaWdodCBwb2ludCB0byB2ZXJ0ZXhcXG5cIiArXG5cIiAgICAgICAgICAgIGZjb2xvciAqPSBkb3Qodm5vcm1hbCwgbGlnaHQgKiAtMS4wKTsgLy8gKyBhbWJpZW50ICsgY2xhbXAodnBvc2l0aW9uLnogKiAyLjAgLyBtZXRlcl96b29tLngsIDAuMCwgMC4yNSk7XFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBQb2ludCBsaWdodC1iYXNlZCBncmFkaWVudFxcblwiICtcblwiICAgICAgICAgICAgbGlnaHQgPSBub3JtYWxpemUodmVjMyh2cG9zaXRpb24ueCwgdnBvc2l0aW9uLnksIC12cG9zaXRpb24ueikgLSBsaWdodCk7IC8vIGxpZ2h0IGFuZ2xlIGZyb20gbGlnaHQgcG9pbnQgdG8gdmVydGV4XFxuXCIgK1xuXCIgICAgICAgICAgICBmY29sb3IgKj0gZG90KHZub3JtYWwsIGxpZ2h0ICogLTEuMCkgKyBhbWJpZW50ICsgY2xhbXAodnBvc2l0aW9uLnogKiAyLjAgLyBtZXRlcl96b29tLngsIDAuMCwgMC4yNSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2VsaWYgZGVmaW5lZChMSUdIVElOR19ESVJFQ1RJT04pXFxuXCIgK1xuXCIgICAgICAgIC8vIEZsYXQgc2hhZGluZ1xcblwiICtcblwiICAgICAgICBsaWdodCA9IG5vcm1hbGl6ZSh2ZWMzKDAuMiwgMC43LCAtMC41KSk7XFxuXCIgK1xuXCIgICAgICAgIC8vIGxpZ2h0ID0gbm9ybWFsaXplKHZlYzMoLTEuLCAwLjcsIC0uMCkpO1xcblwiICtcblwiICAgICAgICAvLyBsaWdodCA9IG5vcm1hbGl6ZSh2ZWMzKC0xLiwgMC43LCAtLjc1KSk7XFxuXCIgK1xuXCIgICAgICAgIC8vIGZjb2xvciAqPSBtYXgoZG90KHZub3JtYWwsIGxpZ2h0ICogLTEuMCksIDAuMSkgKyBhbWJpZW50O1xcblwiICtcblwiICAgICAgICBmY29sb3IgKj0gZG90KHZub3JtYWwsIGxpZ2h0ICogLTEuMCkgKyBhbWJpZW50O1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoUFJPSkVDVElPTl9QRVJTUEVDVElWRSlcXG5cIiArXG5cIiAgICAgICAgLy8gUGVyc3BlY3RpdmUtc3R5bGUgcHJvamVjdGlvblxcblwiICtcblwiICAgICAgICB2ZWMyIHBlcnNwZWN0aXZlX29mZnNldCA9IHZlYzIoLTAuMjUsIC0wLjI1KTtcXG5cIiArXG5cIiAgICAgICAgdmVjMiBwZXJzcGVjdGl2ZV9mYWN0b3IgPSB2ZWMyKDAuOCwgMC44KTsgLy8gdmVjMigtMC4yNSwgMC43NSk7XFxuXCIgK1xuXCIgICAgICAgIHZwb3NpdGlvbi54eSArPSB2cG9zaXRpb24ueiAqIHBlcnNwZWN0aXZlX2ZhY3RvciAqICh2cG9zaXRpb24ueHkgLSBwZXJzcGVjdGl2ZV9vZmZzZXQpIC8gbWV0ZXJfem9vbS54eTsgLy8gcGVyc3BlY3RpdmUgZnJvbSBvZmZzZXQgY2VudGVyIHNjcmVlblxcblwiICtcblwiICAgICNlbGlmIGRlZmluZWQoUFJPSkVDVElPTl9JU09NRVRSSUMpIHx8IGRlZmluZWQoUFJPSkVDVElPTl9QT1BVUClcXG5cIiArXG5cIiAgICAgICAgLy8gUG9wLXVwIGVmZmVjdCAtIDNkIGluIGNlbnRlciBvZiB2aWV3cG9ydCwgZmFkaW5nIHRvIDJkIGF0IGVkZ2VzXFxuXCIgK1xuXCIgICAgICAgICNpZiBkZWZpbmVkKFBST0pFQ1RJT05fUE9QVVApXFxuXCIgK1xuXCIgICAgICAgICAgICBpZiAodnBvc2l0aW9uLnogPiAxLjApIHtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBjZCA9IGRpc3RhbmNlKHZwb3NpdGlvbi54eSAqIChyZXNvbHV0aW9uLnh5IC8gcmVzb2x1dGlvbi55eSksIHZlYzIoMC4wLCAwLjApKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBwb3B1cF9mYWRlX2lubmVyID0gMC41O1xcblwiICtcblwiICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IHBvcHVwX2ZhZGVfb3V0ZXIgPSAwLjc1O1xcblwiICtcblwiICAgICAgICAgICAgICAgIGlmIChjZCA+IHBvcHVwX2ZhZGVfaW5uZXIpIHtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAgICAgdnBvc2l0aW9uLnogKj0gMS4wIC0gc21vb3Roc3RlcChwb3B1cF9mYWRlX2lubmVyLCBwb3B1cF9mYWRlX291dGVyLCBjZCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgfVxcblwiICtcblwiICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IHpvb21fYm9vc3Rfc3RhcnQgPSAxNS4wO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IHpvb21fYm9vc3RfZW5kID0gMTcuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCB6b29tX2Jvb3N0X21hZ25pdHVkZSA9IDAuNzU7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgdnBvc2l0aW9uLnogKj0gMS4wICsgKDEuMCAtIHNtb290aHN0ZXAoem9vbV9ib29zdF9zdGFydCwgem9vbV9ib29zdF9lbmQsIG1hcF96b29tKSkgKiB6b29tX2Jvb3N0X21hZ25pdHVkZTtcXG5cIiArXG5cIiAgICAgICAgICAgIH1cXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gSXNvbWV0cmljLXN0eWxlIHByb2plY3Rpb25cXG5cIiArXG5cIiAgICAgICAgdnBvc2l0aW9uLnkgKz0gdnBvc2l0aW9uLnogLyBtZXRlcl96b29tLnk7IC8vIHogY29vcmRpbmF0ZSBpcyBhIHNpbXBsZSB0cmFuc2xhdGlvbiB1cCBhbG9uZyB5IGF4aXMsIGFsYSBpc29tZXRyaWNcXG5cIiArXG5cIiAgICAgICAgLy8gdnBvc2l0aW9uLnkgKz0gdnBvc2l0aW9uLnogKiAwLjU7IC8vIGNsb3NlciB0byBVbHRpbWEgNy1zdHlsZSBheG9ub21ldHJpY1xcblwiICtcblwiICAgICAgICAvLyB2cG9zaXRpb24ueCAtPSB2cG9zaXRpb24ueiAqIDAuNTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFJvdGF0aW9uIHRlc3RcXG5cIiArXG5cIiAgICAvLyBmbG9hdCB0aGV0YSA9IDA7XFxuXCIgK1xuXCIgICAgLy8gY29uc3QgZmxvYXQgcGkgPSAzLjE0MTU5MjY7XFxuXCIgK1xuXCIgICAgLy8gdmVjMiBwcjtcXG5cIiArXG5cIiAgICAvLyBwci54ID0gdnBvc2l0aW9uLnggKiBjb3ModGhldGEgKiBwaSAvIDE4MC4wKSArIHZwb3NpdGlvbi55ICogLXNpbih0aGV0YSAqIHBpIC8gMTgwLjApO1xcblwiICtcblwiICAgIC8vIHByLnkgPSB2cG9zaXRpb24ueCAqIHNpbih0aGV0YSAqIHBpIC8gMTgwLjApICsgdnBvc2l0aW9uLnkgKiBjb3ModGhldGEgKiBwaSAvIDE4MC4wKTtcXG5cIiArXG5cIiAgICAvLyB2cG9zaXRpb24ueHkgPSBwcjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIHZwb3NpdGlvbi55ICo9IG1heChhYnMoc2luKHZwb3NpdGlvbi54KSksIDAuMSk7IC8vIGhvdXJnbGFzcyBlZmZlY3RcXG5cIiArXG5cIiAgICAvLyB2cG9zaXRpb24ueSAqPSBhYnMobWF4KHNpbih2cG9zaXRpb24ueCksIDAuMSkpOyAvLyBmdW5uZWwgZWZmZWN0XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBSZXZlcnNlIGFuZCBzY2FsZSB0byAwLTEgZm9yIEdMIGRlcHRoIGJ1ZmZlclxcblwiICtcblwiICAgIC8vIExheWVycyBhcmUgZm9yY2Utb3JkZXJlZCAoaGlnaGVyIGxheWVycyBndWFyYW50ZWVkIHRvIHJlbmRlciBvbiB0b3Agb2YgbG93ZXIpLCB0aGVuIGJ5IGhlaWdodC9kZXB0aFxcblwiICtcblwiICAgIGZsb2F0IHpfbGF5ZXJfc2NhbGUgPSA0MDk2LjtcXG5cIiArXG5cIiAgICBmbG9hdCB6X2xheWVyX3JhbmdlID0gKG51bV9sYXllcnMgKyAxLikgKiB6X2xheWVyX3NjYWxlO1xcblwiICtcblwiICAgIGZsb2F0IHpfbGF5ZXIgPSAobGF5ZXIgKyAxLikgKiB6X2xheWVyX3NjYWxlO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdnBvc2l0aW9uLnogPSB6X2xheWVyICsgY2xhbXAodnBvc2l0aW9uLnosIDEuLCB6X2xheWVyX3NjYWxlKTtcXG5cIiArXG5cIiAgICB2cG9zaXRpb24ueiA9ICh6X2xheWVyX3JhbmdlIC0gdnBvc2l0aW9uLnopIC8gel9sYXllcl9yYW5nZTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2cG9zaXRpb24sIDEuMCk7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuaWYgKG1vZHVsZS5leHBvcnRzICE9PSB1bmRlZmluZWQpIHsgbW9kdWxlLmV4cG9ydHMgPSBzaGFkZXJfc291cmNlczsgfVxuXG4iLCIvKioqIFN0eWxlIGhlbHBlcnMgKioqL1xuXG52YXIgU3R5bGUgPSB7fTtcblxuU3R5bGUuY29sb3IgPSB7XG4gICAgcHNldWRvUmFuZG9tR3JheXNjYWxlOiBmdW5jdGlvbiAoZikgeyB2YXIgYyA9IE1hdGgubWF4KChwYXJzZUludChmLmlkLCAxNikgJSAxMDApIC8gMTAwLCAwLjQpOyByZXR1cm4gWzAuNyAqIGMsIDAuNyAqIGMsIDAuNyAqIGNdOyB9LCAvLyBwc2V1ZG8tcmFuZG9tIGdyYXlzY2FsZSBieSBnZW9tZXRyeSBpZFxuICAgIHBzZXVkb1JhbmRvbUNvbG9yOiBmdW5jdGlvbiAoZikgeyByZXR1cm4gWzAuNyAqIChwYXJzZUludChmLmlkLCAxNikgLyAxMDAgJSAxKSwgMC43ICogKHBhcnNlSW50KGYuaWQsIDE2KSAvIDEwMDAwICUgMSksIDAuNyAqIChwYXJzZUludChmLmlkLCAxNikgLyAxMDAwMDAwICUgMSldOyB9LCAvLyBwc2V1ZG8tcmFuZG9tIGNvbG9yIGJ5IGdlb21ldHJ5IGlkXG4gICAgcmFuZG9tQ29sb3I6IGZ1bmN0aW9uIChmKSB7IHJldHVybiBbMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKV07IH0gLy8gcmFuZG9tIGNvbG9yXG59O1xuXG5TdHlsZS53aWR0aCA9IHtcbiAgICBwaXhlbHM6IGZ1bmN0aW9uIChwKSB7IHJldHVybiBmdW5jdGlvbiAoZiwgdCkgeyByZXR1cm4gKHR5cGVvZiBwID09ICdmdW5jdGlvbicgPyBwKGYsIHQpIDogcCkgKiB0LnVuaXRzX3Blcl9waXhlbDsgfTsgfSwgLy8gbG9jYWwgdGlsZSB1bml0cyBmb3IgYSBnaXZlbiBwaXhlbCB3aWR0aFxuICAgIG1ldGVyczogZnVuY3Rpb24gKHApIHsgcmV0dXJuIGZ1bmN0aW9uIChmLCB0KSB7IHJldHVybiAodHlwZW9mIHAgPT0gJ2Z1bmN0aW9uJyA/IHAoZiwgdCkgOiBwKSAqIHQudW5pdHNfcGVyX21ldGVyOyB9OyB9ICAvLyBsb2NhbCB0aWxlIHVuaXRzIGZvciBhIGdpdmVuIG1ldGVyIHdpZHRoXG59O1xuXG5pZiAobW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xufVxuIiwiLyoqKiBWZWN0b3IgZnVuY3Rpb25zIC0gdmVjdG9ycyBwcm92aWRlZCBhcyBbeCwgeSwgel0gYXJyYXlzICoqKi9cblxudmFyIFZlY3RvciA9IHt9O1xuXG4vLyBWZWN0b3IgbGVuZ3RoIHNxdWFyZWRcblZlY3Rvci5sZW5ndGhTcSA9IGZ1bmN0aW9uICh2KVxue1xuICAgIGlmICh2Lmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIHJldHVybiAodlswXSp2WzBdICsgdlsxXSp2WzFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAodlswXSp2WzBdICsgdlsxXSp2WzFdICsgdlsyXSp2WzJdKTtcbiAgICB9XG59O1xuXG4vLyBWZWN0b3IgbGVuZ3RoXG5WZWN0b3IubGVuZ3RoID0gZnVuY3Rpb24gKHYpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydChWZWN0b3IubGVuZ3RoU3EodikpO1xufTtcblxuLy8gTm9ybWFsaXplIGEgdmVjdG9yXG5WZWN0b3Iubm9ybWFsaXplID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdmFyIGQ7XG4gICAgaWYgKHYubGVuZ3RoID09IDIpIHtcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXTtcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcblxuICAgICAgICBpZiAoZCAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3ZbMF0gLyBkLCB2WzFdIC8gZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gdlswXSp2WzBdICsgdlsxXSp2WzFdICsgdlsyXSp2WzJdO1xuICAgICAgICBkID0gTWF0aC5zcXJ0KGQpO1xuXG4gICAgICAgIGlmIChkICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbdlswXSAvIGQsIHZbMV0gLyBkLCB2WzJdIC8gZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICB9XG59O1xuXG4vLyBDcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IuY3Jvc3MgID0gZnVuY3Rpb24gKHYxLCB2MilcbntcbiAgICByZXR1cm4gW1xuICAgICAgICAodjFbMV0gKiB2MlsyXSkgLSAodjFbMl0gKiB2MlsxXSksXG4gICAgICAgICh2MVsyXSAqIHYyWzBdKSAtICh2MVswXSAqIHYyWzJdKSxcbiAgICAgICAgKHYxWzBdICogdjJbMV0pIC0gKHYxWzFdICogdjJbMF0pXG4gICAgXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gbGluZXMgc3BlY2lmaWVkIGFzIHNlZ21lbnRzIGZyb20gcG9pbnRzIChwMSwgcDIpIGFuZCAocDMsIHA0KVxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lLWxpbmVfaW50ZXJzZWN0aW9uXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NyYW1lcidzX3J1bGVcblZlY3Rvci5saW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0LCBwYXJhbGxlbF90b2xlcmFuY2UpXG57XG4gICAgdmFyIHBhcmFsbGVsX3RvbGVyYW5jZSA9IHBhcmFsbGVsX3RvbGVyYW5jZSB8fCAwLjAxO1xuXG4gICAgLy8gYTEqeCArIGIxKnkgPSBjMSBmb3IgbGluZSAoeDEsIHkxKSB0byAoeDIsIHkyKVxuICAgIC8vIGEyKnggKyBiMip5ID0gYzIgZm9yIGxpbmUgKHgzLCB5MykgdG8gKHg0LCB5NClcbiAgICB2YXIgYTEgPSBwMVsxXSAtIHAyWzFdOyAvLyB5MSAtIHkyXG4gICAgdmFyIGIxID0gcDFbMF0gLSBwMlswXTsgLy8geDEgLSB4MlxuICAgIHZhciBhMiA9IHAzWzFdIC0gcDRbMV07IC8vIHkzIC0geTRcbiAgICB2YXIgYjIgPSBwM1swXSAtIHA0WzBdOyAvLyB4MyAtIHg0XG4gICAgdmFyIGMxID0gKHAxWzBdICogcDJbMV0pIC0gKHAxWzFdICogcDJbMF0pOyAvLyB4MSp5MiAtIHkxKngyXG4gICAgdmFyIGMyID0gKHAzWzBdICogcDRbMV0pIC0gKHAzWzFdICogcDRbMF0pOyAvLyB4Myp5NCAtIHkzKng0XG4gICAgdmFyIGRlbm9tID0gKGIxICogYTIpIC0gKGExICogYjIpO1xuXG4gICAgaWYgKE1hdGguYWJzKGRlbm9tKSA+IHBhcmFsbGVsX3RvbGVyYW5jZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKChjMSAqIGIyKSAtIChiMSAqIGMyKSkgLyBkZW5vbSxcbiAgICAgICAgICAgICgoYzEgKiBhMikgLSAoYTEgKiBjMikpIC8gZGVub21cbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiBudWxsIGlmIGxpbmVzIGFyZSAoY2xvc2UgdG8pIHBhcmFsbGVsXG59O1xuXG5pZiAobW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZlY3Rvcjtcbn1cbiIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQuanMnKTtcbnZhciBHZW8gPSByZXF1aXJlKCcuL2dlby5qcycpO1xudmFyIFN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZS5qcycpO1xuXG4vLyBHZXQgYmFzZSBVUkwgZnJvbSB3aGljaCB0aGUgbGlicmFyeSB3YXMgbG9hZGVkXG4vLyBVc2VkIHRvIGxvYWQgYWRkaXRpb25hbCByZXNvdXJjZXMgbGlrZSBzaGFkZXJzLCB0ZXh0dXJlcywgZXRjLiBpbiBjYXNlcyB3aGVyZSBsaWJyYXJ5IHdhcyBsb2FkZWQgZnJvbSBhIHJlbGF0aXZlIHBhdGhcbihmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBWZWN0b3JSZW5kZXJlci5saWJyYXJ5X2Jhc2VfdXJsID0gJyc7XG4gICAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpOyAvLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbc3JjKj1cIi5qc1wiXScpO1xuICAgICAgICBmb3IgKHZhciBzPTA7IHMgPCBzY3JpcHRzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAvLyB2YXIgYmFzZV9tYXRjaCA9IHNjcmlwdHNbc10uc3JjLm1hdGNoKC8oLiopdmVjdG9yLW1hcC4oZGVidWd8bWluKS5qcy8pOyAvLyBzaG91bGQgbWF0Y2ggZGVidWcgb3IgbWluaWZpZWQgdmVyc2lvbnNcbiAgICAgICAgICAgIC8vIGlmIChiYXNlX21hdGNoICE9IG51bGwgJiYgYmFzZV9tYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyAgICAgVmVjdG9yUmVuZGVyZXIubGlicmFyeV9iYXNlX3VybCA9IGJhc2VfbWF0Y2hbMV07XG4gICAgICAgICAgICAvLyAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBzY3JpcHRzW3NdLnNyYy5pbmRleE9mKCd2ZWN0b3ItbWFwLmRlYnVnLmpzJyk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHNjcmlwdHNbc10uc3JjLmluZGV4T2YoJ3ZlY3Rvci1tYXAubWluLmpzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2ggPj0gMCkge1xuICAgICAgICAgICAgICAgIFZlY3RvclJlbmRlcmVyLmxpYnJhcnlfYmFzZV91cmwgPSBzY3JpcHRzW3NdLnNyYy5zdWJzdHIoMCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNraXAgaW4gd2ViIHdvcmtlclxuICAgIH1cbn0oKSk7XG5cblZlY3RvclJlbmRlcmVyLnRpbGVfc2NhbGUgPSA0MDk2OyAvLyBjb29yZGluYXRlcyBhcmUgbG9jYWxseSBzY2FsZWQgdG8gdGhlIHJhbmdlIFswLCB0aWxlX3NjYWxlXVxuVmVjdG9yUmVuZGVyZXIudW5pdHNfcGVyX21ldGVyID0gW107XG5WZWN0b3JSZW5kZXJlci51bml0c19wZXJfcGl4ZWwgPSBbXTtcbihmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciB6PTA7IHogPD0gR2VvLm1heF96b29tOyB6KyspIHtcbiAgICAgICAgVmVjdG9yUmVuZGVyZXIudW5pdHNfcGVyX21ldGVyW3pdID0gVmVjdG9yUmVuZGVyZXIudGlsZV9zY2FsZSAvIChHZW8udGlsZV9zaXplICogR2VvLm1ldGVyc19wZXJfcGl4ZWxbel0pO1xuICAgICAgICBWZWN0b3JSZW5kZXJlci51bml0c19wZXJfcGl4ZWxbel0gPSBWZWN0b3JSZW5kZXJlci50aWxlX3NjYWxlIC8gR2VvLnRpbGVfc2l6ZTtcbiAgICB9XG59KCkpO1xuXG4vLyBMYXllcnMgJiBzdHlsZXM6IHBhc3MgYW4gb2JqZWN0IGRpcmVjdGx5LCBvciBhIFVSTCBhcyBzdHJpbmcgdG8gbG9hZCByZW1vdGVseVxuZnVuY3Rpb24gVmVjdG9yUmVuZGVyZXIgKHR5cGUsIHRpbGVfc291cmNlLCBsYXllcnMsIHN0eWxlcywgb3B0aW9ucylcbntcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRpbGVfc291cmNlID0gdGlsZV9zb3VyY2U7XG4gICAgdGhpcy50aWxlcyA9IHt9O1xuICAgIHRoaXMubnVtX3dvcmtlcnMgPSBvcHRpb25zLm51bV93b3JrZXJzIHx8IDE7XG5cbiAgICB0aGlzLmxheWVyX3NvdXJjZSA9IFZlY3RvclJlbmRlcmVyLnVybEZvclBhdGgobGF5ZXJzKTsgLy8gVE9ETzogZml4IHRoaXMgZm9yIGxheWVycyBwcm92aWRlZCBhcyBvYmplY3RzLCB0aGlzIGFzc3VtZXMgYSBVUkwgaXMgcGFzc2VkXG4gICAgaWYgKHR5cGVvZihsYXllcnMpID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gVmVjdG9yUmVuZGVyZXIubG9hZExheWVycyhsYXllcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBsYXllcnM7XG4gICAgfVxuXG4gICAgdGhpcy5zdHlsZV9zb3VyY2UgPSBWZWN0b3JSZW5kZXJlci51cmxGb3JQYXRoKHN0eWxlcyk7IC8vIFRPRE86IGZpeCB0aGlzIGZvciBzdHlsZXMgcHJvdmlkZWQgYXMgb2JqZWN0cywgdGhpcyBhc3N1bWVzIGEgVVJMIGlzIHBhc3NlZFxuICAgIGlmICh0eXBlb2Yoc3R5bGVzKSA9PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFZlY3RvclJlbmRlcmVyLmxvYWRTdHlsZXMoc3R5bGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgIH1cblxuICAgIHRoaXMuY3JlYXRlV29ya2VycygpO1xuXG4gICAgdGhpcy56b29tID0gbnVsbDtcbiAgICB0aGlzLmNlbnRlciA9IG51bGw7XG4gICAgdGhpcy5kZXZpY2VfcGl4ZWxfcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlOyAvLyByZXF1ZXN0IGEgcmVkcmF3XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xufVxuXG5WZWN0b3JSZW5kZXJlci5jcmVhdGUgPSBmdW5jdGlvbiAodHlwZSwgdGlsZV9zb3VyY2UsIGxheWVycywgc3R5bGVzLCBvcHRpb25zKVxue1xuICAgIHJldHVybiBuZXcgVmVjdG9yUmVuZGVyZXJbdHlwZV0odGlsZV9zb3VyY2UsIGxheWVycywgc3R5bGVzLCBvcHRpb25zKTtcbn07XG5cblZlY3RvclJlbmRlcmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBDaGlsZCBjbGFzcy1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiAoZS5nLiBHTCBjb250ZXh0IGNyZWF0aW9uKVxuICAgIGlmICh0eXBlb2YodGhpcy5faW5pdCkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICB0aGlzLndvcmtlcnMuZm9yRWFjaChmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCByZW5kZXJlci50aWxlV29ya2VyQ29tcGxldGVkLmJpbmQocmVuZGVyZXIpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xufTtcblxuLy8gV2ViIHdvcmtlcnMgaGFuZGxlIGhlYXZ5IGR1dHkgZ2VvbWV0cnkgcHJvY2Vzc2luZ1xuVmVjdG9yUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVdvcmtlcnMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgdmFyIHVybCA9IFZlY3RvclJlbmRlcmVyLmxpYnJhcnlfYmFzZV91cmwgKyAndmVjdG9yLW1hcC13b3JrZXIubWluLmpzJztcblxuICAgIC8vIFRvIGFsbG93IHdvcmtlcnMgdG8gYmUgbG9hZGVkIGNyb3NzLWRvbWFpbiwgZmlyc3QgbG9hZCB3b3JrZXIgc291cmNlIHZpYSBYSFIsIHRoZW4gY3JlYXRlIGEgbG9jYWwgVVJMIHZpYSBhIGJsb2JcbiAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdvcmtlcl9sb2NhbF91cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbcmVxLnJlc3BvbnNlXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xuXG4gICAgICAgIHJlbmRlcmVyLndvcmtlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdz0wOyB3IDwgcmVuZGVyZXIubnVtX3dvcmtlcnM7IHcrKykge1xuICAgICAgICAgICAgcmVuZGVyZXIud29ya2Vycy5wdXNoKG5ldyBXb3JrZXIod29ya2VyX2xvY2FsX3VybCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXEub3BlbignR0VUJywgdXJsLCBmYWxzZSAvKiBhc3luYyBmbGFnICovKTtcbiAgICByZXEuc2VuZCgpO1xuXG4gICAgLy8gQWx0ZXJuYXRlIGZvciBkZWJ1Z2dpbmcgLSB0cmFkdGlvbmFsIG1ldGhvZCBvZiBsb2FkaW5nIGZyb20gcmVtb3RlIFVSTCBpbnN0ZWFkIG9mIFhIUi10by1sb2NhbC1ibG9iXG4gICAgLy8gcmVuZGVyZXIud29ya2VycyA9IFtdO1xuICAgIC8vIGZvciAodmFyIHc9MDsgdyA8IHJlbmRlcmVyLm51bV93b3JrZXJzOyB3KyspIHtcbiAgICAvLyAgICAgcmVuZGVyZXIud29ya2Vycy5wdXNoKG5ldyBXb3JrZXIodXJsKSk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5uZXh0X3dvcmtlciA9IDA7XG59O1xuXG5WZWN0b3JSZW5kZXJlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGxuZywgbGF0KVxue1xuICAgIHRoaXMuY2VudGVyID0geyBsbmc6IGxuZywgbGF0OiBsYXQgfTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cblZlY3RvclJlbmRlcmVyLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gKHpvb20pXG57XG4gICAgdGhpcy5tYXBfbGFzdF96b29tID0gdGhpcy56b29tO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5tYXBfem9vbWluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuVmVjdG9yUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0Wm9vbSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5tYXBfbGFzdF96b29tID0gdGhpcy56b29tO1xuICAgIHRoaXMubWFwX3pvb21pbmcgPSB0cnVlO1xufTtcblxuVmVjdG9yUmVuZGVyZXIucHJvdG90eXBlLnNldEJvdW5kcyA9IGZ1bmN0aW9uIChzdywgbmUpXG57XG4gICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgIHN3OiB7IGxuZzogc3cubG5nLCBsYXQ6IHN3LmxhdCB9LFxuICAgICAgICBuZTogeyBsbmc6IG5lLmxuZywgbGF0OiBuZS5sYXQgfVxuICAgIH07XG5cbiAgICB2YXIgYnVmZmVyID0gMjAwICogR2VvLm1ldGVyc19wZXJfcGl4ZWxbfn50aGlzLnpvb21dOyAvLyBwaXhlbHMgLT4gbWV0ZXJzXG4gICAgdGhpcy5idWZmZXJlZF9tZXRlcl9ib3VuZHMgPSB7XG4gICAgICAgIHN3OiBHZW8ubGF0TG5nVG9NZXRlcnMoUG9pbnQodGhpcy5ib3VuZHMuc3cubG5nLCB0aGlzLmJvdW5kcy5zdy5sYXQpKSxcbiAgICAgICAgbmU6IEdlby5sYXRMbmdUb01ldGVycyhQb2ludCh0aGlzLmJvdW5kcy5uZS5sbmcsIHRoaXMuYm91bmRzLm5lLmxhdCkpXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmVkX21ldGVyX2JvdW5kcy5zdy54IC09IGJ1ZmZlcjtcbiAgICB0aGlzLmJ1ZmZlcmVkX21ldGVyX2JvdW5kcy5zdy55IC09IGJ1ZmZlcjtcbiAgICB0aGlzLmJ1ZmZlcmVkX21ldGVyX2JvdW5kcy5uZS54ICs9IGJ1ZmZlcjtcbiAgICB0aGlzLmJ1ZmZlcmVkX21ldGVyX2JvdW5kcy5uZS55ICs9IGJ1ZmZlcjtcblxuICAgIC8vIGNvbnNvbGUubG9nKFwic2V0IHJlbmRlcmVyIGJvdW5kcyB0byBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuYm91bmRzKSk7XG5cbiAgICAvLyBNYXJrIHRpbGVzIGFzIHZpc2libGUvaW52aXNpYmxlXG4gICAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eUZvclRpbGUodGhpcy50aWxlc1t0XSk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG5WZWN0b3JSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlVmlzaWJpbGl0eUZvclRpbGUgPSBmdW5jdGlvbiAodGlsZSlcbntcbiAgICB0aWxlLnZpc2libGUgPSBHZW8uYm94SW50ZXJzZWN0KHRpbGUuYm91bmRzLCB0aGlzLmJ1ZmZlcmVkX21ldGVyX2JvdW5kcyk7XG4gICAgcmV0dXJuIHRpbGUudmlzaWJsZTtcbn07XG5cblZlY3RvclJlbmRlcmVyLnByb3RvdHlwZS5yZXNpemVNYXAgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cblZlY3RvclJlbmRlcmVyLnByb3RvdHlwZS5yZXF1ZXN0UmVkcmF3ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cblZlY3RvclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLmRpcnR5ID09IGZhbHNlIHx8IHRoaXMuaW5pdGlhbGl6ZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7IC8vIHN1YmNsYXNzZXMgY2FuIHNldCB0aGlzIGJhY2sgdG8gdHJ1ZSB3aGVuIGFuaW1hdGlvbiBpcyBuZWVkZWRcblxuICAgIC8vIENoaWxkIGNsYXNzLXNwZWNpZmljIHJlbmRlcmluZyAoZS5nLiBHTCBkcmF3IGNhbGxzKVxuICAgIGlmICh0eXBlb2YodGhpcy5fcmVuZGVyKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKFwicmVuZGVyIG1hcFwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblZlY3RvclJlbmRlcmVyLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uIChjb29yZHMsIGRpdiwgY2FsbGJhY2spXG57XG4gICAgLy8gT3Zlcnpvb20/XG4gICAgaWYgKGNvb3Jkcy56ID4gdGhpcy50aWxlX3NvdXJjZS5tYXhfem9vbSkge1xuICAgICAgICB2YXIgemdhcCA9IGNvb3Jkcy56IC0gdGhpcy50aWxlX3NvdXJjZS5tYXhfem9vbTtcbiAgICAgICAgLy8gdmFyIG9yaWdpbmFsX3RpbGUgPSBbY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMuel0uam9pbignLycpO1xuICAgICAgICBjb29yZHMueCA9IH5+KGNvb3Jkcy54IC8gTWF0aC5wb3coMiwgemdhcCkpO1xuICAgICAgICBjb29yZHMueSA9IH5+KGNvb3Jkcy55IC8gTWF0aC5wb3coMiwgemdhcCkpO1xuICAgICAgICBjb29yZHMuZGlzcGxheV96ID0gY29vcmRzLno7IC8vIHogd2l0aG91dCBvdmVyem9vbVxuICAgICAgICBjb29yZHMueiAtPSB6Z2FwO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImFkanVzdGVkIGZvciBvdmVyem9vbSwgdGlsZSBcIiArIG9yaWdpbmFsX3RpbGUgKyBcIiAtPiBcIiArIFtjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56XS5qb2luKCcvJykpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRyYWNraW5nIG5ldyB0aWxlIHNldCBpZiBubyBvdGhlciB0aWxlcyBhbHJlYWR5IGxvYWRpbmdcbiAgICBpZiAodGhpcy50aWxlX3NldF9sb2FkaW5nID09IG51bGwpIHtcbiAgICAgICAgdGhpcy50aWxlX3NldF9sb2FkaW5nID0gK25ldyBEYXRlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidGlsZSBzZXQgbG9hZCBTVEFSVFwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gW2Nvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnpdLmpvaW4oJy8nKTtcblxuICAgIC8vIEFscmVhZHkgbG9hZGluZy9sb2FkZWQ/XG4gICAgaWYgKHRoaXMudGlsZXNba2V5XSkge1xuICAgICAgICAvLyBpZiAodGhpcy50aWxlc1trZXldLmxvYWRlZCA9PSB0cnVlKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcInVzZSBsb2FkZWQgdGlsZSBcIiArIGtleSArIFwiIGZyb20gY2FjaGVcIik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHRoaXMudGlsZXNba2V5XS5sb2FkaW5nID09IHRydWUpIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwiYWxyZWFkeSBsb2FkaW5nIHRpbGUgXCIgKyBrZXkgKyBcIiwgc2tpcFwiKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGl2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW2tleV0gPSB7fTtcbiAgICB0aWxlLmtleSA9IGtleTtcbiAgICB0aWxlLmNvb3JkcyA9IGNvb3JkcztcbiAgICB0aWxlLm1pbiA9IEdlby5tZXRlcnNGb3JUaWxlKHRpbGUuY29vcmRzKTtcbiAgICB0aWxlLm1heCA9IEdlby5tZXRlcnNGb3JUaWxlKHsgeDogdGlsZS5jb29yZHMueCArIDEsIHk6IHRpbGUuY29vcmRzLnkgKyAxLCB6OiB0aWxlLmNvb3Jkcy56IH0pO1xuICAgIHRpbGUuYm91bmRzID0geyBzdzogeyB4OiB0aWxlLm1pbi54LCB5OiB0aWxlLm1heC55IH0sIG5lOiB7IHg6IHRpbGUubWF4LngsIHk6IHRpbGUubWluLnkgfSB9O1xuICAgIHRpbGUudW5pdHNfcGVyX21ldGVyID0gVmVjdG9yUmVuZGVyZXIudW5pdHNfcGVyX21ldGVyW3RpbGUuY29vcmRzLnpdO1xuICAgIHRpbGUudW5pdHNfcGVyX3BpeGVsID0gVmVjdG9yUmVuZGVyZXIudW5pdHNfcGVyX3BpeGVsW3RpbGUuY29vcmRzLnpdO1xuICAgIHRpbGUuZGVidWcgPSB7fTtcbiAgICB0aWxlLmxvYWRpbmcgPSB0cnVlO1xuICAgIHRpbGUubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5Rm9yVGlsZSh0aWxlKTtcblxuICAgIHRoaXMud29ya2Vyc1t0aGlzLm5leHRfd29ya2VyXS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdsb2FkVGlsZScsXG4gICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgIHJlbmRlcmVyX3R5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgdGlsZV9zb3VyY2U6IHRoaXMudGlsZV9zb3VyY2UsXG4gICAgICAgIGxheWVyX3NvdXJjZTogdGhpcy5sYXllcl9zb3VyY2UsXG4gICAgICAgIHN0eWxlX3NvdXJjZTogdGhpcy5zdHlsZV9zb3VyY2VcbiAgICB9KTtcbiAgICB0aWxlLndvcmtlciA9IHRoaXMud29ya2Vyc1t0aGlzLm5leHRfd29ya2VyXTtcbiAgICB0aGlzLm5leHRfd29ya2VyID0gKHRoaXMubmV4dF93b3JrZXIgKyAxKSAlIHRoaXMud29ya2Vycy5sZW5ndGg7XG5cbiAgICAvLyBEZWJ1ZyBpbmZvXG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS10aWxlLWtleScsIHRpbGUua2V5KTtcbiAgICBkaXYuc3R5bGUud2lkdGggPSAnMjU2cHgnO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnMjU2cHgnO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgdmFyIGRlYnVnX292ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGVidWdfb3ZlcmxheS50ZXh0Q29udGVudCA9IHRpbGUua2V5O1xuICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS50b3AgPSAwO1xuICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5mb250U2l6ZSA9ICcxNnB4JztcbiAgICAgICAgLy8gZGVidWdfb3ZlcmxheS5zdHlsZS50ZXh0T3V0bGluZSA9ICcxcHggIzAwMDAwMCc7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChkZWJ1Z19vdmVybGF5KTtcblxuICAgICAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICAgICAgICBkaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSAnd2hpdGUnO1xuICAgICAgICBkaXYuc3R5bGUuYm9yZGVyV2lkdGggPSAnMXB4JztcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGl2KTtcbiAgICB9XG59O1xuXG4vLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgd2hlbiBhIHdlYiB3b3JrZXIgY29tcGxldGVzIHByb2Nlc3NpbmcgZm9yIGEgc2luZ2xlIHRpbGVcblZlY3RvclJlbmRlcmVyLnByb3RvdHlwZS50aWxlV29ya2VyQ29tcGxldGVkID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIGlmIChldmVudC5kYXRhLnR5cGUgIT0gJ2xvYWRUaWxlQ29tcGxldGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpbGUgPSBldmVudC5kYXRhLnRpbGU7XG5cbiAgICAvLyBSZW1vdmVkIHRoaXMgdGlsZSBkdXJpbmcgbG9hZD9cbiAgICBpZiAodGhpcy50aWxlc1t0aWxlLmtleV0gPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImRpc2NhcmRlZCB0aWxlIFwiICsgdGlsZS5rZXkgKyBcIiBpbiBWZWN0b3JSZW5kZXJlci50aWxlV29ya2VyQ29tcGxldGVkIGJlY2F1c2UgcHJldmlvdXNseSByZW1vdmVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aWxlc1t0aWxlLmtleV0gPSB0aWxlOyAvLyBUT0RPOiBPSyB0byBqdXN0IHdpcGUgb3V0IHRoZSB0aWxlIGhlcmU/IG9yIGNvdWxkIHBhc3MgYmFjayBhIGxpc3Qgb2YgcHJvcGVydGllcyB0byByZXBsYWNlPyBmZWVsaW5nIHRoZSBsYWNrIG9mIHVuZGVyc2NvcmUgaGVyZS4uLlxuXG4gICAgLy8gQ2hpbGQgY2xhc3Mtc3BlY2lmaWMgdGlsZSBwcm9jZXNzaW5nXG4gICAgaWYgKHR5cGVvZih0aGlzLl90aWxlV29ya2VyQ29tcGxldGVkKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3RpbGVXb3JrZXJDb21wbGV0ZWQodGlsZSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRpbGUubGF5ZXJzOyAvLyBkZWxldGUgdGhlIHNvdXJjZSBkYXRhIGluIHRoZSB0aWxlIHRvIHNhdmUgbWVtb3J5XG5cbiAgICAvLyBObyBtb3JlIHRpbGVzIGFjdGl2ZWx5IGxvYWRpbmc/XG4gICAgaWYgKHRoaXMudGlsZV9zZXRfbG9hZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBlbmRfdGlsZV9zZXQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbGVzW3RdLmxvYWRpbmcgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGVuZF90aWxlX3NldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZF90aWxlX3NldCA9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RfdGlsZV9zZXRfbG9hZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLnRpbGVfc2V0X2xvYWRpbmc7XG4gICAgICAgICAgICB0aGlzLnRpbGVfc2V0X2xvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0aWxlIHNldCBsb2FkIEZJTklTSEVEIGluOiBcIiArIHRoaXMubGFzdF90aWxlX3NldF9sb2FkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMucHJpbnREZWJ1Z0ZvclRpbGUodGlsZSk7XG59O1xuXG5WZWN0b3JSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlVGlsZSA9IGZ1bmN0aW9uIChrZXkpXG57XG4gICAgY29uc29sZS5sb2coXCJ0aWxlIHVubG9hZCBmb3IgXCIgKyBrZXkpO1xuICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1trZXldO1xuICAgIGlmICh0aWxlICE9IG51bGwgJiYgdGlsZS5sb2FkaW5nID09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjYW5jZWwgdGlsZSBsb2FkIGZvciBcIiArIGtleSk7XG5cbiAgICAgICAgLy8gV2ViIHdvcmtlciB3aWxsIGNhbmNlbCBYSFIgcmVxdWVzdHNcbiAgICAgICAgaWYgKHRpbGUud29ya2VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRpbGUud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlVGlsZScsXG4gICAgICAgICAgICAgICAga2V5OiB0aWxlLmtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy50aWxlc1trZXldO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuVmVjdG9yUmVuZGVyZXIucHJvdG90eXBlLnByaW50RGVidWdGb3JUaWxlID0gZnVuY3Rpb24gKHRpbGUpXG57XG4gICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiZGVidWcgZm9yIFwiICsgdGlsZS5rZXkgKyAnOiBbICcgK1xuICAgICAgICBPYmplY3Qua2V5cyh0aWxlLmRlYnVnKS5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKyAnOiAnICsgdGlsZS5kZWJ1Z1t0XTsgfSkuam9pbignLCAnKSArICcgXSdcbiAgICApO1xufTtcblxuXG4vKioqIENsYXNzIG1ldGhvZHMgKHN0YXRlbGVzcykgKioqL1xuXG4vLyBTaW1wbGlzdGljIGRldGVjdGlvbiBvZiByZWxhdGl2ZSBwYXRocywgYXBwZW5kIGJhc2UgaWYgbmVjZXNzYXJ5XG5WZWN0b3JSZW5kZXJlci51cmxGb3JQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBwYXRoLnRvTG93ZXJDYXNlKCkuc3Vic3RyKDAsIDQpO1xuICAgIGlmICghKHByb3RvY29sID09ICdodHRwJyB8fCBwcm90b2NvbCA9PSAnZmlsZScpKSB7XG4gICAgICAgIHBhdGggPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG5WZWN0b3JSZW5kZXJlci5sb2FkTGF5ZXJzID0gZnVuY3Rpb24gKHVybClcbntcbiAgICB2YXIgbGF5ZXJzO1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkgeyBldmFsKCdsYXllcnMgPSAnICsgcmVxLnJlc3BvbnNlKTsgfTsgLy8gVE9ETzogc2VjdXJpdHkhXG4gICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UgLyogYXN5bmMgZmxhZyAqLyk7XG4gICAgcmVxLnNlbmQoKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xufTtcblxuVmVjdG9yUmVuZGVyZXIubG9hZFN0eWxlcyA9IGZ1bmN0aW9uICh1cmwpXG57XG4gICAgdmFyIHN0eWxlcztcbiAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgZXZhbCgnc3R5bGVzID0gJyArIHJlcS5yZXNwb25zZSk7IH07IC8vIFRPRE86IHNlY3VyaXR5IVxuICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlIC8qIGFzeW5jIGZsYWcgKi8pO1xuICAgIHJlcS5zZW5kKCk7XG4gICAgcmV0dXJuIHN0eWxlcztcbn07XG5cbi8vIFByb2Nlc3NlcyB0aGUgdGlsZSByZXNwb25zZSB0byBjcmVhdGUgbGF5ZXJzIGFzIGRlZmluZWQgYnkgdGhpcyByZW5kZXJlclxuLy8gQ2FuIGluY2x1ZGUgcG9zdC1wcm9jZXNzaW5nIHRvIHBhcnRpYWxseSBmaWx0ZXIgb3IgcmUtYXJyYW5nZSBkYXRhLCBlLmcuIG9ubHkgaW5jbHVkaW5nIFBPSXMgdGhhdCBoYXZlIG5hbWVzXG5WZWN0b3JSZW5kZXJlci5wcm9jZXNzTGF5ZXJzRm9yVGlsZSA9IGZ1bmN0aW9uIChsYXllcnMsIHRpbGUpXG57XG4gICAgdmFyIHRpbGVfbGF5ZXJzID0ge307XG4gICAgZm9yICh2YXIgdD0wOyB0IDwgbGF5ZXJzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIGxheWVyc1t0XS5udW1iZXIgPSB0O1xuXG4gICAgICAgIGlmIChsYXllcnNbdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSnVzdCBwYXNzIHRocm91Z2ggZGF0YSB1bnRvdWNoZWQgaWYgbm8gZGF0YSB0cmFuc2Zvcm0gZnVuY3Rpb24gZGVmaW5lZFxuICAgICAgICAgICAgaWYgKGxheWVyc1t0XS5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aWxlX2xheWVyc1tsYXllcnNbdF0ubmFtZV0gPSB0aWxlLmxheWVyc1tsYXllcnNbdF0ubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggZGF0YSBidXQgd2l0aCBkaWZmZXJlbnQgbGF5ZXIgbmFtZSBpbiB0aWxlIHNvdXJjZSBkYXRhXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGF5ZXJzW3RdLmRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aWxlX2xheWVyc1tsYXllcnNbdF0ubmFtZV0gPSB0aWxlLmxheWVyc1tsYXllcnNbdF0uZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIGZvciBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsYXllcnNbdF0uZGF0YSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGlsZV9sYXllcnNbbGF5ZXJzW3RdLm5hbWVdID0gbGF5ZXJzW3RdLmRhdGEodGlsZS5sYXllcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIG5vIGRhdGEgd2FzIGZvdW5kIGluIHRpbGUgb3IgcmV0dXJuZWQgYnkgcG9zdC1wcm9jZXNzb3JcbiAgICAgICAgdGlsZV9sYXllcnNbbGF5ZXJzW3RdLm5hbWVdID0gdGlsZV9sYXllcnNbbGF5ZXJzW3RdLm5hbWVdIHx8IHsgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJywgZmVhdHVyZXM6IFtdIH07XG4gICAgfVxuICAgIHRpbGUubGF5ZXJzID0gdGlsZV9sYXllcnM7XG4gICAgcmV0dXJuIHRpbGVfbGF5ZXJzO1xufTtcblxuXG4vKioqIFN0eWxlIHBhcnNpbmcgJiBkZWZhdWx0cyAqKiovXG5cbi8vIERldGVybWluZSBmaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIChjb2xvciwgd2lkdGgsIGV0Yy4pXG5WZWN0b3JSZW5kZXJlci5zdHlsZV9kZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogWzEuMCwgMCwgMF0sXG4gICAgd2lkdGg6IFN0eWxlLndpZHRoLnBpeGVscyg1KSxcbiAgICBzaXplOiBTdHlsZS53aWR0aC5waXhlbHMoNSksXG4gICAgZXh0cnVkZTogZmFsc2UsXG4gICAgaGVpZ2h0OiAyMCxcbiAgICBtaW5faGVpZ2h0OiAwLFxuICAgIG91dGxpbmU6IHtcbiAgICAgICAgLy8gY29sb3I6IFsxLjAsIDAsIDBdLFxuICAgICAgICAvLyB3aWR0aDogMSxcbiAgICAgICAgLy8gZGFzaDogbnVsbFxuICAgIH0sXG4gICAgLy8gcmVuZGVyX21vZGU6IHtcbiAgICAvLyAgICAgbmFtZTogJ3BvbHlnb25zJ1xuICAgIC8vIH1cbiAgICByZW5kZXJfbW9kZTogJ3BvbHlnb25zJ1xufTtcblxuVmVjdG9yUmVuZGVyZXIucGFyc2VTdHlsZUZvckZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXJfc3R5bGUsIHRpbGUpXG57XG4gICAgdmFyIGxheWVyX3N0eWxlID0gbGF5ZXJfc3R5bGUgfHwge307XG4gICAgdmFyIHN0eWxlID0ge307XG5cbiAgICAvLyBUZXN0IHdoZXRoZXIgZmVhdHVyZXMgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGFsbFxuICAgIGlmICh0eXBlb2YgbGF5ZXJfc3R5bGUuZmlsdGVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGxheWVyX3N0eWxlLmZpbHRlcihmZWF0dXJlLCB0aWxlKSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJzZSBzdHlsZXNcbiAgICBzdHlsZS5jb2xvciA9IChsYXllcl9zdHlsZS5jb2xvciAmJiAobGF5ZXJfc3R5bGUuY29sb3JbZmVhdHVyZS5wcm9wZXJ0aWVzLmtpbmRdIHx8IGxheWVyX3N0eWxlLmNvbG9yLmRlZmF1bHQpKSB8fCBWZWN0b3JSZW5kZXJlci5zdHlsZV9kZWZhdWx0cy5jb2xvcjtcbiAgICBpZiAodHlwZW9mIHN0eWxlLmNvbG9yID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3R5bGUuY29sb3IgPSBzdHlsZS5jb2xvcihmZWF0dXJlLCB0aWxlKTtcbiAgICB9XG5cbiAgICBzdHlsZS53aWR0aCA9IChsYXllcl9zdHlsZS53aWR0aCAmJiAobGF5ZXJfc3R5bGUud2lkdGhbZmVhdHVyZS5wcm9wZXJ0aWVzLmtpbmRdIHx8IGxheWVyX3N0eWxlLndpZHRoLmRlZmF1bHQpKSB8fCBWZWN0b3JSZW5kZXJlci5zdHlsZV9kZWZhdWx0cy53aWR0aDtcbiAgICBpZiAodHlwZW9mIHN0eWxlLndpZHRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS53aWR0aChmZWF0dXJlLCB0aWxlKTtcbiAgICB9XG5cbiAgICBzdHlsZS5zaXplID0gKGxheWVyX3N0eWxlLnNpemUgJiYgKGxheWVyX3N0eWxlLnNpemVbZmVhdHVyZS5wcm9wZXJ0aWVzLmtpbmRdIHx8IGxheWVyX3N0eWxlLnNpemUuZGVmYXVsdCkpIHx8IFZlY3RvclJlbmRlcmVyLnN0eWxlX2RlZmF1bHRzLnNpemU7XG4gICAgaWYgKHR5cGVvZiBzdHlsZS5zaXplID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3R5bGUuc2l6ZSA9IHN0eWxlLnNpemUoZmVhdHVyZSwgdGlsZSk7XG4gICAgfVxuXG4gICAgc3R5bGUuZXh0cnVkZSA9IChsYXllcl9zdHlsZS5leHRydWRlICYmIChsYXllcl9zdHlsZS5leHRydWRlW2ZlYXR1cmUucHJvcGVydGllcy5raW5kXSB8fCBsYXllcl9zdHlsZS5leHRydWRlLmRlZmF1bHQpKSB8fCBWZWN0b3JSZW5kZXJlci5zdHlsZV9kZWZhdWx0cy5leHRydWRlO1xuICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBzdHlsZS5leHRydWRlKGZlYXR1cmUsIHRpbGUpOyAvLyByZXR1cm5pbmcgYSBib29sZWFuIHdpbGwgZXh0cnVkZSB3aXRoIHRoZSBmZWF0dXJlJ3MgaGVpZ2h0LCBhIG51bWJlciB3aWxsIG92ZXJyaWRlIHRoZSBmZWF0dXJlIGhlaWdodCAoc2VlIGJlbG93KVxuICAgIH1cblxuICAgIHN0eWxlLmhlaWdodCA9IChmZWF0dXJlLnByb3BlcnRpZXMgJiYgZmVhdHVyZS5wcm9wZXJ0aWVzLmhlaWdodCkgfHwgVmVjdG9yUmVuZGVyZXIuc3R5bGVfZGVmYXVsdHMuaGVpZ2h0O1xuICAgIHN0eWxlLm1pbl9oZWlnaHQgPSAoZmVhdHVyZS5wcm9wZXJ0aWVzICYmIGZlYXR1cmUucHJvcGVydGllcy5taW5faGVpZ2h0KSB8fCBWZWN0b3JSZW5kZXJlci5zdHlsZV9kZWZhdWx0cy5taW5faGVpZ2h0O1xuXG4gICAgLy8gaGVpZ2h0IGRlZmF1bHRzIHRvIGZlYXR1cmUgaGVpZ2h0LCBidXQgZXh0cnVkZSBzdHlsZSBjYW4gZHluYW1pY2FsbHkgYWRqdXN0IGhlaWdodCBieSByZXR1cm5pbmcgYSBudW1iZXIgb3IgYXJyYXkgKGluc3RlYWQgb2YgYSBib29sZWFuKVxuICAgIGlmIChzdHlsZS5leHRydWRlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PSAnb2JqZWN0JyAmJiBzdHlsZS5leHRydWRlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBzdHlsZS5taW5faGVpZ2h0ID0gc3R5bGUuZXh0cnVkZVswXTtcbiAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLmV4dHJ1ZGVbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdHlsZS5vdXRsaW5lID0ge307XG4gICAgbGF5ZXJfc3R5bGUub3V0bGluZSA9IGxheWVyX3N0eWxlLm91dGxpbmUgfHwge307XG4gICAgc3R5bGUub3V0bGluZS5jb2xvciA9IChsYXllcl9zdHlsZS5vdXRsaW5lLmNvbG9yICYmIChsYXllcl9zdHlsZS5vdXRsaW5lLmNvbG9yW2ZlYXR1cmUucHJvcGVydGllcy5raW5kXSB8fCBsYXllcl9zdHlsZS5vdXRsaW5lLmNvbG9yLmRlZmF1bHQpKSB8fCBWZWN0b3JSZW5kZXJlci5zdHlsZV9kZWZhdWx0cy5vdXRsaW5lLmNvbG9yO1xuICAgIGlmICh0eXBlb2Ygc3R5bGUub3V0bGluZS5jb2xvciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBzdHlsZS5vdXRsaW5lLmNvbG9yKGZlYXR1cmUsIHRpbGUpO1xuICAgIH1cblxuICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSAobGF5ZXJfc3R5bGUub3V0bGluZS53aWR0aCAmJiAobGF5ZXJfc3R5bGUub3V0bGluZS53aWR0aFtmZWF0dXJlLnByb3BlcnRpZXMua2luZF0gfHwgbGF5ZXJfc3R5bGUub3V0bGluZS53aWR0aC5kZWZhdWx0KSkgfHwgVmVjdG9yUmVuZGVyZXIuc3R5bGVfZGVmYXVsdHMub3V0bGluZS53aWR0aDtcbiAgICBpZiAodHlwZW9mIHN0eWxlLm91dGxpbmUud2lkdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gc3R5bGUub3V0bGluZS53aWR0aChmZWF0dXJlLCB0aWxlKTtcbiAgICB9XG5cbiAgICBzdHlsZS5vdXRsaW5lLmRhc2ggPSAobGF5ZXJfc3R5bGUub3V0bGluZS5kYXNoICYmIChsYXllcl9zdHlsZS5vdXRsaW5lLmRhc2hbZmVhdHVyZS5wcm9wZXJ0aWVzLmtpbmRdIHx8IGxheWVyX3N0eWxlLm91dGxpbmUuZGFzaC5kZWZhdWx0KSkgfHwgVmVjdG9yUmVuZGVyZXIuc3R5bGVfZGVmYXVsdHMub3V0bGluZS5kYXNoO1xuICAgIGlmICh0eXBlb2Ygc3R5bGUub3V0bGluZS5kYXNoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3R5bGUub3V0bGluZS5kYXNoID0gc3R5bGUub3V0bGluZS5kYXNoKGZlYXR1cmUsIHRpbGUpO1xuICAgIH1cblxuICAgIHN0eWxlLnJlbmRlcl9tb2RlID0gbGF5ZXJfc3R5bGUucmVuZGVyX21vZGUgfHwgVmVjdG9yUmVuZGVyZXIuc3R5bGVfZGVmYXVsdHMucmVuZGVyX21vZGU7XG4gICAgLy8gc3R5bGUucmVuZGVyX21vZGUgPSB7fTtcbiAgICAvLyBzdHlsZS5yZW5kZXJfbW9kZS5uYW1lID0gKGxheWVyX3N0eWxlLnJlbmRlcl9tb2RlICYmIGxheWVyX3N0eWxlLnJlbmRlcl9tb2RlLm5hbWUpIHx8IFZlY3RvclJlbmRlcmVyLnN0eWxlX2RlZmF1bHRzLnJlbmRlcl9tb2RlLm5hbWU7XG5cbiAgICByZXR1cm4gc3R5bGU7XG59O1xuXG5pZiAobW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZlY3RvclJlbmRlcmVyO1xufVxuIl19
(7)
});
