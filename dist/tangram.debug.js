(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;

require("core-js/shim");

require("regenerator-babel/runtime");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/shim":2,"regenerator-babel/runtime":3}],2:[function(require,module,exports){
/**
 * Core.js 0.6.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * Â© 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , console         = global.console || {}
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_TAG         = getWellKnownSymbol(TO_STRING_TAG)
  , SYMBOL_SPECIES     = getWellKnownSymbol('species')
  , SYMBOL_ITERATOR;
function setSpecies(C){
  if(DESC && (framework || !isNative(C)))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

/******************************************************************************
 * Module : common.export                                                     *
 ******************************************************************************/

var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : common.iterators                                                  *
 ******************************************************************************/

SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR);
var ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
    // Safari has byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  FF_ITERATOR in ArrayProto && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function checkDangerIterClosing(fn){
  var danger = true;
  var O = {
    next: function(){ throw 1 },
    'return': function(){ danger = false }
  };
  O[SYMBOL_ITERATOR] = returnThis;
  try {
    fn(O);
  } catch(e){}
  return danger;
}
function closeIterator(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)ret.call(iterator);
}
function safeIterClose(exec, iterator){
  try {
    exec(iterator);
  } catch(e){
    closeIterator(iterator);
    throw e;
  }
}
function forOf(iterable, entries, fn, that){
  safeIterClose(function(iterator){
    var f = ctx(fn, that, entries ? 2 : 1)
      , step;
    while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false){
      return closeIterator(iterator);
    }
  }, getIterator(iterable));
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR || getWellKnownSymbol(ITERATOR),
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object.statics                                                *
 ******************************************************************************/

!function(){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
}();

/******************************************************************************
 * Module : es6.object.prototype                                              *
 ******************************************************************************/

!function(tmp){
  // 19.1.3.6 Object.prototype.toString()
  tmp[SYMBOL_TAG] = DOT;
  if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){
    return '[object ' + classof(this) + ']';
  });
}({});

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.function                                                      *
 ******************************************************************************/

!function(NAME){
  // 19.2.4.2 name
  NAME in FunctionProto || (DESC && defineProperty(FunctionProto, NAME, {
    configurable: true,
    get: function(){
      var match = String(this).match(/^\s*function ([^ (]*)/)
        , name  = match ? match[1] : '';
      has(this, NAME) || defineProperty(this, NAME, descriptor(5, name));
      return name;
    },
    set: function(value){
      has(this, NAME) || defineProperty(this, NAME, descriptor(0, value));
    }
  }));
}('name');

/******************************************************************************
 * Module : es6.number.constructor                                            *
 ******************************************************************************/

Number('0o1') && Number('0b1') || function(_Number, NumberProto){
  function toNumber(it){
    if(isObject(it))it = toPrimitive(it);
    if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
      var binary = false;
      switch(it.charCodeAt(1)){
        case 66 : case 98  : binary = true;
        case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
      }
    } return +it;
  }
  function toPrimitive(it){
    var fn, val;
    if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
    if(isFunction(fn = it[TO_STRING]) && !isObject(val = fn.call(it)))return val;
    throw TypeError("Can't convert object to number");
  }
  Number = function Number(it){
    return this instanceof Number ? new _Number(toNumber(it)) : toNumber(it);
  }
  forEach.call(DESC ? getNames(_Number)
  : array('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY'), function(key){
    key in Number || defineProperty(Number, key, getOwnDescriptor(_Number, key));
  });
  Number[PROTOTYPE] = NumberProto;
  NumberProto[CONSTRUCTOR] = Number;
  hidden(global, NUMBER, Number);
}(Number, Number[PROTOTYPE]);

/******************************************************************************
 * Module : es6.number.statics                                                *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array.statics                                                 *
 ******************************************************************************/

!function(){
  $define(STATIC + FORCED * checkDangerIterClosing(Array.from), ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, step;
      if(isIterable(O)){
        result = new (generic(this, Array));
        safeIterClose(function(iterator){
          for(; !(step = iterator.next()).done; index++){
            result[index] = mapping ? f(step.value, index) : step.value;
          }
        }, getIterator(O));
      } else {
        result = new (generic(this, Array))(length = toLength(O.length));
        for(; length > index; index++){
          result[index] = mapping ? f(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }
  });
  
  $define(STATIC, ARRAY, {
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.array.prototype                                               *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : es6.regexp                                                        *
 ******************************************************************************/

DESC && !function(RegExpProto, _RegExp){  
  // RegExp allows a regex with flags as the pattern
  if(!function(){try{return RegExp(/a/g, 'i') == '/a/i'}catch(e){}}()){
    RegExp = function RegExp(pattern, flags){
      return new _RegExp(cof(pattern) == REGEXP && flags !== undefined
        ? pattern.source : pattern, flags);
    }
    forEach.call(getNames(_RegExp), function(key){
      key in RegExp || defineProperty(RegExp, key, {
        configurable: true,
        get: function(){ return _RegExp[key] },
        set: function(it){ _RegExp[key] = it }
      });
    });
    RegExpProto[CONSTRUCTOR] = RegExp;
    RegExp[PROTOTYPE] = RegExpProto;
    hidden(global, REGEXP, RegExp);
  }
  
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')defineProperty(RegExpProto, 'flags', {
    configurable: true,
    get: createReplacer(/^.*\/(\w*)$/, '$1')
  });
  
  setSpecies(RegExp);
}(RegExp[PROTOTYPE], RegExp);

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, RECORD){
    function isThenable(it){
      var then;
      if(isObject(it))then = it.then;
      return isFunction(then) ? then : false;
    }
    function handledRejectionOrHasOnRejected(promise){
      var record = promise[RECORD]
        , chain  = record.c
        , i      = 0
        , react;
      if(record.h)return true;
      while(chain.length > i){
        react = chain[i++];
        if(react.fail || handledRejectionOrHasOnRejected(react.P))return true;
      }
    }
    function notify(record, reject){
      var chain = record.c;
      if(reject || chain.length)asap(function(){
        var promise = record.p
          , value   = record.v
          , ok      = record.s == 1
          , i       = 0;
        if(reject && !handledRejectionOrHasOnRejected(promise)){
          setTimeout(function(){
            if(!handledRejectionOrHasOnRejected(promise)){
              if(NODE){
                if(!process.emit('unhandledRejection', value, promise)){
                  // default node.js behavior
                }
              } else if(isFunction(console.error)){
                console.error('Unhandled promise rejection', value);
              }
            }
          }, 1e3);
        } else while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              if(!ok)record.h = true;
              ret = cb === true ? value : cb(value);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(value);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(value){
      var record = this
        , then, wrapper;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      try {
        if(then = isThenable(value)){
          wrapper = {r: record, d: false}; // wrap
          then.call(value, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          record.v = value;
          record.s = 1;
          notify(record);
        }
      } catch(err){
        reject.call(wrapper || {r: record, d: false}, err); // wrap
      }
    }
    function reject(value){
      var record = this;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      record.v = value;
      record.s = 2;
      notify(record, true);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var record = {
        p: this,      // promise
        c: [],        // chain
        s: 0,         // state
        d: false,     // done
        v: undefined, // value
        h: false      // handled rejection
      };
      hidden(this, RECORD, record);
      try {
        executor(ctx(resolve, record, 1), ctx(reject, record, 1));
      } catch(err){
        reject.call(record, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), record = this[RECORD];
        record.c.push(react);
        record.s && notify(record);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && RECORD in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('record'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || !DESC || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(checkDangerIterClosing(function(O){ new C(O) })){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: function(target, argumentsList /*, newTarget*/){
      var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
        , instance = create(isObject(proto) ? proto : ObjectProto)
        , result   = apply.call(target, instance, argumentsList);
      return isObject(result) ? result : instance;
    },
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://gist.github.com/WebReflection/9353781
    getOwnPropertyDescriptors: function(object){
      var O      = toObject(object)
        , result = {};
      forEach.call(ownKeys(O), function(key){
        defineProperty(result, key, descriptor(0, getOwnDescriptor(O, key)));
      });
      return result;
    },
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values:  createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), true);
},{}],3:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    return new Promise(function(resolve, reject) {
      var generator = wrap(innerFn, outerFn, self, tryLocsList);
      var callNext = step.bind(generator.next);
      var callThrow = step.bind(generator["throw"]);

      function step(arg) {
        var record = tryCatch(this, null, arg);
        if (record.type === "throw") {
          reject(record.arg);
          return;
        }

        var info = record.arg;
        if (info.done) {
          resolve(info.value);
        } else {
          Promise.resolve(info.value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };

  function Generator(innerFn, outerFn, self, tryLocsList) {
    var generator = outerFn ? Object.create(outerFn.prototype) : this;
    var context = new Context(tryLocsList);
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;

            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart &&
              typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError(
              "attempt to send " + JSON.stringify(arg) + " to newborn generator"
            );
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;

          if (method === "next") {
            context.dispatchException(record.arg);
          } else {
            arg = record.arg;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator["throw"] = invoke.bind(generator, "throw");
    generator["return"] = invoke.bind(generator, "return");

    return generator;
  }

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg < finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          return this.complete(entry.completion, entry.afterLoc);
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":6,"./lib/sweep":10,"typedarray-pool":13}],5:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],6:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":5,"./median":7,"./partition":8,"./sweep":10,"bit-twiddle":11,"typedarray-pool":13}],7:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":8}],8:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],9:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],10:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":9,"bit-twiddle":11,"typedarray-pool":13}],11:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],12:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],13:[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"bit-twiddle":11,"buffer":15,"dup":12}],14:[function(require,module,exports){

},{}],15:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":16,"ieee754":17,"is-array":18}],16:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],17:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],18:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],19:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],20:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(points) {

    var outerNode = linkedList(points[0], true),
        node, minX, minY, maxX, maxY, x, y, size,
        len = 0,
        threshold = 80;

    for (var i = 0; len < threshold && i < points.length; i++) len += points[i].length;

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (len >= threshold) {
        node = outerNode.next;
        minX = maxX = node.p[0];
        minY = maxY = node.p[1];
        do {
            x = node.p[0];
            y = node.p[1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            node = node.next;
        } while (node !== outerNode);

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    if (points.length > 1) outerNode = eliminateHoles(points, outerNode);

    var triangles = [];
    if (outerNode) earcutLinked(outerNode, triangles, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(points, clockwise) {
    var sum = 0,
        len = points.length,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = 0, j = len - 1; i < len; j = i++) {
        var p1 = points[i],
            p2 = points[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = 0; i < len; i++) last = insertNode(points[i], last);
    } else {
        for (i = len - 1; i >= 0; i--) last = insertNode(points[i], last);
    }

    return last;
}

function filterPoints(start) {
    // eliminate colinear or duplicate points
    var node = start,
        again;
    do {
        again = false;

        if (equals(node.p, node.next.p) || orient(node.prev.p, node.p, node.next.p) === 0) {

            node.prev.next = node.next;
            node.next.prev = node.prev;

            if (node.prevZ) node.prevZ.nextZ = node.nextZ;
            if (node.nextZ) node.nextZ.prevZ = node.prevZ;

            node = start = node.prev;

            if (node === node.next) return null;
            again = true;

        } else {
            node = node.next;
        }
    } while (again || node !== start);

    return start;
}

function earcutLinked(ear, triangles, minX, minY, size, secondPass) {
    ear = filterPoints(ear);
    if (!ear) return;

    if (!secondPass && minX !== undefined) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (isEar(ear, minX, minY, size)) {
            triangles.push(prev.p, ear.p, next.p);

            next.prev = prev;
            prev.next = next;

            if (ear.prevZ) ear.prevZ.nextZ = ear.nextZ;
            if (ear.nextZ) ear.nextZ.prevZ = ear.prevZ;

            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        if (ear === stop) {
            // if we can't find any more ears, try filtering points and cutting again
            if (!secondPass) earcutLinked(ear, triangles, minX, minY, size, true);
            // if this didn't work, try splitting the remaining polygon into two
            else splitEarcut(ear, triangles, minX, minY, size);
            break;
        }
    }
}

function isEar(ear, minX, minY, size) {

    var a = ear.prev.p,
        b = ear.p,
        c = ear.next.p,

        ax = a[0], bx = b[0], cx = c[0],
        ay = a[1], by = b[1], cy = c[1],

        abd = ax * by - ay * bx,
        acd = ax * cy - ay * cx,
        cbd = cx * by - cy * bx,
        A = abd - acd - cbd;

    if (A <= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear

    var cay = cy - ay,
        acx = ax - cx,
        aby = ay - by,
        bax = bx - ax,
        p, px, py, s, t, k, node;

    // if we use z-order curve hashing, iterate through the curve
    if (minX !== undefined) {

        // triangle bbox; min & max are calculated like this for speed
        var minTX = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            minTY = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            maxTX = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            maxTY = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy),

            // z-order range for the current triangle bbox;
            minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);

        // first look for points inside the triangle in increasing z-order
        node = ear.nextZ;

        while (node && node.z <= maxZ) {
            p = node.p;
            node = node.nextZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

        // then look for points in decreasing z-order
        node = ear.prevZ;

        while (node && node.z >= minZ) {
            p = node.p;
            node = node.prevZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

    // if we don't use z-order curve hash, simply iterate through all other points
    } else {
        node = ear.next.next;

        while (node !== ear.prev) {
            p = node.p;
            node = node.next;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }
    }

    return true;
}

function splitEarcut(start, triangles, minX, minY, size) {
    // find a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // run earcut on each half
                earcutLinked(a, triangles, minX, minY, size);
                earcutLinked(c, triangles, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function eliminateHoles(points, outerNode) {
    var len = points.length;

    var queue = [];
    for (var i = 1; i < len; i++) {
        var list = filterPoints(linkedList(points[i], false));
        if (list) queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode);
    }

    return outerNode;
}

function eliminateHole(holeNode, outerNode) {
    outerNode = findHoleBridge(holeNode, outerNode);
    if (outerNode) splitPolygon(holeNode, outerNode);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(holeNode, outerNode) {
    var node = outerNode,
        p = holeNode.p,
        px = p[0],
        py = p[1],
        qMax = -Infinity,
        mNode, a, b;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        a = node.p;
        b = node.next.p;

        if (py <= a[1] && py >= b[1]) {
            var qx = a[0] + (py - a[1]) * (b[0] - a[0]) / (b[1] - a[1]);
            if (qx <= px && qx > qMax) {
                qMax = qx;
                mNode = a[0] < b[0] ? node : node.next;
            }
        }
        node = node.next;
    } while (node !== outerNode);

    if (!mNode) return null;

    // look for points strictly inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var bx = mNode.p[0],
        by = mNode.p[1],
        pbd = px * by - py * bx,
        pcd = px * py - py * qMax,
        cpy = py - py,
        pcx = px - qMax,
        pby = py - by,
        bpx = bx - px,
        A = pbd - pcd - (qMax * by - py * bx),
        sign = A <= 0 ? -1 : 1,
        stop = mNode,
        tanMin = Infinity,
        mx, my, amx, s, t, tan;

    node = mNode.next;

    while (node !== stop) {

        mx = node.p[0];
        my = node.p[1];
        amx = px - mx;

        if (amx >= 0 && mx >= bx) {
            s = (cpy * mx + pcx * my - pcd) * sign;
            if (s >= 0) {
                t = (pby * mx + bpx * my + pbd) * sign;

                if (t >= 0 && A * sign - s - t >= 0) {
                    tan = Math.abs(py - my) / amx; // tangential
                    if (tan < tanMin && locallyInside(node, holeNode)) {
                        mNode = node;
                        tanMin = tan;
                    }
                }
            }
        }

        node = node.next;
    }

    return mNode;
}

function indexCurve(start, minX, minY, size) {
    var node = start;

    do {
        node.z = node.z || zOrder(node.p[0], node.p[1], minX, minY, size);
        node.prevZ = node.prev;
        node.nextZ = node.next;
        node = node.next;
    } while (node !== start);

    node.prevZ.nextZ = null;
    node.prevZ = null;

    sortLinked(node);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    while (true) {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;

        if (numMerges <= 1) return list;

        inSize *= 2;
    }
}

// z-order of a point given coords and bbox
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into (0..1000) integer range
    x = 1000 * (x - minX) / size;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = 1000 * (y - minY) / size;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

function getLeftmost(start) {
    var node = start,
        leftmost = start;
    do {
        if (node.p[0] < leftmost.p[0]) leftmost = node;
        node = node.next;
    } while (node !== start);

    return leftmost;
}

function isValidDiagonal(a, b) {
    return !intersectsPolygon(a, a.p, b.p) &&
           locallyInside(a, b) && locallyInside(b, a) &&
           middleInside(a, a.p, b.p);
}

// winding order of triangle formed by 3 given points
function orient(p, q, r) {
    var o = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    return o > 0 ? 1 :
           o < 0 ? -1 : 0;
}

function equals(p1, p2) {
    return p1[0] === p2[0] && p1[1] === p2[1];
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return orient(p1, q1, p2) !== orient(p1, q1, q2) &&
           orient(p2, q2, p1) !== orient(p2, q2, q1);
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(start, a, b) {
    var node = start;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (p1 !== a && p2 !== a && p1 !== b && p2 !== b && intersects(p1, p2, a, b)) return true;

        node = node.next;
    } while (node !== start);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return orient(a.prev.p, a.p, a.next.p) === -1 ?
        orient(a.p, b.p, a.next.p) !== -1 && orient(a.p, a.prev.p, b.p) !== -1 :
        orient(a.p, b.p, a.prev.p) === -1 || orient(a.p, a.next.p, b.p) === -1;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(start, a, b) {
    var node = start,
        inside = false,
        px = (a[0] + b[0]) / 2,
        py = (a[1] + b[1]) / 2;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (((p1[1] > py) !== (p2[1] > py)) &&
            (px < (p2[0] - p1[0]) * (py - p1[1]) / (p2[1] - p1[1]) + p1[0])) inside = !inside;

        node = node.next;
    } while (node !== start);

    return inside;
}

function compareX(a, b) {
    return a.p[0] - b.p[0];
}

// split the polygon vertices circular doubly-linked linked list into two
function splitPolygon(a, b) {
    var a2 = new Node(a.p),
        b2 = new Node(b.p),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return a2;
}

function insertNode(point, last) {
    var node = new Node(point);

    if (!last) {
        node.prev = node;
        node.next = node;

    } else {
        node.next = last.next;
        node.prev = last;
        last.next.prev = node;
        last.next = node;
    }
    return node;
}

function Node(p) {
    this.p = p;
    this.prev = null;
    this.next = null;

    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
}

},{}],21:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matricies
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/*
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/*
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/*
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],22:[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":23}],23:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecared schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":25,"./js-yaml/exception":26,"./js-yaml/loader":27,"./js-yaml/schema":29,"./js-yaml/schema/core":30,"./js-yaml/schema/default_full":31,"./js-yaml/schema/default_safe":32,"./js-yaml/schema/failsafe":33,"./js-yaml/schema/json":34,"./js-yaml/type":35}],24:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (null === subject);
}


function isObject(subject) {
  return (typeof subject === 'object') && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  }
  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],25:[function(require,module,exports){
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== '\n') {
      result += ind;
    }
    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function StringBuilder(source) {
  this.source = source;
  this.result = '';
  this.checkpoint = 0;
}

StringBuilder.prototype.takeUpTo = function (position) {
  var er;

  if (position < this.checkpoint) {
    er = new Error('position should be > checkpoint');
    er.position = position;
    er.checkpoint = this.checkpoint;
    throw er;
  }

  this.result += this.source.slice(this.checkpoint, position);
  this.checkpoint = position;
  return this;
};

StringBuilder.prototype.escapeChar = function () {
  var character, esc;

  character = this.source.charCodeAt(this.checkpoint);
  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
  this.result += esc;
  this.checkpoint += 1;

  return this;
};

StringBuilder.prototype.finish = function () {
  if (this.source.length > this.checkpoint) {
    this.takeUpTo(this.source.length);
  }
};

function writeScalar(state, object, level) {
  var simple, first, spaceWrap, folded, literal, single, double,
      sawLineFeed, linePosition, longestLine, indent, max, character,
      position, escapeSeq, hexEsc, previous, lineLength, modifier,
      trailingLineBreaks, result;

  if (0 === object.length) {
    state.dump = "''";
    return;
  }

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    state.dump = "'" + object + "'";
    return;
  }

  simple = true;
  first = object.length ? object.charCodeAt(0) : 0;
  spaceWrap = (CHAR_SPACE === first ||
               CHAR_SPACE === object.charCodeAt(object.length - 1));

  // Simplified check for restricted first characters
  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
  if (CHAR_MINUS         === first ||
      CHAR_QUESTION      === first ||
      CHAR_COMMERCIAL_AT === first ||
      CHAR_GRAVE_ACCENT  === first) {
    simple = false;
  }

  // can only use > and | if not wrapped in spaces.
  if (spaceWrap) {
    simple = false;
    folded = false;
    literal = false;
  } else {
    folded = true;
    literal = true;
  }

  single = true;
  double = new StringBuilder(object);

  sawLineFeed = false;
  linePosition = 0;
  longestLine = 0;

  indent = state.indent * level;
  max = 80;
  if (indent < 40) {
    max -= indent;
  } else {
    max = 40;
  }

  for (position = 0; position < object.length; position++) {
    character = object.charCodeAt(position);
    if (simple) {
      // Characters that can never appear in the simple scalar
      if (!simpleChar(character)) {
        simple = false;
      } else {
        // Still simple.  If we make it all the way through like
        // this, then we can just dump the string as-is.
        continue;
      }
    }

    if (single && character === CHAR_SINGLE_QUOTE) {
      single = false;
    }

    escapeSeq = ESCAPE_SEQUENCES[character];
    hexEsc = needsHexEscape(character);

    if (!escapeSeq && !hexEsc) {
      continue;
    }

    if (character !== CHAR_LINE_FEED &&
        character !== CHAR_DOUBLE_QUOTE &&
        character !== CHAR_SINGLE_QUOTE) {
      folded = false;
      literal = false;
    } else if (character === CHAR_LINE_FEED) {
      sawLineFeed = true;
      single = false;
      if (position > 0) {
        previous = object.charCodeAt(position - 1);
        if (previous === CHAR_SPACE) {
          literal = false;
          folded = false;
        }
      }
      if (folded) {
        lineLength = position - linePosition;
        linePosition = position;
        if (lineLength > longestLine) {
          longestLine = lineLength;
        }
      }
    }

    if (character !== CHAR_DOUBLE_QUOTE) {
      single = false;
    }

    double.takeUpTo(position);
    double.escapeChar();
  }

  if (simple && testImplicitResolving(state, object)) {
    simple = false;
  }

  modifier = '';
  if (folded || literal) {
    trailingLineBreaks = 0;
    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
      trailingLineBreaks += 1;
      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
        trailingLineBreaks += 1;
      }
    }

    if (trailingLineBreaks === 0) {
      modifier = '-';
    } else if (trailingLineBreaks === 2) {
      modifier = '+';
    }
  }

  if (literal && longestLine < max) {
    folded = false;
  }

  // If it's literally one line, then don't bother with the literal.
  // We may still want to do a fold, though, if it's a super long line.
  if (!sawLineFeed) {
    literal = false;
  }

  if (simple) {
    state.dump = object;
  } else if (single) {
    state.dump = '\'' + object + '\'';
  } else if (folded) {
    result = fold(object, max);
    state.dump = '>' + modifier + '\n' + indentString(result, indent);
  } else if (literal) {
    if (!modifier) {
      object = object.replace(/\n$/, '');
    }
    state.dump = '|' + modifier + '\n' + indentString(object, indent);
  } else if (double) {
    double.finish();
    state.dump = '"' + double.result + '"';
  } else {
    throw new Error('Failed to dump scalar value');
  }

  return;
}

// The `trailing` var is a regexp match of any trailing `\n` characters.
//
// There are three cases we care about:
//
// 1. One trailing `\n` on the string.  Just use `|` or `>`.
//    This is the assumed default. (trailing = null)
// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
//
// In the case of `>+`, these line breaks are *not* doubled (like the line
// breaks within the string), so it's important to only end with the exact
// same number as we started.
function fold(object, max) {
  var result = '',
      position = 0,
      length = object.length,
      trailing = /\n+$/.exec(object),
      newLine;

  if (trailing) {
    length = trailing.index + 1;
  }

  while (position < length) {
    newLine = object.indexOf('\n', position);
    if (newLine > length || newLine === -1) {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, length), max);
      position = length;
    } else {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, newLine), max);
      position = newLine + 1;
    }
  }
  if (trailing && trailing[0] !== '\n') {
    result += trailing[0];
  }

  return result;
}

function foldLine(line, max) {
  if (line === '') {
    return line;
  }

  var foldRe = /[^\s] [^\s]/g,
      result = '',
      prevMatch = 0,
      foldStart = 0,
      match = foldRe.exec(line),
      index,
      foldEnd,
      folded;

  while (match) {
    index = match.index;

    // when we cross the max len, if the previous match would've
    // been ok, use that one, and carry on.  If there was no previous
    // match on this fold section, then just have a long line.
    if (index - foldStart > max) {
      if (prevMatch !== foldStart) {
        foldEnd = prevMatch;
      } else {
        foldEnd = index;
      }

      if (result) {
        result += '\n';
      }
      folded = line.slice(foldStart, foldEnd);
      result += folded;
      foldStart = foldEnd + 1;
    }
    prevMatch = index + 1;
    match = foldRe.exec(line);
  }

  if (result) {
    result += '\n';
  }

  // if we end up with one last word at the end, then the last bit might
  // be slightly bigger than we wanted, because we exited out of the loop.
  if (foldStart !== prevMatch && line.length - foldStart > max) {
    result += line.slice(foldStart, prevMatch) + '\n' +
              line.slice(prevMatch + 1);
  } else {
    result += line.slice(foldStart);
  }

  return result;
}

// Returns true if character can be found in a simple scalar
function simpleChar(character) {
  return CHAR_TAB                  !== character &&
         CHAR_LINE_FEED            !== character &&
         CHAR_CARRIAGE_RETURN      !== character &&
         CHAR_COMMA                !== character &&
         CHAR_LEFT_SQUARE_BRACKET  !== character &&
         CHAR_RIGHT_SQUARE_BRACKET !== character &&
         CHAR_LEFT_CURLY_BRACKET   !== character &&
         CHAR_RIGHT_CURLY_BRACKET  !== character &&
         CHAR_SHARP                !== character &&
         CHAR_AMPERSAND            !== character &&
         CHAR_ASTERISK             !== character &&
         CHAR_EXCLAMATION          !== character &&
         CHAR_VERTICAL_LINE        !== character &&
         CHAR_GREATER_THAN         !== character &&
         CHAR_SINGLE_QUOTE         !== character &&
         CHAR_DOUBLE_QUOTE         !== character &&
         CHAR_PERCENT              !== character &&
         CHAR_COLON                !== character &&
         !ESCAPE_SEQUENCES[character]            &&
         !needsHexEscape(character);
}

// Returns true if the character code needs to be escaped.
function needsHexEscape(character) {
  return !((0x00020 <= character && character <= 0x00007E) ||
           (0x00085 === character)                         ||
           (0x000A0 <= character && character <= 0x00D7FF) ||
           (0x0E000 <= character && character <= 0x00FFFD) ||
           (0x10000 <= character && character <= 0x10FFFF));
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump, level);
      }
    } else {
      if (state.skipInvalid) {
        return false;
      }
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  }
  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":24,"./exception":26,"./schema/default_full":31,"./schema/default_safe":32}],26:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],27:[function(require,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,
                             ((c - 0x010000) & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position + 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else if (detectedIndent) {
      // If current line isn't the first one - count line break from the last content line.
      state.result += common.repeat('\n', emptyLines + 1);
    } else {
      // In case of the first content line - count only empty lines.
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (1 === indentStatus) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (1 === indentStatus) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (0 === indentStatus) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
        0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":24,"./exception":26,"./mark":28,"./schema/default_full":31,"./schema/default_safe":32}],28:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":24}],29:[function(require,module,exports){
'use strict';

/*eslint-disable max-len*/

var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":24,"./exception":26,"./type":35}],30:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":29,"./json":34}],31:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":29,"../type/js/function":40,"../type/js/regexp":41,"../type/js/undefined":42,"./default_safe":32}],32:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":29,"../type/binary":36,"../type/merge":44,"../type/omap":46,"../type/pairs":47,"../type/set":49,"../type/timestamp":51,"./core":30}],33:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":29,"../type/map":43,"../type/seq":48,"../type/str":50}],34:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":29,"../type/bool":37,"../type/float":38,"../type/int":39,"../type/null":45,"./failsafe":33}],35:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":26}],36:[function(require,module,exports){
'use strict';

/*eslint-disable no-bitwise*/

// A trick for browserified version.
// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (null === data) {
    return false;
  }

  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) { continue; }

    // Fail on illegal characters
    if (code < 0) { return false; }

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":35,"buffer":14}],37:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (null === data) {
    return false;
  }

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":35}],38:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (null === data) {
    return false;
  }

  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }
  return object.toString(10);
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":24,"../type":35}],39:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (null === data) {
    return false;
  }

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) { return true; }
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }

  // base 10 (except 0) or base 60

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }

  // if !base60 - done;
  if (ch !== ':') { return true; }

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":24,"../type":35}],40:[function(require,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  esprima = require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') { esprima = window.esprima; }
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (null === data) {
    return false;
  }

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":35,"esprima":52}],41:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (null === data) {
    return false;
  }

  if (0 === data.length) {
    return false;
  }

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":35}],42:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":35}],43:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return null !== data ? data : {}; }
});

},{"../type":35}],44:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data || null === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":35}],45:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (null === data) {
    return true;
  }

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":35}],46:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (null === data) {
    return true;
  }

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

function constructYamlOmap(data) {
  return null !== data ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":35}],47:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (null === data) {
    return true;
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (null === data) {
    return [];
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":35}],48:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return null !== data ? data : []; }
});

},{"../type":35}],49:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (null === data) {
    return true;
  }

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

function constructYamlSet(data) {
  return null !== data ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":35}],50:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return null !== data ? data : ''; }
});

},{"../type":35}],51:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (null === data) {
    return false;
  }

  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":35}],52:[function(require,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        sourceType,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    TokenName[Token.Template] = 'Template';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        ObjectPatternAsRestParameter: 'Unexpected token {',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }

    function octalToDecimal(ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + '01234567'.indexOf(source[index++]);

            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 &&
                    index < length &&
                    isOctalDigit(source[index])) {
                code = code * 8 + '01234567'.indexOf(source[index++]);
            }
        }

        return {
            code: code,
            octal: octal
        };
    }

    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'enum':
        case 'export':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    // 11.6.2.2 Future Reserved Words

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index;
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        // Ran off the end of the file - the whole thing is a comment
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            comment = source.slice(start + 2, index);
            addComment('Block', comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwUnexpectedToken();
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwUnexpectedToken();
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var token, str;

        token = {
            type: Token.Punctuator,
            value: '',
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };

        // Check for most common single-character punctuators.
        str = source[index];
        switch (str) {

        case '(':
            if (extra.tokenize) {
                extra.openParenToken = extra.tokens.length;
            }
            ++index;
            break;

        case '{':
            if (extra.tokenize) {
                extra.openCurlyToken = extra.tokens.length;
            }
            state.curlyStack.push('{');
            ++index;
            break;

        case '.':
            ++index;
            if (source[index] === '.' && source[index + 1] === '.') {
                // Spread operator: ...
                index += 2;
                str = '...';
            }
            break;

        case '}':
            ++index;
            state.curlyStack.pop();
            break;
        case ')':
        case ';':
        case ',':
        case '[':
        case ']':
        case ':':
        case '?':
        case '~':
            ++index;
            break;

        default:
            // 4-character punctuator.
            str = source.substr(index, 4);
            if (str === '>>>=') {
                index += 4;
            } else {

                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                    str === '<<=' || str === '>>=') {
                    index += 3;
                } else {

                    // 2-character punctuators.
                    str = str.substr(0, 2);
                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                        str === '<=' || str === '>=' || str === '=>') {
                        index += 2;
                    } else {

                        // 1-character punctuators.
                        str = source[index];
                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                            ++index;
                        }
                    }
                }
            }
        }

        if (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        return token;
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) {
                                throw throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;
                    case '8':
                    case '9':
                        throw throwUnexpectedToken();

                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        };
    }

    function scanTemplate() {
        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = false;
        tail = false;
        start = index;
        head = (source[index] === '`');
        rawOffset = 2;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    state.curlyStack.push('${');
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (ch === '0') {
                            if (isDecimalDigit(source.charCodeAt(index))) {
                                // Illegal: \01 \02 and so on
                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += '\0';
                        } else if (isOctalDigit(ch)) {
                            // Illegal: \1 \2
                            throwError(Messages.TemplateOctalLiteral);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwUnexpectedToken();
        }

        if (!head) {
            state.curlyStack.pop();
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var tmp = pattern;

        if (flags.indexOf('u') >= 0) {
            // Replace each astral symbol and every Unicode escape sequence
            // that possibly represents an astral symbol or a paired surrogate
            // with a single ASCII symbol to avoid throwing on regular
            // expressions that are only valid in combination with the `/u`
            // flag.
            // Note: replacing with the ASCII symbol `x` might cause false
            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
            // perfectly valid pattern that is equivalent to `[a-b]`, but it
            // would be replaced by `[x-b]` which throws an error.
            tmp = tmp
                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                    if (parseInt($1, 16) <= 0x10FFFF) {
                        return 'x';
                    }
                    throwUnexpectedToken(null, Messages.InvalidRegExp);
                })
                .replace(
                    /\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    'x'
                );
        }

        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        } catch (e) {
            throwUnexpectedToken(null, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        scanning = true;
        var start, body, flags, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch, token;

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            return token;
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }

        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (ch === 0x60 || (ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
            return scanTemplate();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;
        scanning = true;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
        return token;
    }

    function peek() {
        scanning = true;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null;
    }

    function Node() {
        if (extra.range) {
            this.range = [startIndex, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            if (last) {
                while (last && last.range[0] >= this.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
                    this.leadingComments = lastChild.leadingComments;
                    lastChild.leadingComments = undefined;
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = lastIndex;
            }
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrayPattern: function (elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishAssignmentPattern: function (left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassBody: function (body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassDeclaration: function (id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassExpression: function (id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishObjectPattern: function (properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body) {
            this.type = Syntax.Program;
            this.body = body;
            if (sourceType === 'module') {
                // very restrictive for now
                this.sourceType = sourceType;
            }
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishRestElement: function (argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSpreadElement: function (argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSuper: function () {
            this.type = Syntax.Super;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishTaggedTemplateExpression: function (tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this;
        },

        finishTemplateElement: function (value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this;
        },

        finishTemplateLiteral: function (quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [ handler ] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = 'var';
            this.finish();
            return this;
        },

        finishLexicalDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        },

        finishExportSpecifier: function (local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportDefaultSpecifier: function (local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportNamespaceSpecifier: function (local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishExportNamedDeclaration: function (declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishExportDefaultDeclaration: function (declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this;
        },

        finishExportAllDeclaration: function (src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this;
        },

        finishImportSpecifier: function (local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this;
        },

        finishImportDeclaration: function (specifiers, src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        }
    };


    function recordError(error) {
        var e, existing;

        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            // Prevent duplicated error.
            /* istanbul ignore next */
            if (existing.index === error.index && existing.message === error.message) {
                return;
            }
        }

        extra.errors.push(error);
    }

    function createError(line, pos, description) {
        var error = new Error('Line ' + line + ': ' + description);
        error.index = pos;
        error.lineNumber = line;
        error.column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error.description = description;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;

        if (token) {
            if (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } else {
            value = 'ILLEGAL';
        }

        msg = msg.replace('%0', value);

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
            lex();
            return;
        }

        if (hasLineTerminator) {
            return;
        }

        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements â AssignmentTargets â AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result;
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result;
    }

    function parseArrayPattern() {
        var node = new Node(), elements = [], rest, restNode;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                if (match('...')) {
                    restNode = new Node();
                    lex();
                    rest = parseVariableIdentifier();
                    elements.push(restNode.finishRestElement(rest));
                    break;
                } else {
                    elements.push(parsePatternWithDefault());
                }
                if (!match(']')) {
                    expect(',');
                }
            }

        }

        expect(']');

        return node.finishArrayPattern(elements);
    }

    function parsePropertyPattern() {
        var node = new Node(), key, computed = match('['), init;
        if (lookahead.type === Token.Identifier) {
            key = parseVariableIdentifier();
            if (match('=')) {
                lex();
                init = parseAssignmentExpression();
                return node.finishProperty(
                    'init', key, false,
                    new WrappingNode(key).finishAssignmentPattern(key, init), false, false);
            } else if (!match(':')) {
                return node.finishProperty('init', key, false, key, false, true);
            }
        } else {
            key = parseObjectPropertyKey();
        }
        expect(':');
        init = parsePatternWithDefault();
        return node.finishProperty('init', key, computed, init, false, false);
    }

    function parseObjectPattern() {
        var node = new Node(), properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parsePropertyPattern());
            if (!match('}')) {
                expect(',');
            }
        }

        lex();

        return node.finishObjectPattern(properties);
    }

    function parsePattern() {
        if (lookahead.type === Token.Identifier) {
            return parseVariableIdentifier();
        } else if (match('[')) {
            return parseArrayPattern();
        } else if (match('{')) {
            return parseObjectPattern();
        }
        throwUnexpectedToken(lookahead);
    }

    function parsePatternWithDefault() {
        var startToken = lookahead, pattern, right;
        pattern = parsePattern();
        if (match('=')) {
            lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        return pattern;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], node = new Node(), restSpread;

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else if (match('...')) {
                restSpread = new Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    isAssignmentTarget = isBindingElement = false;
                    expect(',');
                }
                elements.push(restSpread);
            } else {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(node, paramInfo) {
        var previousStrict, body;

        isAssignmentTarget = isBindingElement = false;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        if (strict && paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        if (strict && paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body);
    }

    function parsePropertyMethodFunction() {
        var params, method, node = new Node();

        params = parseParams();
        method = parsePropertyFunction(node, params);

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node(), expr;

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        switch (token.type) {
        case Token.StringLiteral:
        case Token.NumericLiteral:
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        case Token.Identifier:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.Keyword:
            return node.finishIdentifier(token.value);
        case Token.Punctuator:
            if (token.value === '[') {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(']');
                return expr;
            }
            break;
        }
        throwUnexpectedToken(token);
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
        case Token.Identifier:
        case Token.StringLiteral:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.NumericLiteral:
        case Token.Keyword:
            return true;
        case Token.Punctuator:
            return lookahead.value === '[';
        }
        return false;
    }

    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
    // This can only be determined after we consumed up to the left parentheses.
    //
    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
    // is responsible to visit other options.
    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode;

        if (token.type === Token.Identifier) {
            // check for `get` and `set`;

            if (token.value === 'get' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');
                expect(')');
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                });
                return node.finishProperty('get', key, computed, value, false, false);
            } else if (token.value === 'set' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');

                options = {
                    params: [],
                    defaultCount: 0,
                    defaults: [],
                    firstRestricted: null,
                    paramSet: {}
                };
                if (match(')')) {
                    tolerateUnexpectedToken(lookahead);
                } else {
                    parseParam(options);
                    if (options.defaultCount === 0) {
                        options.defaults = [];
                    }
                }
                expect(')');

                value = parsePropertyFunction(methodNode, options);
                return node.finishProperty('set', key, computed, value, false, false);
            }
        }

        if (match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, computed, value, true, false);
        }

        // Not a MethodDefinition.
        return null;
    }

    function checkProto(key, computed, hasProto) {
        if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' ||
            key.type === Syntax.Literal && key.value === '__proto__')) {
            if (hasProto.value) {
                tolerateError(Messages.DuplicateProtoProperty);
            } else {
                hasProto.value = true;
            }
        }
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead, node = new Node(), computed, key, maybeMethod, value;

        computed = match('[');
        key = parseObjectPropertyKey();
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);

        if (maybeMethod) {
            checkProto(maybeMethod.key, maybeMethod.computed, hasProto);
            // finished
            return maybeMethod;
        }

        // init property or short hand property.
        checkProto(key, computed, hasProto);

        if (match(':')) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty('init', key, computed, value, false, false);
        }

        if (token.type === Token.Identifier) {
            if (match('=')) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed,
                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
            }
            return node.finishProperty('init', key, computed, key, false, true);
        }

        throwUnexpectedToken(lookahead);
    }

    function parseObjectInitialiser() {
        var properties = [], hasProto = {value: false}, node = new Node();

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty(hasProto));

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
        case Syntax.Identifier:
        case Syntax.MemberExpression:
        case Syntax.RestElement:
        case Syntax.AssignmentPattern:
            break;
        case Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            break;
        case Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            for (i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            break;
        case Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            for (i = 0; i < expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            break;
        case Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            break;
        default:
            // Allow other node type for tolerant parsing.
            break;
        }
    }

    function parseTemplateElement(option) {
        var node, token;

        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = new Node();
        token = lex();

        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node();

        quasi = parseTemplateElement({ head: true });
        quasis = [ quasi ];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return node.finishTemplateLiteral(quasis, expressions);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr, expressions, startToken, i;

        expect('(');

        if (match(')')) {
            lex();
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: []
            };
        }

        startToken = lookahead;
        if (match('...')) {
            expr = parseRestElement();
            expect(')');
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
        }

        isBindingElement = true;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            isAssignmentTarget = false;
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();

                if (match('...')) {
                    if (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement());
                    expect(')');
                    if (!match('=>')) {
                        expect('=>');
                    }
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(')');

        if (match('=>')) {
            if (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            if (expr.type === Syntax.SequenceExpression) {
                for (i = 0; i < expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = false;
        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression);
        }

        if (match('[')) {
            return inheritCoverGrammar(parseArrayInitialiser);
        }

        if (match('{')) {
            return inheritCoverGrammar(parseObjectInitialiser);
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                return node.finishThisExpression();
            }
            if (matchKeyword('class')) {
                return parseClassExpression();
            }
            throwUnexpectedToken(lex());
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            isAssignmentTarget = isBindingElement = false;
            index = startIndex;

            if (typeof extra.tokens !== 'undefined') {
                token = collectRegex();
            } else {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } else if (type === Token.Template) {
            expr = parseTemplateLiteral();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (startIndex < length) {
                args.push(isolateCoverGrammar(parseAssignmentExpression));
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = isolateCoverGrammar(parseExpression);

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');
        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match('(') ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = false;

        return node.finishNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('(') && !match('.') && !match('[')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                isBindingElement = false;
                isAssignmentTarget = false;
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('[') && !match('.')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
            if (match('++') || match('--')) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = false;

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = false;
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        isAssignmentTarget = isBindingElement = false;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false;
        }

        return expr;
    }

    // [ES6] 14.2 Arrow Function

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return isolateCoverGrammar(parseAssignmentExpression);
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
        case Syntax.Identifier:
            validateParam(options, param, param.name);
            break;
        case Syntax.RestElement:
            checkPatternParam(options, param.argument);
            break;
        case Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            break;
        case Syntax.ArrayPattern:
            for (i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            break;
        default:
            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
            for (i = 0; i < param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            break;
        }
    }
    function reinterpretAsCoverFormalsList(expr) {
        var i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = 0;
        params = [expr];

        switch (expr.type) {
        case Syntax.Identifier:
            break;
        case PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            break;
        default:
            return null;
        }

        options = {
            paramSet: {}
        };

        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
            case Syntax.AssignmentPattern:
                params[i] = param.left;
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                break;
            default:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(null);
                break;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, body;

        if (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect('=>');
        previousStrict = strict;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        expr = parseConditionalExpression();

        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);

            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }

            return expr;
        }

        if (matchAssign()) {
            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
            }

            if (!match('=')) {
                isAssignmentTarget = isBindingElement = false;
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null;
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                if (sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                return parseExportDeclaration();
            case 'import':
                if (sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                return parseImportDeclaration();
            case 'const':
            case 'let':
                return parseLexicalDeclaration({inFor: false});
            case 'function':
                return parseFunctionDeclaration(new Node());
            case 'class':
                return parseClassDeclaration();
            }
        }

        return parseStatement();
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            list.push(parseStatementListItem());
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, node = new Node();

        token = lex();

        if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                throwUnexpectedToken(token);
            }
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration() {
        var init = null, id, node = new Node();

        id = parsePattern();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (match('=')) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } else if (id.type !== Syntax.Identifier) {
            expect('=');
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList() {
        var list = [];

        do {
            list.push(parseVariableDeclaration());
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations);
    }

    function parseLexicalBinding(kind, options) {
        var init = null, id, node = new Node();

        id = parsePattern();

        // 12.2.1
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            if (!matchKeyword('in')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
            expect('=');
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseBindingList(kind, options) {
        var list = [];

        do {
            list.push(parseLexicalBinding(kind, options));
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node();

        kind = lex().value;
        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        return node.finishLexicalDeclaration(declarations, kind);
    }

    function parseRestElement() {
        var param, node = new Node();

        lex();

        if (match('{')) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        param = parseVariableIdentifier();

        if (match('=')) {
            throwError(Messages.DefaultRestParameter);
        }

        if (!match(')')) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        return node.finishRestElement(param);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement(node) {
        expect(';');
        return node.finishEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForStatement(node) {
        var init, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var')) {
                init = new Node();
                lex();

                state.allowIn = false;
                init = init.finishVariableDeclaration(parseVariableDeclarationList());
                state.allowIn = previousAllowIn;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    expect(';');
                }
            } else if (matchKeyword('const') || matchKeyword('let')) {
                init = new Node();
                kind = lex().value;

                state.allowIn = false;
                declarations = parseBindingList(kind, {inFor: true});
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                    init = init.finishLexicalDeclaration(declarations, kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    consumeSemicolon();
                    init = init.finishLexicalDeclaration(declarations, kind);
                }
            } else {
                initStartToken = lookahead;
                state.allowIn = false;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    if (match(',')) {
                        initSeq = [init];
                        while (match(',')) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(';');
                }
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                node.finishForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(startIndex) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (hasLineTerminator) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(lastIndex) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(lastIndex) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (hasLineTerminator) {
            // HACK
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (startIndex < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern();

        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handler = null, finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handler = parseCatchClause();
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (!handler && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, handler, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        isAssignmentTarget = isBindingElement = true;
        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            body.push(parseStatementListItem());
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(body);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, def;

        token = lookahead;
        if (token.value === '...') {
            param = parseRestElement();
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false;
        }

        param = parsePatternWithDefault();
        validateParam(options, token, token.value);

        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;

        expectKeyword('function');
        if (!identifierIsOptional || !match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionDeclaration(id, params, defaults, body);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node();

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionExpression(id, params, defaults, body);
    }


    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

        classBody = new Node();

        expect('{');
        body = [];
        while (!match('}')) {
            if (match(';')) {
                lex();
            } else {
                method = new Node();
                token = lookahead;
                isStatic = false;
                computed = match('[');
                key = parseObjectPropertyKey();
                if (key.name === 'static' && lookaheadPropertyName()) {
                    token = lookahead;
                    isStatic = true;
                    computed = match('[');
                    key = parseObjectPropertyKey();
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method['static'] = isStatic;
                    if (method.kind === 'init') {
                        method.kind = 'method';
                    }
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } else {
                                hasConstructor = true;
                            }
                            method.kind = 'constructor';
                        }
                    } else {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method);
                } else {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        return classBody.finishClassBody(body);
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassDeclaration(id, superClass, classBody);
    }

    function parseClassExpression() {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassExpression(id, superClass, classBody);
    }

    // Modules grammar from:
    // people.mozilla.org/~jorendorff/es6-draft.html

    function parseModuleSpecifier() {
        var node = new Node();

        if (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        return node.finishLiteral(lex());
    }

    function parseExportSpecifier() {
        var exported, local, node = new Node(), def;
        if (matchKeyword('default')) {
            // export {default} from 'something';
            def = new Node();
            lex();
            local = def.finishIdentifier('default');
        } else {
            local = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            exported = parseNonComputedProperty();
        }
        return node.finishExportSpecifier(local, exported);
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier,
            src = null, specifiers = [];

        // non-default export
        if (lookahead.type === Token.Keyword) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
                case 'let':
                case 'const':
                case 'var':
                case 'class':
                case 'function':
                    declaration = parseStatementListItem();
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
            }
        }

        expect('{');
        if (!match('}')) {
            do {
                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
                specifiers.push(parseExportSpecifier());
            } while (match(',') && lex());
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from 'foo';
            // export {foo} from 'foo';
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;

        // covers:
        // export default ...
        expectKeyword('default');

        if (matchKeyword('function')) {
            // covers:
            // export default function foo () {}
            // export default function () {}
            declaration = parseFunctionDeclaration(new Node(), true);
            return node.finishExportDefaultDeclaration(declaration);
        }
        if (matchKeyword('class')) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration);
        }

        if (matchContextualKeyword('from')) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        // export default (1 + 2);
        if (match('{')) {
            expression = parseObjectInitialiser();
        } else if (match('[')) {
            expression = parseArrayInitialiser();
        } else {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression);
    }

    function parseExportAllDeclaration(node) {
        var src;

        // covers:
        // export * from 'foo';
        expect('*');
        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishExportAllDeclaration(src);
    }

    function parseExportDeclaration() {
        var node = new Node();
        if (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword('export');

        if (matchKeyword('default')) {
            return parseExportDefaultDeclaration(node);
        }
        if (match('*')) {
            return parseExportAllDeclaration(node);
        }
        return parseExportNamedDeclaration(node);
    }

    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var local, imported, node = new Node();

        imported = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            local = parseVariableIdentifier();
        }

        return node.finishImportSpecifier(local, imported);
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        if (!match('}')) {
            do {
                specifiers.push(parseImportSpecifier());
            } while (match(',') && lex());
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var local, node = new Node();

        local = parseNonComputedProperty();

        return node.finishImportDefaultSpecifier(local);
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var local, node = new Node();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        return node.finishImportNamespaceSpecifier(local);
    }

    function parseImportDeclaration() {
        var specifiers, src, node = new Node();

        if (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword('import');
        specifiers = [];

        if (lookahead.type === Token.StringLiteral) {
            // covers:
            // import 'foo';
            src = parseModuleSpecifier();
            consumeSemicolon();
            return node.finishImportDeclaration(specifiers, src);
        }

        if (!matchKeyword('default') && isIdentifierName(lookahead)) {
            // covers:
            // import foo
            // import foo, ...
            specifiers.push(parseImportDefaultSpecifier());
            if (match(',')) {
                lex();
            }
        }
        if (match('*')) {
            // covers:
            // import foo, * as foo
            // import * as foo
            specifiers.push(parseImportNamespaceSpecifier());
        } else if (match('{')) {
            // covers:
            // import foo, {bar}
            // import {bar}
            specifiers = specifiers.concat(parseNamedImports());
        }

        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishImportDeclaration(specifiers, src);
    }

    // 14 Program

    function parseScriptBody() {
        var statement, body = [], token, directive, firstRestricted;

        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (startIndex < length) {
            statement = parseStatementListItem();
            /* istanbul ignore if */
            if (typeof statement === 'undefined') {
                break;
            }
            body.push(statement);
        }
        return body;
    }

    function parseProgram() {
        var body, node;

        peek();
        node = new Node();

        body = parseScriptBody();
        return node.finishProgram(body);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        recordError(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };
        sourceType = 'script';
        strict = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            if (options.sourceType === 'module') {
                // very restrictive condition for now
                sourceType = options.sourceType;
                strict = true;
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.2.0';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],53:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof require === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel]);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            persistLevelIfPossible(level);
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function() {
        self.setLevel(self.levels.TRACE);
    };

    self.disableAll = function() {
        self.setLevel(self.levels.SILENT);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],54:[function(require,module,exports){
'use strict';

var whiteList = ['not', 'any', 'all', 'none'];


function notNull(x)  { return x != null; }
function toString(x) { return x.toString(); }
function wrap(x)     { return '(' + x + ')';}

function maybeQuote(value) {
    if (typeof value === 'string') {
        return '"' + value + '"';
    }
    return value;
}

function lookUp(key) {
    if (key.lastIndexOf('$') === 0) {
        return 'context.' + key.substring(1);
    }
    return 'context.feature.properties.' + key;
}

function nullValue(key, value) {
    return {
        type: 'nullValue',
        key: key,
        toString: function () {
            return ' true ';
        }
    };
}

function propertyEqual(key, value) {
    return {
        type: 'propertyEqual',
        opt: '===' ,
        key: key,
        value: value,
        toString: function () {
            return wrap(maybeQuote(this.value) + ' ' + this.opt + ' ' + lookUp(key));
        }
    };
}

function propertyOr(key, values) {
    return {
        type: 'propertyOr',
        key: key,
        values: values.map(function (x) { return propertyEqual(key, x); }),
        toString: function () {
            return wrap(this.values.map(toString).join(' || '));
        }
    };
}

function not(key, value) {
    return {
        type: 'notProperty',
        key: key,
        value: parseFilter(value),
        toString: function () {
            return '!' + wrap(this.value.toString());
        }
    };
}

function none(key, values) {
    return {
        type: 'none',
        values: any(null, values),
        toString: function () {
            return '!' + wrap(this.values.toString());
        }
    };
}

function printNested(values, joiner) {
    return wrap(values.filter(notNull).map(function (x) {
        return wrap(x.join(' && '));
    }).join(' ' + joiner + ' '));
}

function any(_, values) {
    return {
        type: 'any',
        values: values.map(parseFilter),
        toString: function () {
            return printNested(this.values, '||');
        }
    };
}

function all(_, values) {
    return {
        type: 'all',
        values: values.filter(notNull).map(parseFilter),
        toString: function () {
            return printNested(this.values, '&&');
        }
    };
}

function propertyMatchesBoolean(key, value) {
    return {
        type: 'propertyMatchesBoolean',
        key: key,
        value: value,
        toString: function () {
            return wrap(lookUp(this.key) + (this.value ? ' != ' : ' == ')  + 'null');
        }
    };
}

function rangeMatch(key, values) {
    return {
        type: 'rangeMatch',
        key: key,
        values: values,
        toString: function () {
            var expressions = [];

            if (this.values.max) {
                expressions.push('' + lookUp(key) + ' < ' + this.values.max);
            }

            if (this.values.min) {
                expressions.push('' + lookUp(key) + ' >= ' + this.values.min);
            }

            return wrap(expressions.join(' && '));
        }
    };
}

function parseFilter(filter) {
    var filterAST = [];

    // Function filter
    if (typeof filter === 'function') {
        filterAST.push(wrap(filter.toString() + '(context)'));
        return filterAST;
    }

    // Object filter
    var keys = Object.keys(filter);
    keys.forEach(function (key, idx) {

        var value = filter[key],
            type  = typeof value;
        if (type === 'string' || type === 'number') {
            filterAST.push(propertyEqual(key, value));
        } else if (type === 'boolean') {
            filterAST.push(propertyMatchesBoolean(key, value));
        } else if (value == null) {
            filterAST.push(nullValue(key, value));
        } else if (whiteList.indexOf(key) >= 0) {
            switch (key) {
            case 'not':
                filterAST.push(not(key, value));
                break;
            case 'any':
                filterAST.push(any(key, value));
                break;
            case 'all':
                filterAST.push(all(key, value));
                break;
            case 'none':
                filterAST.push(none(key, value));
                break;
            default:
                throw new Error('Unhandled WhiteListed property: ' + key);
            }
        } else if (Array.isArray(value)) {
            filterAST.push(propertyOr(key, value));
        } else if (type === 'object' && value != null) {
            if (value.max || value.min) {
                filterAST.push(rangeMatch(key, value));
            }
        } else {
            throw new Error('Unknown Query sytnax: ' + value);
        }
    });

    return keys.length === 0 ? ['true'] : filterAST;
}

function filterToString(filterAST) {
    return wrap(filterAST.join(' && '));
}

function match(filter) {
    if (filter == null) { return function () { return true; }; }
    // jshint evil: true
    return new Function('context', 'return ' + filterToString(parseFilter(filter)) + ';');
}

module.exports = {
    match: match,
    filterToString: filterToString,
    parseFilter: parseFilter
};

},{}],55:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":57}],56:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f);

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f);

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 21) & 0x7f);

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);

        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":55}],57:[function(require,module,exports){
module.exports=require(17)
},{"/Users/bcamper/Documents/dev/vector-map/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":17}],58:[function(require,module,exports){
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */

'use stric';

var reBlock = '\\/\\*';
var reBlockIgnore = '\\/\\*(?!\\*?\\!)';
var reBlockEnd = '(.|[\\r\\n]|\\n)*?\\*\\/\\n?\\n?';
var reLine = /(^|[^\S\n])(?:\/\/)([\s\S]+?)$/gm;
var reLineIgnore = /(^|[^\S\n])(?:\/\/[^!])([\s\S]+?)$/gm;


/**
 * Strip all comments
 *
 * {%= docs("strip") %}
 *
 * @param   {String} `str`  file contents or string to strip.
 * @param   {Object} `opts`  options are passed to `.block`, and `.line`
 * @return  {String} String without comments.
 * @api public
 */

var strip = module.exports = function(str, opts) {
  return str ? strip.block(strip.line(str, opts), opts) : '';
};


/**
 * Strip only block comments, optionally leaving protected comments
 * (e.g. `/*!`) intact.
 *
 * {%= docs("block") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip only comments that do not start with `/*!` or `/**!`
 * @return  {String} String without block comments.
 * @api public
 */

strip.block = function(str, opts) {
  opts = opts || {};
  var re = new RegExp(reBlock + reBlockEnd, 'gm');
  if(opts.safe) {
    re = new RegExp(reBlockIgnore + reBlockEnd, 'gm');
  }
  return str ? str.replace(re, '') : '';
};


/**
 * Strip only line comments
 *
 * {%= docs("line") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip all that not starts with `//!`
 * @return  {String} String without line comments.
 * @api public
 */

strip.line = function(str, opts) {
  opts = opts || {};
  var re = reLine;
  if(opts.safe) {
    re = reLineIgnore;
  }
  return str ? str.replace(re, '') : '';
};

},{}],59:[function(require,module,exports){
!function() {
  var topojson = {
    version: "1.6.19",
    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },
    meshArcs: meshArcs,
    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },
    mergeArcs: mergeArcs,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function stitchArcs(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function meshArcs(topology, o, filter) {
    var arcs = [];

    if (arguments.length > 1) {
      var geomsByArc = [],
          geom;

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs) { arcs.forEach(polygon); }
      };

      geometry(o);

      geomsByArc.forEach(arguments.length < 3
          ? function(geoms) { arcs.push(geoms[0].i); }
          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
    }

    return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        components = [];

    objects.forEach(function(o) {
      if (o.type === "Polygon") register(o.arcs);
      else if (o.type === "MultiPolygon") o.arcs.forEach(register);
    });

    function register(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function exterior(ring) {
      return cartesianRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var component = [],
            neighbors = [polygon];
        polygon._ = 1;
        components.push(component);
        while (polygon = neighbors.pop()) {
          component.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: components.map(function(polygons) {
        var arcs = [];

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitchArcs(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // this exterior ring has the same winding order
        // as any exterior ring in the original polygons.
        if ((n = arcs.length) > 1) {
          var sgn = exterior(polygons[0][0]);
          for (var i = 0, t; i < n; ++i) {
            if (sgn === exterior(arcs[i])) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
              break;
            }
          }
        }

        return arcs;
      })
    };
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function(o) { return feature(topology, o); })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0].slice());
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
          : null;
    }

    var geometryType = {
      Point: function(o) { return point(o.coordinates); },
      MultiPoint: function(o) { return o.coordinates.map(point); },
      LineString: function(o) { return line(o.arcs); },
      MultiLineString: function(o) { return o.arcs.map(line); },
      Polygon: function(o) { return polygon(o.arcs); },
      MultiPolygon: function(o) { return o.arcs.map(polygon); }
    };

    return geometry(o);
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

    if (!triangleArea) triangleArea = cartesianTriangleArea;

    topology.arcs.forEach(function(arc) {
      var triangles = [],
          maxArea = 0,
          triangle;

      // To store each pointâs effective area, we create a new array rather than
      // extending the passed-in point to workaround a Chrome/V8 bug (getting
      // stuck in smi mode). For midpoints, the initial effective area of
      // Infinity will be computed in the next step.
      for (var i = 0, n = arc.length, p; i < n; ++i) {
        p = arc[i];
        absolute(arc[i] = [p[0], p[1], Infinity], i);
      }

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      }

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }

      while (triangle = heap.pop()) {
        var previous = triangle.previous,
            next = triangle.next;

        // If the area of the current point is less than that of the previous point
        // to be eliminated, use the latter's area instead. This ensures that the
        // current point cannot be eliminated without eliminating previously-
        // eliminated points.
        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
        else maxArea = triangle[1][2];

        if (previous) {
          previous.next = next;
          previous[2] = triangle[2];
          update(previous);
        }

        if (next) {
          next.previous = previous;
          next[0] = triangle[0];
          update(next);
        }
      }

      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  };

  function cartesianRingArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }

    return area * .5;
  }

  function cartesianTriangleArea(triangle) {
    var a = triangle[0], b = triangle[1], c = triangle[2];
    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minAreaHeap() {
    var heap = {},
        array = [],
        size = 0;

    heap.push = function(object) {
      up(array[object._ = size] = object, size++);
      return size;
    };

    heap.pop = function() {
      if (size <= 0) return;
      var removed = array[0], object;
      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
      return removed;
    };

    heap.remove = function(removed) {
      var i = removed._, object;
      if (array[i] !== removed) return; // invalid request
      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
      return i;
    };

    function up(object, i) {
      while (i > 0) {
        var j = ((i + 1) >> 1) - 1,
            parent = array[j];
        if (compareArea(object, parent) >= 0) break;
        array[parent._ = i] = parent;
        array[object._ = i = j] = object;
      }
    }

    function down(object, i) {
      while (true) {
        var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
        if (j === i) break;
        array[child._ = i] = child;
        array[object._ = i = j] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  if (typeof define === "function" && define.amd) define(topojson);
  else if (typeof module === "object" && module.exports) module.exports = topojson;
  else this.topojson = topojson;
}();

},{}],60:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":61,"./lib/vectortilefeature.js":62,"./lib/vectortilelayer.js":63}],61:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":63}],62:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {
            line.push(line[0].clone()); // closePolygon

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type];

    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    if (type === 'Point' && coords.length === 1) {
        coords = coords[0][0];
    } else if (type === 'Point') {
        coords = coords[0];
        type = 'MultiPoint';
    } else if (type === 'LineString' && coords.length === 1) {
        coords = coords[0];
    } else if (type === 'LineString') {
        type = 'MultiLineString';
    }

    return {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };
};

},{"point-geometry":64}],63:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":62}],64:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(Î¸) for Î¸.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],65:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Camera */

var Geo = _interopRequire(require("./geo"));

var Utils = _interopRequire(require("./utils/utils"));

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var glMatrix = _interopRequire(require("gl-matrix"));

var mat4 = glMatrix.mat4;
var vec3 = glMatrix.vec3;

// Abstract base class

var Camera = (function () {
    function Camera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Camera);

        this.scene = scene;
        this.position = options.position;
        this.zoom = options.zoom;
        // this.updateScene();
    }

    _createClass(Camera, {
        update: {

            // Update method called once per frame

            value: function update() {}
        },
        setupProgram: {

            // Called once per frame per program (e.g. for main render pass, then for each additional pass for feature selection, etc.)

            value: function setupProgram(program) {}
        },
        updateScene: {

            /**
                Sync camera position and/or zoom to scene
                position: [lat, lng] or [lat, lng, zoom]
                zoom: zoom
            */

            value: function updateScene() {
                if (this.position || this.zoom) {
                    var view = {};
                    if (this.position) {
                        view = { lng: this.position[0], lat: this.position[1], zoom: this.position[2] };
                    }
                    if (this.zoom) {
                        view.zoom = this.zoom;
                    }
                    this.scene.setView(view);
                }
            }
        }
    }, {
        create: {

            // Create a camera by type name, factory-style

            value: function create(name, scene, config) {
                switch (config.type) {
                    case "isometric":
                        return new IsometricCamera(name, scene, config);
                    case "flat":
                        return new FlatCamera(name, scene, config);
                    case "perspective":
                    /* falls through */
                    default:
                        return new PerspectiveCamera(name, scene, config);
                }
            }
        }
    });

    return Camera;
})();

module.exports = Camera;

/**
    Perspective matrix projection

    This is a specialized perspective camera that, given a desired camera focal length (which can also vary by zoom level),
    constrains the camera height above the ground plane such that the displayed ground area of the map matches that of
    a traditional web mercator map. This means you can set the camera location by [lat, lng, zoom] as you would a typical
    web mercator map, then adjust the focal length as needed.

    Vanishing point can also be adjusted to achieve different "viewing angles", e.g. instead of looking straight down into
    the center of the viewport, the camera appears to be tilted at an angle. For example:

    [0, 0] = looking towards center of viewport
    [-250, -250] = looking 250 pixels from the viewport center to the lower-left corner
    [400, 0] = looking 400 pixels to the right of the viewport center
*/

var PerspectiveCamera = (function (_Camera) {
    function PerspectiveCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, PerspectiveCamera);

        _get(Object.getPrototypeOf(PerspectiveCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "perspective";

        // a single scalar, or pairs of stops mapping zoom levels, e.g. [zoom, focal length]
        this.focal_length = options.focal_length;
        this.fov = options.fov;
        if (!this.focal_length && !this.fov) {
            // Default focal length ranges by zoom
            this.focal_length = [[16, 2], [17, 2.5], [18, 3], [19, 4], [20, 6]];
        }

        this.vanishing_point = options.vanishing_point || [0, 0]; // [x, y]
        this.vanishing_point_skew = [];

        this.position_meters = null;
        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        ShaderProgram.replaceBlock("camera", "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n            }");
    }

    _inherits(PerspectiveCamera, _Camera);

    _createClass(PerspectiveCamera, {
        constrainCamera: {

            // Constrains the camera so that the viewable area matches given the viewport height
            // (in world space, e.g. meters), given either a camera focal length or field-of-view
            // (focal length is used if both are passed).

            value: function constrainCamera(_ref) {
                var view_height = _ref.view_height;
                var height = _ref.height;
                var focal_length = _ref.focal_length;
                var fov = _ref.fov;

                // Solve for camera height
                if (!height) {
                    // We have focal length, calculate FOV
                    if (focal_length) {
                        fov = Math.atan(1 / focal_length) * 2;
                    }
                    // We have FOV, calculate focal length
                    else if (fov) {
                        fov = fov * Math.PI / 180; // convert FOV degrees to radians
                        focal_length = 1 / Math.tan(fov / 2);
                    }

                    // Distance that camera should be from ground such that it fits the field of view expected
                    // for a conventional web mercator map at the current zoom level and camera focal length
                    height = view_height / 2 * focal_length;
                }
                // Solve for camera focal length / field-of-view
                else {
                    focal_length = 2 * height / view_height;
                    fov = Math.atan(1 / focal_length) * 2;
                }

                return { view_height: view_height, height: height, focal_length: focal_length, fov: fov };
            }
        },
        updateMatrices: {
            value: function updateMatrices() {
                // TODO: only re-calculate these vars when necessary

                // Height of the viewport in meters at current zoom
                var viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);

                // Compute camera properties to fit desired view

                var _constrainCamera = this.constrainCamera({
                    view_height: viewport_height,
                    focal_length: Utils.interpolate(this.scene.zoom, this.focal_length),
                    fov: Utils.interpolate(this.scene.zoom, this.fov)
                });

                var height = _constrainCamera.height;
                var fov = _constrainCamera.fov;

                // View matrix
                var position = [this.scene.center_meters.x, this.scene.center_meters.y, height];
                this.position_meters = position;

                // mat4.lookAt(this.viewMatrix,
                //     vec3.fromValues(...position),
                //     vec3.fromValues(position[0], position[1], height - 1),
                //     vec3.fromValues(0, 1, 0));
                // Exclude camera height from view matrix
                mat4.lookAt(this.viewMatrix, vec3.fromValues(position[0], position[1], 0), vec3.fromValues(position[0], position[1], -1), vec3.fromValues(0, 1, 0));

                // Projection matrix
                mat4.perspective(this.projectionMatrix, fov, this.scene.view_aspect, 1, height * 2);

                // Convert vanishing point from pixels to viewport space
                this.vanishing_point_skew[0] = this.vanishing_point[0] / this.scene.css_size.width;
                this.vanishing_point_skew[1] = this.vanishing_point[1] / this.scene.css_size.height;

                // Adjust projection matrix to include vanishing point skew
                this.projectionMatrix[8] = -this.vanishing_point_skew[0]; // z column of x row, e.g. amount z skews x
                this.projectionMatrix[9] = -this.vanishing_point_skew[1]; // z column of y row, e.g. amount z skews y

                // Translate geometry into the distance so that camera is appropriate height above ground
                // Additionally, adjust xy to compensate for any vanishing point skew, e.g. move geometry so that the displayed g
                // plane of the map matches that expected by a traditional web mercator map at this [lat, lng, zoom].
                mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(viewport_height / 2 * this.scene.view_aspect * -this.vanishing_point_skew[0], viewport_height / 2 * -this.vanishing_point_skew[1], 0));

                // Include camera height in projection matrix
                mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(0, 0, -height));
            }
        },
        update: {
            value: function update() {
                _get(Object.getPrototypeOf(PerspectiveCamera.prototype), "update", this).call(this);
                this.updateMatrices();
            }
        },
        setupProgram: {
            value: function setupProgram(program) {
                program.uniform("Matrix4fv", "u_projection", false, this.projectionMatrix);
                program.uniform("3f", "u_eye", 0, 0, this.position_meters[2]);
                program.uniform("2fv", "u_vanishing_point", this.vanishing_point_skew);
            }
        }
    });

    return PerspectiveCamera;
})(Camera);

// Isometric-style projection
// Note: this is actually an "axonometric" projection, but I'm using the colloquial term isometric because it is more recognizable.
// An isometric projection is a specific subset of axonometric projections.
// 'axis' determines the xy skew applied to a vertex based on its z coordinate, e.g. [0, 1] axis causes buildings to be drawn
// straight upwards on screen at their true height, [0, .5] would draw them up at half-height, [1, 0] would be sideways, etc.

var IsometricCamera = (function (_Camera2) {
    function IsometricCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, IsometricCamera);

        _get(Object.getPrototypeOf(IsometricCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "isometric";
        this.axis = options.axis || { x: 0, y: 1 };
        if (this.axis.length === 2) {
            this.axis = { x: this.axis[0], y: this.axis[1] }; // allow axis to also be passed as 2-elem array
        }

        this.position_meters = null;
        this.viewport_height = null;

        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        ShaderProgram.replaceBlock("camera", "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n                // position.xy += position.z * u_isometric_axis;\n\n                // Reverse z for depth buffer so up is negative,\n                // and scale down values so objects higher than one screen height will not get clipped\n                // pull forward slightly to avoid going past far clipping plane\n                position.z = -position.z / 100. + 1. - 0.001;\n            }");
    }

    _inherits(IsometricCamera, _Camera2);

    _createClass(IsometricCamera, {
        update: {
            value: function update() {
                _get(Object.getPrototypeOf(IsometricCamera.prototype), "update", this).call(this);

                this.viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);
                var position = [this.scene.center_meters.x, this.scene.center_meters.y, this.viewport_height];
                this.position_meters = position;

                // View
                mat4.identity(this.viewMatrix);
                mat4.translate(this.viewMatrix, this.viewMatrix, vec3.fromValues(-position[0], -position[1], 0));

                // Projection
                mat4.identity(this.projectionMatrix);

                // apply isometric skew
                this.projectionMatrix[8] = this.axis.x / this.scene.view_aspect; // z column of x row, e.g. amount z skews x
                this.projectionMatrix[9] = this.axis.y; // z column of x row, e.g. amount z skews y

                // convert meters to viewport
                mat4.scale(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(2 / this.scene.viewport_meters.x, 2 / this.scene.viewport_meters.y, 2 / this.scene.viewport_meters.y));
            }
        },
        setupProgram: {
            value: function setupProgram(program) {
                program.uniform("Matrix4fv", "u_projection", false, this.projectionMatrix);

                program.uniform("3f", "u_eye", 0, 0, this.viewport_height);
                // program.uniform('3f', 'u_eye', this.viewport_height * this.axis.x, this.viewport_height * this.axis.y, this.viewport_height);
                program.uniform("2f", "u_vanishing_point", 0, 0);
            }
        }
    });

    return IsometricCamera;
})(Camera);

// Flat projection (e.g. just top-down, no perspective) - a degenerate isometric camera

var FlatCamera = (function (_IsometricCamera) {
    function FlatCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, FlatCamera);

        _get(Object.getPrototypeOf(FlatCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "flat";
    }

    _inherits(FlatCamera, _IsometricCamera);

    _createClass(FlatCamera, {
        update: {
            value: function update() {
                // Axis is fixed to (0, 0) for flat camera
                this.axis.x = 0;
                this.axis.y = 0;

                _get(Object.getPrototypeOf(FlatCamera.prototype), "update", this).call(this);
            }
        }
    });

    return FlatCamera;
})(IsometricCamera);

// this.updateScene();

},{"./geo":67,"./gl/shader_program":71,"./utils/utils":102,"gl-matrix":21}],66:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*jshint worker: true */
/*globals DataSource, topojson */

var Geo = _interopRequire(require("./geo"));

var MethodNotImplemented = require("./utils/errors").MethodNotImplemented;

var Utils = _interopRequire(require("./utils/utils"));

// For TopoJSON tiles

var topojson = _interopRequire(require("topojson"));

// For MVT tiles

var Pbf = _interopRequire(require("pbf"));

var _vectorTile = require("vector-tile");

var VectorTile = _vectorTile.VectorTile;
var VectorTileFeature = _vectorTile.VectorTileFeature;

var DataSource = (function () {
    function DataSource(source) {
        _classCallCheck(this, DataSource);

        this.id = source.id;
        this.name = source.name;
        this.url = source.url;

        // Optional function to transform source data
        this.transform = source.transform;
        if (typeof this.transform === "function") {
            this.transform.bind(this);
        }

        // Optional additional data to pass to the transform function
        this.extra_data = source.extra_data;

        // Optional additional scripts made available to the transform function
        if (typeof importScripts === "function" && source.scripts) {
            source.scripts.forEach(function (s, si) {
                try {
                    importScripts(s);
                    Utils.log("info", "DataSource: loaded library: " + s);
                } catch (e) {
                    Utils.log("error", "DataSource: failed to load library: " + s);
                    Utils.log("error", e);
                }
            });
        }

        // overzoom will apply for zooms higher than this
        this.max_zoom = source.max_zoom || Geo.max_zoom;
    }

    _createClass(DataSource, {
        load: {
            value: function load(dest) {
                throw new MethodNotImplemented("load");
            }
        }
    }, {
        create: {

            // Create a tile source by type, factory-style

            value: function create(source) {
                if (DataSource.types[source.type]) {
                    return new DataSource.types[source.type](source);
                }
            }
        },
        projectData: {

            // Mercator projection

            value: function projectData(source) {
                var timer = +new Date();
                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            var _Geo$latLngToMeters = Geo.latLngToMeters(coord);

                            var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                            var x = _Geo$latLngToMeters2[0];
                            var y = _Geo$latLngToMeters2[1];

                            coord[0] = x;
                            coord[1] = y;
                        });
                    }
                }

                if (source.debug !== undefined) {
                    source.debug.projection = +new Date() - timer;
                }
            }
        },
        scaleData: {

            /**
             Re-scale geometries within each source to the range [0, scale]
             TODO: clip vertices at edges? right now vertices can have
             values outside [0, scale] (over or under bounds); this would
             pose a problem if we wanted to binary encode the vertices in
             fewer bits (e.g. 12 bits each for scale of 4096)
            */

            value: function scaleData(source, _ref) {
                var z = _ref.coords.z;
                var min = _ref.min;

                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            coord[0] = (coord[0] - min.x) * Geo.units_per_meter[z];
                            // TODO: this will create negative y-coords, force positive as below instead? or, if later storing positive coords in bit-packed values, flip to negative in post-processing?
                            coord[1] = (coord[1] - min.y) * Geo.units_per_meter[z];
                            // coord[1] = (coord[1] - tile.max.y) * Geo.units_per_meter[tile.coords.z]; // alternate to force y-coords to be positive, subtract tile max instead of min
                        });
                    }
                }
            }
        },
        register: {

            // Register a new data source type

            value: function register(type_class) {
                if (!type_class || !type_class.type) {
                    return;
                }

                DataSource.types[type_class.type] = type_class;
            }
        }
    });

    return DataSource;
})();

exports["default"] = DataSource;

DataSource.types = {}; // set of supported data source classes, referenced by type name

/*** Generic network loading source - abstract class ***/

var NetworkSource = exports.NetworkSource = (function (_DataSource) {
    function NetworkSource(source) {
        _classCallCheck(this, NetworkSource);

        _get(Object.getPrototypeOf(NetworkSource.prototype), "constructor", this).call(this, source);
        this.response_type = ""; // use to set explicit XHR type
    }

    _inherits(NetworkSource, _DataSource);

    _createClass(NetworkSource, {
        load: {
            value: function load(dest) {
                var _this = this;

                var url = this.formatUrl(dest);

                if (dest.sources == null) {
                    dest.sources = {};
                }

                var source_data = dest.source_data = {};
                source_data.url = url;
                dest.debug = dest.debug || {};
                dest.debug.network = +new Date();

                return new Promise(function (resolve, reject) {
                    source_data.error = null;
                    // For testing network errors
                    // var promise = Utils.io(url, 60 * 100, this.response_type);
                    // if (Math.random() < .7) {
                    //     promise = Promise.reject(Error('fake data source error'));
                    // }
                    // promise.then((body) => {
                    var promise = Utils.io(url, 60 * 1000, _this.response_type);
                    source_data.request = promise.request;

                    promise.then(function (body) {
                        dest.debug.response_size = body.length || body.byteLength;
                        dest.debug.network = +new Date() - dest.debug.network;
                        dest.debug.parsing = +new Date();
                        _this.parseSourceData(dest, source_data, body);
                        dest.debug.parsing = +new Date() - dest.debug.parsing;
                        resolve(dest);
                    })["catch"](function (error) {
                        source_data.error = error.toString();
                        resolve(dest); // resolve request but pass along error
                    });
                });
            }
        },
        formatUrl: {

            // Sub-classes must implement:

            value: function formatUrl(dest) {
                throw new MethodNotImplemented("formatUrl");
            }
        },
        parseSourceData: {
            value: function parseSourceData(dest, source, reponse) {
                throw new MethodNotImplemented("parseSourceData");
            }
        }
    });

    return NetworkSource;
})(DataSource);

/*** Generic network tile loading - abstract class ***/

var NetworkTileSource = exports.NetworkTileSource = (function (_NetworkSource) {
    function NetworkTileSource(source) {
        _classCallCheck(this, NetworkTileSource);

        _get(Object.getPrototypeOf(NetworkTileSource.prototype), "constructor", this).call(this, source);

        this.tiled = true;
        this.url_hosts = null;
        var host_match = this.url.match(/{s:\[([^}+]+)\]}/);
        if (host_match != null && host_match.length > 1) {
            this.url_hosts = host_match[1].split(",");
            this.next_host = 0;
        }
    }

    _inherits(NetworkTileSource, _NetworkSource);

    _createClass(NetworkTileSource, {
        formatUrl: {
            value: function formatUrl(tile) {
                var coords = Geo.wrapTile(tile.coords, { x: true });
                var url = this.url.replace("{x}", coords.x).replace("{y}", coords.y).replace("{z}", coords.z);

                if (this.url_hosts != null) {
                    url = url.replace(/{s:\[([^}+]+)\]}/, this.url_hosts[this.next_host]);
                    this.next_host = (this.next_host + 1) % this.url_hosts.length;
                }
                return url;
            }
        }
    });

    return NetworkTileSource;
})(NetworkSource);

/**
 GeoJSON standalone (non-tiled) source
*/

var GeoJSONSource = exports.GeoJSONSource = (function (_NetworkSource2) {
    function GeoJSONSource() {
        _classCallCheck(this, GeoJSONSource);

        if (_NetworkSource2 != null) {
            _NetworkSource2.apply(this, arguments);
        }
    }

    _inherits(GeoJSONSource, _NetworkSource2);

    _createClass(GeoJSONSource, {
        formatUrl: {
            value: function formatUrl(dest) {
                return this.url;
            }
        },
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                source.layers = { _default: JSON.parse(response) };
                DataSource.projectData(source); // mercator projection
            }
        }
    });

    return GeoJSONSource;
})(NetworkSource);

GeoJSONSource.type = "GeoJSON";
DataSource.register(GeoJSONSource);

/**
 Mapzen/OSM.US-style GeoJSON vector tiles
 @class GeoJSONTileSource
*/

var GeoJSONTileSource = exports.GeoJSONTileSource = (function (_NetworkTileSource) {
    function GeoJSONTileSource() {
        _classCallCheck(this, GeoJSONTileSource);

        if (_NetworkTileSource != null) {
            _NetworkTileSource.apply(this, arguments);
        }
    }

    _inherits(GeoJSONTileSource, _NetworkTileSource);

    _createClass(GeoJSONTileSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var data = JSON.parse(response);
                this.prepareGeoJSON(data, tile, source);
            }
        },
        prepareGeoJSON: {
            value: function prepareGeoJSON(data, tile, source) {
                // Apply optional data transform
                if (typeof this.transform === "function") {
                    data = this.transform(data, source);
                }

                // Single layer or multi-layers?
                if (data.type === "Feature" || data.type === "FeatureCollection") {
                    source.layers = { _default: data };
                } else {
                    source.layers = data;
                }

                // A "synthetic" tile that adjusts the tile min anchor to account for tile longitude wrapping
                var anchor = {
                    coords: tile.coords,
                    min: Geo.metersForTile(Geo.wrapTile(tile.coords, { x: true }))
                };

                DataSource.projectData(source); // mercator projection
                DataSource.scaleData(source, anchor); // re-scale from meters to local tile coords
            }
        }
    });

    return GeoJSONTileSource;
})(NetworkTileSource);

GeoJSONTileSource.type = "GeoJSONTiles";
DataSource.register(GeoJSONTileSource);

/**
 Mapzen/OSM.US-style TopoJSON vector tiles
 @class TopoJSONTileSource
*/

var TopoJSONTileSource = exports.TopoJSONTileSource = (function (_GeoJSONTileSource) {
    function TopoJSONTileSource() {
        _classCallCheck(this, TopoJSONTileSource);

        if (_GeoJSONTileSource != null) {
            _GeoJSONTileSource.apply(this, arguments);
        }
    }

    _inherits(TopoJSONTileSource, _GeoJSONTileSource);

    _createClass(TopoJSONTileSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var data = JSON.parse(response);

                // Single layer
                if (data.objects && Object.keys(data.objects).length === 1 && data.objects.vectile != null) {
                    data = topojson.feature(data, data.objects.vectile);
                }
                // Multiple layers
                else {
                    var layers = {};
                    for (var key in data.objects) {
                        layers[key] = topojson.feature(data, data.objects[key]);
                    }
                    data = layers;
                }

                this.prepareGeoJSON(data, tile, source);
            }
        }
    });

    return TopoJSONTileSource;
})(GeoJSONTileSource);

TopoJSONTileSource.type = "TopoJSONTiles";
DataSource.register(TopoJSONTileSource);

/**
 Mapbox Vector Tile format
 @class MVTSource
*/

var MVTSource = exports.MVTSource = (function (_NetworkTileSource2) {
    function MVTSource(source) {
        _classCallCheck(this, MVTSource);

        _get(Object.getPrototypeOf(MVTSource.prototype), "constructor", this).call(this, source);
        this.response_type = "arraybuffer"; // binary data
        this.pad_scale = source.pad_scale || 0.001; // scale tile up by this factor (0.1%) to cover seams
    }

    _inherits(MVTSource, _NetworkTileSource2);

    _createClass(MVTSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var _this = this;

                // Convert Mapbox vector tile to GeoJSON
                var data = new Uint8Array(response);
                var buffer = new Pbf(data);
                source.data = new VectorTile(buffer);
                source.layers = this.toGeoJSON(source.data);
                delete source.data; // comment out to save raw data for debugging

                // Post-processing
                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];

                        // Copy OSM id
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            // Slightly scale up tile to cover seams
                            coord[0] = Math.round(coord[0] * (1 + _this.pad_scale) - 4096 * _this.pad_scale / 2);
                            coord[1] = Math.round(coord[1] * (1 + _this.pad_scale) - 4096 * _this.pad_scale / 2);

                            // Flip Y coord
                            coord[1] = -coord[1];
                        });
                    }
                }
            }
        },
        toGeoJSON: {

            // Loop through layers/features using Mapbox lib API, convert to GeoJSON features
            // Returns an object with keys for each layer, e.g. { layer: geojson }

            value: function toGeoJSON(tile) {
                var layers = {};
                for (var l in tile.layers) {
                    var layer = tile.layers[l];
                    var layer_geojson = {
                        type: "FeatureCollection",
                        features: []
                    };

                    for (var f = 0; f < layer.length; f++) {
                        var feature = layer.feature(f);
                        var feature_geojson = {
                            type: "Feature",
                            geometry: {},
                            properties: feature.properties
                        };

                        var geometry = feature_geojson.geometry;
                        var coordinates = feature.loadGeometry();
                        for (var r = 0; r < coordinates.length; r++) {
                            var ring = coordinates[r];
                            for (var c = 0; c < ring.length; c++) {
                                ring[c] = [ring[c].x, ring[c].y];
                            }
                        }
                        geometry.coordinates = coordinates;

                        if (VectorTileFeature.types[feature.type] === "Point") {
                            geometry.type = "Point";
                            geometry.coordinates = geometry.coordinates[0][0];
                        } else if (VectorTileFeature.types[feature.type] === "LineString") {
                            if (coordinates.length === 1) {
                                geometry.type = "LineString";
                                geometry.coordinates = geometry.coordinates[0];
                            } else {
                                geometry.type = "MultiLineString";
                            }
                        } else if (VectorTileFeature.types[feature.type] === "Polygon") {
                            geometry.type = "Polygon";
                        }

                        layer_geojson.features.push(feature_geojson);
                    }
                    layers[l] = layer_geojson;
                }
                return layers;
            }
        }
    });

    return MVTSource;
})(NetworkTileSource);

MVTSource.type = "MVT";
DataSource.register(MVTSource);

},{"./geo":67,"./utils/errors":100,"./utils/utils":102,"pbf":56,"topojson":59,"vector-tile":60}],67:[function(require,module,exports){
"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

// Miscellaneous geo functions

var Geo;
module.exports = Geo = {};

// Projection constants
Geo.tile_size = 256;
Geo.half_circumference_meters = 20037508.342789244;
Geo.circumference_meters = Geo.half_circumference_meters * 2;
Geo.min_zoom_meters_per_pixel = Geo.circumference_meters / Geo.tile_size; // min zoom draws world as 2 tiles wide
Geo.meters_per_pixel = [];
Geo.meters_per_tile = [];
Geo.max_zoom = 20;
for (var z = 0; z <= Geo.max_zoom; z++) {
    Geo.meters_per_pixel[z] = Geo.min_zoom_meters_per_pixel / Math.pow(2, z);
    Geo.meters_per_tile[z] = Geo.circumference_meters / Math.pow(2, z);
}

Geo.metersPerPixel = function (zoom) {
    return Geo.min_zoom_meters_per_pixel / Math.pow(2, zoom);
};

// Conversion functions based on an defined tile scale
Geo.units_per_meter = [];
Geo.tile_scale = 4096; // coordinates are locally scaled to the range [0, tile_scale]
Geo.units_per_pixel = Geo.tile_scale / Geo.tile_size;

for (var _z = 0; _z <= Geo.max_zoom; _z++) {
    Geo.units_per_meter[_z] = Geo.tile_scale / (Geo.tile_size * Geo.meters_per_pixel[_z]);
}

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
Geo.metersForTile = function (tile) {
    return {
        x: tile.x * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters,
        y: -(tile.y * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters)
    };
};

/**
   Given a point in mercator meters and a zoom level, return the tile X/Y/Z that the point lies in
*/
Geo.tileForMeters = function (_ref, zoom) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return {
        x: Math.floor((x + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        y: Math.floor((-y + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        z: zoom
    };
};

// Wrap a tile to positive #s for zoom
// Optionally specify the axes to wrap
Geo.wrapTile = function (_ref) {
    var x = _ref.x;
    var y = _ref.y;
    var z = _ref.z;
    var mask = arguments[1] === undefined ? { x: true, y: false } : arguments[1];

    var m = (1 << z) - 1;
    if (mask.x) {
        x = x & m;
    }
    if (mask.y) {
        y = y & m;
    }
    return { x: x, y: y, z: z };
};

/**
   Convert mercator meters to lat-lng
*/
Geo.metersToLatLng = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    x /= Geo.half_circumference_meters;
    y /= Geo.half_circumference_meters;

    y = (2 * Math.atan(Math.exp(y * Math.PI)) - Math.PI / 2) / Math.PI;

    x *= 180;
    y *= 180;

    return [x, y];
};

/**
  Convert lat-lng to mercator meters
*/
Geo.latLngToMeters = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    // Latitude
    y = Math.log(Math.tan(y * Math.PI / 360 + Math.PI / 4)) / Math.PI;
    y *= Geo.half_circumference_meters;

    // Longitude
    x *= Geo.half_circumference_meters / 180;

    return [x, y];
};

Geo.wrapLng = function (x) {
    if (x > 180 || x < -180) {
        x = ((x + 180) % 360 + 360) % 360 - 180;
    }
    return x;
};

// Run an in-place transform function on each cooordinate in a GeoJSON geometry
Geo.transformGeometry = function (geometry, transform) {
    if (geometry.type === "Point") {
        transform(geometry.coordinates);
    } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
        geometry.coordinates.forEach(transform);
    } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
        geometry.coordinates.forEach(function (coordinates) {
            return coordinates.forEach(transform);
        });
    } else if (geometry.type === "MultiPolygon") {
        geometry.coordinates.forEach(function (polygon) {
            polygon.forEach(function (coordinates) {
                return coordinates.forEach(transform);
            });
        });
    }
    // TODO: support GeometryCollection
};

Geo.boxIntersect = function (b1, b2) {
    return !(b2.sw.x > b1.ne.x || b2.ne.x < b1.sw.x || b2.sw.y > b1.ne.y || b2.ne.y < b1.sw.y);
};

// Finds the axis-aligned bounding box for a polygon
Geo.findBoundingBox = function (polygon) {
    var min_x = Infinity,
        max_x = -Infinity,
        min_y = Infinity,
        max_y = -Infinity;

    // Only need to examine outer ring (polygon[0])
    var num_coords = polygon[0].length;
    for (var c = 0; c < num_coords; c++) {
        var coord = polygon[0][c];

        if (coord[0] < min_x) {
            min_x = coord[0];
        }
        if (coord[1] < min_y) {
            min_y = coord[1];
        }
        if (coord[0] > max_x) {
            max_x = coord[0];
        }
        if (coord[1] > max_y) {
            max_y = coord[1];
        }
    }

    return [min_x, min_y, max_x, max_y];
};

// Convert geometry type to one of: 'point', 'line', 'polygon'
Geo.geometryType = function (type) {
    if (type === "Polygon" || type === "MultiPolygon") {
        return "polygon";
    } else if (type === "LineString" || type === "MultiLineString") {
        return "line";
    }
    if (type === "Point" || type === "MultiPoint") {
        return "point";
    }
};

},{}],68:[function(require,module,exports){
// WebGL constants - need to import these separately to make them available in the web worker

"use strict";

var gl;
module.exports = gl = {};

/* DataType */
gl.BYTE = 5120;
gl.UNSIGNED_BYTE = 5121;
gl.SHORT = 5122;
gl.UNSIGNED_SHORT = 5123;
gl.INT = 5124;
gl.UNSIGNED_INT = 5125;
gl.FLOAT = 5126;

},{}],69:[function(require,module,exports){
// WebGL context wrapper

"use strict";

var Context;
module.exports = Context = {};

// Setup a WebGL context
// If no canvas element is provided, one is created and added to the document body
Context.getContext = function getContext(canvas, options) {
    var fullscreen = false;
    if (canvas == null) {
        canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.zIndex = -1;
        document.body.appendChild(canvas);
        fullscreen = true;
    }

    var gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
    if (!gl) {
        throw new Error("Couldn't create WebGL context.");
    }

    Context.resize(gl, window.innerWidth, window.innerHeight, options.device_pixel_ratio);
    if (fullscreen === true) {
        window.addEventListener("resize", function () {
            Context.resize(gl, window.innerWidth, window.innerHeight);
        });
    }

    return gl;
};

Context.resize = function (gl, width, height, device_pixel_ratio) {
    device_pixel_ratio = device_pixel_ratio || window.devicePixelRatio || 1;
    gl.canvas.style.width = width + "px";
    gl.canvas.style.height = height + "px";
    gl.canvas.width = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.canvas.height = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};

},{}],70:[function(require,module,exports){
"use strict";

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var GLSL = {};
module.exports = GLSL;

/**
    Parse uniforms from a JS object, infers types and returns an array of objects with the
    necessary information to set uniform values on a GL program. Each object in the returned
    array has the form:
    { type, method, name, value }

    type: the GL uniform type, such as 'vec3', 'float', etc.
    method: the GL uniform setter method to use, such as '1f', '3fv', etc.
    name: the fully qualified name of the GL uniform location, e.g. 'array[0].field', etc.
    value: the value to be passed to the GL uniform setter for that type, e.g. [1, 2, 3] for a vec3

    Textures have special behavior: uniforms with string values are treated as textures, and
    the string is used as a unique texture 'key' to be interpreted by the caller (which is responsible
    for actually setting the uniforms). For example, this could be used as a key into a dictionary of
    known texture names, or it could simply be used as a URL to dynamically load the texture from.
*/
GLSL.parseUniforms = function (uniforms) {
    var prefix = arguments[1] === undefined ? null : arguments[1];

    var parsed = [];

    for (var name in uniforms) {
        var uniform = uniforms[name];
        var u;

        if (prefix) {
            name = prefix + "." + name;
        }

        // Single float
        if (typeof uniform === "number") {
            parsed.push({
                type: "float",
                method: "1f",
                name: name, value: uniform
            });
        }
        // Array: vector, array of floats, array of textures, or array of structs
        else if (Array.isArray(uniform)) {
            // Numeric values
            if (typeof uniform[0] === "number") {
                // float vectors (vec2, vec3, vec4)
                if (uniform.length >= 2 && uniform.length <= 4) {
                    parsed.push({
                        type: "vec" + uniform.length,
                        method: uniform.length + "fv",
                        name: name,
                        value: uniform
                    });
                }
                // float array
                else if (uniform.length > 4) {
                    parsed.push({
                        type: "float[]",
                        method: "1fv",
                        name: name + "[0]",
                        value: uniform
                    });
                }
                // TODO: assume matrix for (typeof == Float32Array && length == 16)?
            }
            // Array of textures
            else if (typeof uniform[0] === "string") {
                for (u = 0; u < uniform.length; u++) {
                    parsed.push({
                        type: "sampler2D",
                        method: "1i",
                        name: name + "[" + u + "]",
                        value: uniform[u]
                    });
                }
            }
            // Array of arrays - but only arrays of vectors are allowed in this case
            else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === "number") {
                // float vectors (vec2, vec3, vec4)
                if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                    // Set each vector in the array
                    for (u = 0; u < uniform.length; u++) {
                        parsed.push({
                            type: "vec" + uniform[0].length,
                            method: uniform[u].length + "fv",
                            name: name + "[" + u + "]",
                            value: uniform[u]
                        });
                    }
                }
                // else error?
            }
            // Array of structures
            else if (typeof uniform[0] === "object") {
                for (u = 0; u < uniform.length; u++) {
                    // Set each struct in the array
                    parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform[u], name + "[" + u + "]")));
                }
            }
        }
        // Boolean
        else if (typeof uniform === "boolean") {
            parsed.push({
                type: "bool",
                method: "1i",
                name: name,
                value: uniform
            });
        }
        // Texture
        else if (typeof uniform === "string") {
            parsed.push({
                type: "sampler2D",
                method: "1i",
                name: name,
                value: uniform
            });
        }
        // Structure
        else if (typeof uniform === "object") {
            // Set each field in the struct
            parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform, name)));
        }

        // TODO: support other non-float types? (int, etc.)
    }

    return parsed;
};

/**
    Generate a GLSL variable definition from a JS object
*/
GLSL.defineVariable = function (name, value) {
    var prefix = arguments[2] === undefined ? null : arguments[2];

    var type, array;
    var structs = "";
    prefix = prefix ? prefix + "_" + name : name;

    // Single float
    if (typeof value === "number") {
        type = "float";
    }
    // Multiple floats - vector or array
    else if (Array.isArray(value)) {
        // Numeric values
        if (typeof value[0] === "number") {
            // float vectors (vec2, vec3, vec4)
            if (value.length >= 2 && value.length <= 4) {
                type = "vec" + value.length;
            }
            // float array
            else {
                //if (value.length > 4) {
                type = "float";
                array = value.length;
            }
            // TODO: assume matrix for (typeof == Float32Array && length == 16)?
        }
        // Array of textures
        else if (typeof value[0] === "string") {
            type = "sampler2D";
            array = value.length;
        }
        // Array of arrays - but only arrays of vectors are allowed in this case
        else if (Array.isArray(value[0]) && typeof value[0][0] === "number") {
            // float vectors (vec2, vec3, vec4)
            if (value[0].length >= 2 && value[0].length <= 4) {
                type = "vec" + value[0].length;
            }
            // else error?
            array = value[0].length;
        }
        // Array of structures
        else if (typeof value[0] === "object") {
            type = "_type_" + prefix; // custom struct name
            array = value.length;
            structs += GLSL.defineStruct(type, value[0], prefix) + "\n"; // build & add to list of dependent structs
        }
    }
    // Boolean
    else if (typeof value === "boolean") {
        type = "bool";
    }
    // Texture
    else if (typeof value === "string") {
        type = "sampler2D";
    }
    // Structure
    else if (typeof value === "object") {
        type = "_type_" + prefix; // custom struct name
        structs += GLSL.defineStruct(type, value, prefix) + "\n"; // build & add to list of dependent structs
    }

    // Construct variable definition
    var variable = "";
    variable += "" + type + " " + name;
    if (array) {
        variable += "[" + array + "]";
    }
    variable += ";\n";

    // Return the variable definition itself, and any dependent struct definitions
    return { variable: variable, structs: structs };
};

/**
    Generate a GLSL structure definition from a JS object
*/
GLSL.defineStruct = function (type, value) {
    var prefix = arguments[2] === undefined ? null : arguments[2];

    var struct = "struct " + type + " {\n";
    var dependents = "";
    for (var field in value) {
        var subvar = GLSL.defineVariable(field, value[field], prefix);
        struct += "    " + subvar.variable;
        dependents += subvar.structs;
    }
    struct += "};\n";
    struct = dependents + struct;
    return struct;
};

/**
    Generate a GLSL uniform definition from a JS object
*/
GLSL.defineUniform = function (name, value) {
    var def = GLSL.defineVariable(name, value);
    def = def.structs + "uniform " + def.variable;
    return def;
};

/**
    Check for a uniform definition of 'name' in the provided GLSL source
    Simple regex check for 'uniform' keyword and var name, does not attempt to parse/extract GLSL
    NOTE: assumes comments have been stripped from source
*/
GLSL.isUniformDefined = function (name, source) {
    // Match, in order:
    // - the keyword 'uniform'
    // - at least one character that is anything except a semicolon, ;
    // - optionally, anything enclosed in curly braces, { ... } (an inline structure definition can go here)
    // - optionally, any # of characters that is not a semicolon, ;
    // - the name of the uniform

    var re = new RegExp("uniform[^;]+(?:{[\\s\\S]*})?[^;]*\\b" + name + "\\b", "g");
    if (source.match(re)) {
        return true;
    }
    return false;
};

/**
    Check that a symbol is referenced in the GLSL source
    NOTE: assumes comments have been stripped from source
*/
GLSL.isSymbolReferenced = function (name, source) {
    var re = new RegExp("\\b" + name + "\\b", "g");
    if (source.search(re) >= 0) {
        return true;
    }
    return false;
};

/**
    Expand a single value or 2-element array into a 3-element array, with the last ( z )
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec3 = function (v) {
    var z = arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 2) {
        x = [].concat(_toConsumableArray(v), [z]).map(parseFloat);
    } else {
        x = [v, v, v].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === "number" && !isNaN(n);
    })) {
        return x;
    }
};

/**
    Expand a single value or 3-element array into a 4-element array, with the last (e.g. w or a)
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec4 = function (v) {
    var w = arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 3) {
        x = [].concat(_toConsumableArray(v), [w]).map(parseFloat);
    } else {
        x = [v, v, v, w].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === "number" && !isNaN(n);
    })) {
        return x;
    }
};

},{}],71:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global ShaderProgram */
// GL program wrapper to cache uniform locations/values, do compile-time pre-processing
// (injecting #defines and #pragma blocks into shaders), etc.

var GLSL = _interopRequire(require("./glsl"));

var Texture = _interopRequire(require("./texture"));

var log = _interopRequire(require("loglevel"));

var strip = _interopRequire(require("strip-comments"));

var ShaderProgram = (function () {
    function ShaderProgram(gl, vertex_source, fragment_source, options) {
        _classCallCheck(this, ShaderProgram);

        options = options || {};

        this.gl = gl;
        this.program = null;
        this.compiled = false;
        this.compiling = false;
        this.error = null;

        // key/values inserted as #defines into shaders at compile-time
        this.defines = Object.assign({}, options.defines || {});

        // key/values for blocks that can be injected into shaders at compile-time
        this.blocks = Object.assign({}, options.blocks || {});

        // JS-object uniforms that are expected by this program
        // If they are not found in the existing shader source, their types will be inferred and definitions
        // for each will be injected.
        this.dependent_uniforms = options.uniforms;

        this.uniforms = {}; // program locations of uniforms, lazily added as each uniform is set
        this.attribs = {}; // program locations of vertex attributes, lazily added as each attribute is accessed

        this.vertex_source = vertex_source;
        this.fragment_source = fragment_source;

        this.id = ShaderProgram.id++;
        ShaderProgram.programs[this.id] = this;
        this.name = options.name; // can provide a program name (useful for debugging)
    }

    _createClass(ShaderProgram, {
        destroy: {
            value: function destroy() {
                this.gl.useProgram(null);
                this.gl.deleteProgram(this.program);
                this.program = null;
                this.uniforms = {};
                this.attribs = {};
                delete ShaderProgram.programs[this.id];
                this.compiled = false;
            }
        },
        use: {

            // Use program wrapper with simple state cache

            value: function use() {
                if (!this.compiled) {
                    return;
                }

                if (ShaderProgram.current !== this) {
                    this.gl.useProgram(this.program);
                }
                ShaderProgram.current = this;
            }
        },
        compile: {
            value: function compile() {
                if (this.compiling) {
                    throw new Error("ShaderProgram.compile(): skipping for " + this.id + " (" + this.name + ") because already compiling");
                }
                this.compiling = true;
                this.compiled = false;
                this.error = null;

                // Copy sources from pre-modified template
                this.computed_vertex_source = this.vertex_source;
                this.computed_fragment_source = this.fragment_source;

                // Make list of defines to be injected later
                var defines = this.buildDefineList();

                // Inject user-defined blocks (arbitrary code points matching named #pragmas)
                // Replace according to this pattern:
                // #pragma tangram: [key]
                // e.g. #pragma tangram: global

                // Gather all block code snippets
                var blocks = this.buildShaderBlockList();
                var regexp;

                for (var key in blocks) {
                    var block = blocks[key];
                    if (!block || Array.isArray(block) && block.length === 0) {
                        continue;
                    }

                    // First find code replace points in shaders
                    regexp = new RegExp("^\\s*#pragma\\s+tangram:\\s+" + key + "\\s*$", "m");
                    var inject_vertex = this.computed_vertex_source.match(regexp);
                    var inject_fragment = this.computed_fragment_source.match(regexp);

                    // Avoid network request if nothing to replace
                    if (inject_vertex == null && inject_fragment == null) {
                        continue;
                    }

                    // Each key can be a single string or array of strings
                    var source = "\n" + block + "\n";
                    if (Array.isArray(block)) {
                        // Combine all blocks into one string
                        source = block.reduce(function (prev, cur) {
                            return "\n" + prev + "\n" + cur + "\n";
                        });
                    }

                    // Inject
                    if (inject_vertex != null) {
                        this.computed_vertex_source = this.computed_vertex_source.replace(regexp, source);
                    }
                    if (inject_fragment != null) {
                        this.computed_fragment_source = this.computed_fragment_source.replace(regexp, source);
                    }

                    // Add a #define for this injection point
                    defines["TANGRAM_BLOCK_" + key.replace(/[\s-]+/g, "_").toUpperCase()] = true;
                }

                // Clean-up any #pragmas that weren't replaced (to prevent compiler warnings)
                regexp = new RegExp("^\\s*#pragma.*$", "gm");
                this.computed_vertex_source = this.computed_vertex_source.replace(regexp, "");
                this.computed_fragment_source = this.computed_fragment_source.replace(regexp, "");

                // Build & inject defines
                // This is done *after* code injection so that we can add defines for which code points were injected
                defines.TANGRAM_VERTEX_SHADER = true;
                defines.TANGRAM_FRAGMENT_SHADER = false;
                this.computed_vertex_source = ShaderProgram.buildDefineString(defines) + this.computed_vertex_source;

                defines.TANGRAM_VERTEX_SHADER = false;
                defines.TANGRAM_FRAGMENT_SHADER = true;
                this.computed_fragment_source = ShaderProgram.buildDefineString(defines) + this.computed_fragment_source;

                // Detect uniform definitions, inject any missing ones
                this.ensureUniforms(this.dependent_uniforms);

                // Include program info useful for debugging
                var info = this.name ? this.name + " / id " + this.id : "id " + this.id;
                this.computed_vertex_source = "// Program: " + info + "\n" + this.computed_vertex_source;
                this.computed_fragment_source = "// Program: " + info + "\n" + this.computed_fragment_source;

                // Compile & set uniforms to cached values
                try {
                    this.program = ShaderProgram.updateProgram(this.gl, this.program, this.computed_vertex_source, this.computed_fragment_source);
                    this.compiled = true;
                    this.compiling = false;
                } catch (error) {
                    this.program = null;
                    this.compiled = false;
                    this.compiling = false;
                    this.error = error;
                    throw new Error("ShaderProgram.compile(): program " + this.id + " (" + this.name + ") error:", error);
                }

                this.use();
                this.refreshUniforms();
                this.refreshAttributes();
            }
        },
        buildDefineList: {

            // Make list of defines (global, then program-specific)

            value: function buildDefineList() {
                var d,
                    defines = {};
                for (d in ShaderProgram.defines) {
                    defines[d] = ShaderProgram.defines[d];
                }
                for (d in this.defines) {
                    defines[d] = this.defines[d];
                }
                return defines;
            }
        },
        buildShaderBlockList: {

            // Make list of shader blocks (global, then program-specific)

            value: function buildShaderBlockList() {
                var d,
                    blocks = {};
                for (d in ShaderProgram.blocks) {
                    blocks[d] = [];

                    if (Array.isArray(ShaderProgram.blocks[d])) {
                        var _blocks$d;

                        (_blocks$d = blocks[d]).push.apply(_blocks$d, _toConsumableArray(ShaderProgram.blocks[d]));
                    } else {
                        blocks[d] = [ShaderProgram.blocks[d]];
                    }
                }
                for (d in this.blocks) {
                    blocks[d] = blocks[d] || [];

                    if (Array.isArray(this.blocks[d])) {
                        var _blocks$d2;

                        (_blocks$d2 = blocks[d]).push.apply(_blocks$d2, _toConsumableArray(this.blocks[d]));
                    } else {
                        blocks[d].push(this.blocks[d]);
                    }
                }
                return blocks;
            }
        },
        ensureUniforms: {

            // Detect uniform definitions, inject any missing ones

            value: function ensureUniforms(uniforms) {
                if (!uniforms) {
                    return;
                }

                var vs = strip(this.computed_vertex_source);
                var fs = strip(this.computed_fragment_source);
                var inject,
                    vs_injections = [],
                    fs_injections = [];

                // Check for missing uniform definitions
                for (var name in uniforms) {
                    inject = null;

                    // Check vertex shader
                    if (!GLSL.isUniformDefined(name, vs) && GLSL.isSymbolReferenced(name, vs)) {
                        if (!inject) {
                            inject = GLSL.defineUniform(name, uniforms[name]);
                        }
                        log.trace("Program " + this.name + ": " + name + " not defined in vertex shader, injecting: '" + inject + "'");
                        vs_injections.push(inject);
                    }
                    // Check fragment shader
                    if (!GLSL.isUniformDefined(name, fs) && GLSL.isSymbolReferenced(name, fs)) {
                        if (!inject) {
                            inject = GLSL.defineUniform(name, uniforms[name]);
                        }
                        log.trace("Program " + this.name + ": " + name + " not defined in fragment shader, injecting: '" + inject + "'");
                        fs_injections.push(inject);
                    }
                }

                // Inject missing uniforms
                // NOTE: these are injected at the very top of the shaders, even before any #defines or #pragmas are added
                // this could cause some issues with certain #pragmas, or other functions that might expect #defines
                if (vs_injections.length > 0) {
                    this.computed_vertex_source = vs_injections.join("\n") + this.computed_vertex_source;
                }

                if (fs_injections.length > 0) {
                    this.computed_fragment_source = fs_injections.join("\n") + this.computed_fragment_source;
                }
            }
        },
        setUniforms: {

            // Set uniforms from a JS object, with inferred types

            value: function setUniforms(uniforms) {
                var reset_texture_unit = arguments[1] === undefined ? true : arguments[1];

                if (!this.compiled) {
                    return;
                }

                // TODO: only update uniforms when changed

                // Texture units must be tracked and incremented each time a texture sampler uniform is set.
                // By default, the texture unit is reset to 0 each time setUniforms is called, but they can
                // also be preserved, for example in cases where multiple calls to setUniforms are expected
                // (e.g. program-specific uniforms followed by mesh-specific ones).
                if (reset_texture_unit) {
                    this.texture_unit = 0;
                }

                // Parse uniform types and values from the JS object
                var parsed = GLSL.parseUniforms(uniforms);

                // Set each uniform
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = parsed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var uniform = _step.value;

                        if (uniform.type === "sampler2D") {
                            // For textures, we need to track texture units, so we have a special setter
                            this.setTextureUniform(uniform.name, uniform.value);
                        } else {
                            this.uniform(uniform.method, uniform.name, uniform.value);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        saveUniforms: {

            // Cache some or all uniform values so they can be restored

            value: function saveUniforms(subset) {
                var uniforms = subset || this.uniforms;
                for (var u in uniforms) {
                    var uniform = this.uniforms[u];
                    if (uniform) {
                        uniform.saved_value = uniform.value;
                    }
                }
                this.saved_texture_unit = this.texture_unit || 0;
            }
        },
        restoreUniforms: {

            // Restore some or all uniforms to saved values

            value: function restoreUniforms(subset) {
                var uniforms = subset || this.uniforms;
                for (var u in uniforms) {
                    var uniform = this.uniforms[u];
                    if (uniform && uniform.saved_value) {
                        uniform.value = uniform.saved_value;
                        this.updateUniform(u);
                    }
                }
                this.texture_unit = this.saved_texture_unit || 0;
            }
        },
        setTextureUniform: {

            // Set a texture uniform, finds texture by name or creates a new one

            value: function setTextureUniform(uniform_name, texture_name) {
                var texture = Texture.textures[texture_name];
                if (texture == null) {
                    texture = new Texture(this.gl, texture_name);
                    texture.load(texture_name);
                }

                texture.bind(this.texture_unit);
                this.uniform("1i", uniform_name, this.texture_unit);
                this.texture_unit++; // TODO: track max texture units and log/throw errors
            }
        },
        uniform: {

            // ex: program.uniform('3f', 'position', x, y, z);
            // TODO: only update uniforms when changed

            value: function uniform(method, name) {
                for (var _len = arguments.length, value = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    value[_key - 2] = arguments[_key];
                }

                // 'value' is a method-appropriate arguments list
                if (!this.compiled) {
                    return;
                }

                this.uniforms[name] = this.uniforms[name] || {};
                var uniform = this.uniforms[name];
                uniform.name = name;
                if (uniform.location === undefined) {
                    uniform.location = this.gl.getUniformLocation(this.program, name);
                }
                uniform.method = "uniform" + method;
                uniform.value = value;
                this.updateUniform(name);
            }
        },
        updateUniform: {

            // Set a single uniform

            value: function updateUniform(name) {
                if (!this.compiled) {
                    return;
                }

                var uniform = this.uniforms[name];
                if (!uniform || uniform.location == null) {
                    return;
                }

                this.use();
                this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value)); // call appropriate GL uniform method and pass through arguments
            }
        },
        refreshUniforms: {

            // Refresh uniform locations and set to last cached values

            value: function refreshUniforms() {
                if (!this.compiled) {
                    return;
                }

                for (var u in this.uniforms) {
                    this.uniforms[u].location = this.gl.getUniformLocation(this.program, u);
                    this.updateUniform(u);
                }
            }
        },
        refreshAttributes: {
            value: function refreshAttributes() {
                // var len = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
                // for (var i=0; i < len; i++) {
                //     var a = this.gl.getActiveAttrib(this.program, i);
                // }
                this.attribs = {};
            }
        },
        attribute: {

            // Get the location of a vertex attribute

            value: function attribute(name) {
                if (!this.compiled) {
                    return;
                }

                var attrib = this.attribs[name] = this.attribs[name] || {};
                if (attrib.location != null) {
                    return attrib;
                }

                attrib.name = name;
                attrib.location = this.gl.getAttribLocation(this.program, name);

                // var info = this.gl.getActiveAttrib(this.program, attrib.location);
                // attrib.type = info.type;
                // attrib.size = info.size;

                return attrib;
            }
        }
    });

    return ShaderProgram;
})();

module.exports = ShaderProgram;

// Static methods and state

ShaderProgram.id = 0; // assign each program a unique id
ShaderProgram.programs = {}; // programs, by id
ShaderProgram.current = null; // currently bound program

// Global config applied to all programs (duplicate properties for a specific program will take precedence)
ShaderProgram.defines = {};
ShaderProgram.blocks = {};

// Turn an object of key/value pairs into single string of #define statements
ShaderProgram.buildDefineString = function (defines) {
    var define_str = "";
    for (var d in defines) {
        if (defines[d] === false) {
            continue;
        } else if (typeof defines[d] === "boolean" && defines[d] === true) {
            // booleans are simple defines with no value
            define_str += "#define " + d + "\n";
        } else if (typeof defines[d] === "number" && Math.floor(defines[d]) === defines[d]) {
            // int to float conversion to satisfy GLSL floats
            define_str += "#define " + d + " " + defines[d].toFixed(1) + "\n";
        } else {
            // any other float or string value
            define_str += "#define " + d + " " + defines[d] + "\n";
        }
    }
    return define_str;
};

ShaderProgram.addBlock = function (key) {
    var _ShaderProgram$blocks$key;

    for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        blocks[_key - 1] = arguments[_key];
    }

    ShaderProgram.blocks[key] = ShaderProgram.blocks[key] || [];
    (_ShaderProgram$blocks$key = ShaderProgram.blocks[key]).push.apply(_ShaderProgram$blocks$key, blocks);
};

// Remove all global shader blocks for a given key
ShaderProgram.removeBlock = function (key) {
    ShaderProgram.blocks[key] = [];
};

ShaderProgram.replaceBlock = function (key) {
    for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        blocks[_key - 1] = arguments[_key];
    }

    ShaderProgram.removeBlock(key);
    ShaderProgram.addBlock.apply(ShaderProgram, [key].concat(blocks));
};

// Compile & link a WebGL program from provided vertex and fragment shader sources
// update a program if one is passed in. Create one if not. Alert and don't update anything if the shaders don't compile.
ShaderProgram.updateProgram = function (gl, program, vertex_shader_source, fragment_shader_source) {
    try {
        var vertex_shader = ShaderProgram.createShader(gl, vertex_shader_source, gl.VERTEX_SHADER);
        var fragment_shader = ShaderProgram.createShader(gl, "#ifdef GL_ES\nprecision highp float;\n#endif\n\n" + fragment_shader_source, gl.FRAGMENT_SHADER);
    } catch (err) {
        log.error(err);
        throw err;
    }

    gl.useProgram(null);
    if (program != null) {
        var old_shaders = gl.getAttachedShaders(program);
        for (var i = 0; i < old_shaders.length; i++) {
            gl.detachShader(program, old_shaders[i]);
        }
    } else {
        program = gl.createProgram();
    }

    if (vertex_shader == null || fragment_shader == null) {
        return program;
    }

    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);

    gl.deleteShader(vertex_shader);
    gl.deleteShader(fragment_shader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var program_error = new Error("WebGL program error:\n            VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n            ERROR: " + gl.getError() + "\n            --- Vertex Shader ---\n            " + vertex_shader_source + "\n            --- Fragment Shader ---\n            " + fragment_shader_source);
        log.error(program_error);
        throw program_error;
    }

    return program;
};

// Compile a vertex or fragment shader from provided source
ShaderProgram.createShader = function (gl, source, type) {
    var shader = gl.createShader(type);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var shader_error = "WebGL shader error:\n" + (type === gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader);
        throw shader_error;
    }

    return shader;
};

},{"./glsl":70,"./texture":73,"loglevel":53,"strip-comments":58}],72:[function(require,module,exports){
// Generated from GLSL files, don't edit!
"use strict";

var shaderSources = {};

shaderSources["gl/shaders/ambientLight"] = "/*\n" + "\n" + "Expected globals:\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct AmbientLight {\n" + "    vec4 ambient;\n" + "};\n" + "\n" + "void calculateLight(in AmbientLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "    light_accumulator_ambient += _light.ambient;\n" + "}\n" + "";

shaderSources["gl/shaders/directionalLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct DirectionalLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec3 direction;\n" + "};\n" + "\n" + "void calculateLight(in DirectionalLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    light_accumulator_ambient += _light.ambient;\n" + "\n" + "    float nDotVP = clamp(dot(_normal, -normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(normalize(_light.direction), _normal);\n" + "            float eyeDotR = max(dot(normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/layer_order"] = "// Apply layer ordering to avoid z-fighting\n" + "void applyLayerOrder (float layer, inout vec4 position) {\n" + "    position.z -= layer * TANGRAM_LAYER_DELTA * position.w;\n" + "}\n" + "";

shaderSources["gl/shaders/material"] = "/*\n" + "\n" + "Defines globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "\n" + "// MATERIALS\n" + "//\n" + "struct Material {\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION\n" + "        vec4 emission;\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "            vec3 emissionScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        vec4 ambient;\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "            vec3 ambientScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        vec4 diffuse;\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "            vec3 diffuseScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        vec4 specular;\n" + "        float shininess;\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "            vec3 specularScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        vec3 normalScale;\n" + "        float normalAmount;\n" + "    #endif\n" + "};\n" + "\n" + "// Note: uniform is copied to a global instance to allow modification\n" + "uniform Material u_material;\n" + "Material material = u_material;\n" + "\n" + "#ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "uniform sampler2D u_material_emission_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "uniform sampler2D u_material_ambient_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "uniform sampler2D u_material_diffuse_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "uniform sampler2D u_material_specular_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "uniform sampler2D u_material_normal_texture;\n" + "#endif\n" + "\n" + "// Global light accumulators for each property\n" + "vec4 light_accumulator_ambient = vec4(0.0);\n" + "vec4 light_accumulator_diffuse = vec4(0.0);\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR\n" + "    vec4 light_accumulator_specular = vec4(0.0);\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_SPHEREMAP\n" + "vec4 getSphereMap (in sampler2D _tex, in vec3 _eyeToPoint, in vec3 _normal, in vec2 _skew) {\n" + "    vec3 eye = normalize(_eyeToPoint);\n" + "    eye.xy -= _skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    vec3 r = reflect(eye, _normal);\n" + "    r.z += 1.0;\n" + "    float m = 2. * length(r);\n" + "    vec2 uv = r.xy / m + .5;\n" + "    return texture2D(_tex, uv);\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_TRIPLANAR\n" + "vec3 getTriPlanarBlend (in vec3 _normal) {\n" + "    vec3 blending = abs(_normal);\n" + "    blending = normalize(max(blending, 0.00001));\n" + "    float b = (blending.x + blending.y + blending.z);\n" + "    return blending / b;\n" + "}\n" + "\n" + "vec4 getTriPlanar (in sampler2D _tex, in vec3 _pos, in vec3 _normal, in vec3 _scale) {\n" + "    vec3 blending = getTriPlanarBlend(_normal);\n" + "    vec4 xaxis = texture2D(_tex, fract(_pos.yz * _scale.x));\n" + "    vec4 yaxis = texture2D(_tex, fract(_pos.xz * _scale.y));\n" + "    vec4 zaxis = texture2D(_tex, fract(_pos.xy * _scale.z));\n" + "    return  xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_PLANAR\n" + "vec4 getPlanar (in sampler2D _tex, in vec3 _pos, in vec2 _scale) {\n" + "    return texture2D( _tex, fract(_pos.xy * _scale.x) );\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "void calculateNormal (inout vec3 _normal) {\n" + "    // Get NORMALMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_UV\n" + "    _normal += texture2D(u_material_normal_texture, fract(v_texcoord*material.normalScale.xy)).rgb*2.0-1.0;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_PLANAR\n" + "    vec3 normalTex = getPlanar(u_material_normal_texture, v_world_position.xyz, material.normalScale.xy).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_TRIPLANAR\n" + "    vec3 normalTex = getTriPlanar(u_material_normal_texture, v_world_position.xyz, _normal, material.normalScale).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    _normal = normalize(_normal);\n" + "}\n" + "#endif\n" + "\n" + "void calculateMaterial (in vec3 _eyeToPoint, inout vec3 _normal) {\n" + "    // get EMISSION TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_UV\n" + "        material.emission *= texture2D(u_material_emission_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_PLANAR\n" + "        material.emission *= getPlanar(u_material_emission_texture, v_world_position.xyz, material.emissionScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_TRIPLANAR\n" + "        material.emission *= getTriPlanar(u_material_emission_texture, v_world_position.xyz, _normal, material.emissionScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_SPHEREMAP\n" + "        material.emission *= getSphereMap(u_material_emission_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get AMBIENT TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_UV\n" + "        material.ambient *= texture2D(u_material_ambient_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_PLANAR\n" + "        material.ambient *= getPlanar(u_material_ambient_texture, v_world_position.xyz, material.ambientScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_TRIPLANAR\n" + "        material.ambient *= getTriPlanar(u_material_ambient_texture, v_world_position.xyz, _normal, material.ambientScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_SPHEREMAP\n" + "        material.ambient *= getSphereMap(u_material_ambient_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get DIFFUSE TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_UV\n" + "        material.diffuse *= texture2D(u_material_diffuse_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_PLANAR\n" + "        material.diffuse *= getPlanar(u_material_diffuse_texture, v_world_position.xyz, material.diffuseScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_TRIPLANAR\n" + "        material.diffuse *= getTriPlanar(u_material_diffuse_texture, v_world_position.xyz, _normal, material.diffuseScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP\n" + "        material.diffuse *= getSphereMap(u_material_diffuse_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get SPECULAR TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_UV\n" + "        material.specular *= texture2D(u_material_specular_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_PLANAR\n" + "        material.specular *= getPlanar(u_material_specular_texture, v_world_position.xyz, material.specularScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_TRIPLANAR\n" + "        material.specular *= getTriPlanar(u_material_specular_texture, v_world_position.xyz, _normal, material.specularScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_SPHEREMAP\n" + "        material.specular *= getSphereMap(u_material_specular_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/pointLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct PointLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "};\n" + "\n" + "void calculateLight(in PointLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // Normalize the vector from surface to light position\n" + "    float nDotVP = clamp(dot(VP, _normal), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // Computer accumulators\n" + "    light_accumulator_ambient += _light.ambient * attenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0; // power factor for shiny speculars\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(0.0, dot(-normalize(_eyeToPoint), reflectVector));\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "\n" + "        light_accumulator_specular += _light.specular * pf * attenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/selection_fragment"] = "// Fragment shader for feature selection passes\n" + "// Renders in silhouette according to selection (picking) color, or black if none defined\n" + "\n" + "#ifdef TANGRAM_FEATURE_SELECTION\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "void main (void) {\n" + "    #ifdef TANGRAM_FEATURE_SELECTION\n" + "        gl_FragColor = v_selection_color;\n" + "    #else\n" + "        gl_FragColor = vec4(0., 0., 0., 1.);\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/selection_globals"] = "// Vertex attribute + varying for feature selection\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "";

shaderSources["gl/shaders/selection_vertex"] = "// Selection pass-specific rendering\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    if (a_selection_color.rgb == vec3(0.)) {\n" + "        // Discard by forcing invalid triangle if we're in the feature\n" + "        // selection pass but have no selection info\n" + "        // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "        gl_Position = vec4(0., 0., 0., 1.);\n" + "        return;\n" + "    }\n" + "    v_selection_color = a_selection_color;\n" + "#endif\n" + "";

shaderSources["gl/shaders/spherical_environment_map"] = "// Spherical environment map\n" + "// Based on: http://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader\n" + "\n" + "// view: location of camera\n" + "// position: location of current point on surface\n" + "// normal: normal of current point on surface\n" + "// skew: skewing factor (used to compensate for altered vanishing point)\n" + "// envmap: spherical environment map texture\n" + "\n" + "vec4 sphericalEnvironmentMap(vec3 view, vec3 position, vec3 normal, vec2 skew, sampler2D envmap) {\n" + "    // Normalized vector from camera to surface\n" + "    vec3 eye = normalize(position.xyz - view.xyz);\n" + "\n" + "    // Skew\n" + "    eye.xy -= skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    // Reflection of eye off of surface normal\n" + "    vec3 r = reflect(eye, normal);\n" + "\n" + "    // Map reflected vector onto the surface of a sphere\n" + "    r.z += 1.;\n" + "    float m = 2. * length(r);\n" + "\n" + "    // Adjust xy to account for spherical shape, and center in middle of texture\n" + "    vec2 uv = r.xy / m + .5;\n" + "\n" + "    // Sample the environment map\n" + "    return texture2D(envmap, uv);\n" + "}\n" + "";

shaderSources["gl/shaders/spotLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct SpotLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "\n" + "    vec3 direction;\n" + "    float spotCosCutoff;\n" + "    float spotExponent;\n" + "};\n" + "\n" + "void calculateLight(in SpotLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // normal . light direction\n" + "    float nDotVP = clamp(dot(_normal, VP), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // spotlight attenuation factor\n" + "    float spotAttenuation = 0.0;\n" + "\n" + "    // See if point on surface is inside cone of illumination\n" + "    float spotDot = clamp(dot(-VP, normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    if (spotDot >= _light.spotCosCutoff) {\n" + "        spotAttenuation = pow(spotDot, _light.spotExponent);\n" + "    }\n" + "\n" + "    light_accumulator_ambient += _light.ambient * attenuation * spotAttenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation * spotAttenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        // Power factor for shiny speculars\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(dot(-normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf * attenuation * spotAttenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/world_position_wrap"] = "// Define a wrap value for world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "    vec2 world_position_anchor = vec2(floor(u_tile_origin / TANGRAM_WORLD_POSITION_WRAP) * TANGRAM_WORLD_POSITION_WRAP);\n" + "\n" + "    // Convert back to absolute world position if needed\n" + "    vec4 absoluteWorldPosition () {\n" + "        return vec4(v_world_position.xy + world_position_anchor, v_world_position.z, v_world_position.w);\n" + "    }\n" + "#else\n" + "    vec4 absoluteWorldPosition () {\n" + "        return v_world_position;\n" + "    }\n" + "#endif\n" + "";

shaderSources["styles/points/points_fragment"] = "uniform vec2 u_resolution;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "\n" + "uniform sampler2D u_texture;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Alpha discard threshold (substitute for alpha blending)\n" + "#ifndef TANGRAM_ALPHA_DISCARD\n" + "#define TANGRAM_ALPHA_DISCARD 0.5\n" + "#endif\n" + "\n" + "// Alpha fade range for edges of points\n" + "#ifndef TANGRAM_FADE_RANGE\n" + "#define TANGRAM_FADE_RANGE .15\n" + "#endif\n" + "#define TANGRAM_FADE_START (1. - TANGRAM_FADE_RANGE)\n" + "\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    vec4 color = v_color;\n" + "\n" + "    // Apply a texture\n" + "    #ifdef TANGRAM_POINT_TEXTURE\n" + "        color *= texture2D(u_texture, v_texcoord);\n" + "    // Draw a point\n" + "    #else\n" + "        // Fade alpha near circle edge\n" + "        vec2 uv = v_texcoord * 2. - 1.;\n" + "        float point_dist = length(uv);\n" + "        color.a = clamp(1. - (smoothstep(0., TANGRAM_FADE_RANGE, (point_dist - TANGRAM_FADE_START)) / TANGRAM_FADE_RANGE), 0., 1.);\n" + "    #endif\n" + "\n" + "    // If blending is off, use alpha discard as a lower-quality substitute\n" + "    #ifndef TANGRAM_BLEND_OVERLAY\n" + "        if (color.a < TANGRAM_ALPHA_DISCARD) {\n" + "            discard;\n" + "        }\n" + "    #endif\n" + "\n" + "    #pragma tangram: color\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources["styles/points/points_vertex"] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "\n" + "attribute vec3 a_position;\n" + "attribute vec4 a_shape;\n" + "attribute vec4 a_color;\n" + "attribute vec2 a_texcoord;\n" + "#ifdef TANGRAM_ORDER_ATTRIBUTE\n" + "    attribute float a_layer;\n" + "#endif\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: global\n" + "\n" + "vec2 rotate2D(vec2 _st, float _angle) {\n" + "    return mat2(cos(_angle),-sin(_angle),\n" + "                sin(_angle),cos(_angle)) * _st;\n" + "}\n" + "\n" + "void main() {\n" + "    // Adds vertex shader support for feature selection\n" + "    #pragma tangram: feature-selection-vertex\n" + "\n" + "    v_color = a_color;\n" + "    v_texcoord = a_texcoord;\n" + "\n" + "    // Apply scaling in screen space\n" + "    vec4 shape = a_shape;\n" + "    float zscale = fract(u_map_position.z) * (shape.w * 256. - 1.) + 1.;\n" + "    // float zscale = log(fract(u_map_position.z) + 1.) / log(2.) * (shape.w - 1.) + 1.;\n" + "    vec2 shape_offset = shape.xy * 256. * zscale;\n" + "\n" + "    // Position\n" + "    vec4 position = u_modelView * vec4(a_position, 1.);\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * vec4(a_position, 1.);\n" + "    v_world_position.xy += shape_offset * u_meters_per_pixel;\n" + "    #if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "        v_world_position.xy -= world_position_anchor;\n" + "    #endif\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    cameraProjection(position);\n" + "\n" + "    #ifdef TANGRAM_ORDER_ATTRIBUTE\n" + "        applyLayerOrder(a_layer, position);\n" + "    #endif\n" + "\n" + "    position.xy += rotate2D(shape_offset, radians(shape.z * 360.)) * 2. * position.w / u_resolution;\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

shaderSources["styles/polygons/polygons_fragment"] = "uniform vec2 u_resolution;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    vec4 color = v_color;\n" + "    vec3 normal = v_normal;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        calculateNormal(normal);\n" + "    #endif\n" + "\n" + "    // Modify normal before lighting\n" + "    #pragma tangram: normal\n" + "\n" + "    // Modify color and material properties before lighting\n" + "    #if !defined(TANGRAM_LIGHTING_VERTEX)\n" + "    #pragma tangram: color\n" + "    #endif\n" + "\n" + "    #if defined(TANGRAM_LIGHTING_FRAGMENT)\n" + "        color = calculateLighting(v_position.xyz - u_eye, normal, color);\n" + "    #elif defined(TANGRAM_LIGHTING_VERTEX)\n" + "        color = v_lighting;\n" + "    #endif\n" + "\n" + "    // Modify color after lighting (filter-like effects that don't require a additional render passes)\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources["styles/polygons/polygons_vertex"] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "\n" + "attribute vec3 a_position;\n" + "attribute vec4 a_color;\n" + "attribute float a_layer;\n" + "\n" + "// Optional normal attribute, otherwise default to up\n" + "#ifdef TANGRAM_NORMAL_ATTRIBUTE\n" + "    attribute vec3 a_normal;\n" + "    #define TANGRAM_NORMAL a_normal\n" + "#else\n" + "    #define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "#endif\n" + "\n" + "// Optional dynamic line extrusion\n" + "#ifdef TANGRAM_EXTRUDE_LINES\n" + "    attribute vec3 a_extrude;\n" + "    attribute float a_scale;\n" + "#endif\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Optional texture UVs\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    attribute vec2 a_texcoord;\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main() {\n" + "    // Adds vertex shader support for feature selection\n" + "    #pragma tangram: feature-selection-vertex\n" + "\n" + "    // Texture UVs\n" + "    #ifdef TANGRAM_TEXTURE_COORDS\n" + "        v_texcoord = a_texcoord;\n" + "    #endif\n" + "\n" + "    // Position\n" + "    vec4 position = vec4(a_position, 1.);\n" + "\n" + "    #ifdef TANGRAM_EXTRUDE_LINES\n" + "        vec2 extrude = a_extrude.xy;\n" + "        float width = a_extrude.z;\n" + "\n" + "        // Keep line width constant in screen-space\n" + "        float zscale = u_tile_origin.z - u_map_position.z;\n" + "        width *= pow(2., zscale);\n" + "\n" + "        // Smoothly interpolate line width between zooms\n" + "        width = mix(width, width * a_scale * 256., -zscale);\n" + "\n" + "        // Modify line width before extrusion\n" + "        #pragma tangram: width\n" + "\n" + "        position.xy += extrude * width;\n" + "    #endif\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * position;\n" + "    #if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "        v_world_position.xy -= world_position_anchor;\n" + "    #endif\n" + "\n" + "    // Adjust for tile and view position\n" + "    position = u_modelView * position;\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    // Setup varyings\n" + "    v_position = position;\n" + "    v_normal = normalize(u_normalMatrix * TANGRAM_NORMAL);\n" + "    v_color = a_color;\n" + "\n" + "    // Vertex lighting\n" + "    #if defined(TANGRAM_LIGHTING_VERTEX)\n" + "        vec4 color = a_color;\n" + "        vec3 normal = TANGRAM_NORMAL;\n" + "\n" + "        // Modify normal before lighting\n" + "        #pragma tangram: normal\n" + "\n" + "        // Modify color and material properties before lighting\n" + "        #pragma tangram: color\n" + "\n" + "        v_lighting = calculateLighting(position.xyz, normal, color);\n" + "        v_color = color;\n" + "    #endif\n" + "\n" + "    // Camera\n" + "    cameraProjection(position);\n" + "    applyLayerOrder(a_layer, position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

module.exports = shaderSources;

},{}],73:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Texture */
// Texture management

var Utils = _interopRequire(require("../utils/utils"));

var subscribeMixin = _interopRequire(require("../utils/subscribe"));

var WorkerBroker = _interopRequire(require("../utils/worker_broker"));

var Builders = _interopRequire(require("../styles/builders"));

var log = _interopRequire(require("loglevel"));

// GL texture wrapper object for keeping track of a global set of textures, keyed by a unique user-defined name

var Texture = (function () {
    function Texture(gl, name) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Texture);

        this.gl = gl;
        this.texture = gl.createTexture();
        if (this.texture) {
            this.valid = true;
        }
        this.bind();
        this.image = null; // an Image object/element that is the source for this texture
        this.canvas = null; // a Canvas object/element that is the source for this texture
        this.loading = null; // a Promise object to track the loading state of this texture

        // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
        // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
        this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: "nearest" });

        // TODO: better support for non-URL sources: canvas/video elements, raw pixel buffers

        this.name = name;
        this.filtering = options.filtering;

        // Destroy previous texture if present
        if (Texture.textures[this.name]) {
            Texture.textures[this.name].destroy();
        }

        Texture.textures[this.name] = this;

        this.sprites = options.sprites;
        this.texcoords = {};
    }

    _createClass(Texture, {
        destroy: {

            // Destroy a single texture instance

            value: function destroy() {
                if (!this.valid) {
                    return;
                }
                this.gl.deleteTexture(this.texture);
                this.texture = null;
                delete this.data;
                this.data = null;
                delete Texture.textures[this.name];
                this.valid = false;
            }
        },
        bind: {
            value: function bind(unit) {
                if (!this.valid) {
                    return;
                }
                if (typeof unit === "number") {
                    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                }
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
            }
        },
        unbind: {
            value: function unbind() {
                this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            }
        },
        load: {

            // Loads a texture from a URL

            value: function load(url) {
                var _this = this;

                var options = arguments[1] === undefined ? {} : arguments[1];

                if (!this.valid) {
                    return;
                }

                if (Texture.base_url) {
                    url = Utils.addBaseURL(url, Texture.base_url);
                }

                this.loading = new Promise(function (resolve, reject) {
                    _this.image = new Image();
                    _this.image.onload = function () {
                        _this.update(options);
                        _this.setTextureFiltering(options);
                        _this.calculateSprites();

                        _this.canvas = null; // mutually exclusive with other types
                        _this.data = null;

                        resolve(_this);
                    };
                    _this.image.crossOrigin = "anonymous";
                    _this.image.src = url;
                    // TODO: error/promise reject
                });
                return this.loading;
            }
        },
        setData: {

            // Sets texture to a raw image buffer

            value: function setData(width, height, data) {
                var options = arguments[3] === undefined ? {} : arguments[3];

                this.width = width;
                this.height = height;
                this.data = data;

                this.image = null; // mutually exclusive with other types
                this.canvas = null;

                this.update(options);
                this.setTextureFiltering(options);
            }
        },
        setCanvas: {

            // Sets the texture to track a canvas element

            value: function setCanvas(canvas, options) {
                this.canvas = canvas;
                this.update(options);
                this.setTextureFiltering(options);

                this.image = null; // mutually exclusive with other types
                this.data = null;
            }
        },
        update: {

            // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)

            value: function update() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return;
                }

                this.bind();
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
                this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

                // Image element
                if (this.image && this.image.complete) {
                    this.width = this.image.width;
                    this.height = this.image.height;
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);
                }
                // Canvas element
                else if (this.canvas) {
                    this.width = this.canvas.width;
                    this.height = this.canvas.height;
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.canvas);
                }
                // Raw image buffer
                else if (this.width && this.height) {
                    // NOTE: this.data can be null, to zero out texture
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.data);
                }

                Texture.trigger("update", this);
            }
        },
        setTextureFiltering: {

            // Determines appropriate filtering mode

            value: function setTextureFiltering() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return;
                }

                options.filtering = options.filtering || this.filtering || "linear"; // default to mipmaps for power-of-2 textures

                var gl = this.gl;
                this.bind();

                // For power-of-2 textures, the following presets are available:
                // mipmap: linear blend from nearest mip
                // linear: linear blend from original image (no mips)
                // nearest: nearest pixel from original image (no mips, 'blocky' look)
                if (Utils.isPowerOf2(this.width) && Utils.isPowerOf2(this.height)) {
                    this.power_of_2 = true;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || gl.REPEAT);
                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || gl.REPEAT);

                    if (options.filtering === "mipmap") {
                        log.trace("power-of-2 MIPMAP");
                        this.filtering = "mipmap";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else if (options.filtering === "linear") {
                        log.trace("power-of-2 LINEAR");
                        this.filtering = "linear";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    } else if (options.filtering === "nearest") {
                        log.trace("power-of-2 NEAREST");
                        this.filtering = "nearest";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    }
                } else {
                    // WebGL has strict requirements on non-power-of-2 textures:
                    // No mipmaps and must clamp to edge
                    this.power_of_2 = false;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    if (options.filtering === "nearest") {
                        log.trace("power-of-2 NEAREST");
                        this.filtering = "nearest";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    } else {
                        // default to linear for non-power-of-2 textures
                        log.trace("power-of-2 LINEAR");
                        this.filtering = "linear";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    }
                }

                this.unbind();
                Texture.trigger("update", this);
            }
        },
        calculateSprites: {

            // Pre-calc sprite regions for a texture sprite in UV [0, 1] space

            value: function calculateSprites() {
                if (this.sprites) {
                    for (var s in this.sprites) {
                        var sprite = this.sprites[s];

                        // Map [0, 0] to [1, 1] coords to the appropriate sprite sub-area of the texture
                        this.texcoords[s] = Builders.getTexcoordsForSprite([sprite[0], sprite[1]], [sprite[2], sprite[3]], [this.width, this.height]);
                    }
                }
            }
        }
    });

    return Texture;
})();

module.exports = Texture;

// Static/class methods and state

// Destroy all texture instances for a given GL context
Texture.destroy = function (gl) {
    var textures = Object.keys(Texture.textures);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t = _step.value;

            var texture = Texture.textures[t];
            if (texture.gl === gl) {
                log.trace("destroying Texture " + texture.name);
                texture.destroy();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

// Get sprite sub-area to use for texture coordinates (default is [0, 1])
Texture.getSpriteTexcoords = function (texname, sprite) {
    var texture = Texture.textures[texname];
    return texture && texture.texcoords[sprite];
};

// Create a set of textures keyed in an object
// Optionally load each if it has a URL specified
Texture.createFromObject = function (gl, textures) {
    var loading = [];
    if (textures) {
        for (var texname in textures) {
            var config = textures[texname];
            if (!Texture.textures[texname]) {
                var texture = new Texture(gl, texname, config);
                if (config.url) {
                    loading.push(texture.load(config.url, config));
                }
            }
        }
    }
    return Promise.all(loading);
};

// Get metadata for a texture by name
// Returns via promise, in case texture is still loading
// Can be called on main thread from worker, to sync texture info to worker
Texture.getInfo = function (name) {
    // Get info for all textures by default
    if (!name) {
        name = Object.keys(Texture.textures);
    }

    // Get multiple textures
    if (Array.isArray(name)) {
        return Promise.all(name.map(function (n) {
            return Texture.getInfo(n);
        }));
    }

    // Get single texture
    var tex = Texture.textures[name];
    if (tex) {
        // Wait for this texture to finish loading, or return immediately
        var loading = tex.loading || Promise.resolve(tex);
        return loading.then(function () {
            // Return a subset of texture info
            // (compatible w/structured cloning, suitable for passing to a worker)
            return {
                name: tex.name,
                width: tex.width,
                height: tex.height,
                sprites: tex.sprites,
                texcoords: tex.texcoords,
                filtering: tex.filtering,
                power_of_2: tex.power_of_2,
                valid: tex.valid
            };
        });
    } else {
        // No texture found
        return Promise.resolve(null);
    }
};

// Sync texture info to worker
// Called from worker, gets info on one or more textures info from main thread via remote call, then stores it
// locally in worker. 'textures' can be an array of texture names to sync, or if null, all textures are synced.
Texture.syncTexturesToWorker = function (names) {
    return WorkerBroker.postMessage("Texture", "getInfo", names).then(function (textures) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var tex = _step.value;

                Texture.textures[tex.name] = tex;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return Texture.textures;
    });
};

// Global set of textures, by name
Texture.textures = {};

Texture.base_url = null; // optional base URL to add to textures

subscribeMixin(Texture);

},{"../styles/builders":85,"../utils/subscribe":101,"../utils/utils":102,"../utils/worker_broker":104,"loglevel":53}],74:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// Creates a Vertex Array Object if the extension is available, or falls back on standard attribute calls

var log = _interopRequire(require("loglevel"));

var VertexArrayObject;
module.exports = VertexArrayObject = {};

VertexArrayObject.disabled = false; // set to true to disable VAOs even if extension is available
VertexArrayObject.bound_vao = null; // currently bound VAO

VertexArrayObject.init = function (gl) {
    if (VertexArrayObject.ext == null) {
        if (VertexArrayObject.disabled !== true) {
            VertexArrayObject.ext = gl.getExtension("OES_vertex_array_object");
        }

        if (VertexArrayObject.ext != null) {
            log.info("Vertex Array Object extension available");
        } else if (VertexArrayObject.disabled !== true) {
            log.warn("Vertex Array Object extension NOT available");
        } else {
            log.warn("Vertex Array Object extension force disabled");
        }
    }
};

VertexArrayObject.create = function (setup, teardown) {
    var vao = {};
    vao.setup = setup;
    vao.teardown = teardown;

    var ext = VertexArrayObject.ext;
    if (ext != null) {
        vao._vao = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vao._vao);
        vao.setup();
    } else {
        vao.setup();
    }

    return vao;
};

VertexArrayObject.bind = function (vao) {
    var ext = VertexArrayObject.ext;
    if (vao != null) {
        if (ext != null && vao._vao != null) {
            ext.bindVertexArrayOES(vao._vao);
            VertexArrayObject.bound_vao = vao;
        } else {
            vao.setup();
        }
    } else {
        if (ext != null) {
            ext.bindVertexArrayOES(null);
        } else if (VertexArrayObject.bound_vao != null && typeof VertexArrayObject.bound_vao.teardown === "function") {
            VertexArrayObject.bound_vao.teardown();
        }
        VertexArrayObject.bound_vao = null;
    }
};

},{"loglevel":53}],75:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VBOMesh */
// Manage rendering for primitives

var GLSL = _interopRequire(require("./glsl"));

var ShaderProgram = _interopRequire(require("./shader_program"));

var Texture = _interopRequire(require("./texture"));

var VertexArrayObject = _interopRequire(require("./vao"));

var log = _interopRequire(require("loglevel"));

// A single mesh/VBO, described by a vertex layout, that can be drawn with one or more programs

var VBOMesh = (function () {
    function VBOMesh(gl, vertex_data, vertex_layout, options) {
        _classCallCheck(this, VBOMesh);

        options = options || {};

        this.gl = gl;
        this.vertex_data = vertex_data; // typed array
        this.vertex_layout = vertex_layout;
        this.buffer = this.gl.createBuffer();
        this.draw_mode = options.draw_mode || this.gl.TRIANGLES;
        this.data_usage = options.data_usage || this.gl.STATIC_DRAW;
        this.vertices_per_geometry = 3; // TODO: support lines, strip, fan, etc.
        this.uniforms = options.uniforms;
        this.retain = options.retain || false; // whether to retain mesh data in CPU after uploading to GPU

        this.vertex_count = this.vertex_data.byteLength / this.vertex_layout.stride;
        this.geometry_count = this.vertex_count / this.vertices_per_geometry;
        this.vaos = new Map(); // map of VertexArrayObjects, keyed by program

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertex_data, this.data_usage);

        if (!this.retain) {
            delete this.vertex_data;
        }
        this.valid = true;
    }

    _createClass(VBOMesh, {
        render: {

            // Render, by default with currently bound program, or otherwise with optionally provided one

            value: function render() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return false;
                }

                if (typeof this._render_setup === "function") {
                    this._render_setup();
                }

                var program = options.program || ShaderProgram.current;
                program.use();

                if (this.uniforms) {
                    program.saveUniforms(this.uniforms);
                    program.setUniforms(this.uniforms, false); // don't reset texture unit
                }

                this.bind(program);

                // TODO: support element array mode
                this.gl.drawArrays(this.draw_mode, 0, this.vertex_count);
                VertexArrayObject.bind(null);

                if (this.uniforms) {
                    program.restoreUniforms(this.uniforms);
                }

                return true;
            }
        },
        bind: {

            // Bind buffers and vertex attributes to prepare for rendering

            value: function bind(program) {
                var _this = this;

                // Bind VAO for this progam, or create one
                var vao = this.vaos.get(program);
                if (vao) {
                    VertexArrayObject.bind(vao);
                } else {
                    this.vaos.set(program, VertexArrayObject.create(function () {
                        _this.gl.bindBuffer(_this.gl.ARRAY_BUFFER, _this.buffer);
                        _this.vertex_layout.enable(_this.gl, program);
                    }));
                }
            }
        },
        destroy: {
            value: function destroy() {
                if (!this.valid) {
                    return false;
                }
                this.valid = false;

                log.trace("VBOMesh.destroy: delete buffer" + (this.vertex_data ? " of size " + this.vertex_data.byteLength : ""));

                this.gl.deleteBuffer(this.buffer);
                this.buffer = null;
                delete this.vertex_data;

                // Free texture uniforms that are owned by this mesh
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = GLSL.parseUniforms(this.uniforms)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _step.value;
                        var type = _step$value.type;
                        var value = _step$value.value;

                        if (type === "sampler2D" && Texture.textures[value]) {
                            Texture.textures[value].destroy();
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return true;
            }
        }
    });

    return VBOMesh;
})();

module.exports = VBOMesh;

},{"./glsl":70,"./shader_program":71,"./texture":73,"./vao":74,"loglevel":53}],76:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VertexData */

var gl = _interopRequire(require("./constants"));

// web workers don't have access to GL context, so import all GL constants

var log = require("../utils/utils").log;

// Maps GL types to JS array types
var array_types = (function () {
    var _array_types = {};

    _defineProperty(_array_types, gl.FLOAT, Float32Array);

    _defineProperty(_array_types, gl.BYTE, Int8Array);

    _defineProperty(_array_types, gl.UNSIGNED_BYTE, Uint8Array);

    _defineProperty(_array_types, gl.INT, Int32Array);

    _defineProperty(_array_types, gl.UNSIGNED_INT, Uint32Array);

    _defineProperty(_array_types, gl.SHORT, Int16Array);

    _defineProperty(_array_types, gl.UNSIGNED_SHORT, Uint16Array);

    return _array_types;
})();

// An intermediary object that holds vertex data in typed arrays, according to a given vertex layout
// Used to construct a mesh/VBO for rendering

var VertexData = (function () {
    function VertexData(vertex_layout) {
        var _ref = arguments[1] === undefined ? {} : arguments[1];

        var prealloc = _ref.prealloc;

        _classCallCheck(this, VertexData);

        this.vertex_layout = vertex_layout;

        if (VertexData.array_pool.length > 0) {
            this.buffer = VertexData.array_pool.pop();
            this.buffer_length = this.buffer.byteLength;
            this.buffer_size = Math.floor(this.buffer_length / this.vertex_layout.stride);
            log("trace", "VertexData: reused buffer of bytes " + this.buffer_length + ", " + this.buffer_size + " vertices");
        } else {
            this.buffer_size = prealloc || 500; // # of vertices to allocate
            this.buffer_length = this.vertex_layout.stride * this.buffer_size;
            this.buffer = new Uint8Array(this.buffer_length);
        }
        this.buffer_offset = 0; // byte offset into currently allocated buffer

        this.components = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.vertex_layout.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var component = _step.value;

                this.components.push([].concat(_toConsumableArray(component)));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        this.vertex_count = 0;
        this.realloc_count = 0;
        this.setBufferViews();
    }

    _createClass(VertexData, {
        setBufferViews: {

            // (Re-)allocate typed views into the main buffer - only create the types we need for this layout

            value: function setBufferViews() {
                this.buffer_views = {};
                this.buffer_views[gl.UNSIGNED_BYTE] = this.buffer;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.vertex_layout.attribs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var attrib = _step.value;

                        // Need view for this type?
                        if (this.buffer_views[attrib.type] == null) {
                            var array_type = array_types[attrib.type];
                            this.buffer_views[attrib.type] = new array_type(this.buffer.buffer);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Update component buffer pointers
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = this.components[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var component = _step2.value;

                        component[1] = this.buffer_views[component[0]];
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                            _iterator2["return"]();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        },
        checkBufferSize: {

            // Check allocated buffer size, expand/realloc buffer if needed

            value: function checkBufferSize() {
                if (this.buffer_offset + this.vertex_layout.stride > this.buffer_length) {
                    this.buffer_size = Math.floor(this.buffer_size * 1.5);
                    this.buffer_size -= this.buffer_size % 4;
                    this.buffer_length = this.vertex_layout.stride * this.buffer_size;
                    var new_view = new Uint8Array(this.buffer_length);
                    new_view.set(this.buffer); // copy existing data to new buffer
                    VertexData.array_pool.push(this.buffer); // save previous buffer for use by next tile
                    this.buffer = new_view;
                    this.setBufferViews();
                    this.realloc_count++;
                    // log.info(`VertexData: expanded vertex block to ${this.buffer_size} vertices`);
                }
            }
        },
        addVertex: {

            // Add a vertex, copied from a plain JS array of elements matching the order of the vertex layout.
            // Note: uses pre-calculated info about each attribute, including pointer to appropriate typed array
            // view and offset into it. This was the fastest method profiled so far for filling a mixed-type
            // vertex layout (though still slower than the previous method that only supported Float32Array attributes).

            value: function addVertex(vertex) {
                this.checkBufferSize();
                var i = 0;

                var clen = this.components.length;
                for (var c = 0; c < clen; c++) {
                    var component = this.components[c];
                    component[1][(this.buffer_offset >> component[2]) + component[3]] = vertex[i++];
                }

                this.buffer_offset += this.vertex_layout.stride;
                this.vertex_count++;
            }
        },
        end: {

            // Finalize vertex buffer for use in constructing a mesh

            value: function end() {
                // Clip the buffer to size used for this VBO
                this.buffer = this.buffer.subarray(0, this.buffer_offset);
                log("trace", "VertexData: " + this.buffer_size + " vertices total, realloc count " + this.realloc_count);
                return this;
            }
        }
    });

    return VertexData;
})();

module.exports = VertexData;

VertexData.array_pool = []; // pool of currently available (previously used) buffers (uint8)

},{"../utils/utils":102,"./constants":68}],77:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VertexLayout */

var gl = _interopRequire(require("./constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexData = _interopRequire(require("./vertex_data"));

// Describes a vertex layout that can be used with many different GL programs.

var VertexLayout = (function () {
    // Attribs are an array, in layout order, of: name, size, type, normalized
    // ex: { name: 'position', size: 3, type: gl.FLOAT, normalized: false }

    function VertexLayout(attribs) {
        _classCallCheck(this, VertexLayout);

        this.attribs = attribs; // dictionary of attributes, specified as standard GL attrib options
        this.components = []; // list of type and offset info about each attribute component
        this.index = {}; // linear buffer index of each attribute component, e.g. this.index.position.x

        // Calc vertex stride
        this.stride = 0;

        var count = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.attribs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var attrib = _step.value;

                attrib.offset = this.stride;
                attrib.byte_size = attrib.size;
                var shift = 0;

                switch (attrib.type) {
                    case gl.FLOAT:
                    case gl.INT:
                    case gl.UNSIGNED_INT:
                        attrib.byte_size *= 4;
                        shift = 2;
                        break;
                    case gl.SHORT:
                    case gl.UNSIGNED_SHORT:
                        attrib.byte_size *= 2;
                        shift = 1;
                        break;
                }

                // Force 4-byte alignment on attributes
                this.stride += attrib.byte_size;
                if (this.stride & 3) {
                    // pad to multiple of 4 bytes
                    this.stride += 4 - (this.stride & 3);
                }

                // Add info to list of attribute components
                // Used to build the vertex data, provides pointers and offsets into each typed array view
                // Each component is an array of:
                // [GL attrib type, pointer to typed array view, bits to shift right to determine buffer offset, additional buffer offset for the component]
                var offset_typed = attrib.offset >> shift;
                if (attrib.size > 1) {
                    for (var a = 0; a < attrib.size; a++) {
                        this.components.push([attrib.type, null, shift, offset_typed++]);
                    }
                } else {
                    this.components.push([attrib.type, null, shift, offset_typed]);
                }

                // Provide an index into the vertex data buffer for each attribute component
                this.index[attrib.name] = count;
                count += attrib.size;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    _createClass(VertexLayout, {
        enable: {

            // Setup a vertex layout for a specific GL program
            // Assumes that the desired vertex buffer (VBO) is already bound
            // If a given program doesn't include all attributes, it can still use the vertex layout
            // to read those attribs that it does recognize, using the attrib offsets to skip others.

            value: function enable(gl, program) {
                var attrib, location;

                // Enable all attributes for this layout
                for (var a = 0; a < this.attribs.length; a++) {
                    attrib = this.attribs[a];
                    location = program.attribute(attrib.name).location;

                    if (location !== -1) {
                        gl.enableVertexAttribArray(location);
                        gl.vertexAttribPointer(location, attrib.size, attrib.type, attrib.normalized, this.stride, attrib.offset);
                        VertexLayout.enabled_attribs[location] = program;
                    }
                }

                // Disable any previously bound attributes that aren't for this layout
                for (location in VertexLayout.enabled_attribs) {
                    this.disableUnusedAttribute(gl, location, program);
                }
            }
        },
        disableUnusedAttribute: {

            // Disable an attribute if it was not enabled for the specified program
            // NOTE: this was moved out of the inner loop in enable() to assist w/VM optimization

            value: function disableUnusedAttribute(gl, location, program) {
                if (VertexLayout.enabled_attribs[location] !== program) {
                    gl.disableVertexAttribArray(location);
                    delete VertexLayout.enabled_attribs[location];
                }
            }
        },
        createVertexData: {
            value: function createVertexData() {
                return new VertexData(this);
            }
        }
    });

    return VertexLayout;
})();

module.exports = VertexLayout;

// Track currently enabled attribs, by the program they are bound to
// Static class property to reflect global GL state
VertexLayout.enabled_attribs = {};

},{"./constants":68,"./vertex_data":76}],78:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

exports.leafletLayer = leafletLayer;
Object.defineProperty(exports, "__esModule", {
    value: true
});

var Utils = _interopRequire(require("./utils/utils"));

var Scene = _interopRequire(require("./scene"));

var log = _interopRequire(require("loglevel"));

// Exports must appear outside a function, but will only be defined in main thread (below)
var LeafletLayer;
exports.LeafletLayer = LeafletLayer;

function leafletLayer(options) {
    return new LeafletLayer(options);
}

// Leaflet layer functionality is only defined in main thread
if (Utils.isMainThread) {
    (function () {

        // Determine if we are extending the leaflet 0.7.x TileLayer class, or the newer
        // leaflet 1.x GridLayer class.
        var layerBaseClass = L.GridLayer ? L.GridLayer : L.TileLayer;
        var leafletVersion = layerBaseClass === L.GridLayer ? "1.x" : "0.7.x";
        var layerClassConfig = {};

        // If extending leaflet 0.7.x TileLayer, make add/remove tile no ops
        if (layerBaseClass === L.TileLayer) {
            layerClassConfig._addTile = function () {};
            layerClassConfig._removeTile = function () {};
        }

        // Define custom layer methods
        Object.assign(layerClassConfig, {

            initialize: function initialize(options) {
                // Defaults
                options.showDebug = !options.showDebug ? false : true;

                L.setOptions(this, options);
                this.createScene();
                this.hooks = {};
                this._updating_tangram = false;

                // Force leaflet zoom animations off
                this._zoomAnimated = false;
            },

            createScene: function createScene() {
                this.scene = Scene.create(this.options.scene, {
                    numWorkers: this.options.numWorkers,
                    preUpdate: this.options.preUpdate,
                    postUpdate: this.options.postUpdate,
                    continuousZoom: LeafletLayer.leafletVersion === "1.x",
                    highDensityDisplay: this.options.highDensityDisplay,
                    logLevel: this.options.logLevel,
                    // advanced option, app will have to manually called scene.update() per frame
                    disableRenderLoop: this.options.disableRenderLoop,
                    // advanced option, will require library to be served as same host as page
                    allowCrossDomainWorkers: this.options.allowCrossDomainWorkers
                });
            },

            // Finish initializing scene and setup events when layer is added to map
            onAdd: function onAdd(map) {
                var _this = this;

                if (!this.scene) {
                    this.createScene();
                }

                layerBaseClass.prototype.onAdd.apply(this, arguments);

                this.hooks.resize = function () {
                    _this._updating_tangram = true;
                    var size = map.getSize();
                    _this.scene.resizeMap(size.x, size.y);
                    _this._updating_tangram = false;
                };
                map.on("resize", this.hooks.resize);

                this.hooks.move = function () {
                    if (_this._updating_tangram) {
                        return;
                    }

                    _this._updating_tangram = true;
                    var view = map.getCenter();
                    view.zoom = map.getZoom();

                    _this.scene.setView(view);
                    _this.scene.immediateRedraw();
                    _this._updating_tangram = false;
                };
                map.on("move", this.hooks.move);

                this.hooks.zoomstart = function () {
                    if (_this._updating_tangram) {
                        return;
                    }

                    _this._updating_tangram = true;
                    _this.scene.startZoom();
                    _this._updating_tangram = false;
                };
                map.on("zoomstart", this.hooks.zoomstart);

                this.hooks.dragstart = function () {
                    _this.scene.panning = true;
                };
                map.on("dragstart", this.hooks.dragstart);

                this.hooks.dragend = function () {
                    _this.scene.panning = false;
                };
                map.on("dragend", this.hooks.dragend);

                // Force leaflet zoom animations off
                map._zoomAnimated = false;

                // Modify default leaflet scroll wheel behavior
                this.modifyScrollWheelBehavior(map);

                // Canvas element will be inserted after map container (leaflet transforms shouldn't be applied to the GL canvas)
                // TODO: find a better way to deal with this? right now GL map only renders correctly as the bottom layer
                this.scene.container = map.getContainer();

                // Initial view
                var view = map.getCenter();
                view.zoom = map.getZoom();
                this.scene.setView(view);

                // Subscribe to tangram events
                this.scene.subscribe({
                    move: this.onTangramViewUpdate.bind(this)
                });

                // Use leaflet's existing event system as the callback mechanism
                this.scene.init().then(function () {
                    log.debug("Scene.init() succeeded");
                    _this.fire("init");
                })["catch"](function (error) {
                    log.error("Scene.init() failed: " + error.message, error);
                    _this.fire("error", error);
                });
            },

            onRemove: function onRemove(map) {
                layerBaseClass.prototype.onRemove.apply(this, arguments);

                map.off("resize", this.hooks.resize);
                map.off("move", this.hooks.move);
                map.off("zoomstart", this.hooks.zoomstart);
                map.off("dragstart", this.hooks.dragstart);
                map.off("dragend", this.hooks.dragend);
                this.hooks = {};

                if (this.scene) {
                    this.scene.destroy();
                    this.scene = null;
                }
            },

            createTile: function createTile(coords) {
                var key = coords.x + "/" + coords.y + "/" + coords.z;
                var div = document.createElement("div");
                div.setAttribute("data-tile-key", key);
                div.style.width = "256px";
                div.style.height = "256px";

                if (this.options.showDebug) {
                    var debug_overlay = document.createElement("div");
                    debug_overlay.textContent = key;
                    debug_overlay.style.position = "absolute";
                    debug_overlay.style.left = 0;
                    debug_overlay.style.top = 0;
                    debug_overlay.style.color = "white";
                    debug_overlay.style.fontSize = "16px";
                    debug_overlay.style.textOutline = "1px #000000";
                    debug_overlay.style.padding = "8px";

                    div.appendChild(debug_overlay);
                    div.style.borderStyle = "solid";
                    div.style.borderColor = "white";
                    div.style.borderWidth = "1px";
                }

                return div;
            },

            // Modify leaflet's default scroll wheel behavior to have a much more sensitve/continuous zoom
            // Note: this should be deprecated once leaflet continuous zoom is more widely used and the
            // default behavior is presumably improved
            modifyScrollWheelBehavior: function modifyScrollWheelBehavior(map) {
                if (this.scene.continuous_zoom && map.scrollWheelZoom && this.options.modifyScrollWheel !== false) {
                    map.scrollWheelZoom._performZoom = function () {
                        var map = this._map,
                            delta = this._delta,
                            zoom = map.getZoom();

                        map.stop(); // stop panning and fly animations if any

                        // NOTE: this is the only real modification to default leaflet behavior
                        delta /= 40;

                        delta = Math.max(Math.min(delta, 4), -4);
                        delta = map._limitZoom(zoom + delta) - zoom;

                        this._delta = 0;
                        this._startTime = null;

                        if (!delta) {
                            return;
                        }

                        if (map.options.scrollWheelZoom === "center") {
                            map.setZoom(zoom + delta);
                        } else {
                            map.setZoomAround(this._lastMousePos, zoom + delta);
                        }
                        return false;
                    };
                }
            },

            onTangramViewUpdate: function onTangramViewUpdate() {
                if (!this._map || this._updating_tangram) {
                    return;
                }
                this._updating_tangram = true;
                this._map.setView([this.scene.center.lat, this.scene.center.lng], this.scene.zoom, { animate: false });
                this._updating_tangram = false;
            },

            render: function render() {
                if (!this.scene) {
                    return;
                }
                this.scene.update();
            }

        });

        // Create the layer class
        LeafletLayer = exports.LeafletLayer = layerBaseClass.extend(layerClassConfig);

        // Polyfill some 1.0 methods
        if (typeof LeafletLayer.remove !== "function") {
            LeafletLayer.prototype.remove = function () {
                if (this._map) {
                    this._map.removeLayer(this);
                }
                this.fire("remove");
            };
        }

        LeafletLayer.layerBaseClass = layerBaseClass;
        LeafletLayer.leafletVersion = leafletVersion;
    })();
}

},{"./scene":82,"./utils/utils":102,"loglevel":53}],79:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Light */

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var shaderSources = _interopRequire(require("./gl/shader_sources"));

// built-in shaders

var GLSL = _interopRequire(require("./gl/glsl"));

var Geo = _interopRequire(require("./geo"));

var StyleParser = require("./styles/style_parser").StyleParser;

// Abstract light

var Light = (function () {
    function Light(scene, config) {
        _classCallCheck(this, Light);

        this.name = config.name;
        this.scene = scene;

        if (config.ambient == null || typeof config.ambient === "number") {
            this.ambient = GLSL.expandVec4(config.ambient || 0);
        } else {
            this.ambient = StyleParser.parseColor(config.ambient);
        }

        if (config.diffuse == null || typeof config.diffuse === "number") {
            this.diffuse = GLSL.expandVec4(config.diffuse != null ? config.diffuse : 1);
        } else {
            this.diffuse = StyleParser.parseColor(config.diffuse);
        }

        if (config.specular == null || typeof config.specular === "number") {
            this.specular = GLSL.expandVec4(config.specular || 0);
        } else {
            this.specular = StyleParser.parseColor(config.specular);
        }
    }

    _createClass(Light, {
        inject: {

            // Common instance definition

            value: function inject() {
                var instance = "\n            uniform " + this.struct_name + " u_" + this.name + ";\n            " + this.struct_name + " " + this.name + " = u_" + this.name + ";\n";

                ShaderProgram.addBlock(Light.block, instance);
            }
        },
        update: {

            // Update method called once per frame

            value: function update() {}
        },
        setupProgram: {

            // Called once per frame per program (e.g. for main render pass, then for each additional
            // pass for feature selection, etc.)

            value: function setupProgram(_program) {
                //  Three common light properties
                _program.uniform("4fv", "u_" + this.name + ".ambient", this.ambient);
                _program.uniform("4fv", "u_" + this.name + ".diffuse", this.diffuse);
                _program.uniform("4fv", "u_" + this.name + ".specular", this.specular);
            }
        }
    }, {
        create: {

            // Create a light by type name, factory-style
            // 'config' must include 'name' and 'type', along with any other type-specific properties

            value: function create(scene, config) {
                if (Light.types[config.type]) {
                    return new Light.types[config.type](scene, config);
                }
            }
        },
        setMode: {

            // Set light for a style: fragment lighting, vertex lighting, or none

            value: function setMode(mode, style) {
                mode = Light.enabled && (mode != null ? mode : "fragment"); // default to fragment lighting
                style.defines.TANGRAM_LIGHTING_FRAGMENT = mode === "fragment";
                style.defines.TANGRAM_LIGHTING_VERTEX = mode === "vertex";
            }
        },
        inject: {

            // Inject all provided light definitions, and calculate cumulative light function

            value: function inject(lights) {
                // Clear previous injections
                ShaderProgram.removeBlock(Light.block);

                // If lighting is globally disabled, nothing is injected (mostly for debugging or live editing)
                if (!Light.enabled) {
                    return;
                }

                // Construct code to calculate each light instance
                var calculateLights = "";
                if (lights && Object.keys(lights).length > 0) {
                    // Collect uniques types of lights
                    var types = {};
                    for (var light_name in lights) {
                        types[lights[light_name].type] = true;
                    }

                    // Inject each type of light
                    for (var type in types) {
                        Light.types[type].inject();
                    }

                    // Inject per-instance blocks and construct the list of functions to calculate each light
                    for (var light_name in lights) {
                        // Define instance
                        lights[light_name].inject();

                        // Add the calculation function to the list
                        calculateLights += "calculateLight(" + light_name + ", _eyeToPoint, _normal);\n";
                    }
                } else {
                    // If no light is defined, use 100% omnidirectional diffuse light
                    calculateLights = "\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    light_accumulator_diffuse = vec4(1.);\n                #endif\n            ";
                }

                // Glue together the final lighting function that sums all the lights
                var calculateFunction = "\n            vec4 calculateLighting(in vec3 _eyeToPoint, in vec3 _normal, in vec4 _color) {\n\n                // Do initial material calculations over normal, emission, ambient, diffuse and specular values\n                calculateMaterial(_eyeToPoint,_normal);\n\n                // Un roll the loop of individual ligths to calculate\n                " + calculateLights + "\n\n                //  Final light intensity calculation\n                vec4 color = vec4(0.0);\n\n                #ifdef TANGRAM_MATERIAL_EMISSION\n                    color = material.emission;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_AMBIENT\n                    color += light_accumulator_ambient * _color * material.ambient;\n                #else\n                    #ifdef TANGRAM_MATERIAL_DIFFUSE\n                        color += light_accumulator_ambient * _color * material.diffuse;\n                    #endif\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    color += light_accumulator_diffuse * _color * material.diffuse;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_SPECULAR\n                    color += light_accumulator_specular * material.specular;\n                #endif\n\n                // Clamp final color\n                color = clamp(color, 0.0, 1.0);\n\n                return color;\n            }";

                ShaderProgram.addBlock(Light.block, calculateFunction);
            }
        }
    });

    return Light;
})();

module.exports = Light;

Light.types = {}; // references to subclasses by short name
Light.block = "lighting"; // shader block name
Light.enabled = true; // lighting can be globally enabled/disabled

// Light subclasses

var AmbientLight = (function (_Light) {
    function AmbientLight(scene, config) {
        _classCallCheck(this, AmbientLight);

        _get(Object.getPrototypeOf(AmbientLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "ambient";
        this.struct_name = "AmbientLight";
    }

    _inherits(AmbientLight, _Light);

    _createClass(AmbientLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _program.uniform("4fv", "u_" + this.name + ".ambient", this.ambient);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/ambientLight"]);
            }
        }
    });

    return AmbientLight;
})(Light);

Light.types.ambient = AmbientLight;

var DirectionalLight = (function (_Light2) {
    function DirectionalLight(scene, config) {
        _classCallCheck(this, DirectionalLight);

        _get(Object.getPrototypeOf(DirectionalLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "directional";
        this.struct_name = "DirectionalLight";

        this.direction = (config.direction || [0.2, 0.7, -0.5]).map(parseFloat); // [x, y, z]
    }

    _inherits(DirectionalLight, _Light2);

    _createClass(DirectionalLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(DirectionalLight.prototype), "setupProgram", this).call(this, _program);
                _program.uniform("3fv", "u_" + this.name + ".direction", this.direction);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/directionalLight"]);
            }
        }
    });

    return DirectionalLight;
})(Light);

Light.types.directional = DirectionalLight;

var PointLight = (function (_Light3) {
    function PointLight(scene, config) {
        _classCallCheck(this, PointLight);

        _get(Object.getPrototypeOf(PointLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "point";
        this.struct_name = "PointLight";

        this.position = config.position || [0, 0, 0];
        this.position_eye = []; // position in eyespace
        this.origin = config.origin || "world";
        this.attenuation = !isNaN(parseFloat(config.attenuation)) ? parseFloat(config.attenuation) : 0;

        if (config.radius) {
            if (Array.isArray(config.radius) && config.radius.length === 2) {
                this.radius = config.radius;
            } else {
                this.radius = [null, config.radius];
            }
        } else {
            this.radius = null;
        }
    }

    _inherits(PointLight, _Light3);

    _createClass(PointLight, {
        inject: {

            // Inject isntance-specific settings

            value: function inject() {
                _get(Object.getPrototypeOf(PointLight.prototype), "inject", this).call(this);

                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT = this.attenuation !== 0;
                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS = this.radius != null && this.radius[0] != null;
                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS = this.radius != null;
            }
        },
        update: {
            value: function update() {
                this.updateEyePosition();
            }
        },
        updateEyePosition: {
            value: function updateEyePosition() {
                if (this.origin === "world") {
                    // For world origin, format is: [longitude, latitude, meters (default) or pixels w/px units]

                    // Move light's world position into camera space

                    var _Geo$latLngToMeters = Geo.latLngToMeters(this.position);

                    var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                    var x = _Geo$latLngToMeters2[0];
                    var y = _Geo$latLngToMeters2[1];

                    this.position_eye[0] = x - this.scene.camera.position_meters[0];
                    this.position_eye[1] = y - this.scene.camera.position_meters[1];

                    this.position_eye[2] = StyleParser.convertUnits(this.position[2], { zoom: this.scene.zoom });
                    this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
                }
                if (this.origin === "ground" || this.origin === "camera") {
                    // For camera or ground origin, format is: [x, y, z] in meters (default) or pixels w/px units

                    // Light is in camera space by default
                    this.position_eye = StyleParser.convertUnits(this.position, { zoom: this.scene.zoom });

                    if (this.origin === "ground") {
                        // Leave light's xy in camera space, but z needs to be moved relative to ground plane
                        this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
                    }
                }
            }
        },
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(PointLight.prototype), "setupProgram", this).call(this, _program);

                _program.uniform("4f", "u_" + this.name + ".position", this.position_eye[0], this.position_eye[1], this.position_eye[2], 1);

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT) {
                    _program.uniform("1f", "u_" + this.name + ".attenuationExponent", this.attenuation);
                }

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS) {
                    _program.uniform("1f", "u_" + this.name + ".innerRadius", StyleParser.convertUnits(this.radius[0], { zoom: this.scene.zoom }));
                }

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS) {
                    _program.uniform("1f", "u_" + this.name + ".outerRadius", StyleParser.convertUnits(this.radius[1], { zoom: this.scene.zoom }));
                }
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/pointLight"]);
            }
        }
    });

    return PointLight;
})(Light);

Light.types.point = PointLight;

var SpotLight = (function (_PointLight) {
    function SpotLight(scene, config) {
        _classCallCheck(this, SpotLight);

        _get(Object.getPrototypeOf(SpotLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "spotlight";
        this.struct_name = "SpotLight";

        this.direction = (config.direction || [0, 0, -1]).map(parseFloat); // [x, y, z]
        this.exponent = config.exponent ? parseFloat(config.exponent) : 0.2;
        this.angle = config.angle ? parseFloat(config.angle) : 20;
    }

    _inherits(SpotLight, _PointLight);

    _createClass(SpotLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(SpotLight.prototype), "setupProgram", this).call(this, _program);

                _program.uniform("3fv", "u_" + this.name + ".direction", this.direction);
                _program.uniform("1f", "u_" + this.name + ".spotCosCutoff", Math.cos(this.angle * 3.14159 / 180));
                _program.uniform("1f", "u_" + this.name + ".spotExponent", this.exponent);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/spotLight"]);
            }
        }
    });

    return SpotLight;
})(PointLight);

Light.types.spotlight = SpotLight;

},{"./geo":67,"./gl/glsl":70,"./gl/shader_program":71,"./gl/shader_sources":72,"./styles/style_parser":92}],80:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Material */

var shaderSources = _interopRequire(require("./gl/shader_sources"));

// built-in shaders

var GLSL = _interopRequire(require("./gl/glsl"));

var StyleParser = require("./styles/style_parser").StyleParser;

var Material = (function () {
    function Material(config) {
        _classCallCheck(this, Material);

        config = config || {};

        // These properties all have the same defaults, so they can be set in bulk
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var prop = _step.value;

                if (config[prop] != null) {
                    if (config[prop].texture) {
                        this[prop] = {
                            texture: config[prop].texture,
                            mapping: config[prop].mapping || "spheremap",
                            scale: GLSL.expandVec3(config[prop].scale != null ? config[prop].scale : 1),
                            amount: GLSL.expandVec4(config[prop].amount != null ? config[prop].amount : 1)
                        };
                    } else if (typeof config[prop] === "number") {
                        this[prop] = { amount: GLSL.expandVec4(config[prop]) };
                    } else if (typeof config[prop] === "string") {
                        this[prop] = { amount: StyleParser.parseColor(config[prop]) };
                    } else {
                        this[prop] = config[prop];
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        // Extra specular props
        if (this.specular) {
            this.specular.shininess = config.shininess ? parseFloat(config.shininess) : 0.2;
        }

        // Normal mapping
        if (config.normal != null) {
            this.normal = {
                texture: config.normal.texture,
                mapping: config.normal.mapping || "triplanar",
                scale: GLSL.expandVec3(config.normal.scale != null ? config.normal.scale : 1),
                amount: config.normal.amount != null ? config.normal.amount : 1
            };
        }
    }

    _createClass(Material, {
        inject: {
            value: function inject(style) {
                // For each property, sets defines to configure texture mapping, with a pattern like:
                //   TANGRAM_MATERIAL_DIFFUSE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP
                // Also sets flags to keep track of each unique mapping type being used, e.g.:
                //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
                // Enables texture coordinates if needed and not already on
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var prop = _step.value;

                        var def = "TANGRAM_MATERIAL_" + prop.toUpperCase();
                        var texdef = def + "_TEXTURE";
                        style.defines[def] = this[prop] != null;
                        if (this[prop] && this[prop].texture) {
                            style.defines[texdef] = true;
                            style.defines[texdef + "_" + this[prop].mapping.toUpperCase()] = true;
                            style.defines["TANGRAM_MATERIAL_TEXTURE_" + this[prop].mapping.toUpperCase()] = true;
                            style.texcoords = style.texcoords || this[prop].mapping === "uv";
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Normal mapping
                // As anove, sets flags to keep track of each unique mapping type being used, e.g.:
                //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
                if (this.normal && this.normal.texture) {
                    style.defines.TANGRAM_MATERIAL_NORMAL_TEXTURE = true;
                    style.defines["TANGRAM_MATERIAL_NORMAL_TEXTURE_" + this.normal.mapping.toUpperCase()] = true;
                    style.defines["TANGRAM_MATERIAL_TEXTURE_" + this.normal.mapping.toUpperCase()] = true;
                    style.texcoords = style.texcoords || this.normal.mapping === "uv";
                }

                style.replaceShaderBlock(Material.block, shaderSources["gl/shaders/material"]);
            }
        },
        setupProgram: {
            value: function setupProgram(_program) {
                // For each property, sets uniforms in the pattern:
                // u_material.diffuse, u_material.diffuseScale u_material_diffuse_texture
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var prop = _step.value;

                        if (this[prop]) {
                            if (this[prop].texture) {
                                _program.setTextureUniform("u_material_" + prop + "_texture", this[prop].texture);
                                _program.uniform("3fv", "u_material." + prop + "Scale", this[prop].scale);
                                _program.uniform("4fv", "u_material." + prop, this[prop].amount);
                            } else if (this[prop].amount) {
                                _program.uniform("4fv", "u_material." + prop, this[prop].amount);
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Extra specular props
                if (this.specular) {
                    _program.uniform("1f", "u_material.shininess", this.specular.shininess);
                }

                // Normal mapping
                if (this.normal && this.normal.texture) {
                    _program.setTextureUniform("u_material_normal_texture", this.normal.texture);
                    _program.uniform("3fv", "u_material.normalScale", this.normal.scale);
                    _program.uniform("1f", "u_material.normalAmount", this.normal.amount);
                }
            }
        }
    }, {
        isValid: {

            // Determine if a material config block has sufficient properties to create a material

            value: function isValid(config) {
                if (config == null) {
                    return false;
                }

                if (config.emission == null && config.ambient == null && config.diffuse == null && config.specular == null) {
                    return false;
                }

                return true;
            }
        }
    });

    return Material;
})();

module.exports = Material;

Material.block = "material";

},{"./gl/glsl":70,"./gl/shader_sources":72,"./styles/style_parser":92}],81:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/*jshint worker: true*/

// Modules and dependencies to expose in the public Tangram module

var Utils = _interopRequire(require("./utils/utils"));

// The leaflet layer plugin is currently the primary public API

var _leaflet_layer = require("./leaflet_layer");

var LeafletLayer = _leaflet_layer.LeafletLayer;
var leafletLayer = _leaflet_layer.leafletLayer;

// The scene worker is only activated when a worker thread is instantiated, but must always be loaded

var SceneWorker = require("../src/scene_worker").SceneWorker;

// Additional modules are exposed for debugging

var version = _interopRequire(require("./utils/version"));

var log = _interopRequire(require("loglevel"));

var Geo = _interopRequire(require("./geo"));

var DataSource = _interopRequire(require("./data_source"));

var TileManager = _interopRequire(require("./tile_manager"));

var GLSL = _interopRequire(require("./gl/glsl"));

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var VertexData = _interopRequire(require("./gl/vertex_data"));

var Texture = _interopRequire(require("./gl/texture"));

var Material = _interopRequire(require("./material"));

var Light = _interopRequire(require("./light"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var ruleCache = require("./styles/rule").ruleCache;

var StyleManager = require("./styles/style_manager").StyleManager;

var StyleParser = require("./styles/style_parser").StyleParser;

var FeatureSelection = _interopRequire(require("./selection"));

var glMatrix = _interopRequire(require("gl-matrix"));

// Default to 64-bit because we need the extra precision when multiplying matrices w/mercator projected values
glMatrix.glMatrix.setMatrixArrayType(Float64Array);

// Make some modules accessible for debugging
var debug = {
    log: log,
    Utils: Utils,
    Geo: Geo,
    DataSource: DataSource,
    TileManager: TileManager,
    GLSL: GLSL,
    ShaderProgram: ShaderProgram,
    VertexData: VertexData,
    Texture: Texture,
    Material: Material,
    Light: Light,
    SceneWorker: SceneWorker,
    WorkerBroker: WorkerBroker,
    ruleCache: ruleCache,
    StyleManager: StyleManager,
    StyleParser: StyleParser,
    FeatureSelection: FeatureSelection
};

// Window can only be set in main thread
if (Utils.isMainThread) {
    // Main thread objects that can be called from workers
    WorkerBroker.addTarget("Texture", Texture);

    window.Tangram = module.exports = {
        LeafletLayer: LeafletLayer,
        leafletLayer: leafletLayer,
        debug: debug,
        version: version.string
    };
}

if (Utils.isWorkerThread) {
    self.Tangram = {
        debug: debug,
        version: version.string
    };
}

if (Utils.isMainThread) {
    Utils.requestAnimationFramePolyfill();
}

// Setup logging to prefix with Tangram version
var originalFactory = log.methodFactory;
log.methodFactory = function (methodName, logLevel) {
    var rawMethod = originalFactory(methodName, logLevel);
    return function () {
        for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
            message[_key] = arguments[_key];
        }

        rawMethod.apply(undefined, ["Tangram " + version.string + ": "].concat(message));
    };
};

},{"../src/scene_worker":83,"./data_source":66,"./geo":67,"./gl/glsl":70,"./gl/shader_program":71,"./gl/texture":73,"./gl/vertex_data":76,"./leaflet_layer":78,"./light":79,"./material":80,"./selection":84,"./styles/rule":89,"./styles/style_manager":91,"./styles/style_parser":92,"./tile_manager":99,"./utils/utils":102,"./utils/version":103,"./utils/worker_broker":104,"gl-matrix":21,"loglevel":53}],82:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Scene */

var Geo = _interopRequire(require("./geo"));

var Utils = _interopRequire(require("./utils/utils"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var subscribeMixin = _interopRequire(require("./utils/subscribe"));

var Context = _interopRequire(require("./gl/context"));

var Texture = _interopRequire(require("./gl/texture"));

var VertexArrayObject = _interopRequire(require("./gl/vao"));

var StyleManager = require("./styles/style_manager").StyleManager;

var StyleParser = require("./styles/style_parser").StyleParser;

var Camera = _interopRequire(require("./camera"));

var Light = _interopRequire(require("./light"));

var TileManager = _interopRequire(require("./tile_manager"));

var DataSource = _interopRequire(require("./data_source"));

var FeatureSelection = _interopRequire(require("./selection"));

var Polygons = require("./styles/polygons/polygons").Polygons;

var Lines = require("./styles/lines/lines").Lines;

var Points = require("./styles/points/points").Points;

var TextStyle = require("./styles/text/text").TextStyle;

// Add built-in rendering styles
StyleManager.register(Polygons);
StyleManager.register(Lines);
StyleManager.register(Points);
StyleManager.register(TextStyle);

var log = _interopRequire(require("loglevel"));

var glMatrix = _interopRequire(require("gl-matrix"));

var mat4 = glMatrix.mat4;
var mat3 = glMatrix.mat3;
var vec3 = glMatrix.vec3;

// Load scene definition: pass an object directly, or a URL as string to load remotely

var Scene = (function () {
    function Scene(config_source, options) {
        _classCallCheck(this, Scene);

        options = options || {};
        subscribeMixin(this);

        this.initialized = false;
        this.initializing = false;
        this.sources = {};

        this.tile_manager = TileManager;
        this.tile_manager.init(this);
        this.num_workers = options.numWorkers || 2;
        this.continuous_zoom = typeof options.continuousZoom === "boolean" ? options.continuousZoom : true;
        this.tile_simplification_level = 0; // level-of-detail downsampling to apply to tile loading
        this.allow_cross_domain_workers = options.allowCrossDomainWorkers === false ? false : true;
        this.worker_url = options.workerUrl;
        if (options.disableVertexArrayObjects === true) {
            VertexArrayObject.disabled = true;
        }

        Utils.use_high_density_display = options.highDensityDisplay !== undefined ? options.highDensityDisplay : true;
        Utils.updateDevicePixelRatio();

        this.config = null;
        this.config_source = config_source;
        this.config_serialized = null;

        this.styles = null;
        this.active_styles = {};

        this.building = null; // tracks current scene building state (tiles being built, etc.)
        this.dirty = true; // request a redraw
        this.animated = false; // request redraw every frame
        this.preUpdate = options.preUpdate; // optional pre-render loop hook
        this.postUpdate = options.postUpdate; // optional post-render loop hook
        this.render_loop = !options.disableRenderLoop; // disable render loop - app will have to manually call Scene.render() per frame
        this.frame = 0;
        this.resetTime();

        this.zoom = null;
        this.center = null;

        this.zooming = false;
        this.preserve_tiles_within_zoom = 1;
        this.panning = false;
        this.container = options.container;

        this.camera = null;
        this.lights = null;
        this.background = null;

        // Model-view matrices
        // 64-bit versions are for CPU calcuations
        // 32-bit versions are downsampled and sent to GPU
        this.modelMatrix = new Float64Array(16);
        this.modelMatrix32 = new Float32Array(16);
        this.modelViewMatrix = new Float64Array(16);
        this.modelViewMatrix32 = new Float32Array(16);
        this.normalMatrix = new Float64Array(9);
        this.normalMatrix32 = new Float32Array(9);

        this.selection = null;
        this.texture_listener = null;

        // Debug config
        this.debug = {
            profile: {
                geometry_build: false
            }
        };

        this.initialized = false;
        this.initializing = false;
        this.updating = 0;
        this.generation = 0; // an id that is incremented each time the scene config is invalidated

        this.logLevel = options.logLevel || "warn";
        log.setLevel(this.logLevel);
    }

    _createClass(Scene, {
        init: {
            value: function init() {
                var _this = this;

                if (this.initialized) {
                    return Promise.resolve();
                }
                this.initializing = true;

                // Load scene definition (sources, styles, etc.), then create styles & workers
                return new Promise(function (resolve, reject) {
                    _this.tile_manager.init(_this);
                    _this.loadScene().then(function () {
                        _this.createWorkers().then(function () {
                            _this.createCanvas();
                            _this.selection = new FeatureSelection(_this.gl, _this.workers);

                            _this.texture_listener = { update: function () {
                                    return _this.dirty = true;
                                } };
                            Texture.subscribe(_this.texture_listener);

                            // Loads rendering styles from config, sets GL context and compiles programs
                            _this.updateConfig();

                            _this.initializing = false;
                            _this.initialized = true;
                            resolve();

                            if (_this.render_loop !== false) {
                                _this.setupRenderLoop();
                            }
                        })["catch"](function (e) {
                            return reject(e);
                        });
                    })["catch"](function (e) {
                        return reject(e);
                    });
                });
            }
        },
        destroy: {
            value: function destroy() {
                this.initialized = false;
                this.renderLoop = function () {}; // set to no-op because a null can cause requestAnimationFrame to throw

                this.unsubscribeAll(); // clear all event listeners

                Texture.unsubscribe(this.texture_listener);
                this.texture_listener = null;

                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                    this.canvas = null;
                }
                this.container = null;

                if (this.gl) {
                    this.gl.deleteFramebuffer(this.fbo);
                    this.fbo = null;

                    Texture.destroy(this.gl);
                    StyleManager.destroy(this.gl);
                    this.styles = {};

                    this.gl = null;
                }

                this.sources = {};

                if (Array.isArray(this.workers)) {
                    this.workers.forEach(function (worker) {
                        worker.terminate();
                    });
                    this.workers = null;
                }

                this.tile_manager.destroy();
            }
        },
        createCanvas: {
            value: function createCanvas() {
                this.container = this.container || document.body;
                this.canvas = document.createElement("canvas");
                this.canvas.style.position = "absolute";
                this.canvas.style.top = 0;
                this.canvas.style.left = 0;

                // Force tangram canvas underneath all leaflet layers, and set background to transparent
                this.canvas.style.zIndex = -1;
                this.container.style.cssText += "background: transparent;";
                this.container.appendChild(this.canvas);

                try {
                    this.gl = Context.getContext(this.canvas, {
                        alpha: false /*premultipliedAlpha: false*/,
                        device_pixel_ratio: Utils.device_pixel_ratio
                    });
                } catch (e) {
                    throw new Error("Couldn't create WebGL context. " + "Your browser may not support WebGL, or it's turned off? " + "Visit http://webglreport.com/ for more info.");
                }

                this.resizeMap(this.container.clientWidth, this.container.clientHeight);
                VertexArrayObject.init(this.gl);
            }
        },
        createObjectURL: {
            value: function createObjectURL() {
                return window.URL && window.URL.createObjectURL || window.webkitURL && window.webkitURL.createObjectURL;
            }
        },
        loadWorkerUrl: {
            value: function loadWorkerUrl(scene) {
                var worker_url = scene.worker_url || Utils.findCurrentURL("tangram.debug.js", "tangram.min.js"),
                    createObjectURL = scene.createObjectURL();

                return new Promise(function (resolve, reject) {
                    if (!worker_url) {
                        reject(new Error("Can't load worker because couldn't find base URL that library was loaded from"));
                        return;
                    }

                    if (createObjectURL && scene.allow_cross_domain_workers) {
                        var body = "importScripts('" + worker_url + "');";
                        var worker_local_url = createObjectURL(new Blob([body], { type: "application/javascript" }));
                        resolve(worker_local_url);
                    } else {
                        resolve(worker_url);
                    }
                });
            }
        },
        createWorkers: {

            // Web workers handle heavy duty tile construction: networking, geometry processing, etc.

            value: function createWorkers() {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    _this.loadWorkerUrl(_this).then(function (worker_url) {
                        _this.makeWorkers(worker_url).then(resolve, reject);
                    });
                });
            }
        },
        makeWorkers: {

            // Instantiate workers from URL, init event handlers

            value: function makeWorkers(url) {
                var _this = this;

                var queue = [];

                this.workers = [];
                for (var id = 0; id < this.num_workers; id++) {
                    var worker;

                    (function () {
                        worker = new Worker(url);

                        _this.workers[id] = worker;

                        worker.addEventListener("message", _this.workerLogMessage.bind(_this));
                        WorkerBroker.addWorker(worker);

                        log.debug("Scene.makeWorkers: initializing worker " + id);
                        var _id = id;
                        queue.push(WorkerBroker.postMessage(worker, "init", id, _this.num_workers, Utils.device_pixel_ratio).then(function (id) {
                            log.debug("Scene.makeWorkers: initialized worker " + id);
                            return id;
                        }, function (error) {
                            log.error("Scene.makeWorkers: failed to initialize worker " + _id + ":", error);
                            return Promise.reject(error);
                        }));
                    })();
                }

                this.next_worker = 0;
                return Promise.all(queue);
            }
        },
        nextWorker: {

            // Round robin selection of next worker

            value: function nextWorker() {
                var worker = this.workers[this.next_worker];
                this.next_worker = (this.next_worker + 1) % this.workers.length;
                return worker;
            }
        },
        setView: {

            /**
                Set the map view, can be passed an object with lat/lng and/or zoom
            */

            value: function setView() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var lng = _ref.lng;
                var lat = _ref.lat;
                var zoom = _ref.zoom;

                var changed = false;

                // Set center
                if (typeof lng === "number" && typeof lat === "number") {
                    if (!this.center || lng !== this.center.lng || lat !== this.center.lat) {
                        changed = true;
                        this.center = { lng: Geo.wrapLng(lng), lat: lat };
                    }
                }

                // Set zoom
                if (typeof zoom === "number" && zoom !== this.zoom) {
                    changed = true;
                    this.setZoom(zoom);
                }

                if (changed) {
                    this.updateBounds();
                }
                return changed;
            }
        },
        startZoom: {
            value: function startZoom() {
                this.last_zoom = this.zoom;
                this.zooming = true;
            }
        },
        baseZoom: {

            // Choose the base zoom level to use for a given fractional zoom

            value: function baseZoom(zoom) {
                return Math.floor(zoom);
            }
        },
        tileZoom: {

            // For a given view zoom, what tile zoom should be loaded?

            value: function tileZoom(view_zoom) {
                return this.baseZoom(view_zoom) - this.tile_simplification_level;
            }
        },
        styleZoom: {

            // For a given tile zoom, what style zoom should be used?

            value: function styleZoom(tile_zoom) {
                return this.baseZoom(tile_zoom) + this.tile_simplification_level;
            }
        },
        setZoom: {
            value: function setZoom(zoom) {
                var _this = this;

                this.zooming = false;
                var tile_zoom = this.tileZoom(zoom);

                if (!this.continuous_zoom) {
                    zoom = tile_zoom;
                }

                if (tile_zoom !== this.tileZoom(this.last_zoom)) {
                    // Remove tiles outside current zoom that are still loading
                    this.tile_manager.removeTiles(function (tile) {
                        if (tile.loading && _this.tileZoom(tile.coords.z) !== tile_zoom) {
                            log.trace("removed " + tile.key + " (was loading, but outside current zoom)");
                            return true;
                        }
                    });
                }

                this.last_zoom = this.zoom;
                this.zoom = zoom;
                this.tile_zoom = tile_zoom;

                this.updateBounds();

                this.dirty = true;
            }
        },
        viewReady: {
            value: function viewReady() {
                if (this.css_size == null || this.center == null || this.zoom == null || Object.keys(this.sources).length === 0) {
                    return false;
                }
                return true;
            }
        },
        updateBounds: {

            // Calculate viewport bounds based on current center and zoom

            value: function updateBounds() {
                // TODO: better concept of "readiness" state?
                if (!this.viewReady()) {
                    return;
                }

                this.meters_per_pixel = Geo.metersPerPixel(this.zoom);

                // Size of the half-viewport in meters at current zoom
                this.viewport_meters = {
                    x: this.css_size.width * this.meters_per_pixel,
                    y: this.css_size.height * this.meters_per_pixel
                };

                // Center of viewport in meters, and tile

                var _Geo$latLngToMeters = Geo.latLngToMeters([this.center.lng, this.center.lat]);

                var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                var x = _Geo$latLngToMeters2[0];
                var y = _Geo$latLngToMeters2[1];

                this.center_meters = { x: x, y: y };

                var z = this.tileZoom(this.zoom);
                this.center_tile = Geo.tileForMeters([this.center_meters.x, this.center_meters.y], z);

                this.bounds_meters = {
                    sw: {
                        x: this.center_meters.x - this.viewport_meters.x / 2,
                        y: this.center_meters.y - this.viewport_meters.y / 2
                    },
                    ne: {
                        x: this.center_meters.x + this.viewport_meters.x / 2,
                        y: this.center_meters.y + this.viewport_meters.y / 2
                    }
                };

                this.tile_manager.updateTilesForView();

                this.trigger("move");
                this.dirty = true;
            }
        },
        findVisibleTileCoordinates: {
            value: function findVisibleTileCoordinates() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var buffer = _ref.buffer;

                if (!this.bounds_meters) {
                    return [];
                }

                var z = this.tileZoom(this.zoom);
                var sw = Geo.tileForMeters([this.bounds_meters.sw.x, this.bounds_meters.sw.y], z);
                var ne = Geo.tileForMeters([this.bounds_meters.ne.x, this.bounds_meters.ne.y], z);
                buffer = buffer || 0;

                var coords = [];
                for (var x = sw.x - buffer; x <= ne.x + buffer; x++) {
                    for (var y = ne.y - buffer; y <= sw.y + buffer; y++) {
                        coords.push({ x: x, y: y, z: z });
                    }
                }
                return coords;
            }
        },
        pruneTileCoordinatesForView: {

            // Remove tiles too far outside of view

            value: function pruneTileCoordinatesForView() {
                var _this = this;

                var border_buffer = arguments[0] === undefined ? 2 : arguments[0];

                if (!this.viewReady()) {
                    return;
                }

                // Remove tiles that are a specified # of tiles outside of the viewport border
                var border_tiles = [Math.ceil((Math.floor(this.css_size.width / Geo.tile_size) + 2) / 2), Math.ceil((Math.floor(this.css_size.height / Geo.tile_size) + 2) / 2)];
                var style_zoom = this.tileZoom(this.zoom);

                this.tile_manager.removeTiles(function (tile) {
                    // Ignore visible tiles
                    if (tile.visible) {
                        return false;
                    }

                    // Discard if too far from current zoom
                    var zdiff = tile.coords.z - style_zoom;
                    if (Math.abs(zdiff) > _this.preserve_tiles_within_zoom) {
                        return true;
                    }

                    // Handle tiles at different zooms
                    var ztrans = Math.pow(2, zdiff);
                    var coords = {
                        x: Math.floor(tile.coords.x / ztrans),
                        y: Math.floor(tile.coords.y / ztrans)
                    };

                    // Discard tiles outside an area surrounding the viewport
                    if (Math.abs(coords.x - _this.center_tile.x) - border_tiles[0] > border_buffer) {
                        log.trace("Scene: remove tile " + tile.key + " (as " + coords.x + "/" + coords.y + "/" + style_zoom + ") for being too far out of visible area ***");
                        return true;
                    } else if (Math.abs(coords.y - _this.center_tile.y) - border_tiles[1] > border_buffer) {
                        log.trace("Scene: remove tile " + tile.key + " (as " + coords.x + "/" + coords.y + "/" + style_zoom + ") for being too far out of visible area ***");
                        return true;
                    }
                    return false;
                });
            }
        },
        resizeMap: {
            value: function resizeMap(width, height) {
                this.dirty = true;

                this.css_size = { width: width, height: height };
                this.device_size = {
                    width: Math.round(this.css_size.width * Utils.device_pixel_ratio),
                    height: Math.round(this.css_size.height * Utils.device_pixel_ratio)
                };
                this.view_aspect = this.css_size.width / this.css_size.height;
                this.updateBounds();

                if (this.canvas) {
                    this.canvas.style.width = this.css_size.width + "px";
                    this.canvas.style.height = this.css_size.height + "px";
                    this.canvas.width = this.device_size.width;
                    this.canvas.height = this.device_size.height;

                    if (this.gl) {
                        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    }
                }
            }
        },
        requestRedraw: {

            // Request scene be redrawn at next animation loop

            value: function requestRedraw() {
                this.dirty = true;
            }
        },
        immediateRedraw: {

            // Redraw scene immediately - don't wait for animation loop
            // Use sparingly, but for cases where you need the closest possible sync with other UI elements,
            // such as other, non-WebGL map layers (e.g. Leaflet raster layers, markers, etc.)

            value: function immediateRedraw() {
                this.dirty = true;
                this.render();
            }
        },
        setupRenderLoop: {

            // Setup the render loop

            value: function setupRenderLoop() {
                var _this = this;

                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var pre_render = _ref.pre_render;
                var post_render = _ref.post_render;

                this.renderLoop = function () {
                    if (_this.initialized) {
                        // Render the scene
                        _this.update();
                    }

                    // Request the next frame
                    window.requestAnimationFrame(_this.renderLoop);
                };
                setTimeout(function () {
                    _this.renderLoop();
                }, 0); // delay start by one tick
            }
        },
        update: {
            value: function update() {
                this.tile_manager.loadQueuedCoordinates();

                // Render on demand
                var will_render = !(this.dirty === false || this.initialized === false || this.updating > 0 || this.viewReady() === false);

                // Pre-render loop hook
                if (typeof this.preUpdate === "function") {
                    this.preUpdate(will_render);
                }

                // Bail if no need to render
                if (!will_render) {
                    return false;
                }
                this.dirty = false; // subclasses can set this back to true when animation is needed

                // Render the scene
                this.render();

                // Post-render loop hook
                if (typeof this.postUpdate === "function") {
                    this.postUpdate(will_render);
                }

                // Redraw every frame if animating
                if (this.animated === true) {
                    this.dirty = true;
                }

                this.frame++;
                log.trace("Scene.render()");
                return true;
            }
        },
        render: {
            value: function render() {
                var _this = this;

                var gl = this.gl;

                // Map transforms
                if (!this.center_meters) {
                    return;
                }

                // Update styles, camera, lights
                this.camera.update();
                Object.keys(this.active_styles).forEach(function (i) {
                    return _this.styles[i].update();
                });
                Object.keys(this.lights).forEach(function (i) {
                    return _this.lights[i].update();
                });

                // Renderable tile list
                this.renderable_tiles = this.tile_manager.getRenderableTiles();
                this.renderable_tiles_count = this.renderable_tiles.length;

                // Render main pass
                this.render_count = this.renderPass();

                // Render selection pass (if needed)
                if (this.selection.pendingRequests()) {
                    if (this.panning) {
                        return;
                    }

                    this.selection.bind(); // switch to FBO
                    this.renderPass("selection_program", // render w/alternate program
                    { allow_alpha_blend: false });
                    this.selection.read(); // read results from selection buffer

                    // Reset to screen buffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }

                if (this.render_count !== this.last_render_count) {
                    this.getFeatureSelectionMapSize().then(function (size) {
                        log.info("Scene: rendered " + _this.render_count + " primitives (" + size + " features in selection map)");
                    }, function () {}); // no op when promise rejects (only print last response)
                }
                this.last_render_count = this.render_count;

                return true;
            }
        },
        renderPass: {

            // Render all active styles, grouped by blend/depth type (opaque, overlay, etc.) and by program (style)
            // Called both for main render pass, and for secondary passes like selection buffer

            value: function renderPass() {
                var _this = this;

                var program_key = arguments[0] === undefined ? "program" : arguments[0];

                var _ref = arguments[1] === undefined ? {} : arguments[1];

                var allow_alpha_blend = _ref.allow_alpha_blend;

                var styles = undefined;
                var count = 0; // how many primitives were rendered

                // optionally force alpha off (e.g. for selection pass)
                allow_alpha_blend = allow_alpha_blend == null ? true : allow_alpha_blend;

                this.clearFrame({ clear_color: true, clear_depth: true });

                // Opaque styles: depth test on, depth write on, blending off
                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "opaque";
                });
                this.setRenderState({ depth_test: true, depth_write: true, alpha_blend: false });
                count += this.renderStyles(styles, program_key);

                // Transparent styles: depth test off, depth write on, custom blending
                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "add";
                });
                this.setRenderState({ depth_test: true, depth_write: false, alpha_blend: allow_alpha_blend && "add" });
                count += this.renderStyles(styles, program_key);

                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "multiply";
                });
                this.setRenderState({ depth_test: true, depth_write: false, alpha_blend: allow_alpha_blend && "multiply" });
                count += this.renderStyles(styles, program_key);

                // Overlay styles: depth test off, depth write off, blending on
                styles = Object.keys(this.styles).filter(function (s) {
                    return _this.styles[s].blend === "overlay";
                });
                this.setRenderState({ depth_test: false, depth_write: false, alpha_blend: allow_alpha_blend });
                count += this.renderStyles(styles, program_key);

                return count;
            }
        },
        renderStyles: {
            value: function renderStyles(styles, program_key) {
                var count = 0;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = styles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var style = _step.value;

                        var program = this.styles[style][program_key];
                        if (!program || !program.compiled) {
                            continue;
                        }
                        count += this.renderStyle(style, program);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return count;
            }
        },
        renderStyle: {
            value: function renderStyle(style, program) {
                var first_for_style = true;
                var render_count = 0;

                // Render tile GL geometries
                for (var t in this.renderable_tiles) {
                    var tile = this.renderable_tiles[t];

                    if (tile.meshes[style] != null) {
                        // Setup style if encountering for first time this frame
                        // (lazy init, not all styles will be used in all screen views; some styles might be defined but never used)
                        if (first_for_style === true) {
                            first_for_style = false;

                            program.use();
                            this.styles[style].setup();

                            // TODO: don't set uniforms when they haven't changed
                            program.uniform("2f", "u_resolution", this.device_size.width, this.device_size.height);
                            program.uniform("1f", "u_time", (+new Date() - this.start_time) / 1000);
                            program.uniform("3f", "u_map_position", this.center_meters.x, this.center_meters.y, this.zoom);
                            // Math.floor(this.zoom) + (Math.log((this.zoom % 1) + 1) / Math.LN2 // scale fractional zoom by log
                            program.uniform("1f", "u_meters_per_pixel", this.meters_per_pixel);
                            program.uniform("1f", "u_device_pixel_ratio", Utils.device_pixel_ratio);

                            this.camera.setupProgram(program);
                            for (var i in this.lights) {
                                this.lights[i].setupProgram(program);
                            }
                        }

                        // TODO: calc these once per tile (currently being needlessly re-calculated per-tile-per-style)

                        // Tile origin
                        program.uniform("3f", "u_tile_origin", tile.min.x, tile.min.y, tile.style_zoom);

                        // Model matrix - transform tile space into world space (meters, absolute mercator position)
                        mat4.identity(this.modelMatrix);
                        mat4.translate(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.min.x, tile.min.y, 0));
                        mat4.scale(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.span.x / Geo.tile_scale, -1 * tile.span.y / Geo.tile_scale, 1)); // scale tile local coords to meters
                        mat4.copy(this.modelMatrix32, this.modelMatrix);
                        program.uniform("Matrix4fv", "u_model", false, this.modelMatrix32);

                        // Model view matrix - transform tile space into view space (meters, relative to camera)
                        mat4.multiply(this.modelViewMatrix32, this.camera.viewMatrix, this.modelMatrix);
                        program.uniform("Matrix4fv", "u_modelView", false, this.modelViewMatrix32);

                        // Normal matrix - transforms surface normals into view space
                        mat3.normalFromMat4(this.normalMatrix32, this.modelViewMatrix32);
                        program.uniform("Matrix3fv", "u_normalMatrix", false, this.normalMatrix32);

                        // Render tile
                        tile.meshes[style].render();
                        render_count += tile.meshes[style].geometry_count;
                    }
                }

                return render_count;
            }
        },
        clearFrame: {
            value: function clearFrame() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var clear_color = _ref.clear_color;
                var clear_depth = _ref.clear_depth;

                if (!this.initialized) {
                    return;
                }

                // Defaults
                clear_color = clear_color === false ? false : true; // default true
                clear_depth = clear_depth === false ? false : true; // default true

                // Reset frame state
                var gl = this.gl;

                if (clear_color) {
                    gl.clearColor.apply(gl, _toConsumableArray(this.background.color));
                }

                if (clear_depth) {
                    gl.depthMask(true); // always clear depth if requested, even if depth write will be turned off
                }

                if (clear_color || clear_depth) {
                    var mask = (clear_color && gl.COLOR_BUFFER_BIT) | (clear_depth && gl.DEPTH_BUFFER_BIT);
                    gl.clear(mask);
                }
            }
        },
        setRenderState: {
            value: function setRenderState() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var depth_test = _ref.depth_test;
                var depth_write = _ref.depth_write;
                var cull_face = _ref.cull_face;
                var alpha_blend = _ref.alpha_blend;

                if (!this.initialized) {
                    return;
                }

                // Defaults
                // TODO: when we abstract out support for multiple render passes, these can be per-pass config options
                depth_test = depth_test === false ? false : true; // default true
                depth_write = depth_write === false ? false : true; // default true
                cull_face = cull_face === false ? false : true; // default true
                alpha_blend = alpha_blend != null ? alpha_blend : false; // default false

                // Reset frame state
                var gl = this.gl;

                if (depth_test) {
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.LEQUAL);
                } else {
                    gl.disable(gl.DEPTH_TEST);
                }

                gl.depthMask(depth_write);

                if (cull_face) {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                } else {
                    gl.disable(gl.CULL_FACE);
                }

                if (alpha_blend) {
                    gl.enable(gl.BLEND);

                    // Traditional blending
                    if (alpha_blend === true) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    }
                    // Additive blending
                    else if (alpha_blend === "add") {
                        gl.blendFunc(gl.ONE, gl.ONE);
                    }
                    // Multiplicative blending
                    else if (alpha_blend === "multiply") {
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    }
                } else {
                    gl.disable(gl.BLEND);
                }
            }
        },
        getFeatureAt: {

            // Request feature selection at given pixel. Runs async and returns results via a promise.

            value: function getFeatureAt(pixel) {
                if (!this.initialized) {
                    return Promise.reject(new Error("Scene.getFeatureAt() called before scene was initialized"));
                }

                // Point scaled to [0..1] range
                var point = {
                    x: pixel.x * Utils.device_pixel_ratio / this.device_size.width,
                    y: pixel.y * Utils.device_pixel_ratio / this.device_size.height
                };

                this.dirty = true; // need to make sure the scene re-renders for these to be processed
                return this.selection.getFeatureAt(point);
            }
        },
        rebuild: {

            // Rebuild geometry, without re-parsing the config or re-compiling styles
            // TODO: detect which elements need to be refreshed/rebuilt (stylesheet changes, etc.)

            value: function rebuild() {
                return this.rebuildGeometry();
            }
        },
        rebuildGeometry: {

            // Rebuild all tiles

            value: function rebuildGeometry() {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    // Skip rebuild if already in progress
                    if (_this.building) {
                        // Queue up to one rebuild call at a time, only save last request
                        if (_this.building.queued && _this.building.queued.reject) {
                            // notify previous request that it did not complete
                            log.debug("Scene.rebuildGeometry: request superceded by a newer call");
                            _this.building.queued.resolve(false); // false flag indicates rebuild request was superceded
                        }

                        // Save queued request
                        _this.building.queued = { resolve: resolve, reject: reject };
                        log.trace("Scene.rebuildGeometry(): queuing request");
                        return;
                    }

                    // Track tile build state
                    _this.building = { resolve: resolve, reject: reject };

                    // Profiling
                    if (_this.debug.profile.geometry_build) {
                        _this._profile("rebuildGeometry");
                    }

                    // Update config (in case JS objects were manipulated directly)
                    _this.syncConfigToWorker();
                    StyleManager.compile(_this.updateActiveStyles()); // only recompile newly active styles
                    _this.resetFeatureSelection();
                    _this.resetTime();

                    // Rebuild visible tiles, sorted from center
                    var build = [];
                    _this.tile_manager.forEachTile(function (tile) {
                        if (tile.visible) {
                            build.push(tile);
                        } else {
                            _this.tile_manager.removeTile(tile.key);
                        }
                    });
                    _this.tile_manager.buildTiles(build);
                }).then(function () {
                    // Profiling
                    if (_this.debug.profile.geometry_build) {
                        _this._profileEnd("rebuildGeometry");
                    }
                });
            }
        },
        tileManagerBuildDone: {

            // Tile manager finished building tiles

            value: function tileManagerBuildDone() {
                if (this.building) {
                    log.info("Scene: build geometry finished");
                    if (this.building.resolve) {
                        this.building.resolve(true);
                    }

                    // Another rebuild queued?
                    var queued = this.building.queued;
                    this.building = null;
                    if (queued) {
                        log.debug("Scene: starting queued rebuildGeometry() request");
                        this.rebuildGeometry().then(queued.resolve, queued.reject);
                    }
                }
            }
        },
        loadScene: {

            /**
               Load (or reload) the scene config
               @return {Promise}
            */

            value: function loadScene() {
                var _this = this;

                this.config_path = typeof this.config_source === "string" && Utils.pathForURL(this.config_source);
                Texture.base_url = this.config_path;

                return Utils.loadResource(this.config_source).then(function (config) {
                    _this.config = config;
                    return _this.preProcessConfig().then(function () {
                        _this.trigger("loadScene", _this.config);
                    });
                })["catch"](function (e) {
                    throw new Error("Error loading scene file '" + _this.config_source + "': " + e.message);
                });
            }
        },
        reload: {

            // Reload scene config and rebuild tiles
            // Optionally specify new scene file URL

            value: function reload() {
                var _this = this;

                var config_source = arguments[0] === undefined ? null : arguments[0];

                if (!this.initialized) {
                    return Promise.resolve(this);
                }

                // Remove tiles before rebuilding
                this.tile_manager.removeTiles(function (tile) {
                    return !tile.visible;
                });

                this.updating++;
                this.initialized = false;
                this.initializing = true;

                this.config_source = config_source || this.config_source;

                return this.loadScene().then(function () {
                    _this.updateConfig();
                    _this.syncConfigToWorker();
                    return _this.rebuildGeometry().then(function () {
                        _this.updating--;
                        _this.initialized = true;
                        _this.initializing = false;
                        return _this;
                    });
                }, function (error) {
                    _this.initialized = true;
                    _this.initializing = false;
                    _this.updating--;
                    throw error;
                });
            }
        },
        loadDataSources: {
            value: function loadDataSources() {
                for (var name in this.config.sources) {
                    var source = this.config.sources[name];
                    source.url = Utils.addBaseURL(source.url);
                    this.sources[name] = DataSource.create(Object.assign({}, source, { name: name }));
                }
            }
        },
        preProcessConfig: {

            // Normalize some settings that may not have been explicitly specified in the scene definition

            value: function preProcessConfig() {
                // Assign ids to data sources
                var source_id = 0;
                for (var source in this.config.sources) {
                    this.config.sources[source].id = source_id++;
                }

                // If only one camera specified, set it as default
                this.config.cameras = this.config.cameras || {};
                if (this.config.camera) {
                    this.config.cameras["default"] = this.config.camera;
                }
                var camera_names = Object.keys(this.config.cameras);
                if (camera_names.length === 0) {
                    this.config.cameras["default"] = { active: true };
                } else if (!this._active_camera) {
                    // If no camera set as active, use first one
                    this.config.cameras[camera_names[0]].active = true;
                }

                this.config.lights = this.config.lights || {}; // ensure lights object
                this.config.styles = this.config.styles || {}; // ensure styles object

                return StyleManager.preload(this.config.styles, this.config_path);
            }
        },
        loadTextures: {

            // Load all textures in the scene definition

            value: function loadTextures() {
                this.normalizeTextures();
                return Texture.createFromObject(this.gl, this.config.textures);
            }
        },
        normalizeTextures: {

            // Handle single or multi-texture syntax, for stylesheet convenience

            value: function normalizeTextures() {
                if (!this.config.styles) {
                    return;
                }

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.entries(this.config.styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _slicedToArray(_step.value, 2);

                        var style_name = _step$value[0];
                        var style = _step$value[1];

                        // If style has a single 'texture' object, move it to the global scene texture set
                        // and give it a default name
                        if (style.texture && typeof style.texture === "object") {
                            var texture_name = "__" + style_name;
                            this.config.textures = this.config.textures || {};
                            this.config.textures[texture_name] = style.texture;
                            style.texture = texture_name; // point stlye to location of texture
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        updateStyles: {

            // Called (currently manually) after styles are updated in stylesheet

            value: function updateStyles() {
                if (!this.initialized && !this.initializing) {
                    throw new Error("Scene.updateStyles() called before scene was initialized");
                }

                // (Re)build styles from config
                StyleManager.init();
                this.styles = StyleManager.build(this.config.styles, this);

                // Optionally set GL context (used when initializing or re-initializing GL resources)
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.values(this.styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var style = _step.value;

                        style.setGL(this.gl);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Find & compile active styles
                this.updateActiveStyles();
                StyleManager.compile(Object.keys(this.active_styles));

                this.dirty = true;
            }
        },
        updateActiveStyles: {
            value: function updateActiveStyles() {
                var _this = this;

                // Make a set of currently active styles (used in a draw rule)
                // Note: doesn't actually check if any geometry matches the rule, just that the style is potentially renderable
                var prev_styles = Object.keys(this.active_styles || {});
                this.active_styles = {};
                var animated = false; // is any active style animated?
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.recurseValues(this.config.layers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var rule = _step.value;

                        if (rule.draw) {
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Utils.entries(rule.draw)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var _step2$value = _slicedToArray(_step2.value, 2);

                                    var _name = _step2$value[0];
                                    var group = _step2$value[1];

                                    // TODO: warn on non-object draw group
                                    if (typeof group === "object" && group.visible !== false) {
                                        (function () {
                                            var style_name = group.style || _name;
                                            var styles = [style_name];

                                            // optional additional outline style
                                            if (group.outline && group.outline.style) {
                                                styles.push(group.outline.style);
                                            }

                                            styles = styles.filter(function (x) {
                                                return _this.styles[x];
                                            }).forEach(function (style_name) {
                                                var style = _this.styles[style_name];
                                                if (style) {
                                                    _this.active_styles[style_name] = true;
                                                    if (style.animated) {
                                                        animated = true;
                                                    }
                                                }
                                            });
                                        })();
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                        _iterator2["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Use explicitly set scene animation flag if defined, otherwise turn on animation
                // if there are any animated styles
                this.animated = this.config.scene.animated !== undefined ? this.config.scene.animated : animated;

                // Compile newly active styles
                return Object.keys(this.active_styles).filter(function (s) {
                    return prev_styles.indexOf(s) === -1;
                });
            }
        },
        createCamera: {

            // Create camera

            value: function createCamera() {
                this.camera = Camera.create(this._active_camera, this, this.config.cameras[this._active_camera]);

                // TODO: replace this and move all position info to camera
                this.camera.updateScene();
            }
        },
        getActiveCamera: {

            // Get active camera - for public API

            value: function getActiveCamera() {
                return this._active_camera;
            }
        },
        setActiveCamera: {

            // Set active camera and recompile - for public API

            value: function setActiveCamera(name) {
                this._active_camera = name;
                this.updateConfig();
                return this._active_camera;
            }
        },
        _active_camera: {

            // Internal management of active camera

            get: function () {
                for (var name in this.config.cameras) {
                    if (this.config.cameras[name].active) {
                        return name;
                    }
                }
            },
            set: function (name) {
                var prev = this._active_camera;

                // Set new active camera
                if (this.config.cameras[name]) {
                    this.config.cameras[name].active = true;

                    // Clear previously active camera
                    if (prev && prev !== name && this.config.cameras[prev]) {
                        delete this.config.cameras[prev].active;
                    }
                }
            }
        },
        createLights: {

            // Create lighting

            value: function createLights() {
                this.lights = {};
                for (var i in this.config.lights) {
                    this.config.lights[i].name = i;
                    this.config.lights[i].visible = this.config.lights[i].visible === false ? false : true;
                    if (this.config.lights[i].visible) {
                        this.lights[i] = Light.create(this, this.config.lights[i]);
                    }
                }
                Light.inject(this.lights);
            }
        },
        setBackground: {

            // Set background color

            value: function setBackground() {
                var bg = this.config.scene.background;
                this.background = {};
                if (bg && bg.color) {
                    this.background.color = StyleParser.parseColor(bg.color);
                }
                if (!this.background.color) {
                    this.background.color = [0, 0, 0, 1]; // default background to black
                }
            }
        },
        updateConfig: {

            // Update scene config, and optionally rebuild geometry

            value: function updateConfig() {
                var _this = this;

                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var rebuild = _ref.rebuild;

                this.generation++;
                this.updating++;
                this.config.scene = this.config.scene || {};
                this.createCamera();
                this.createLights();
                this.loadDataSources();
                this.loadTextures();
                this.setBackground();
                this.updateBounds();

                // TODO: detect changes to styles? already (currently) need to recompile anyway when camera or lights change
                this.updateStyles();
                this.syncConfigToWorker();
                if (rebuild) {
                    return this.rebuildGeometry().then(function () {
                        return _this.updating--;
                    });
                } else {
                    this.updating--;
                    return Promise.resolve();
                }
            }
        },
        syncConfigToWorker: {

            // Serialize config and send to worker

            value: function syncConfigToWorker() {
                var _this = this;

                // Tell workers we're about to rebuild (so they can update styles, etc.)
                this.config_serialized = Utils.serializeWithFunctions(this.config);
                this.workers.forEach(function (worker) {
                    WorkerBroker.postMessage(worker, "updateConfig", {
                        config: _this.config_serialized,
                        generation: _this.generation
                    });
                });
            }
        },
        resetFeatureSelection: {
            value: function resetFeatureSelection() {
                this.workers.forEach(function (worker) {
                    return WorkerBroker.postMessage(worker, "resetFeatureSelection");
                });
            }
        },
        getFeatureSelectionMapSize: {

            // Gets the current feature selection map size across all workers. Returns a promise.

            value: function getFeatureSelectionMapSize() {
                var _this = this;

                if (this.fetching_selection_map) {
                    return Promise.reject();
                }
                this.fetching_selection_map = true;

                return Promise.all(this.workers.map(function (worker) {
                    return WorkerBroker.postMessage(worker, "getFeatureSelectionMapSize");
                })).then(function (sizes) {
                    _this.fetching_selection_map = false;
                    return sizes.reduce(function (a, b) {
                        return a + b;
                    });
                });
            }
        },
        resetTime: {

            // Reset internal clock, mostly useful for consistent experience when changing styles/debugging

            value: function resetTime() {
                this.start_time = +new Date();
            }
        },
        getDebugSum: {

            // Stats/debug/profiling methods

            // Sum of a debug property across tiles

            value: function getDebugSum(prop, filter) {
                var sum = 0;
                for (var t in this.tiles) {
                    if (this.tiles[t].debug[prop] != null && (typeof filter !== "function" || filter(this.tiles[t]) === true)) {
                        sum += this.tiles[t].debug[prop];
                    }
                }
                return sum;
            }
        },
        getDebugAverage: {

            // Average of a debug property across tiles

            value: function getDebugAverage(prop, filter) {
                return this.getDebugSum(prop, filter) / Object.keys(this.tiles).length;
            }
        },
        workerLogMessage: {

            // Log messages pass through from web workers

            value: function workerLogMessage(event) {
                if (event.data.type !== "log") {
                    return;
                }

                var _event$data = event.data;
                var worker_id = _event$data.worker_id;
                var level = _event$data.level;
                var msg = _event$data.msg;

                if (log[level]) {
                    log[level].apply(log, ["worker " + worker_id + ":"].concat(_toConsumableArray(msg)));
                } else {
                    log.error("Scene.workerLogMessage: unrecognized log level " + level);
                }
            }
        },
        _profile: {

            // Profile helpers, issues a profile on main thread & all workers

            value: function _profile(name) {
                console.profile("main thread: " + name);
                this.workers.forEach(function (w) {
                    return WorkerBroker.postMessage(w, "profile", name);
                });
            }
        },
        _profileEnd: {
            value: function _profileEnd(name) {
                console.profileEnd("main thread: " + name);
                this.workers.forEach(function (w) {
                    return WorkerBroker.postMessage(w, "profileEnd", name);
                });
            }
        }
    });

    return Scene;
})();

module.exports = Scene;

// Static methods/state

Scene.create = function (config) {
    var options = arguments[1] === undefined ? {} : arguments[1];

    return new Scene(config, options);
};

},{"./camera":65,"./data_source":66,"./geo":67,"./gl/context":69,"./gl/texture":73,"./gl/vao":74,"./light":79,"./selection":84,"./styles/lines/lines":86,"./styles/points/points":87,"./styles/polygons/polygons":88,"./styles/style_manager":91,"./styles/style_parser":92,"./styles/text/text":97,"./tile_manager":99,"./utils/subscribe":101,"./utils/utils":102,"./utils/worker_broker":104,"gl-matrix":21,"loglevel":53}],83:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*jshint worker: true*/

var Utils = _interopRequire(require("./utils/utils"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

// jshint ignore:line

var Tile = _interopRequire(require("./tile"));

var DataSource = _interopRequire(require("./data_source.js"));

var FeatureSelection = _interopRequire(require("./selection"));

var StyleParser = require("./styles/style_parser").StyleParser;

var StyleManager = require("./styles/style_manager").StyleManager;

var parseRules = require("./styles/rule").parseRules;

var Texture = _interopRequire(require("./gl/texture"));

var SceneWorker = self;

exports.SceneWorker = SceneWorker;
// Worker functionality will only be defined in worker thread
Utils.isWorkerThread && Object.assign(self, {

    sources: {
        tiles: {},
        objects: {}
    },
    styles: {},
    rules: {},
    layers: {},
    tiles: {},
    objects: {},
    config: {},

    // Initialize worker
    init: function init(worker_id, num_workers, device_pixel_ratio) {
        self._worker_id = worker_id;
        self.num_workers = num_workers;
        Utils.device_pixel_ratio = device_pixel_ratio;
        FeatureSelection.setPrefix(self._worker_id);
        return worker_id;
    },

    // Starts a config refresh
    updateConfig: function updateConfig(_ref) {
        var config = _ref.config;
        var generation = _ref.generation;

        self.config = null;
        config = JSON.parse(config);

        self.generation = generation;
        self.styles = null;

        // Data block functions are not macro'ed and wrapped like the rest of the style functions are
        // TODO: probably want a cleaner way to exclude these
        for (var layer in config.layers) {
            config.layers[layer].data = Utils.stringsToFunctions(config.layers[layer].data);
        }

        // Create data sources
        config.sources = Utils.stringsToFunctions(StyleParser.expandMacros(config.sources));
        for (var name in config.sources) {
            var source = DataSource.create(Object.assign(config.sources[name], { name: name }));
            if (source.tiled) {
                self.sources.tiles[name] = source;
            } else {
                // Distribute object sources across workers
                if (source.id % self.num_workers === self._worker_id) {
                    // Load source if not cached
                    self.sources.objects[name] = source;
                    if (!self.objects[source.name]) {
                        self.objects[source.name] = {};
                        source.load(self.objects[source.name]);
                    }
                }
            }
        }

        // Expand styles
        self.config = Utils.stringsToFunctions(StyleParser.expandMacros(config), StyleParser.wrapFunction);
        self.styles = StyleManager.build(self.config.styles, { generation: self.generation });

        // Parse each top-level layer as a separate rule tree
        // TODO: find a more graceful way to incorporate this

        self.rules = parseRules(self.config.layers);

        // Sync tetxure info from main thread
        self.syncing_textures = self.syncTextures();

        // Return promise for when config refresh finishes
        self.configuring = self.syncing_textures.then(function () {
            Utils.log("debug", "updated config");
        });
    },

    // Returns a promise that fulfills when config refresh is finished
    awaitConfiguration: function awaitConfiguration() {
        return self.configuring;
    },

    // Build a tile: load from tile source if building for first time, otherwise rebuild with existing data
    buildTile: function buildTile(_ref) {
        var tile = _ref.tile;

        // Tile cached?
        if (self.tiles[tile.key] != null) {
            // Already loading?
            if (self.tiles[tile.key].loading === true) {
                return;
            }
        }

        // Update tile cache
        tile = self.tiles[tile.key] = Object.assign(self.tiles[tile.key] || {}, tile);

        // Update config (styles, etc.), then build tile
        return self.awaitConfiguration().then(function () {
            // First time building the tile
            if (tile.loaded !== true) {

                return new Promise(function (resolve, reject) {

                    tile.loading = true;
                    tile.loaded = false;
                    tile.error = null;

                    self.loadTileSourceData(tile).then(function () {
                        // Warn and continue on data source error
                        if (tile.source_data.error) {
                            Utils.log("warn", "tile load error(s) for " + tile.key + ": " + tile.source_data.error);
                        }

                        tile.loading = false;
                        tile.loaded = true;
                        Tile.buildGeometry(tile, self.config.layers, self.rules, self.styles).then(function (keys) {
                            resolve({ tile: Tile.slice(tile, keys) });
                        });
                    })["catch"](function (error) {
                        tile.loading = false;
                        tile.loaded = false;
                        tile.error = error.toString();
                        Utils.log("error", "tile load error for " + tile.key + ": " + error.stack);

                        resolve({ tile: Tile.slice(tile) });
                    });
                });
            }
            // Tile already loaded, just rebuild
            else {
                Utils.log("trace", "used worker cache for tile " + tile.key);

                // Build geometry
                return Tile.buildGeometry(tile, self.config.layers, self.rules, self.styles).then(function (keys) {
                    return { tile: Tile.slice(tile, keys) };
                });
            }
        });
    },

    // Load this tile's data source
    loadTileSourceData: function loadTileSourceData(tile) {
        return self.sources.tiles[tile.source].load(tile);
    },

    // Remove tile
    removeTile: function removeTile(key) {
        var tile = self.tiles[key];

        if (tile != null) {
            // Cancel if loading
            if (tile.loading === true) {
                Utils.log("trace", "cancel tile load for " + key);
                tile.loading = false;
            }

            Tile.cancel(tile);

            // Remove from cache
            FeatureSelection.clearTile(key);
            delete self.tiles[key];
            Utils.log("trace", "remove tile from cache for " + key);
        }
    },

    // Get a feature from the selection map
    getFeatureSelection: function getFeatureSelection() {
        var _ref = arguments[0] === undefined ? {} : arguments[0];

        var id = _ref.id;
        var key = _ref.key;

        var selection = FeatureSelection.map[key];

        return {
            id: id,
            feature: selection && selection.feature
        };
    },

    // Resets the feature selection state
    resetFeatureSelection: function resetFeatureSelection() {
        FeatureSelection.reset();
    },

    // Selection map size for this worker
    getFeatureSelectionMapSize: function getFeatureSelectionMapSize() {
        return FeatureSelection.getMapSize();
    },

    // Texture info needs to be synced from main thread
    syncTextures: function syncTextures() {
        // We're only syncing the textures that have sprites defined, since these are (currently) the only ones we
        // need info about for geometry construction (e.g. width/height, which we only know after the texture loads)
        var textures = [];
        if (self.config.textures) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Utils.entries(self.config.textures)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 2);

                    var texname = _step$value[0];
                    var texture = _step$value[1];

                    if (texture.sprites) {
                        textures.push(texname);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        Utils.log("trace", "sync textures to worker:", textures);
        if (textures.length > 0) {
            return Texture.syncTexturesToWorker(textures);
        }
        return Promise.resolve();
    },

    // Profiling helpers
    profile: function profile(name) {
        console.profile("worker " + self._worker_id + ": " + name);
    },

    profileEnd: function profileEnd(name) {
        console.profileEnd("worker " + self._worker_id + ": " + name);
    }

});

},{"./data_source.js":66,"./gl/texture":73,"./selection":84,"./styles/rule":89,"./styles/style_manager":91,"./styles/style_parser":92,"./tile":98,"./utils/utils":102,"./utils/worker_broker":104}],84:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Texture = _interopRequire(require("./gl/texture"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var FeatureSelection = (function () {
    function FeatureSelection(gl, workers) {
        _classCallCheck(this, FeatureSelection);

        this.gl = gl;
        this.workers = workers; // pool of workers to request feature look-ups from, keyed by id
        this.init();
    }

    _createClass(FeatureSelection, {
        init: {
            value: function init() {
                // Selection state tracking
                this.requests = {}; // pending selection requests
                this.feature = null; // currently selected feature
                this.read_delay = 5; // delay time from selection render to framebuffer sample, to avoid CPU/GPU sync lock
                this.read_delay_timer = null; // current timer (setTimeout) for delayed selection reads

                this.pixel = new Uint8Array(4);
                this.pixel32 = new Float32Array(this.pixel.buffer);

                // Frame buffer for selection
                // TODO: initiate lazily in case we don't need to do any selection
                this.fbo = this.gl.createFramebuffer();
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
                this.fbo_size = { width: 256, height: 256 }; // TODO: make configurable / adaptive based on canvas size
                this.fbo_size.aspect = this.fbo_size.width / this.fbo_size.height;

                // Texture for the FBO color attachment
                var fbo_texture = new Texture(this.gl, "selection_fbo");
                fbo_texture.setData(this.fbo_size.width, this.fbo_size.height, null, { filtering: "nearest" });
                this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, fbo_texture.texture, 0);

                // Renderbuffer for the FBO depth attachment
                var fbo_depth_rb = this.gl.createRenderbuffer();
                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, fbo_depth_rb);
                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.fbo_size.width, this.fbo_size.height);
                this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, fbo_depth_rb);

                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            }
        },
        bind: {
            value: function bind() {
                // Switch to FBO
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
                this.gl.viewport(0, 0, this.fbo_size.width, this.fbo_size.height);
            }
        },
        getFeatureAt: {

            // Request feature selection
            // Runs asynchronously, schedules selection buffer to be updated

            value: function getFeatureAt(point) {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    // Queue requests for feature selection, and they will be picked up by the render loop
                    _this.selection_request_id = _this.selection_request_id + 1 || 0;
                    _this.requests[_this.selection_request_id] = {
                        type: "point",
                        id: _this.selection_request_id,
                        point: point,
                        resolve: resolve
                    };
                });
            }
        },
        pendingRequests: {

            // Any pending selection requests

            value: function pendingRequests() {
                return this.requests;
            }
        },
        read: {

            // Read pending results from the selection buffer. Called after rendering to selection buffer.

            value: function read() {
                var _this = this;

                // Delay reading the pixel result from the selection buffer to avoid CPU/GPU sync lock.
                // Calling readPixels synchronously caused a massive performance hit, presumably since it
                // forced this function to wait for the GPU to finish rendering and retrieve the texture contents.
                if (this.read_delay_timer != null) {
                    clearTimeout(this.read_delay_timer);
                }
                this.read_delay_timer = setTimeout(function () {
                    var gl = _this.gl;

                    gl.bindFramebuffer(gl.FRAMEBUFFER, _this.fbo);

                    for (var r in _this.requests) {
                        var request = _this.requests[r];

                        // This request was already sent to the worker, we're just awaiting its reply
                        if (request.sent) {
                            continue;
                        }

                        // TODO: support other selection types, such as features within a box
                        if (request.type !== "point") {
                            continue;
                        }

                        // Check selection map against FBO
                        gl.readPixels(Math.floor(request.point.x * _this.fbo_size.width), Math.floor((1 - request.point.y) * _this.fbo_size.height), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, _this.pixel);
                        var feature_key = _this.pixel[0] + (_this.pixel[1] << 8) + (_this.pixel[2] << 16) + (_this.pixel[3] << 24) >>> 0;

                        // If feature found, ask appropriate web worker to lookup feature
                        var worker_id = _this.pixel[3];
                        if (worker_id !== 255) {
                            // 255 indicates an empty selection buffer pixel
                            if (_this.workers[worker_id] != null) {
                                WorkerBroker.postMessage(_this.workers[worker_id], "getFeatureSelection", { id: request.id, key: feature_key }).then(function (message) {
                                    _this.finishRead(message);
                                });
                            }
                        }
                        // No feature found, but still need to resolve promise
                        else {
                            _this.finishRead({ id: request.id, feature: null });
                        }

                        request.sent = true;
                    }

                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }, this.read_delay);
            }
        },
        finishRead: {

            // Called on main thread when a web worker finds a feature in the selection buffer

            value: function finishRead(message) {
                var request = this.requests[message.id];
                if (!request) {
                    throw new Error("FeatureSelection.finishRead() called without any message");
                }

                var feature = message.feature;
                var changed = false;
                if (feature != null && this.feature == null || feature == null && this.feature != null || feature != null && this.feature != null && feature.id !== this.feature.id) {
                    changed = true;
                }

                this.feature = feature; // store the most recently selected feature

                // Resolve the request
                request.resolve({ feature: feature, changed: changed, request: request });
                delete this.requests[message.id]; // done processing this request
            }
        }
    }, {
        makeEntry: {

            // Selection map generation
            // Each worker will create its own independent, 'local' selection map

            // Create a unique 32-bit color to identify a feature
            // Workers independently create/modify selection colors in their own threads, but we also
            // need the main thread to know where each feature color originated. To accomplish this,
            // we partition the map by setting the 4th component (alpha channel) to the worker's id.

            value: function makeEntry(tile) {
                // 32-bit color key
                this.map_entry++;
                var ir = this.map_entry & 255;
                var ig = this.map_entry >> 8 & 255;
                var ib = this.map_entry >> 16 & 255;
                var ia = this.map_prefix;
                var r = ir / 255;
                var g = ig / 255;
                var b = ib / 255;
                var a = ia / 255;
                var key = ir + (ig << 8) + (ib << 16) + (ia << 24) >>> 0; // need unsigned right shift to convert to positive #

                this.map[key] = {
                    color: [r, g, b, a] };
                this.map_size++;

                this.tiles[tile.key] = this.tiles[tile.key] || [];
                this.tiles[tile.key].push(key);

                return this.map[key];
            }
        },
        makeColor: {
            value: function makeColor(feature, tile) {
                var selector = this.makeEntry(tile);
                selector.feature = {
                    id: feature.id,
                    properties: feature.properties,
                    tile: tile.key
                };

                return selector.color;
            }
        },
        reset: {
            value: function reset() {
                this.map = {};
                this.map_size = 0;
                this.map_entry = 0;
            }
        },
        clearTile: {
            value: function clearTile(key) {
                var _this = this;

                if (Array.isArray(this.tiles[key])) {
                    this.tiles[key].forEach(function (k) {
                        return delete _this.map[k];
                    });
                    this.map_size -= this.tiles[key].length;
                    delete this.tiles[key];
                }
            }
        },
        getMapSize: {
            value: function getMapSize() {
                return this.map_size;
            }
        },
        setPrefix: {
            value: function setPrefix(prefix) {
                this.map_prefix = prefix;
            }
        }
    });

    return FeatureSelection;
})();

module.exports = FeatureSelection;

// Static properties
FeatureSelection.map = {}; // this will be unique per module instance (so unique per worker)
FeatureSelection.tiles = {}; // selection keys, by tile
FeatureSelection.map_size = 0;
FeatureSelection.map_entry = 0;
FeatureSelection.map_prefix = 0; // set by worker to worker id #
FeatureSelection.defaultColor = [0, 0, 0, 1];

},{"./gl/texture":73,"./utils/worker_broker":104}],85:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

// Geometry building functions

var Vector = _interopRequire(require("../vector"));

var Geo = _interopRequire(require("../geo"));

var earcut = _interopRequire(require("earcut"));

var Builders;
module.exports = Builders = {};

Builders.debug = false;

Builders.tile_bounds = [{ x: 0, y: 0 }, { x: Geo.tile_scale, y: -Geo.tile_scale } // TODO: correct for flipped y-axis?
];

// Re-scale UVs from [0, 1] range to a smaller area within the image
Builders.scaleTexcoordsToSprite = function (uv, area_origin, area_size, tex_size) {
    var area_origin_y = tex_size[1] - area_origin[1] - area_size[1];
    var suv = [];
    suv[0] = (uv[0] * area_size[0] + area_origin[0]) / tex_size[0];
    suv[1] = (uv[1] * area_size[1] + area_origin_y) / tex_size[1];
    return suv;
};

Builders.getTexcoordsForSprite = function (area_origin, area_size, tex_size) {
    return [Builders.scaleTexcoordsToSprite([0, 0], area_origin, area_size, tex_size), Builders.scaleTexcoordsToSprite([1, 1], area_origin, area_size, tex_size)];
};

// Tesselate a flat 2D polygon
// x & y coordinates will be set as first two elements of provided vertex_template
Builders.buildPolygons = function (polygons, vertex_data, vertex_template, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        // Find polygon extents to calculate UVs, fit them to the axis-aligned bounding box
        if (texcoord_index) {
            var _Geo$findBoundingBox = Geo.findBoundingBox(polygon);

            var _Geo$findBoundingBox2 = _slicedToArray(_Geo$findBoundingBox, 4);

            var min_x = _Geo$findBoundingBox2[0];
            var min_y = _Geo$findBoundingBox2[1];
            var max_x = _Geo$findBoundingBox2[2];
            var max_y = _Geo$findBoundingBox2[3];

            var span_x = max_x - min_x;
            var span_y = max_y - min_y;
            var scale_u = (max_u - min_u) / span_x;
            var scale_v = (max_v - min_v) / span_y;
        }

        // Tessellate
        var vertices = Builders.triangulatePolygon(polygon);

        // Add vertex data
        var num_vertices = vertices.length;
        for (var v = 0; v < num_vertices; v++) {
            var vertex = vertices[v];
            vertex_template[0] = vertex[0];
            vertex_template[1] = vertex[1];

            // Add UVs
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = (vertex[0] - min_x) * scale_u + min_u;
                vertex_template[texcoord_index + 1] = (vertex[1] - min_y) * scale_v + min_v;
            }

            vertex_data.addVertex(vertex_template);
        }
    }
};

// Tesselate and extrude a flat 2D polygon into a simple 3D model with fixed height and add to GL vertex buffer
Builders.buildExtrudedPolygons = function (polygons, z, height, min_height, vertex_data, vertex_template, normal_index, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;

    // Top
    var min_z = z + (min_height || 0);
    var max_z = z + height;
    vertex_template[2] = max_z;
    Builders.buildPolygons(polygons, vertex_data, vertex_template, { texcoord_index: texcoord_index });

    // Walls
    // Fit UVs to wall quad

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    if (texcoord_index) {
        var texcoords = [[min_u, max_v], [min_u, min_v], [max_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        for (var q = 0; q < polygon.length; q++) {
            var contour = polygon[q];

            for (var w = 0; w < contour.length - 1; w++) {
                // Two triangles for the quad formed by each vertex pair, going from bottom to top height
                var wall_vertices = [
                // Triangle
                [contour[w + 1][0], contour[w + 1][1], max_z], [contour[w + 1][0], contour[w + 1][1], min_z], [contour[w][0], contour[w][1], min_z],
                // Triangle
                [contour[w][0], contour[w][1], min_z], [contour[w][0], contour[w][1], max_z], [contour[w + 1][0], contour[w + 1][1], max_z]];

                // Calc the normal of the wall from up vector and one segment of the wall triangles
                var normal = Vector.cross([0, 0, 1], Vector.normalize([contour[w + 1][0] - contour[w][0], contour[w + 1][1] - contour[w][1], 0]));

                // Update vertex template with current surface normal
                vertex_template[normal_index + 0] = normal[0];
                vertex_template[normal_index + 1] = normal[1];
                vertex_template[normal_index + 2] = normal[2];

                for (var wv = 0; wv < wall_vertices.length; wv++) {
                    vertex_template[0] = wall_vertices[wv][0];
                    vertex_template[1] = wall_vertices[wv][1];
                    vertex_template[2] = wall_vertices[wv][2];

                    if (texcoord_index) {
                        vertex_template[texcoord_index + 0] = texcoords[wv][0];
                        vertex_template[texcoord_index + 1] = texcoords[wv][1];
                    }

                    vertex_data.addVertex(vertex_template);
                }
            }
        }
    }
};

// Build tessellated triangles for a polyline
Builders.buildPolylines = function (lines, width, vertex_data, vertex_template, _ref) {
    var closed_polygon = _ref.closed_polygon;
    var remove_tile_edges = _ref.remove_tile_edges;
    var tile_edge_tolerance = _ref.tile_edge_tolerance;
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var scaling_index = _ref.scaling_index;
    var join = _ref.join;
    var cap = _ref.cap;

    var cornersOnCap = cap === "square" ? 2 : cap === "round" ? 3 : 0; // Butt is the implicit default
    var trianglesOnJoin = join === "bevel" ? 1 : join === "round" ? 3 : 0; // Miter is the implicit default

    // Build variables

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    // Values that are constant for each line and are passed to helper functions
    var constants = {
        vertex_data: vertex_data,
        vertex_template: vertex_template,
        halfWidth: width / 2,
        vertices: [],
        scaling_index: scaling_index,
        scalingVecs: scaling_index && [],
        texcoord_index: texcoord_index,
        texcoords: texcoord_index && [],
        min_u: min_u, min_v: min_v, max_u: max_u, max_v: max_v,
        nPairs: 0
    };

    for (var ln = 0; ln < lines.length; ln++) {
        var line = lines[ln];
        var lineSize = line.length;

        // Ignore non-lines
        if (lineSize < 2) {
            continue;
        }

        //  Initialize variables
        var coordPrev = [0, 0],
            // Previous point coordinates
        coordCurr = [0, 0],
            // Current point coordinates
        coordNext = [0, 0]; // Next point coordinates

        var normPrev = [0, 0],
            // Right normal to segment between previous and current m_points
        normCurr = [0, 0],
            // Right normal at current point, scaled for miter joint
        normNext = [0, 0]; // Right normal to segment between current and next m_points

        var isPrev = false,
            isNext = true;

        // Add vertices to buffer acording their index
        indexPairs(constants);

        // Do this with the rest (except the last one)
        for (var i = 0; i < lineSize; i++) {

            // There is a next one?
            isNext = i + 1 < lineSize;

            if (isPrev) {
                // If there is a previus one, copy the current (previous) values on *Prev
                coordPrev = coordCurr;
                normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
            } else if (i === 0 && closed_polygon === true) {
                // If is the first point and is a close polygon

                var needToClose = true;
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(line[i], line[lineSize - 2], { tile_edge_tolerance: tile_edge_tolerance })) {
                        needToClose = false;
                    }
                }

                if (needToClose) {
                    coordPrev = line[lineSize - 2];
                    normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
                    isPrev = true;
                }
            }

            // Assign current coordinate
            coordCurr = line[i];

            if (isNext) {
                coordNext = line[i + 1];
            } else if (closed_polygon === true) {
                // If is the last point a close polygon
                coordNext = line[1];
                isNext = true;
            }

            if (isNext) {
                // If is not the last one get next coordinates and calculate the right normal

                normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(coordCurr, coordNext, { tile_edge_tolerance: tile_edge_tolerance })) {
                        normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
                        if (isPrev) {
                            addVertexPair(coordCurr, normCurr, i / lineSize, constants);
                            constants.nPairs++;

                            // Add vertices to buffer acording their index
                            indexPairs(constants);
                        }
                        isPrev = false;
                        continue;
                    }
                }
            }

            //  Compute current normal
            if (isPrev) {
                //  If there is a PREVIUS ...
                if (isNext) {
                    // ... and a NEXT ONE, compute previus and next normals (scaled by the angle with the last prev)
                    normCurr = Vector.normalize(Vector.add(normPrev, normNext));
                    var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
                    normCurr = Vector.mult(normCurr, scale * scale);
                } else {
                    // ... and there is NOT a NEXT ONE, copy the previus next one (which is the current one)
                    normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
                }
            } else {
                // If is NOT a PREVIUS ...
                if (isNext) {
                    // ... and a NEXT ONE,
                    normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
                    normCurr = normNext;
                } else {
                    // ... and NOT a NEXT ONE, nothing to do (without prev or next one this is just a point)
                    continue;
                }
            }

            if (isPrev || isNext) {
                // If is the BEGINING of a LINE
                if (i === 0 && !isPrev && !closed_polygon) {
                    addCap(coordCurr, normCurr, cornersOnCap, true, constants);
                }

                // If is a JOIN
                if (trianglesOnJoin !== 0 && isPrev && isNext) {
                    addJoin([coordPrev, coordCurr, coordNext], [normPrev, normCurr, normNext], i / lineSize, trianglesOnJoin, constants);
                } else {
                    addVertexPair(coordCurr, normCurr, i / (lineSize - 1), constants);
                }

                if (isNext) {
                    constants.nPairs++;
                }

                isPrev = true;
            }
        }

        // Add vertices to buffer acording their index
        indexPairs(constants);

        // If is the END OF a LINE
        if (!closed_polygon) {
            addCap(coordCurr, normCurr, cornersOnCap, false, constants);
        }
    }
};

// Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertex(coord, normal, uv, _ref) {
    var halfWidth = _ref.halfWidth;
    var vertices = _ref.vertices;
    var scalingVecs = _ref.scalingVecs;
    var texcoords = _ref.texcoords;

    if (scalingVecs) {
        //  a. If scaling is on add the vertex (the currCoord) and the scaling Vecs (normals pointing where to extrude the vertexes)
        vertices.push(coord);
        scalingVecs.push(normal);
    } else {
        //  b. Add the extruded vertexes
        vertices.push([coord[0] + normal[0] * halfWidth, coord[1] + normal[1] * halfWidth]);
    }

    // c) Add uv's if they are enable
    if (texcoords) {
        texcoords.push(uv);
    }
}

//  Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertexPair(coord, normal, v_pct, constants) {
    addVertex(coord, normal, [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
    addVertex(coord, Vector.neg(normal), [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
}

//  Tessalate a FAN geometry between points A       B
//  using their normals from a center        \ . . /
//  and interpolating their UVs               \ p /
//                                             \./
//                                              C
function addFan(coord, nA, nC, nB, uA, uC, uB, signed, numTriangles, constants) {

    if (numTriangles < 1) {
        return;
    }

    // Add previus vertices to buffer and clean the buffers and index pairs
    // Because we are going to add more triangles.
    indexPairs(constants);

    var normCurr = Vector.set(nA);
    var normPrev = [0, 0];

    var angle_delta = Vector.dot(nA, nB);
    if (angle_delta < -1) {
        angle_delta = -1;
    }
    angle_delta = Math.acos(angle_delta) / numTriangles;

    if (!signed) {
        angle_delta *= -1;
    }

    var uvCurr = Vector.set(uA);
    var uv_delta = Vector.div(Vector.sub(uB, uA), numTriangles);

    //  Add the first and CENTER vertex
    //  The triangles will be composed on FAN style arround it
    addVertex(coord, nC, uC, constants);

    //  Add first corner
    addVertex(coord, normCurr, uA, constants);

    // Iterate through the rest of the coorners
    for (var t = 0; t < numTriangles; t++) {
        normPrev = Vector.normalize(normCurr);
        normCurr = Vector.rot(Vector.normalize(normCurr), angle_delta); //  Rotate the extrusion normal

        if (numTriangles === 4 && (t === 0 || t === numTriangles - 2)) {
            var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
            normCurr = Vector.mult(normCurr, scale * scale);
        }

        uvCurr = Vector.add(uvCurr, uv_delta);

        addVertex(coord, normCurr, uvCurr, constants); //  Add computed corner
    }

    for (var i = 0; i < numTriangles; i++) {
        if (signed) {
            addIndex(i + 2, constants);
            addIndex(0, constants);
            addIndex(i + 1, constants);
        } else {
            addIndex(i + 1, constants);
            addIndex(0, constants);
            addIndex(i + 2, constants);
        }
    }

    // Clean the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

//  Add speccials joins (not miter) tipes that require FAN tessalations
//  Using this ( http://www.codeproject.com/Articles/226569/Drawing-polylines-by-tessellation ) as reference
function addJoin(coords, normals, v_pct, nTriangles, constants) {

    var T = [Vector.set(normals[0]), Vector.set(normals[1]), Vector.set(normals[2])];
    var signed = Vector.signed_area(coords[0], coords[1], coords[2]) > 0;

    var nA = T[0],
        // normal to point A (aT)
    nC = Vector.neg(T[1]),
        // normal to center (-vP)
    nB = T[2]; // normal to point B (bT)

    var uA = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uC = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uB = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];

    if (signed) {
        addVertex(coords[1], nA, uA, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        nA = Vector.neg(T[0]);
        nC = T[1];
        nB = Vector.neg(T[2]);
        uA = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uC = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uB = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nA, uA, constants);
    }

    addFan(coords[1], nA, nC, nB, uA, uC, uB, signed, nTriangles, constants);

    if (signed) {
        addVertex(coords[1], nB, uB, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nB, uB, constants);
    }
}

//  Function to add the vertex need for line caps,
//  because re-use the buffers needs to be at the end
function addCap(coord, normal, numCorners, isBeginning, constants) {

    if (numCorners < 1) {
        return;
    }

    // UVs
    var uvA = [constants.min_u, constants.min_v],
        // Begining angle UVs
    uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.min_v],
        // center point UVs
    uvB = [constants.max_u, constants.min_v]; // Ending angle UVs

    if (!isBeginning) {
        uvA = [constants.min_u, constants.max_v], // Begining angle UVs
        uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.max_v], // center point UVs
        uvB = [constants.max_u, constants.max_v];
    }

    addFan(coord, Vector.neg(normal), [0, 0], normal, uvA, uvC, uvB, isBeginning, numCorners * 2, constants);
}

// Add a vertex based on the index position into the VBO (internal method for polyline builder)
function addIndex(index, _ref) {
    var vertex_data = _ref.vertex_data;
    var vertex_template = _ref.vertex_template;
    var halfWidth = _ref.halfWidth;
    var vertices = _ref.vertices;
    var scaling_index = _ref.scaling_index;
    var scalingVecs = _ref.scalingVecs;
    var texcoord_index = _ref.texcoord_index;
    var texcoords = _ref.texcoords;

    // Prevent access to undefined vertices
    if (index >= vertices.length) {
        return;
    }

    // set vertex position
    vertex_template[0] = vertices[index][0];
    vertex_template[1] = vertices[index][1];

    // set UVs
    if (texcoord_index) {
        vertex_template[texcoord_index + 0] = texcoords[index][0];
        vertex_template[texcoord_index + 1] = texcoords[index][1];
    }

    // set Scaling vertex (X, Y normal direction + Z haltwidth as attribute)
    if (scaling_index) {
        vertex_template[scaling_index + 0] = scalingVecs[index][0];
        vertex_template[scaling_index + 1] = scalingVecs[index][1];
        vertex_template[scaling_index + 2] = halfWidth;
    }

    //  Add vertex to VBO
    vertex_data.addVertex(vertex_template);
}

// Add the index vertex to the VBO and clean the buffers
function indexPairs(constants) {
    // Add vertices to buffer acording their index
    for (var i = 0; i < constants.nPairs; i++) {
        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 1, constants);
        addIndex(2 * i + 0, constants);

        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 3, constants);
        addIndex(2 * i + 1, constants);
    }

    constants.nPairs = 0;

    // Clean the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

// Build a billboard sprite quad centered on a point. Sprites are intended to be drawn in screenspace, and have
// properties for width, height, angle, and a scale factor that can be used to interpolate the screenspace size
// of a sprite between two zoom levels.
Builders.buildQuadsForPoints = function (points, width, height, angle, scale, vertex_data, vertex_template, scaling_index, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;

    var w2 = width / 2;
    var h2 = height / 2;
    var scaling = [[-w2, -h2], [w2, -h2], [w2, h2], [-w2, -h2], [w2, h2], [-w2, h2]];

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    var texcoords = undefined;
    if (texcoord_index) {
        texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_points = points.length;
    for (var p = 0; p < num_points; p++) {
        var point = points[p];

        for (var pos = 0; pos < 6; pos++) {
            // Add texcoords
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = texcoords[pos][0];
                vertex_template[texcoord_index + 1] = texcoords[pos][1];
            }

            vertex_template[0] = point[0];
            vertex_template[1] = point[1];

            vertex_template[scaling_index + 0] = scaling[pos][0];
            vertex_template[scaling_index + 1] = scaling[pos][1];
            vertex_template[scaling_index + 2] = angle;
            vertex_template[scaling_index + 3] = scale;

            vertex_data.addVertex(vertex_template);
        }
    }
};

/* Utility functions */

// Triangulation using earcut
// https://github.com/mapbox/earcut
Builders.triangulatePolygon = function (contours) {
    return earcut(contours);
};

// Tests if a line segment (from point A to B) is nearly coincident with the edge of a tile
Builders.isOnTileEdge = function (pa, pb, options) {
    options = options || {};

    var tolerance_function = options.tolerance_function || Builders.valuesWithinTolerance;
    var tolerance = options.tolerance || 3; // tweak this adjust if catching too few/many line segments near tile edges
    // TODO: make tolerance configurable by source if necessary
    var tile_min = Builders.tile_bounds[0];
    var tile_max = Builders.tile_bounds[1];
    var edge = null;

    if (tolerance_function(pa[0], tile_min.x, tolerance) && tolerance_function(pb[0], tile_min.x, tolerance)) {
        edge = "left";
    } else if (tolerance_function(pa[0], tile_max.x, tolerance) && tolerance_function(pb[0], tile_max.x, tolerance)) {
        edge = "right";
    } else if (tolerance_function(pa[1], tile_min.y, tolerance) && tolerance_function(pb[1], tile_min.y, tolerance)) {
        edge = "top";
    } else if (tolerance_function(pa[1], tile_max.y, tolerance) && tolerance_function(pb[1], tile_max.y, tolerance)) {
        edge = "bottom";
    }
    return edge;
};

Builders.valuesWithinTolerance = function (a, b, tolerance) {
    tolerance = tolerance || 1;
    return Math.abs(a - b) < tolerance;
};

// Build a zigzag line pattern for testing joins and caps
Builders.buildZigzagLineTestPattern = function () {
    var min = { x: 0, y: 0 }; //  tile.min;
    var max = { x: 4096, y: 4096 }; // tile.max;

    var g = {
        id: 123,
        geometry: {
            type: "LineString",
            coordinates: [[min.x * 0.75 + max.x * 0.25, min.y * 0.75 + max.y * 0.25], [min.x * 0.75 + max.x * 0.25, min.y * 0.5 + max.y * 0.5], [min.x * 0.25 + max.x * 0.75, min.y * 0.75 + max.y * 0.25], [min.x * 0.25 + max.x * 0.75, min.y * 0.25 + max.y * 0.75], [min.x * 0.4 + max.x * 0.6, min.y * 0.5 + max.y * 0.5], [min.x * 0.5 + max.x * 0.5, min.y * 0.25 + max.y * 0.75], [min.x * 0.75 + max.x * 0.25, min.y * 0.25 + max.y * 0.75], [min.x * 0.75 + max.x * 0.25, min.y * 0.4 + max.y * 0.6]]
        },
        properties: {
            kind: "debug"
        }
    };
    return g;
};

},{"../geo":67,"../vector":105,"earcut":20}],86:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Line rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var StyleManager = require("../style_manager").StyleManager;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Utils = _interopRequire(require("../../utils/utils"));

var Lines = Object.create(Style);

exports.Lines = Lines;
Object.assign(Lines, {
    name: "lines",
    built_in: true,
    vertex_shader_key: "styles/polygons/polygons_vertex", // re-use polygon shaders
    fragment_shader_key: "styles/polygons/polygons_fragment",
    selection: true,

    init: function init() {
        Style.init.apply(this, arguments);

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: "a_position", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_extrude", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_scale", size: 1, type: gl.SHORT, normalized: true }, { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_layer", size: 1, type: gl.FLOAT, normalized: false }];

        // Tell the shader we want an order attribute, and to extrude lines
        this.defines.TANGRAM_ORDER_ATTRIBUTE = true;
        this.defines.TANGRAM_EXTRUDE_LINES = true;

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: "a_texcoord", size: 2, type: gl.FLOAT, normalized: false });
        }

        this.vertex_layout = new VertexLayout(attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        var inner_width = rule_style.width && StyleParser.cacheDistance(rule_style.width, context, "meters");
        if (!inner_width) {
            return;
        }
        style.width = inner_width * context.units_per_meter;

        // Smoothly interpolate line width between zooms: get scale factor to next zoom
        // Adjust by factor of 2 because tile units are zoom-dependent (a given value is twice as
        // big in world space at the next zoom than at the previous)
        context.zoom++;
        context.units_per_meter *= 2;
        var next_width = StyleParser.cacheDistance(rule_style.next_width, context, "meters");
        style.next_width = Utils.scaleInt16(next_width * context.units_per_meter / style.width, 256);
        context.zoom--;
        context.units_per_meter /= 2; // reset to original scale

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return null;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && StyleParser.cacheDistance(rule_style.z || 0, context) || StyleParser.defaults.z;
        style.height = feature.properties.height || StyleParser.defaults.height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === "function") {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === "number") {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.height = style.extrude[1];
            }
        }

        // Raise line height if extruded
        if (style.extrude && style.height) {
            style.z += style.height;
        }

        style.cap = rule_style.cap;
        style.join = rule_style.join;
        style.tile_edges = rule_style.tile_edges;

        // Construct an outline style
        style.outline = style.outline || {};
        if (rule_style.outline && rule_style.outline.color && rule_style.outline.width) {
            var outline_width = StyleParser.cacheDistance(rule_style.outline.width, context, "meters") * 2;

            context.zoom++;
            context.units_per_meter *= 2;
            var outline_next_width = StyleParser.cacheDistance(rule_style.outline.next_width, context, "meters") * 2;
            context.zoom--;
            context.units_per_meter /= 2; // reset to original scale

            // Maintain consistent outline width around the inner line
            style.outline.width = { value: outline_width + inner_width };
            style.outline.next_width = { value: outline_next_width + next_width };

            style.outline.color = rule_style.outline.color;
            style.outline.cap = rule_style.outline.cap || rule_style.cap;
            style.outline.join = rule_style.outline.join || rule_style.join;
            style.outline.style = rule_style.outline.style || this.name;

            // Explicitly defined outline order, or inherited from inner line
            if (rule_style.outline.order) {
                style.outline.order = this.parseOrder(rule_style.outline.order, context);
            } else {
                style.outline.order = style.order;
            }

            // Don't let outline be above inner line
            if (style.outline.order > style.order) {
                style.outline.order = style.order;
            }

            // Outlines are always at half-layer intervals to avoid conflicting with inner lines
            style.outline.order -= 0.5;

            style.outline.preprocessed = true; // signal that we've already wrapped properties in cache objects
        } else {
            style.outline.color = null;
            style.outline.width = null;
        }

        return style;
    },

    preprocess: function preprocess(draw) {
        draw.color = draw.color && { value: draw.color };
        draw.width = draw.width && { value: draw.width };
        draw.next_width = draw.width && { value: draw.width.value };
        draw.z = draw.z && { value: draw.z };

        if (draw.outline) {
            draw.outline.color = draw.outline.color && { value: draw.outline.color };
            draw.outline.width = draw.outline.width && { value: draw.outline.width };
            draw.outline.next_width = draw.outline.width && { value: draw.outline.width.value };
        }
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[0] = 0;
        this.vertex_template[1] = 0;
        this.vertex_template[2] = style.z || 0;

        // extrusion vector
        this.vertex_template[3] = 0;
        this.vertex_template[4] = 0;
        this.vertex_template[5] = 1;

        // scaling to previous and next zoom
        this.vertex_template[6] = style.next_width;

        // color
        this.vertex_template[7] = style.color[0] * 255;
        this.vertex_template[8] = style.color[1] * 255;
        this.vertex_template[9] = style.color[2] * 255;
        this.vertex_template[10] = style.color[3] * 255;

        // selection color
        this.vertex_template[11] = style.selection_color[0] * 255;
        this.vertex_template[12] = style.selection_color[1] * 255;
        this.vertex_template[13] = style.selection_color[2] * 255;
        this.vertex_template[14] = style.selection_color[3] * 255;

        // layer order
        this.vertex_template[15] = style.order;

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[16] = 0;
            this.vertex_template[17] = 0;
        }

        return this.vertex_template;
    },

    buildLines: function buildLines(lines, style, vertex_data, context, options) {
        var vertex_template = this.makeVertexTemplate(style);

        // Main line
        if (style.color && style.width) {
            Builders.buildPolylines(lines, style.width, vertex_data, vertex_template, {
                cap: style.cap,
                join: style.join,
                scaling_index: this.vertex_layout.index.a_extrude,
                texcoord_index: this.vertex_layout.index.a_texcoord,
                texcoord_scale: this.texcoord_scale,
                closed_polygon: options && options.closed_polygon,
                remove_tile_edges: !style.tile_edges && options && options.remove_tile_edges
            });
        }

        // Outline
        if (style.outline && style.outline.color && style.outline.width) {
            var outline_style = StyleManager.styles[style.outline.style];
            if (outline_style) {
                outline_style.addFeature(context.feature, style.outline, context);
            }
        }
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data, context) {
        // Render polygons as individual lines
        for (var p = 0; p < polygons.length; p++) {
            this.buildLines(polygons[p], style, vertex_data, context, { closed_polygon: true, remove_tile_edges: true });
        }
    }

});

},{"../../gl/constants":68,"../../gl/vertex_layout":77,"../../utils/utils":102,"../builders":85,"../style":90,"../style_manager":91,"../style_parser":92}],87:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Point rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Texture = _interopRequire(require("../../gl/texture"));

var Utils = _interopRequire(require("../../utils/utils"));

var log = _interopRequire(require("loglevel"));

var Points = Object.create(Style);

exports.Points = Points;
Object.assign(Points, {
    name: "points",
    built_in: true,
    selection: true,
    blend: "overlay", // overlays drawn on top of all other styles, with blending

    init: function init() {
        var options = arguments[0] === undefined ? {} : arguments[0];

        Style.init.apply(this, arguments);

        // Base shaders
        this.vertex_shader_key = "styles/points/points_vertex";
        this.fragment_shader_key = "styles/points/points_fragment";

        var attribs = [{ name: "a_position", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_shape", size: 4, type: gl.SHORT, normalized: true }, { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_texcoord", size: 2, type: gl.FLOAT, normalized: false } // TODO: pack into shorts
        ];

        // If we're not rendering as overlay, we need a layer attribute
        if (this.blend !== "overlay") {
            this.defines.TANGRAM_ORDER_ATTRIBUTE = true;
            attribs.push({ name: "a_layer", size: 1, type: gl.FLOAT, normalized: false });
        }

        this.vertex_layout = new VertexLayout(attribs);

        if (this.texture) {
            this.defines.TANGRAM_POINT_TEXTURE = true;
            this.shaders.uniforms = this.shaders.uniforms || {};
            this.shaders.uniforms.u_texture = this.texture;
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;
        var tile = context.tile.key;

        style.color = this.parseColor(rule_style.color, context);

        // require color or texture
        if (!style.color && !this.texture) {
            return null;
        }

        style.sprite = rule_style.sprite;
        if (typeof style.sprite === "function") {
            style.sprite = style.sprite(context);
        }

        // require sprite to draw?
        if (this.texture && !style.sprite && Texture.textures[this.texture] && Texture.textures[this.texture].sprites) {
            return; // skip feature
        }

        style.z = rule_style.z && StyleParser.cacheDistance(rule_style.z, context) || StyleParser.defaults.z;

        // point style only supports sizes in pixel units, so unit conversion flag is off
        style.size = rule_style.size || { value: [32, 32] };
        style.size = StyleParser.cacheDistance(style.size, context, "pixels");

        // scale size to 16-bit signed int, with a max allowed width + height of 128 pixels
        style.size = [Math.min(style.size[0] || style.size, 256), Math.min(style.size[1] || style.size, 256)];

        style.size[0] *= Utils.device_pixel_ratio;
        style.size[1] *= Utils.device_pixel_ratio;

        style.angle = rule_style.angle || 0;
        if (typeof style.angle === "function") {
            style.angle = style.angle(context);
        }

        // factor by which point scales from current zoom level to next zoom level
        style.scale = rule_style.scale || 1;

        // to store bbox by tiles
        style.tile = tile;

        // polygons rendering as points will render each individual polygon point by default, but
        // rendering a single point at the polygon's centroid can be enabled
        style.centroid = rule_style.centroid;

        // Sets texcoord scale if needed (e.g. for sprite sub-area)
        if (this.texture && style.sprite) {
            this.texcoord_scale = Texture.getSpriteTexcoords(this.texture, style.sprite);
            if (!this.texcoord_scale) {
                log.warn("Style: in style '" + this.name + "', could not find sprite '" + style.sprite + "' for texture '" + this.texture + "'");
            }
        } else {
            this.texcoord_scale = null;
        }

        return style;
    },

    preprocess: function preprocess(draw) {
        draw.color = draw.color && { value: draw.color };
        draw.z = draw.z && { value: draw.z };
        draw.size = draw.size && { value: draw.size };
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var color = style.color || StyleParser.defaults.color;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[0] = 0;
        this.vertex_template[1] = 0;
        this.vertex_template[2] = style.z || 0;

        // scaling vector - (x, y) components per pixel, z = angle, w = scaling factor
        this.vertex_template[3] = 0;
        this.vertex_template[4] = 0;
        this.vertex_template[5] = 0;
        this.vertex_template[6] = 0;

        // color
        this.vertex_template[7] = color[0] * 255;
        this.vertex_template[8] = color[1] * 255;
        this.vertex_template[9] = color[2] * 255;
        this.vertex_template[10] = color[3] * 255;

        // selection color
        this.vertex_template[11] = style.selection_color[0] * 255;
        this.vertex_template[12] = style.selection_color[1] * 255;
        this.vertex_template[13] = style.selection_color[2] * 255;
        this.vertex_template[14] = style.selection_color[3] * 255;

        // texture coords
        this.vertex_template[15] = 0;
        this.vertex_template[16] = 0;

        // Add layer attribute if needed
        if (this.defines.TANGRAM_ORDER_ATTRIBUTE) {
            this.vertex_template[17] = style.order;
        }

        return this.vertex_template;
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        if (!style.size) {
            return;
        }

        var vertex_template = this.makeVertexTemplate(style);

        var size = style.size;
        var angle = style.angle;

        Builders.buildQuadsForPoints(points, Utils.scaleInt16(size[0], 256), Utils.scaleInt16(size[1], 256), Utils.scaleInt16(Utils.radToDeg(angle), 360), Utils.scaleInt16(style.scale, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, { texcoord_index: this.vertex_layout.index.a_texcoord, texcoord_scale: this.texcoord_scale });
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        // Render polygons as individual points, or centroid
        if (!style.centroid) {
            for (var poly = 0; poly < polygons.length; poly++) {
                var polygon = polygons[poly];
                for (var r = 0; r < polygon.length; r++) {
                    this.buildPoints(polygon[r], style, vertex_data);
                }
            }
        } else {
            var centroid = Utils.multiCentroid(polygons);
            this.buildPoints([centroid], style, vertex_data);
        }
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        // Render lines as individual points
        for (var ln = 0; ln < lines.length; ln++) {
            this.buildPoints(lines[ln], style, vertex_data);
        }
    }

});

},{"../../gl/constants":68,"../../gl/texture":73,"../../gl/vertex_layout":77,"../../utils/utils":102,"../builders":85,"../style":90,"../style_parser":92,"loglevel":53}],88:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Polygon rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Polygons = Object.create(Style);

exports.Polygons = Polygons;
Object.assign(Polygons, {
    name: "polygons",
    built_in: true,

    init: function init() {
        Style.init.apply(this, arguments);

        // Base shaders
        this.vertex_shader_key = "styles/polygons/polygons_vertex";
        this.fragment_shader_key = "styles/polygons/polygons_fragment";

        // Turn feature selection on
        this.selection = true;

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: "a_position", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_normal", size: 3, type: gl.FLOAT, normalized: false },
        // { name: 'a_normal', size: 3, type: gl.BYTE, normalized: true }, // attrib isn't a multiple of 4!
        // { name: 'a_color', size: 3, type: gl.FLOAT, normalized: false },
        { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true },
        // { name: 'a_selection_color', size: 4, type: gl.FLOAT, normalized: false },
        { name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_layer", size: 1, type: gl.FLOAT, normalized: false }];

        // Tell the shader we have a normal and order attributes
        this.defines.TANGRAM_NORMAL_ATTRIBUTE = true;
        this.defines.TANGRAM_ORDER_ATTRIBUTE = true;

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: "a_texcoord", size: 2, type: gl.FLOAT, normalized: false });
        }

        this.vertex_layout = new VertexLayout(attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return null;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && StyleParser.cacheDistance(rule_style.z, context) || StyleParser.defaults.z;
        style.height = feature.properties.height || StyleParser.defaults.height;
        style.min_height = feature.properties.min_height || StyleParser.defaults.min_height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === "function") {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === "number") {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.min_height = style.extrude[0];
                style.height = style.extrude[1];
            }
        }

        // style.outline = style.outline || {};
        // if (rule_style.outline) {
        //     style.outline.color = StyleParser.parseColor(rule_style.outline.color, context);
        //     style.outline.width = StyleParser.parseDistance(rule_style.outline.width, context);
        //     style.outline.tile_edges = rule_style.outline.tile_edges;
        //     style.outline.cap = rule_style.outline.cap || rule_style.cap;
        //     style.outline.join = rule_style.outline.join || rule_style.join;
        // }
        // else {
        //     style.outline.color = null;
        //     style.outline.width = null;
        //     style.outline.tile_edges = false;
        // }

        return style;
    },

    preprocess: function preprocess(draw) {
        draw.color = draw.color && { value: draw.color };
        draw.z = draw.z && { value: draw.z };
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[0] = 0;
        this.vertex_template[1] = 0;
        this.vertex_template[2] = style.z || 0;

        // normal
        this.vertex_template[3] = 0;
        this.vertex_template[4] = 0;
        this.vertex_template[5] = 1;

        // color
        this.vertex_template[6] = style.color[0] * 255;
        this.vertex_template[7] = style.color[1] * 255;
        this.vertex_template[8] = style.color[2] * 255;
        this.vertex_template[9] = style.color[3] * 255;

        // selection color
        this.vertex_template[10] = style.selection_color[0] * 255;
        this.vertex_template[11] = style.selection_color[1] * 255;
        this.vertex_template[12] = style.selection_color[2] * 255;
        this.vertex_template[13] = style.selection_color[3] * 255;

        // layer order
        this.vertex_template[14] = style.order;

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[15] = 0;
            this.vertex_template[16] = 0;
        }

        return this.vertex_template;
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);

        // Extruded polygons (e.g. 3D buildings)
        if (style.extrude && style.height) {
            Builders.buildExtrudedPolygons(polygons, style.z, style.height, style.min_height, vertex_data, vertex_template, this.vertex_layout.index.a_normal, { texcoord_index: this.vertex_layout.index.a_texcoord, texcoord_scale: this.texcoord_scale });
        }
        // Regular polygons
        else {
            Builders.buildPolygons(polygons, vertex_data, vertex_template, { texcoord_index: this.vertex_layout.index.a_texcoord, texcoord_scale: this.texcoord_scale });
        }
    }

});

},{"../../gl/constants":68,"../../gl/vertex_layout":77,"../builders":85,"../style":90,"../style_parser":92}],89:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

exports.mergeTrees = mergeTrees;
exports.walkUp = walkUp;
exports.walkDown = walkDown;
exports.groupProps = groupProps;
exports.calculateDraw = calculateDraw;
exports.mergeObjects = mergeObjects;
exports.calculateOrder = calculateOrder;
exports.parseRuleTree = parseRuleTree;
exports.parseRules = parseRules;
exports.matchFeature = matchFeature;
Object.defineProperty(exports, "__esModule", {
    value: true
});

var match = require("match-feature").match;

var log = _interopRequire(require("loglevel"));

var whiteList = ["filter", "draw", "visible", "data", "properties"];

exports.whiteList = whiteList;
var ruleCache = {};

exports.ruleCache = ruleCache;
function cacheKey(rules) {
    var k = rules[0].id;
    for (var i = 1; i < rules.length; i++) {
        k += "/" + rules[i].id;
    }
    return k;
}

function mergeTrees(matchingTrees, key, context) {
    var draw = {},
        draws,

    // order = [],
    // order_draws = [],
    treeDepth = 0,
        x,
        t;

    // Visible by default
    draw.visible = true;

    // Find deepest tree
    for (t = 0; t < matchingTrees.length; t++) {
        if (matchingTrees[t].length > treeDepth) {
            treeDepth = matchingTrees[t].length;
        }
    }

    // No rules to parse
    if (treeDepth === 0) {
        return null;
    }

    // Iterate trees in parallel
    for (x = 0; x < treeDepth; x++) {
        draws = matchingTrees.map(function (tree) {
            return tree[x] && tree[x][key];
        });
        if (draws.length === 0) {
            continue;
        }

        // Property-specific logic
        // for (i=0; i < draws.length; i++) {
        //     if (!draws[i]) {
        //         continue;
        //     }

        //     // Collect unique orders (don't add the order multiple times for the smae draw rule)
        //     if (draws[i].order !== undefined) {
        //         if (order_draws.indexOf(draws[i]) === -1) {
        //             order.push(draws[i].order);
        //             order_draws.push(draws[i]);
        //         }
        //     }
        // }

        // Merge remaining draw objects
        mergeObjects.apply(undefined, [draw].concat(_toConsumableArray(draws)));
    }

    // Short-circuit if not visible
    if (draw.visible === false) {
        return null;
    }

    // Sum all orders
    // Note: temporarily commenting out, will revisit with new scene file syntax
    // if (order.length > 0) {
    //     // Order can be cached if it is all numeric
    //     if (order.length === 1 && typeof order[0] === 'number') {
    //         order = order[0];
    //     }
    //     else if (order.every(v => typeof v === 'number')) {
    //         order = calculateOrder(order, context); // TODO: use StyleParser.calculateOrder
    //     }
    //     draw.order = order;
    // }

    return draw;
}

var Rule = (function () {
    function Rule(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, Rule);

        this.id = Rule.id++;
        this.parent = parent;
        this.name = name;
        this.draw = draw;
        this.filter = filter;
        this.visible = visible !== undefined ? visible : this.parent && this.parent.visible;
        this.properties = properties !== undefined ? properties : this.parent && this.parent.properties;

        // Denormalize properties to draw groups
        if (this.draw) {
            for (var group in this.draw) {
                if (this.properties !== undefined) {
                    this.draw[group].properties = this.properties;
                }
            }
        }

        this.buildFilter();
        this.buildDraw();
    }

    _createClass(Rule, {
        buildDraw: {
            value: function buildDraw() {
                this.calculatedDraw = calculateDraw(this);
            }
        },
        buildFilter: {
            value: function buildFilter() {
                var type = typeof this.filter;
                if (type === "object") {
                    this.filter = match(this.filter);
                }
            }
        },
        toJSON: {
            value: function toJSON() {
                return {
                    name: this.name,
                    draw: this.draw
                };
            }
        }
    });

    return Rule;
})();

Rule.id = 0;

var RuleLeaf = exports.RuleLeaf = (function (_Rule) {
    function RuleLeaf(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleLeaf);

        _get(Object.getPrototypeOf(RuleLeaf.prototype), "constructor", this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
    }

    _inherits(RuleLeaf, _Rule);

    return RuleLeaf;
})(Rule);

var RuleTree = exports.RuleTree = (function (_Rule2) {
    function RuleTree(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var rules = _ref.rules;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleTree);

        _get(Object.getPrototypeOf(RuleTree.prototype), "constructor", this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
        this.rules = rules || [];
    }

    _inherits(RuleTree, _Rule2);

    _createClass(RuleTree, {
        addRule: {
            value: function addRule(rule) {
                this.rules.push(rule);
            }
        },
        buildDrawGroups: {
            value: function buildDrawGroups(context) {
                var rules = [];
                //TODO, should this function take a RuleTree
                matchFeature(context, [this], rules);

                if (rules.length > 0) {
                    var cache_key = cacheKey(rules);

                    // Only evaluate each rule combination once (undefined means not yet evaluated,
                    // null means evaluated with no draw object)
                    if (ruleCache[cache_key] === undefined) {
                        // Visible?
                        if (rules.some(function (x) {
                            return x.visible === false;
                        })) {
                            ruleCache[cache_key] = null;
                        } else {
                            // Find all the unique draw blocks for this rule tree
                            var draw_rules = rules.map(function (x) {
                                return x && x.calculatedDraw;
                            });
                            var draw_keys = {};

                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = draw_rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var rule = _step.value;

                                    if (!rule) {
                                        continue;
                                    }
                                    var _iteratorNormalCompletion2 = true;
                                    var _didIteratorError2 = false;
                                    var _iteratorError2 = undefined;

                                    try {
                                        for (var _iterator2 = rule[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                            var group = _step2.value;

                                            for (var key in group) {
                                                draw_keys[key] = true;
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError2 = true;
                                        _iteratorError2 = err;
                                    } finally {
                                        try {
                                            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                                _iterator2["return"]();
                                            }
                                        } finally {
                                            if (_didIteratorError2) {
                                                throw _iteratorError2;
                                            }
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            // Calculate each draw group
                            for (var draw_key in draw_keys) {
                                ruleCache[cache_key] = ruleCache[cache_key] || {};
                                ruleCache[cache_key][draw_key] = mergeTrees(draw_rules, draw_key, context);

                                // Only save the ones that weren't null
                                if (!ruleCache[cache_key][draw_key]) {
                                    delete ruleCache[cache_key][draw_key];
                                } else {
                                    ruleCache[cache_key][draw_key].key = cache_key + "/" + draw_key;
                                }
                            }

                            // No rules evaluated
                            if (ruleCache[cache_key] && Object.keys(ruleCache[cache_key]).length === 0) {
                                ruleCache[cache_key] = null;
                            }
                        }
                    }
                    return ruleCache[cache_key];
                }
            }
        }
    });

    return RuleTree;
})(Rule);

function isWhiteListed(key) {
    return whiteList.indexOf(key) > -1;
}

function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}

function walkUp(rule, cb) {

    if (rule.parent) {
        walkUp(rule.parent, cb);
    }

    cb(rule);
}

function walkDown(rule, cb) {

    if (rule.rules) {
        rule.rules.forEach(function (r) {
            walkDown(r, cb);
        });
    }

    cb(rule);
}

function groupProps(obj) {
    var whiteListed = {},
        nonWhiteListed = {};

    for (var key in obj) {
        if (isWhiteListed(key)) {
            whiteListed[key] = obj[key];
        } else {
            nonWhiteListed[key] = obj[key];
        }
    }
    return [whiteListed, nonWhiteListed];
}

function calculateDraw(rule) {

    var draw = [];

    if (rule.parent) {
        var cs = rule.parent.calculatedDraw || [];
        draw.push.apply(draw, _toConsumableArray(cs));
    }

    draw.push(rule.draw);
    return draw;
}

function mergeObjects(newObj) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {

        for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var source = _step.value;

            if (!source) {
                continue;
            }
            for (var key in source) {
                var value = source[key];
                if (typeof value === "object" && !Array.isArray(value)) {
                    newObj[key] = mergeObjects(newObj[key] || {}, value);
                } else {
                    newObj[key] = value;
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return newObj;
}

function calculateOrder(orders) {
    var context = arguments[1] === undefined ? null : arguments[1];
    var defaultOrder = arguments[2] === undefined ? 0 : arguments[2];

    var sum = defaultOrder;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = orders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var order = _step.value;

            if (typeof order === "function") {
                order = order(context);
            } else {
                order = parseFloat(order);
            }

            if (!order || isNaN(order)) {
                continue;
            }
            sum += order;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return sum;
}

function parseRuleTree(name, rule, parent) {

    var properties = { name: name, parent: parent };

    var _groupProps = groupProps(rule);

    var _groupProps2 = _slicedToArray(_groupProps, 2);

    var whiteListed = _groupProps2[0];
    var nonWhiteListed = _groupProps2[1];

    var empty = isEmpty(nonWhiteListed);
    var Create = undefined;

    if (empty && parent != null) {
        Create = RuleLeaf;
    } else {
        Create = RuleTree;
    }

    var r = new Create(Object.assign(properties, whiteListed));

    if (parent) {
        parent.addRule(r);
    }

    if (!empty) {
        for (var key in nonWhiteListed) {
            var property = nonWhiteListed[key];
            if (typeof property === "object") {
                parseRuleTree(key, property, r);
            } else {
                log.warn("Rule property must be an object: ", name, rule, property);
            }
        }
    }

    return r;
}

function parseRules(rules) {
    var ruleTrees = {};

    for (var key in rules) {
        var rule = rules[key];
        ruleTrees[key] = parseRuleTree(key, rule);
    }

    return ruleTrees;
}

function doesMatch(filter, context) {
    return typeof filter === "function" && filter(context) || filter == null;
}

function matchFeature(context, rules, collectedRules) {
    var matched = false;
    var childMatched = false;

    if (rules.length === 0) {
        return;
    }

    for (var r = 0; r < rules.length; r++) {
        var current = rules[r];
        context.properties = current.properties;

        if (current instanceof RuleLeaf) {

            if (doesMatch(current.filter, context)) {
                matched = true;
                collectedRules.push(current);
            }
        } else if (current instanceof RuleTree) {
            if (doesMatch(current.filter, context)) {
                matched = true;

                childMatched = matchFeature(context, current.rules, collectedRules);

                if (!childMatched) {
                    collectedRules.push(current);
                }
            }
        }

        context.properties = null;
    }

    return matched;
}

},{"loglevel":53,"match-feature":54}],90:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Rendering styles

var StyleParser = require("./style_parser").StyleParser;

var FeatureSelection = _interopRequire(require("../selection"));

var ShaderProgram = _interopRequire(require("../gl/shader_program"));

var VBOMesh = _interopRequire(require("../gl/vbo_mesh"));

var Material = _interopRequire(require("../material"));

var Light = _interopRequire(require("../light"));

var MethodNotImplemented = require("../utils/errors").MethodNotImplemented;

var shaderSources = _interopRequire(require("../gl/shader_sources"));

// built-in shaders

var log = _interopRequire(require("loglevel"));

// Base class

var Style = {
    init: function init() {
        var _ref = arguments[0] === undefined ? {} : arguments[0];

        var generation = _ref.generation;

        if (!this.isBuiltIn()) {
            this.built_in = false; // explicitly set to false to avoid any confusion
        }

        this.generation = generation; // scene generation id this style was created for
        this.defines = this.hasOwnProperty("defines") && this.defines || {}; // #defines to be injected into the shaders
        this.shaders = this.hasOwnProperty("shaders") && this.shaders || {}; // shader customization (uniforms, defines, blocks, etc.)
        this.selection = this.selection || false; // flag indicating if this style supports feature selection
        this.compiling = false; // programs are currently compiling
        this.compiled = false; // programs are finished compiling
        this.program = null; // GL program reference (for main render pass)
        this.selection_program = null; // GL program reference for feature selection render pass
        this.feature_style = {}; // style for feature currently being parsed, shared to lessen GC/memory thrash
        this.vertex_template = []; // shared single-vertex template, filled out by each style
        this.tile_data = {};
        this.feature_options = {};

        // Default world coords to wrap every 100,000 meters, can turn off by setting this to 'false'
        this.defines.TANGRAM_WORLD_POSITION_WRAP = 100000;

        // Blending
        this.blend = this.blend || "opaque"; // default: opaque styles are drawn first, without blending
        this.defines["TANGRAM_BLEND_" + this.blend.toUpperCase()] = true;

        // If the style defines its own material, replace the inherited material instance
        if (!(this.material instanceof Material)) {
            if (!Material.isValid(this.material)) {
                this.material = StyleParser.defaults.material;
            }
            this.material = new Material(this.material);
        }
        this.material.inject(this);

        // Set lighting mode: fragment, vertex, or none (specified as 'false')
        Light.setMode(this.lighting, this);

        this.initialized = true;
    },

    destroy: function destroy() {
        if (this.program) {
            this.program.destroy();
            this.program = null;
        }

        if (this.selection_program) {
            this.selection_program.destroy();
            this.selection_program = null;
        }

        this.gl = null;
        this.initialized = false;
    },

    reset: function reset() {},

    isBuiltIn: function isBuiltIn() {
        return this.hasOwnProperty("built_in") && this.built_in;
    },

    /*** Style parsing and geometry construction ***/

    // Returns an object to hold feature data (for a tile or other object)
    startData: function startData(tile) {
        this.tile_data[tile] = {
            vertex_data: null,
            uniforms: null
        };
        return this.tile_data[tile];
    },

    // Finalizes an object holding feature data (for a tile or other object)
    endData: function endData(tile) {
        var tile_data = this.tile_data[tile];
        if (tile_data && tile_data.vertex_data) {
            // Only keep final byte buffer
            tile_data.vertex_data.end();
            tile_data.vertex_data = tile_data.vertex_data.buffer;
        }
        this.tile_data[tile] = null;
        return Promise.resolve(tile_data);
    },

    // Has mesh data for a given tile?
    hasDataForTile: function hasDataForTile(tile) {
        return this.tile_data[tile] != null;
    },

    addFeature: function addFeature(feature, rule, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        if (!this.tile_data[tile.key]) {
            this.startData(tile.key);
        }

        var style = this.parseFeature(feature, rule, context);

        // Skip feature?
        if (!style) {
            return;
        }

        // First feature in this render style?
        if (!this.tile_data[tile.key].vertex_data) {
            this.tile_data[tile.key].vertex_data = this.vertex_layout.createVertexData();
        }

        this.buildGeometry(feature.geometry, style, this.tile_data[tile.key].vertex_data, context);
    },

    buildGeometry: function buildGeometry(geometry, style, vertex_data, context) {
        if (geometry.type === "Polygon") {
            this.buildPolygons([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === "MultiPolygon") {
            this.buildPolygons(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === "LineString") {
            this.buildLines([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === "MultiLineString") {
            this.buildLines(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === "Point") {
            this.buildPoints([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === "MultiPoint") {
            this.buildPoints(geometry.coordinates, style, vertex_data, context);
        }
    },

    parseFeature: function parseFeature(feature, rule_style, context) {
        try {
            var style = this.feature_style;

            // Preprocess first time
            if (!rule_style.preprocessed) {
                this.preprocess(rule_style);
                rule_style.preprocessed = true;
            }

            // Calculate order if it was not cached
            style.order = this.parseOrder(rule_style.order, context);

            // Feature selection (only if style supports it)
            var selectable = false;
            style.interactive = rule_style.interactive;
            if (this.selection) {
                if (typeof style.interactive === "function") {
                    selectable = style.interactive(context);
                } else {
                    selectable = style.interactive;
                }
            }

            // If feature is marked as selectable
            if (selectable) {
                style.selection_color = FeatureSelection.makeColor(feature, context.tile);
            } else {
                style.selection_color = FeatureSelection.defaultColor;
            }

            // Subclass implementation
            style = this._parseFeature(feature, rule_style, context);

            return style;
        } catch (error) {
            log.error("Style.parseFeature: style parsing error", feature, style, error);
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        throw new MethodNotImplemented("_parseFeature");
    },

    preprocess: function preprocess() {},

    // Parse an order value
    parseOrder: function parseOrder(order, context) {
        // Calculate order if it was not cached
        if (typeof order !== "number") {
            return StyleParser.calculateOrder(order, context);
        }
        return order;
    },

    // Parse a color of choose a default if acceptable, return undefined if color missing
    parseColor: function parseColor(color, context) {
        // Need either a color, or a shader block for 'color' or 'filter'
        if (color) {
            return StyleParser.cacheColor(color, context);
        } else if (this.shaders.blocks.color || this.shaders.blocks.filter) {
            return StyleParser.defaults.color;
        }
    },

    // Build functions are no-ops until overriden
    buildPolygons: function buildPolygons() {},
    buildLines: function buildLines() {},
    buildPoints: function buildPoints() {},

    /*** GL state and rendering ***/

    setGL: function setGL(gl) {
        this.gl = gl;
    },

    makeMesh: function makeMesh(vertex_data) {
        var _ref = arguments[1] === undefined ? {} : arguments[1];

        var uniforms = _ref.uniforms;

        return new VBOMesh(this.gl, vertex_data, this.vertex_layout, { uniforms: uniforms });
    },

    compile: function compile() {
        if (!this.gl) {
            throw new Error("style.compile(): skipping for " + this.name + " because no GL context");
        }

        if (this.compiling) {
            throw new Error("style.compile(): skipping for " + this.name + " because style is already compiling");
        }
        this.compiling = true;
        this.compiled = false;

        // Build defines & for selection (need to create a new object since the first is stored as a reference by the program)
        var defines = this.buildDefineList();
        if (this.selection) {
            var selection_defines = Object.assign({}, defines);
            selection_defines.TANGRAM_FEATURE_SELECTION = true;
        }

        // Get any custom code blocks, uniform dependencies, etc.
        var blocks = this.shaders && this.shaders.blocks;
        var uniforms = this.shaders && this.shaders.uniforms;

        // Create shaders
        try {
            this.program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources[this.fragment_shader_key], {
                name: this.name,
                defines: defines,
                uniforms: uniforms,
                blocks: blocks
            });
            this.program.compile();

            if (this.selection) {
                this.selection_program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources["gl/shaders/selection_fragment"], {
                    name: this.name + " (selection)",
                    defines: selection_defines,
                    uniforms: uniforms,
                    blocks: blocks
                });
                this.selection_program.compile();
            } else {
                this.selection_program = null;
            }
        } catch (error) {
            this.compiling = false;
            this.compiled = false;
            throw new Error("style.compile(): style " + this.name + " error:", error);
        }

        this.compiling = false;
        this.compiled = true;
    },

    // Add a shader block
    addShaderBlock: function addShaderBlock(key) {
        var _shaders$blocks$key;

        for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            blocks[_key - 1] = arguments[_key];
        }

        this.shaders.blocks = this.shaders.blocks || {};
        this.shaders.blocks[key] = this.shaders.blocks[key] || [];
        (_shaders$blocks$key = this.shaders.blocks[key]).push.apply(_shaders$blocks$key, blocks);
    },

    // Remove all shader blocks for key
    removeShaderBlock: function removeShaderBlock(key) {
        if (this.shaders.blocks) {
            this.shaders.blocks[key] = null;
        }
    },

    replaceShaderBlock: function replaceShaderBlock(key) {
        for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            blocks[_key - 1] = arguments[_key];
        }

        this.removeShaderBlock(key);
        this.addShaderBlock.apply(this, [key].concat(blocks));
    },

    /** TODO: could probably combine and generalize this with similar method in ShaderProgram
     * (list of define objects that inherit from each other)
     */
    buildDefineList: function buildDefineList() {
        // Add any custom defines to built-in style defines
        var defines = {}; // create a new object to avoid mutating a prototype value that may be shared with other styles
        if (this.defines != null) {
            for (var d in this.defines) {
                defines[d] = this.defines[d];
            }
        }
        if (this.shaders != null && this.shaders.defines != null) {
            for (d in this.shaders.defines) {
                defines[d] = this.shaders.defines[d];
            }
        }
        return defines;
    },

    // Setup any GL state for rendering
    setup: function setup() {
        this.setUniforms();
        this.material.setupProgram(ShaderProgram.current);
    },

    // Set style uniforms on currently bound program
    setUniforms: function setUniforms() {
        var program = ShaderProgram.current;
        if (!program) {
            return;
        }

        program.setUniforms(this.shaders && this.shaders.uniforms, true); // reset texture unit to 0
    },

    update: function update() {}
};
exports.Style = Style;

// Style-specific animation
// if (typeof this.animation === 'function') {
//     this.animation();
// }

},{"../gl/shader_program":71,"../gl/shader_sources":72,"../gl/vbo_mesh":75,"../light":79,"../material":80,"../selection":84,"../utils/errors":100,"./style_parser":92,"loglevel":53}],91:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Manage rendering styles

var Utils = _interopRequire(require("../utils/utils"));

var ShaderProgram = _interopRequire(require("../gl/shader_program"));

var shaderSources = _interopRequire(require("../gl/shader_sources"));

// built-in shaders

var Style = require("./style").Style;

var log = _interopRequire(require("loglevel"));

var StyleManager = {};
exports.StyleManager = StyleManager;
var Styles = {};
exports.Styles = Styles;
var BaseStyles = {};

exports.BaseStyles = BaseStyles;
StyleManager.styles = Styles;

// Set the base object used to instantiate styles
StyleManager.baseStyle = Style;

// Global configuration for all styles
StyleManager.init = function () {
    if (StyleManager.initialized) {
        return;
    }

    ShaderProgram.removeBlock("global");

    // Layer re-ordering function
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/layer_order"]);

    // Feature selection global
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/selection_globals"]);

    // World position wrapping
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/world_position_wrap"]);

    // Feature selection vertex shader support
    ShaderProgram.replaceBlock("feature-selection-vertex", shaderSources["gl/shaders/selection_vertex"]);

    // assume min 16-bit depth buffer, in practice uses 14-bits, 1 extra bit to handle virtual half-layers
    // for outlines (inserted in between layers), another extra bit to prevent precision loss
    ShaderProgram.defines.TANGRAM_LAYER_DELTA = 1 / (1 << 14);

    StyleManager.initialized = true;
};

// Destroy all styles for a given GL context
StyleManager.destroy = function (gl) {
    Object.keys(Styles).forEach(function (_name) {
        var style = Styles[_name];
        if (style.gl === gl) {
            log.trace("StyleManager.destroy: destroying render style " + style.name);

            if (!style.isBuiltIn()) {
                StyleManager.remove(style.name);
            }
            style.destroy();
        }
    });
};

// Register a style
StyleManager.register = function (style) {
    Styles[style.name] = style;
    BaseStyles[style.name] = style;
};

// Remove a style
StyleManager.remove = function (name) {
    delete Styles[name];
};

// Preloads network resources in the stylesheet (shaders, textures, etc.)
StyleManager.preload = function (styles, base) {
    // First load remote styles, then load shader blocks from remote URLs
    return StyleManager.loadRemoteStyles(styles, base).then(function (styles) {
        return StyleManager.loadShaderBlocks(styles, base);
    });
};

// Load style definitions from external URLs
StyleManager.loadRemoteStyles = function (styles, base) {
    var _this = this;

    // Collect URLs and modes to import from them
    // This is done as a separate step becuase it is possible to import multiple modes from a single
    // URL, and we want to avoid duplicate calls for the same file.
    var urls = {};
    for (var name in styles) {
        var style = styles[name];
        if (style.url) {
            var url = style.url;
            if (base) {
                url = Utils.addBaseURL(url, base);
            }

            if (!urls[url]) {
                urls[url] = [];
            }

            // Make a list of the styles to import for this URL
            urls[url].push({
                target_name: name,
                source_name: style.name || name
            });
        }
    }

    // As each URL finishes loading, replace the target style(s)
    return Promise.all(Object.keys(urls).map(function (url) {
        return new Promise(function (resolve, reject) {
            Utils.loadResource(url).then(function (data) {
                // Mixin remote styles, within each remote file
                for (var source_style in data) {
                    StyleManager.mix(data[source_style], data);
                }

                // Add remote styles to local styles
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = urls[url][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var target = _step.value;

                        if (data && data[target.source_name]) {
                            styles[target.target_name] = data[target.source_name];
                        } else {
                            delete styles[target.target_name];
                            return reject(new Error("StyleManager.preload: error importing style " + target.target_name + ", could not find source style " + target.source_name + " in " + url));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                resolve();

                _this.selection = false;
            })["catch"](function (error) {
                log.error("StyleManager.preload: error importing style(s) " + JSON.stringify(urls[url]) + " from " + url, error);
            });
        });
    })).then(function () {
        return Promise.resolve(styles);
    });
};

// Preload shader blocks from external URLs
StyleManager.loadShaderBlocks = function (styles, base) {
    var queue = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Utils.values(styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var style = _step.value;

            if (style.shaders && style.shaders.blocks) {
                var _iteratorNormalCompletion2;

                var _didIteratorError2;

                var _iteratorError2;

                var _iterator2, _step2;

                var _step2$value;

                (function () {
                    var _blocks = style.shaders.blocks;

                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;

                    try {
                        for (_iterator2 = Utils.entries(style.shaders.blocks)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            (function () {
                                _step2$value = _slicedToArray(_step2.value, 2);
                                var key = _step2$value[0];
                                var block = _step2$value[1];

                                var _key = key;

                                // Array of blocks
                                if (Array.isArray(block)) {
                                    for (var b = 0; b < block.length; b++) {
                                        if (typeof block[b] === "object" && block[b].url) {
                                            (function () {
                                                var _index = b;
                                                var url = block[b].url;
                                                if (base) {
                                                    url = Utils.addBaseURL(url, base);
                                                }

                                                queue.push(Utils.io(Utils.cacheBusterForUrl(url)).then(function (data) {
                                                    _blocks[_key][_index] = data;
                                                })["catch"](function (error) {
                                                    log.error("StyleManager.loadShaderBlocks: error loading shader block", _blocks, _key, _index, error);
                                                }));
                                            })();
                                        }
                                    }
                                }
                                // Single block
                                else if (typeof block === "object" && block.url) {
                                    var url = block.url;
                                    if (base) {
                                        url = Utils.addBaseURL(url, base);
                                    }

                                    queue.push(Utils.io(Utils.cacheBusterForUrl(url)).then(function (data) {
                                        _blocks[_key] = data;
                                    })["catch"](function (error) {
                                        log.error("StyleManager.loadShaderBlocks: error loading shader block", _blocks, _key, error);
                                    }));
                                }
                            })();
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                _iterator2["return"]();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                })();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return Promise.all(queue).then(function () {
        return Promise.resolve(styles);
    }); // TODO: add error
};

StyleManager.mix = function (style, styles) {
    // Exit early if we have already applied mixins to this style
    if (style.mixed) {
        return style;
    }

    // Mixin sources, in order
    var sources = [];
    if (style.mix) {
        if (Array.isArray(style.mix)) {
            sources.push.apply(sources, _toConsumableArray(style.mix));
        } else {
            sources.push(style.mix);
        }
        sources = sources.map(function (x) {
            return styles[x];
        }).filter(function (x) {
            return x;
        });
    }
    sources.push(style);

    // Flags - OR'd, true if any style has it set
    style.animated = sources.some(function (x) {
        return x && x.animated;
    });
    style.texcoords = sources.some(function (x) {
        return x && x.texcoords;
    });

    // Overwrites - last definition wins
    style.base = sources.map(function (x) {
        return x.base;
    }).filter(function (x) {
        return x;
    }).pop();
    style.texture = sources.map(function (x) {
        return x.texture;
    }).filter(function (x) {
        return x;
    }).pop();

    // Merges - property-specific rules for merging values
    style.defines = Object.assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));
    style.material = Object.assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.material;
    }).filter(function (x) {
        return x;
    }))));

    var merge = sources.map(function (x) {
        return x.shaders;
    }).filter(function (x) {
        return x;
    });
    var shaders = {};
    shaders.defines = Object.assign.apply(Object, [{}].concat(_toConsumableArray(merge.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));
    shaders.uniforms = Object.assign.apply(Object, [{}].concat(_toConsumableArray(merge.map(function (x) {
        return x.uniforms;
    }).filter(function (x) {
        return x;
    }))));

    merge.map(function (x) {
        return x.blocks;
    }).filter(function (x) {
        return x;
    }).forEach(function (blocks) {
        shaders.blocks = shaders.blocks || {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Utils.entries(blocks)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2);

                var t = _step$value[0];
                var block = _step$value[1];

                shaders.blocks[t] = shaders.blocks[t] || [];

                if (Array.isArray(block)) {
                    var _shaders$blocks$t;

                    (_shaders$blocks$t = shaders.blocks[t]).push.apply(_shaders$blocks$t, _toConsumableArray(block));
                } else {
                    shaders.blocks[t].push(block);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    });

    style.shaders = shaders;
    style.mixed = true; // track that we already applied mixins (avoid dupe work later)

    return style;
};

// Create a new style
// name: name of new style
// config: properties of new style
// styles: working set of styles being built (used for mixing in existing styles)
StyleManager.create = function (name, config) {
    var styles = arguments[2] === undefined ? {} : arguments[2];

    var style = Object.assign({}, config); // shallow copy
    style.name = name;

    // Style mixins
    StyleManager.mix(style, styles);

    // Has base style?
    // Only renderable (instantiated) styles should be included for run-time use
    // Others are intermediary/abstract, used during style composition but not execution
    if (style.base && BaseStyles[style.base]) {
        Styles[name] = style = Object.assign(Object.create(BaseStyles[style.base]), style);
    }

    return style;
};

// Called to create and initialize styles
StyleManager.build = function (styles) {
    var scene = arguments[1] === undefined ? {} : arguments[1];

    // Sort styles by dependency, then build them
    var style_deps = Object.keys(styles).sort(function (a, b) {
        return StyleManager.inheritanceDepth(a, styles) - StyleManager.inheritanceDepth(b, styles);
    });

    // Only keep built-in base styles
    for (var sname in Styles) {
        if (!BaseStyles[sname]) {
            delete Styles[sname];
        } else {
            Styles[sname].reset();
        }
    }

    // Working set of styles being built
    var ws = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = style_deps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var sname = _step.value;

            ws[sname] = StyleManager.create(sname, styles[sname], ws);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    StyleManager.initStyles(scene);
    return Styles;
};

// Initialize all styles
StyleManager.initStyles = function (scene) {
    // Initialize all
    for (var sname in Styles) {
        Styles[sname].init(scene);
    }
};

// Given a style key in a set of styles to add, count the length of the inheritance chain
// TODO: remove current (Styles) and future (styles) duplication, confusing
StyleManager.inheritanceDepth = function (key, styles) {
    var parents = 0;

    while (true) {
        var style = styles[key];
        if (!style) {
            // this is a scene def error, trying to extend a style that doesn't exist
            // TODO: warn/throw?
            break;
        }

        // Dependency chain ends when this style isn't mixing in any others
        if (!style.mix) {
            break;
        }

        // Traverse next parent style
        parents++;

        if (Array.isArray(style.mix)) {
            // If multiple mixins, find the deepest one
            parents += Math.max.apply(Math, _toConsumableArray(style.mix.map(function (s) {
                return StyleManager.inheritanceDepth(s, styles);
            })));
            break;
        } else {
            // If single mixin, continue loop up the tree
            key = style.mix;
        }
    }
    return parents;
};

// Compile all styles
StyleManager.compile = function (keys) {
    keys = keys || Object.keys(Styles);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            try {
                Styles[key].compile();
                log.trace("StyleManager.compile(): compiled style " + key);
            } catch (error) {
                log.error("StyleManager.compile(): error compiling style " + key + ":", error);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    log.debug("StyleManager.compile(): compiled all styles");
};

// Get all styles with mesh data for a given tile
StyleManager.stylesForTile = function (tile) {
    var styles = [];
    for (var s in Styles) {
        if (Styles[s].hasDataForTile(tile)) {
            styles.push(s);
        }
    }
    return styles;
};

},{"../gl/shader_program":71,"../gl/shader_sources":72,"../utils/utils":102,"./style":90,"loglevel":53}],92:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var Utils = _interopRequire(require("../utils/utils"));

var Geo = _interopRequire(require("../geo"));

var parseCSSColor = _interopRequire(require("csscolorparser"));

var log = _interopRequire(require("loglevel"));

var StyleParser = {};

exports.StyleParser = StyleParser;
// Style macros

StyleParser.expandMacros = function expandMacros(obj) {
    for (var p in obj) {
        var val = obj[p];

        // Loop through object properties
        if (typeof val === "object") {
            obj[p] = expandMacros(val);
        }
        // Convert strings back into functions
        else if (typeof val === "string") {
            for (var m in StyleParser.macros) {
                if (val.match(StyleParser.macros[m])) {
                    var f;
                    try {
                        /*jshint ignore:start */
                        eval("f = " + val);
                        /*jshint ignore:end */
                        obj[p] = f;
                        log.trace("expanded macro " + val + " to " + f);
                        break;
                    } catch (e) {
                        // fall-back to original value if parsing failed
                        obj[p] = val;
                        log.trace("failed to expand macro " + val);
                    }
                }
            }
        }
    }

    return obj;
};

// List of macros
StyleParser.macros = ["Style.color.pseudoRandomColor", "Style.color.randomColor"];

var Style = {};

Style.color = {
    // pseudo-random grayscale by geometry id
    pseudoRandomGrayscale: function pseudoRandomGrayscale() {
        var func = "function() {\n            var c = Math.max((parseInt(feature.id, 16) % 100) / 100, 0.4);\n            return [0.7 * c, 0.7 * c, 0.7 * c];\n        }";
        return func;
    },

    // pseudo-random color by geometry id
    pseudoRandomColor: function pseudoRandomColor() {
        var func = "function() {\n            return [\n                0.7 * (parseInt(feature.id, 16) / 100 % 1),\n                0.7 * (parseInt(feature.id, 16) / 10000 % 1),\n                0.7 * (parseInt(feature.id, 16) / 1000000 % 1)\n            ];\n        }";
        return func;
        // return `function() { return [0.7 * (parseInt(feature.id, 16) / 100 % 1), 0.7 * (parseInt(feature.id, 16) / 10000 % 1), 0.7 * (parseInt(feature.id, 16) / 1000000 % 1)]; }`;
    },

    // random color
    randomColor: function randomColor() {
        var func = "function() {\n            return [0.7 * Math.random(), 0.7 * Math.random(), 0.7 * Math.random()];\n        }";
        return func;
    }
};

// Wraps style functions and provides a scope of commonly accessible data:
// - feature: the 'properties' of the feature, e.g. accessed as 'feature.name'
// - $zoom: the current map zoom level
// - $geometry: the type of geometry, 'point', 'line', or 'polygon'
// - $meters_per_pixel: conversion for meters/pixels at current map zoom
// - properties: user-defined properties on the style-rule object in the stylesheet
StyleParser.wrapFunction = function (func) {
    var f = "function(context) {\n                var feature = context.feature.properties;\n                var $zoom = context.zoom;\n                var $geometry = context.geometry;\n                var $meters_per_pixel = context.meters_per_pixel;\n                var properties = context.properties;\n                return (" + func + "());\n            }";
    return f;
};

// Style parsing

// Style defaults
StyleParser.defaults = {
    color: [1, 1, 1, 1],
    width: 1,
    size: 1,
    extrude: false,
    height: 20,
    min_height: 0,
    order: 0,
    z: 0,
    material: {
        ambient: 1,
        diffuse: 1
    }
};

// A context object that is passed to style parsing functions to provide a scope of commonly used values
StyleParser.getFeatureParseContext = function (feature, tile) {
    return {
        feature: feature,
        tile: tile,
        zoom: tile.style_zoom,
        geometry: Geo.geometryType(feature.geometry.type),
        meters_per_pixel: Geo.metersPerPixel(tile.coords.z),
        units_per_meter: Geo.units_per_meter[tile.coords.z]
    };
};

StyleParser.convertUnits = function (val, context) {
    var convert = arguments[2] === undefined ? "meters" : arguments[2];

    if (typeof val === "string") {
        var units = val.match(/([0-9.-]+)([a-z]+)/);
        if (units && units.length === 3) {
            val = parseFloat(units[1]);
            units = units[2];
        }

        // Convert to meters
        if (convert === "meters") {
            // Convert from pixels
            if (units === "px") {
                val *= Geo.metersPerPixel(context.zoom);
            }
            // Convert from kilometers
            else if (units === "km") {
                val *= 1000;
            }
        }
    } else if (Array.isArray(val)) {
        // Array of arrays, e.g. zoom-interpolated stops
        if (Array.isArray(val[0])) {
            return val.map(function (v) {
                return [v[0], StyleParser.convertUnits(v[1], context, convert)];
            });
        }
        // Array of values
        else {
            return val.map(function (v) {
                return StyleParser.convertUnits(v, context, convert);
            });
        }
    }
    return val;
};

// Takes a distance cache object and returns a distance value for this zoom
// (caching the result for future use)
// { value: original, zoom: { z: meters }, dynamic: function(){...} }
StyleParser.cacheDistance = function (val, context) {
    var convert = arguments[2] === undefined ? "units" : arguments[2];

    if (val.dynamic) {
        var v = val.dynamic(context);
        if (convert === "units") {
            v *= context.units_per_meter;
        }
        return v;
    } else if (val.zoom && val.zoom[convert] && val.zoom[convert][context.zoom]) {
        return val.zoom[convert][context.zoom];
    } else {
        // Dynamic function-based
        if (typeof val.value === "function") {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            if (convert === "units") {
                v *= context.units_per_meter;
            }
            return v;
        }
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        else {
            // Calculate color for current zoom
            val.zoom = val.zoom || {};
            var zunits = val.zoom[convert] = val.zoom[convert] || {};

            zunits[context.zoom] = StyleParser.convertUnits(val.value, context, (convert === "units" || convert === "meters") && "meters"); // convert to meters
            zunits[context.zoom] = Utils.interpolate(context.zoom, zunits[context.zoom]);

            // Convert to tile units
            if (convert === "units") {
                zunits[context.zoom] *= context.units_per_meter;
            }
            return zunits[context.zoom];
        }
    }
};

StyleParser.parseDistance = function (val, context) {
    var convert = arguments[2] === undefined ? "units" : arguments[2];

    if (typeof val === "function") {
        val = val(context);
    }
    val = StyleParser.convertUnits(val, context, (convert === "units" || convert === "meters") && "meters"); // convert to meters
    val = Utils.interpolate(context.zoom, val);

    // Convert to tile units
    if (convert === "units") {
        if (typeof val === "number") {
            val *= context.units_per_meter;
        } else if (Array.isArray(val)) {
            val.forEach(function (v, i) {
                return val[i] *= context.units_per_meter;
            });
        }
    }
    return val;
};

// Cache previously parsed color strings
StyleParser.string_colors = {};
StyleParser.colorForString = function (string) {
    // Cached
    if (StyleParser.string_colors[string]) {
        return StyleParser.string_colors[string];
    }

    // Calculate and cache
    var color = parseCSSColor.parseCSSColor(string);
    if (color && color.length === 4) {
        color[0] /= 255;
        color[1] /= 255;
        color[2] /= 255;
        color[3] = 1;
    } else {
        color = StyleParser.defaults.color;
    }
    StyleParser.string_colors[string] = color;
    return color;
};

// Takes a color cache object and returns a color value for this zoom
// (caching the result for future use)
// { value: original, static: [r,g,b,a], zoom: { z: [r,g,b,a] }, dynamic: function(){...} }
StyleParser.cacheColor = function (val) {
    var context = arguments[1] === undefined ? {} : arguments[1];

    if (val.dynamic) {
        var v = val.dynamic(context);
        v[3] = v[3] || 1; // default alpha
        return v;
    } else if (val["static"]) {
        return val["static"];
    } else if (val.zoom && val.zoom[context.zoom]) {
        return val.zoom[context.zoom];
    } else {
        // Dynamic function-based color
        if (typeof val.value === "function") {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            v[3] = v[3] || 1; // default alpha
            return v;
        }
        // Single string color
        else if (typeof val.value === "string") {
            val["static"] = StyleParser.colorForString(val.value);
            return val["static"];
        }
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        else if (Array.isArray(val.value) && Array.isArray(val.value[0])) {
            if (!val.zoom) {
                val.zoom = {};
                // Parse any string colors inside stops
                for (var i = 0; i < val.value.length; i++) {
                    var v = val.value[i];
                    if (typeof v[1] === "string") {
                        v[1] = StyleParser.colorForString(v[1]);
                    }
                }
            }

            // Calculate color for current zoom
            val.zoom[context.zoom] = Utils.interpolate(context.zoom, val.value);
            val.zoom[context.zoom][3] = val.zoom[context.zoom][3] || 1; // default alpha
            return val.zoom[context.zoom];
        }
        // Single array color
        else {
            val["static"] = val.value;
            val["static"][3] = val["static"][3] || 1; // default alpha
            return val["static"];
        }
    }
};

StyleParser.parseColor = function (val) {
    var context = arguments[1] === undefined ? {} : arguments[1];

    if (typeof val === "function") {
        val = val(context);
    }

    // Parse CSS-style colors
    // TODO: change all colors to use 0-255 range internally to avoid dividing and then re-multiplying in geom builder
    if (typeof val === "string") {
        val = parseCSSColor.parseCSSColor(val);
        if (val && val.length === 4) {
            val[0] /= 255;
            val[1] /= 255;
            val[2] /= 255;
        } else {
            val = null;
        }
    } else if (Array.isArray(val) && Array.isArray(val[0])) {
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        for (var i = 0; i < val.length; i++) {
            var v = val[i];
            if (typeof v[1] === "string") {
                var vc = parseCSSColor.parseCSSColor(v[1]);
                if (vc && vc.length === 4) {
                    vc[0] /= 255;
                    vc[1] /= 255;
                    vc[2] /= 255;
                    v[1] = vc;
                }
            }
        }
    }

    if (context.zoom) {
        val = Utils.interpolate(context.zoom, val);
    }

    // Defaults
    if (val) {
        // alpha
        if (!val[3]) {
            val[3] = 1;
        }
    } else {
        val = [0, 0, 0, 1];
    }

    return val;
};

// Order is summed from top to bottom in the style hierarchy:
// each child order value is added to the parent order value
StyleParser.calculateOrder = function (order, context) {
    if (typeof order === "function") {
        order = order(context);
    } else if (Array.isArray(order)) {
        order = order.reduce(function (sum, order) {
            order = order || StyleParser.defaults.order;
            if (typeof order === "function") {
                order = order(context);
            } else if (typeof order === "string") {
                order = context.feature.properties[order];
            } else {
                order = parseFloat(order);
            }

            if (!order || isNaN(order)) {
                return sum;
            }
            return sum + order;
        }, 0);
    } else if (typeof order === "string") {
        if (context.feature.properties[order]) {
            order = context.feature.properties[order];
        } else {
            order = parseFloat(order);
        }
    }

    return order;
};

},{"../geo":67,"../utils/utils":102,"csscolorparser":19,"loglevel":53}],93:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Label */

var boxIntersect = _interopRequire(require("box-intersect"));

var Utils = _interopRequire(require("../../utils/utils"));

var Geo = _interopRequire(require("../../geo"));

var Label = (function () {
    function Label(text, size, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, Label);

        Object.assign(this, {
            text: text,
            size: size,
            position: [],
            bbox: [],
            move_in_tile: move_in_tile,
            keep_in_tile: keep_in_tile
        });

        this.id = Label.id++;

        this.buffer = this.buffer || 2; // TODO: make configurable
        this.buffer *= Geo.units_per_pixel;
    }

    _createClass(Label, {
        isComposite: {
            value: function isComposite() {
                return false;
            }
        },
        occluded: {
            value: function occluded(bboxes) {
                var intersect = false;

                if (bboxes.length > 0) {
                    boxIntersect([this.bbox], bboxes, function (i, j) {
                        intersect = true;
                        return true;
                    });
                }

                if (!intersect) {
                    bboxes.push(this.bbox);
                }

                return intersect;
            }
        },
        inTileBounds: {
            value: function inTileBounds() {
                var min = [this.bbox[0], this.bbox[1]];
                var max = [this.bbox[2], this.bbox[3]];

                if (!Utils.pointInTile(min) || !Utils.pointInTile(max)) {
                    return false;
                }

                return true;
            }
        },
        discard: {
            value: function discard(bboxes) {
                var discard = false;

                // perform specific styling rule, should we keep the label in tile bounds?
                if (this.keep_in_tile) {
                    var in_tile = this.inTileBounds();

                    if (!in_tile && this.move_in_tile) {
                        // can we move?
                        discard = this.moveInTile();
                    } else if (!in_tile) {
                        // we didn't want to move at all,
                        // just discard since we're out of tile bounds
                        return true;
                    }
                }

                // should we discard? if not, just make occlusion test
                return discard || this.occluded(bboxes);
            }
        }
    });

    return Label;
})();

module.exports = Label;

Label.id = 0;

},{"../../geo":67,"../../utils/utils":102,"box-intersect":4}],94:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var LabelPoint = _interopRequire(require("./label_point"));

var LabelLine = _interopRequire(require("./label_line"));

var Utils = _interopRequire(require("../../utils/utils"));

var LabelBuilder;
module.exports = LabelBuilder = {};

LabelBuilder.labelsFromGeometry = function (geometry, _ref, label_style) {
    var text = _ref.text;
    var size = _ref.size;

    var labels = [];

    if (geometry.type === "LineString") {
        var lines = geometry.coordinates;

        labels.push(new LabelLine(text, size, lines, label_style.lines, { move_in_tile: true, keep_in_tile: true }));
    } else if (geometry.type === "MultiLineString") {
        var lines = geometry.coordinates;

        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];

            labels.push(new LabelLine(text, size, line, label_style.lines, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "Point") {
        var width = label_style.points.max_width;

        // if (width && size.text_size[0] > width) {
        //     let line_height = (size.px_logical_size / 100) * label_style.points.line_height;
        //     line_height = Utils.pixelToMercator(line_height);
        //     let label = LabelPoint.explode(text, geometry.coordinates, size, width, line_height, { move_in_tile: true, keep_in_tile: true });

        //     labels.push(label);
        // } else {
        if (!(width && size.text_size[0] > width)) {
            labels.push(new LabelPoint(text, geometry.coordinates, size, null, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "MultiPoint") {
        var points = geometry.coordinates;

        for (var i = 0; i < points.length; ++i) {
            var point = points[i];
            labels.push(new LabelPoint(text, point, size, null, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "Polygon") {
        var centroid = Utils.centroid(geometry.coordinates[0]);
        var area = Utils.polygonArea(geometry.coordinates[0]);

        labels.push(new LabelPoint(text, centroid, size, area, { move_in_tile: true, keep_in_tile: true }));
    } else if (geometry.type === "MultiPolygon") {
        var centroid = Utils.multiCentroid(geometry.coordinates);
        var area = Utils.multiPolygonArea(geometry.coordinates);

        labels.push(new LabelPoint(text, centroid, size, area, { move_in_tile: true, keep_in_tile: true }));
    }

    return labels;
};

},{"../../utils/utils":102,"./label_line":95,"./label_point":96}],95:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Vector = _interopRequire(require("../../vector"));

var Geo = _interopRequire(require("../../geo"));

var Label = _interopRequire(require("./label"));

var Utils = _interopRequire(require("../../utils/utils"));

var LabelLine = (function (_Label) {
    function LabelLine(text, size, lines, style, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, LabelLine);

        _get(Object.getPrototypeOf(LabelLine.prototype), "constructor", this).call(this, text, size, { move_in_tile: move_in_tile, keep_in_tile: keep_in_tile });

        this.segment_index = 0;
        this.lines = lines;
        this.exceed_heuristic = style.exceed;
        this.offset = style.offset;
        this.update();
    }

    _inherits(LabelLine, _Label);

    _createClass(LabelLine, {
        middleSegment: {
            value: function middleSegment(segment) {
                return [(segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2];
            }
        },
        update: {
            value: function update() {
                var segment = this.currentSegment();

                this.angle = this.computeAngle();

                var perp = Vector.normalize(Vector.perp(segment[0], segment[1]));
                var dot = Vector.dot(perp, [0, 1]);
                var offset = Vector.mult(perp, Utils.pixelToMercator(this.offset * Math.sign(dot)));

                this.position = Vector.add(this.middleSegment(segment), offset);
                this.bbox = this.computeBBox();
            }
        },
        moveNextSegment: {
            value: function moveNextSegment() {
                if (this.segment_index + 1 >= this.lines.length - 1) {
                    return false;
                }

                this.segment_index++;
                this.update();

                return true;
            }
        },
        computeAngle: {
            value: function computeAngle() {
                var segment = this.currentSegment();
                var p0p1 = Vector.sub(segment[0], segment[1]);

                p0p1 = Vector.normalize(p0p1);

                var PI_2 = Math.PI / 2;
                var theta = Math.atan2(p0p1[0], p0p1[1]) + PI_2;

                if (theta > PI_2 || theta < -PI_2) {
                    theta += Math.PI;
                }
                theta %= Math.PI * 2;

                return theta;
            }
        },
        fitToSegment: {
            value: function fitToSegment() {
                var should_fit = arguments[0] === undefined ? true : arguments[0];

                if (!should_fit) {
                    return true;
                }

                var segment = this.currentSegment();
                var p0p1 = Vector.sub(segment[0], segment[1]);
                var length = Vector.length(p0p1);

                var label_length = Utils.pixelToMercator(this.size.text_size[0]);

                if (label_length > length) {
                    // an exceed heurestic of 100% would let the label fit in any cases
                    var exceed = (1 - length / label_length) * 100;
                    return exceed < this.exceed_heuristic;
                }

                return label_length < length;
            }
        },
        currentSegment: {
            value: function currentSegment() {
                var p1 = this.lines[this.segment_index];
                var p2 = this.lines[this.segment_index + 1];

                return [p1, p2];
            }
        },
        computeBBox: {
            value: function computeBBox(size) {
                var upp = Geo.units_per_pixel;

                var merc_width = this.size.text_size[0] * upp;
                var merc_height = this.size.text_size[1] * upp;

                var c = Math.cos(this.angle);
                var s = Math.sin(this.angle);

                var x = merc_width * c - merc_height * s;
                var y = merc_width * s + merc_height * c;

                var max = Math.max(Math.abs(x), Math.abs(y)) * 0.5 + this.buffer;

                var bbox = [this.position[0] - max, this.position[1] - max, this.position[0] + max, this.position[1] + max];

                return bbox;
            }
        },
        moveInTile: {
            value: function moveInTile() {
                var in_tile = false;
                var fits_to_segment = this.fitToSegment();

                // move this label until we found a line we can fit in
                while (!in_tile && !fits_to_segment) {
                    if (!this.moveNextSegment()) {
                        // we can't move further in this line
                        break;
                    }

                    in_tile = this.inTileBounds();
                    fits_to_segment = this.fitToSegment();
                }

                return !in_tile || !fits_to_segment;
            }
        },
        discard: {
            value: function discard(bboxes) {
                if (this.lines && !this.fitToSegment()) {
                    while (!this.fitToSegment()) {
                        if (!this.moveNextSegment()) {
                            return true;
                        }
                    }
                }

                return _get(Object.getPrototypeOf(LabelLine.prototype), "discard", this).call(this, bboxes);
            }
        }
    });

    return LabelLine;
})(Label);

module.exports = LabelLine;

},{"../../geo":67,"../../utils/utils":102,"../../vector":105,"./label":93}],96:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Label = _interopRequire(require("./label"));

var Utils = _interopRequire(require("../../utils/utils"));

var Geo = _interopRequire(require("../../geo"));

var LabelPoint = (function (_Label) {
    function LabelPoint(text, position, size, area, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, LabelPoint);

        _get(Object.getPrototypeOf(LabelPoint.prototype), "constructor", this).call(this, text, size, { move_in_tile: move_in_tile, keep_in_tile: keep_in_tile });

        this.area = area;
        this.position = position;
        this.bbox = this.computeBBox();
    }

    _inherits(LabelPoint, _Label);

    _createClass(LabelPoint, {
        computeBBox: {
            value: function computeBBox() {
                var half_merc_width = Utils.pixelToMercator(this.size.text_size[0]) * 0.5 + this.buffer;
                var half_merc_height = Utils.pixelToMercator(this.size.text_size[1]) * 0.5 + this.buffer;

                var bbox = [this.position[0] - half_merc_width, this.position[1] - half_merc_height, this.position[0] + half_merc_width, this.position[1] + half_merc_height];

                return bbox;
            }
        },
        moveInTile: {
            value: function moveInTile(in_tile) {
                var width = this.bbox[2] - this.bbox[0];
                var height = -this.bbox[3] - -this.bbox[1];

                // Move point labels to tile edges
                if (this.position[0] - width / 2 < 0) {
                    this.position[0] = width / 2 + 1;
                } else if (this.position[0] + width / 2 > Geo.tile_scale) {
                    this.position[0] = Geo.tile_scale - (width / 2 + 1);
                }

                this.position[1] *= -1; // just doing this so Y coord is positive
                if (this.position[1] - height / 2 < 0) {
                    // && this.position[1] > 0) {
                    this.position[1] = height / 2 + 1;
                } else if (this.position[1] + height / 2 > Geo.tile_scale) {
                    this.position[1] = Geo.tile_scale - (height / 2 + 1);
                }
                this.position[1] *= -1;

                this.bbox = this.computeBBox();
                return !this.inTileBounds();
            }
        }
    }, {
        explode: {
            value: function explode(text, position, size, max_width, padding, move_in_tile, keep_in_tile) {
                var split_text = text.split(" ");

                if (split_text.length < 2) {
                    return new LabelPoint(text, position, size, null, move_in_tile, keep_in_tile);
                }

                var line = new TextLine(text, size.text_size[0], split_text, size.split_size);
                var lines = line.explode(max_width);
                var labels = [];

                if (lines.length === 1) {
                    return new LabelPoint(text, position, size, null, move_in_tile, keep_in_tile);
                }

                for (var i in lines) {
                    var l = lines[i];
                    var pos = [position[0], position[1] - Math.abs(padding) * i];
                    labels.push(new LabelPoint(l.text, pos, size, null, move_in_tile, keep_in_tile));
                }

                return new LabelComposite(text, position, size, labels, move_in_tile, keep_in_tile);
            }
        }
    });

    return LabelPoint;
})(Label);

module.exports = LabelPoint;

var LabelComposite = (function (_Label2) {
    function LabelComposite(text, position, size, labels, move_in_tile, keep_in_tile) {
        _classCallCheck(this, LabelComposite);

        _get(Object.getPrototypeOf(LabelComposite.prototype), "constructor", this).call(this, text, size, move_in_tile, keep_in_tile);

        this.position = position;
        this.labels = labels;
        this.bbox = this.computeBBox();
    }

    _inherits(LabelComposite, _Label2);

    _createClass(LabelComposite, {
        isComposite: {
            value: function isComposite() {
                return true;
            }
        },
        moveInTile: {
            value: function moveInTile(in_tile) {
                return false;
            }
        },
        computeBBox: {
            value: function computeBBox() {
                var bbox = [Infinity, Infinity, -Infinity, -Infinity];

                for (var i in this.labels) {
                    var b = this.labels[i].bbox;

                    bbox[0] = Math.min(b[0], bbox[0]);
                    bbox[1] = Math.min(b[1], bbox[1]);
                    bbox[2] = Math.max(b[2], bbox[2]);
                    bbox[3] = Math.max(b[3], bbox[3]);
                }

                return bbox;
            }
        }
    });

    return LabelComposite;
})(Label);

var TextLine = (function () {
    function TextLine(text, line_length, words, size_info) {
        _classCallCheck(this, TextLine);

        this.text = text;
        this.line_length = line_length;
        this.size_info = size_info;
        this.words = this.positions(words);
    }

    _createClass(TextLine, {
        positions: {
            value: function positions(words, size_info) {
                var word_infos = [];
                var offset = 0;
                var space_offset = this.size_info[" "];

                for (var i = 0; i < words.length; ++i) {
                    var word = words[i];
                    var word_length = this.size_info[word];

                    word_infos.push({
                        word: word,
                        start: offset,
                        end: offset + word_length
                    });
                    offset += word_length;

                    if (i !== words.length - 1) {
                        word_infos.push({
                            word: " ",
                            start: offset,
                            end: offset + space_offset
                        });
                        offset += space_offset;
                    }
                }

                return word_infos;
            }
        },
        explode: {
            value: function explode(max_width) {
                var exploded_lines = arguments[1] === undefined ? [] : arguments[1];

                if (max_width > this.line_length) {
                    exploded_lines.push(this);
                    return exploded_lines;
                }

                var index = this.wordInfoIndex(max_width);

                if (this.words[index].word === " ") {
                    index -= 1;
                }

                if (index < 1) {
                    exploded_lines.push(this);
                    return exploded_lines;
                }

                if (index < this.words.length) {
                    var next_line_length = 0,
                        previous_line_length = 0;
                    var next_line_words = "",
                        previous_line_words = "";

                    for (var i = index; i < this.words.length; ++i) {
                        next_line_words += this.words[i].word;
                        next_line_length += this.size_info[this.words[i].word];
                    }

                    for (var i = 0; i < index; i++) {
                        if (i !== index - 1 && this.words[i] !== " ") {
                            previous_line_words += this.words[i].word;
                            previous_line_length += this.size_info[this.words[i].word];
                        }
                    }

                    exploded_lines.push(new TextLine(previous_line_words, previous_line_length, previous_line_words.split(" "), this.size_info));

                    var next_line = new TextLine(next_line_words, next_line_length, next_line_words.split(" "), this.size_info);

                    return next_line.explode(max_width, exploded_lines);
                }

                exploded_lines.push(this);
                return exploded_lines;
            }
        },
        wordInfoIndex: {
            value: function wordInfoIndex(position) {
                if (position > this.line_length || this.words[this.words.length - 1].end < position) {
                    return this.words.length - 1;
                } else if (position < 0) {
                    return 0;
                }

                var d = this.words.length / 2;
                var i = Math.ceil(d);
                i = Math.min(Math.max(0, i), this.words.length - 1);
                var word_info = this.words[i];

                // dichotomic search
                while (word_info.start > position || word_info.end < position) {
                    d /= 2;
                    i += word_info.end < position ? Math.ceil(d) : -Math.ceil(d);
                    i = Math.min(Math.max(0, i), this.words.length - 1);
                    word_info = this.words[i];
                }

                return i;
            }
        }
    });

    return TextLine;
})();

},{"../../geo":67,"../../utils/utils":102,"./label":93}],97:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Text rendering style

var Builders = _interopRequire(require("../builders"));

var StyleParser = require("../style_parser").StyleParser;

var Texture = _interopRequire(require("../../gl/texture"));

var WorkerBroker = _interopRequire(require("../../utils/worker_broker"));

var Utils = _interopRequire(require("../../utils/utils"));

var Points = require("../points/points").Points;

var LabelBuilder = _interopRequire(require("./label_builder"));

var log = _interopRequire(require("loglevel"));

var TextStyle = Object.create(Points);

exports.TextStyle = TextStyle;
Object.assign(TextStyle, {
    name: "text",
    "super": Points,
    built_in: true,
    selection: false,

    init: function init() {

        this["super"].init.apply(this, arguments);

        // Provide a hook for this object to be called from worker threads
        if (Utils.isMainThread) {
            WorkerBroker.addTarget("TextStyle", this);
        }

        this.max_priority = 0;

        // Point style (parent class) requires texturing to be turned on
        // (labels are always drawn with textures)
        this.defines.TANGRAM_POINT_TEXTURE = true;

        // default font style
        this.font_style = {
            typeface: "Helvetica 12px",
            fill: "white",
            capitalized: false
        };

        // default label style
        this.label_style = {
            priorities: {
                administrative: 4,
                major_road: 3,
                minor_road: 2,
                restaurant: 1 },
            lines: {
                exceed: 80,
                offset: 0
            },
            points: {
                max_width: 150,
                line_height: 100 // percentage
            }
        };

        this.reset();
    },

    reset: function reset() {
        this["super"].reset.call(this);
        this.texts = {}; // unique texts, keyed by tile
        this.textures = {};
        this.canvas = {};
        this.bboxes = {};
        this.features = {};
        this.feature_labels = {};
        this.feature_style_key = {};
    },

    // Called on main thread to release tile-specific resources
    freeTile: function freeTile(tile) {
        delete this.texts[tile];
        delete this.textures[tile];
        delete this.canvas[tile];
        delete this.bboxes[tile];
        delete this.features[tile];
        delete this.feature_labels[tile];
        delete this.feature_style_key[tile];
    },

    // Set font style params for canvas drawing
    setFont: function setFont(tile, _ref) {
        var font = _ref.font;
        var fill = _ref.fill;
        var stroke = _ref.stroke;
        var stroke_width = _ref.stroke_width;
        var px_size = _ref.px_size;
        var px_logical_size = _ref.px_logical_size;

        this.px_size = parseInt(px_size);
        this.px_logical_size = parseInt(px_logical_size);
        this.text_buffer = 6; // pixel padding around text
        var ctx = this.canvas[tile].context;

        ctx.font = font;
        if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = stroke_width;
        } else {
            ctx.strokeStyle = null;
            ctx.lineWidth = 0;
        }
        ctx.fillStyle = fill;
        ctx.miterLimit = 2;
    },

    // Width and height of text based on current font style
    textSize: function textSize(text, tile, capitalized) {
        var str = capitalized ? text.toUpperCase() : text;
        var ctx = this.canvas[tile].context;
        var split = str.split(" ");
        var px_size = this.px_size;
        var px_logical_size = this.px_logical_size;
        var buffer = this.text_buffer * Utils.device_pixel_ratio;
        var split_size = {
            " ": this.canvas[tile].context.measureText(" ").width / Utils.device_pixel_ratio
        };

        for (var i in split) {
            var word = split[i];
            split_size[word] = ctx.measureText(word).width / Utils.device_pixel_ratio;
        }

        var str_width = ctx.measureText(str).width;
        var text_size = [str_width / Utils.device_pixel_ratio, this.px_size / Utils.device_pixel_ratio];

        var texture_text_size = [Math.ceil(str_width) + buffer * 2, this.px_size + buffer * 2];

        return { split_size: split_size, text_size: text_size, texture_text_size: texture_text_size, px_size: px_size, px_logical_size: px_logical_size };
    },

    // Draw text at specified location, adjusting for buffer and baseline
    drawText: function drawText(text, _ref, tile, stroke, capitalized) {
        var _ref2 = _slicedToArray(_ref, 2);

        var x = _ref2[0];
        var y = _ref2[1];

        var str = capitalized ? text.toUpperCase() : text;
        var buffer = this.text_buffer * Utils.device_pixel_ratio;
        if (stroke) {
            this.canvas[tile].context.strokeText(str, x + buffer, y + buffer + this.px_size);
        }
        this.canvas[tile].context.fillText(str, x + buffer, y + buffer + this.px_size);
    },

    setTextureTextPositions: function setTextureTextPositions(texts) {
        // Find widest label and sum of all label heights
        var widest = 0,
            height = 0;

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var text_info = text_infos[text];
                var size = text_info.size.texture_text_size;

                text_info.position = [0, height];

                if (size[0] > widest) {
                    widest = size[0];
                }

                height += size[1];
            }
        }

        return [widest, height];
    },

    getTextSizes: function getTextSizes(tile, texts) {
        // create a canvas
        if (!this.canvas[tile]) {
            var canvas = document.createElement("canvas");
            this.canvas[tile] = {
                canvas: canvas,
                context: canvas.getContext("2d")
            };
        }

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var text_style = text_infos[text].text_style;
                // update text sizes
                this.setFont(tile, text_style);
                text_infos[text].size = this.textSize(text, tile, text_style.capitalized);
            }
        }

        return Promise.resolve(texts);
    },

    rasterize: function rasterize(tile, texts, texture_size) {
        var pixel_scale = Utils.device_pixel_ratio;

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var info = text_infos[text];

                this.setFont(tile, info.text_style);
                this.drawText(text, info.position, tile, info.text_style.stroke, info.text_style.capitalized);

                info.texcoords = Builders.getTexcoordsForSprite(info.position, info.size.texture_text_size, texture_size);

                if (!info.sub_texts) {
                    continue;
                }

                var width = this.text_buffer;
                var dists = [];
                var space_size = info.size.split_size[" "];

                for (var i = 0; i < info.sub_texts.length; ++i) {
                    var sub_text = info.sub_texts[i];
                    var split = sub_text.split(" ");

                    dists[i] = width * pixel_scale;

                    for (var j = 0; j < split.length; ++j) {
                        var word = split[j];
                        width += info.size.split_size[word];

                        if (j !== split.length - 1) {
                            width += space_size;
                        }
                    }

                    if (i !== info.sub_texts.length - 1) {
                        width += space_size / 2;
                    }
                }

                // sub-texts uv mapping
                for (var i = 0; i < info.sub_texts.length; ++i) {
                    var sub_text = info.sub_texts[i];

                    if (!info.subtexcoords) {
                        info.subtexcoords = {};
                    }

                    var offset = 0;

                    if (i < info.sub_texts.length - 1) {
                        offset = info.size.texture_text_size[0] - dists[i + 1];
                    }

                    var position = [info.position[0] + dists[i], info.position[1]];

                    var size = [info.size.texture_text_size[0] - offset - dists[i], info.size.texture_text_size[1]];

                    if (!info.subtext_size) {
                        info.subtext_size = {};
                    }
                    info.subtext_size[sub_text] = size;

                    info.subtexcoords[sub_text] = Builders.getTexcoordsForSprite(position, size, texture_size);
                }
            }
        }
    },

    // Called on main thread from worker, to create atlas of labels for a tile
    addTexts: function addTexts(tile, texts) {
        if (!this.canvas[tile]) {
            return Promise.resolve({});
        }

        var texture_size = this.setTextureTextPositions(texts);
        var context = this.canvas[tile].context;

        log.trace("text summary for tile " + tile + ": fits in " + texture_size[0] + "x" + texture_size[1] + "px");

        // update the canvas "context"
        this.canvas[tile].canvas.width = texture_size[0];
        this.canvas[tile].canvas.height = texture_size[1];
        context.clearRect(0, 0, texture_size[0], texture_size[1]);

        // create a texture
        var texture = "labels-" + tile + "-" + TextStyle.texture_id++;
        this.textures[tile] = new Texture(this.gl, texture, { filtering: "linear" });
        // this.textures[tile].owner = { tile };

        // ask for rasterization for the text set
        this.rasterize(tile, texts, texture_size);

        this.textures[tile].setCanvas(this.canvas[tile].canvas);

        // we don't need tile canvas/texture once it has been copied to to GPU
        delete this.textures[tile];
        delete this.canvas[tile];

        return Promise.resolve({ texts: texts, texture: texture });
    },

    // Override
    startData: function startData(tile) {
        var tile_data = this["super"].startData.apply(this, arguments);
        tile_data.queue = [];
        return tile_data;
    },

    subTextInfos: function subTextInfos(label_composite, text_info) {
        if (!text_info.sub_texts) {
            text_info.sub_texts = [];
        }

        for (var i in label_composite.labels) {
            var label = label_composite.labels[i];
            text_info.sub_texts.push(label.text);
        }
    },

    createLabels: function createLabels(tile, texts) {
        var labels_priorities = [];

        if (!this.features[tile]) {
            return;
        }

        for (var style in texts) {
            var text_infos = texts[style];

            if (!this.features[tile][style]) {
                return;
            }

            for (var text in text_infos) {
                var text_info = text_infos[text];
                text_info.ref = 0;

                if (!this.features[tile][style][text]) {
                    return;
                }

                for (var f = 0; f < this.features[tile][style][text].length; f++) {
                    var feature = this.features[tile][style][text][f];
                    var labels = LabelBuilder.labelsFromGeometry(feature.geometry, { text: text, size: text_info.size }, this.label_style);

                    for (var i = 0; i < labels.length; ++i) {
                        var label = labels[i];
                        var area = label.area;

                        labels_priorities[text_info.priority] = labels_priorities[text_info.priority] || [];
                        labels_priorities[text_info.priority].push({ style: style, feature: feature, label: label, area: area });

                        if (label.isComposite()) {
                            this.subTextInfos(label, text_info);
                        }
                    }
                }
            }
        }

        // sort by area size if defined
        for (var p = 0; p < labels_priorities.length; ++p) {
            if (!labels_priorities[p]) {
                continue;
            }

            labels_priorities[p].sort(function (e1, e2) {
                if (e1.area && e2.area) {
                    return e1.area < e2.area;
                } else {
                    return false;
                }
            });
        }

        return labels_priorities;
    },

    discardLabels: function discardLabels(tile, labels, texts) {
        this.bboxes[tile] = [];
        this.feature_labels[tile] = new Map();

        for (var priority = this.max_priority; priority >= 0; priority--) {
            if (!labels[priority]) {
                continue;
            }

            for (var i = 0; i < labels[priority].length; i++) {
                var _labels$priority$i = labels[priority][i];
                var style = _labels$priority$i.style;
                var feature = _labels$priority$i.feature;
                var label = _labels$priority$i.label;

                if (!label.discard(this.bboxes[tile])) {
                    if (!this.feature_labels[tile].has(feature)) {
                        this.feature_labels[tile].set(feature, []);
                    }
                    this.feature_labels[tile].get(feature).push(label);
                    texts[style][label.text].ref++;
                }
            }
        }

        for (var style in texts) {
            for (var text in texts[style]) {
                if (texts[style][text].ref < 1) {
                    delete texts[style][text];
                }
            }
        }

        for (var style in texts) {
            var text_infos = texts[style];
            // No labels for this style
            if (Object.keys(text_infos).length === 0) {
                delete texts[style];
            }
        }
    },

    // Override
    endData: function endData(tile) {
        var _this25 = this;

        var _arguments = arguments;

        // Count collected text
        var count = undefined;
        var tile_data = this.tile_data[tile];

        if (tile_data.queue.length > 0) {
            count = Object.keys(this.texts[tile] || {}).length;
            log.trace("# texts for tile " + tile + ": " + count);
        }
        if (!count) {
            return Promise.resolve();
        }

        // first call to main thread, ask for text pixel sizes
        return WorkerBroker.postMessage("TextStyle", "getTextSizes", tile, this.texts[tile]).then(function (texts) {
            if (!texts) {
                _this25.freeTile(tile);
                return _this25["super"].endData.apply(_this25, _arguments);
            }

            var labels = _this25.createLabels(tile, texts);
            if (!labels) {
                _this25.freeTile(tile);
                return _this25["super"].endData.apply(_this25, _arguments);
            }

            _this25.discardLabels(tile, labels, texts);

            // No labels for this tile
            if (Object.keys(texts).length === 0) {
                _this25.freeTile(tile);
                WorkerBroker.postMessage("TextStyle", "freeTile", tile);
                // early exit
                return;
            }

            // second call to main thread, for rasterizing the set of texts
            return WorkerBroker.postMessage("TextStyle", "addTexts", tile, texts).then(function (_ref) {
                var texts = _ref.texts;
                var texture = _ref.texture;

                if (texts) {
                    _this25.texts[tile] = texts;

                    // Attach tile-specific label atlas to mesh as a texture uniform
                    tile_data.uniforms = { u_texture: texture };
                    tile_data.textures = [texture]; // assign texture ownership to tile - TODO: implement in VBOMesh

                    // Build queued features
                    tile_data.queue.forEach(function (q) {
                        return _this25["super"].addFeature.apply(_this25, q);
                    });
                    tile_data.queue = [];
                }

                _this25.freeTile(tile);
                return _this25["super"].endData.apply(_this25, _arguments);
            });
        });
    },

    // Override to queue features instead of processing immediately
    addFeature: function addFeature(feature, rule, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        // Collect text
        var text = undefined;
        var source = rule.text_source || "name";

        if (typeof source === "string") {
            text = feature.properties[source];
        } else if (typeof source === "function") {
            text = source(context);
        }

        if (text) {
            feature.text = text;

            if (!this.texts[tile.key]) {
                this.texts[tile.key] = {};
            }

            var style = this.constructFontStyle(rule, context);
            if (!style) {
                return;
            }

            var style_key = this.constructStyleKey(style);
            this.feature_style_key[tile.key] = this.feature_style_key[tile.key] || new Map();
            this.feature_style_key[tile.key].set(feature, style_key);

            if (!this.texts[tile.key][style_key]) {
                this.texts[tile.key][style_key] = {};
            }

            var priority = 0;
            if (this.label_style.priorities[feature.properties.kind]) {
                priority = this.label_style.priorities[feature.properties.kind];
            }

            this.max_priority = Math.max(priority, this.max_priority);

            if (!this.texts[tile.key][style_key][text]) {
                this.texts[tile.key][style_key][text] = {
                    text_style: style,
                    priority: priority,
                    ref: 0
                };
            }

            this.features = this.features || {};
            this.features[tile.key] = this.features[tile.key] || {};
            this.features[tile.key][style_key] = this.features[tile.key][style_key] || {};
            this.features[tile.key][style_key][text] = this.features[tile.key][style_key][text] || [];
            this.features[tile.key][style_key][text].push(feature);

            if (!this.tile_data[tile.key]) {
                this.startData(tile.key);
            }
            this.tile_data[tile.key].queue.push([feature, rule, context]);
        }
    },

    constructFontStyle: function constructFontStyle(rule, context) {
        var style = undefined;

        if (rule.font) {
            style = {};

            // Use fill if specified, or default
            style.fill = rule.font.fill && Utils.toCanvasColor(StyleParser.parseColor(rule.font.fill, context)) || this.font_style.fill;

            // Use stroke if specified
            if (rule.font.stroke && rule.font.stroke.color) {
                style.stroke = Utils.toCanvasColor(StyleParser.parseColor(rule.font.stroke.color));
                style.stroke_width = rule.font.stroke.width || this.font_style.stroke.width;
            }

            // Use default typeface
            style.font = rule.font.typeface || this.font_style.typeface;
            style.capitalized = rule.font.capitalized || this.font_style.capitalized;

            var size_regex = /([0-9]*\.)?[0-9]+(px|pt|em|%)/g;
            var ft_size = style.font.match(size_regex)[0];
            var size_kind = ft_size.replace(/([0-9]*\.)?[0-9]+/g, "");

            style.px_logical_size = Utils.toPixelSize(ft_size.replace(/([a-z]|%)/g, ""), size_kind);
            style.px_size = style.px_logical_size * Utils.device_pixel_ratio;
            style.stroke_width *= Utils.device_pixel_ratio;
            style.font = style.font.replace(size_regex, style.px_size + "px");
        }

        return style;
    },

    constructStyleKey: function constructStyleKey(_ref) {
        var font = _ref.font;
        var fill = _ref.fill;
        var stroke = _ref.stroke;
        var stroke_width = _ref.stroke_width;

        return "" + font + "/" + fill + "/" + stroke + "/" + stroke_width;
    },

    buildLabel: function buildLabel(label, size, vertex_data, vertex_template, texcoord_scale) {
        var angle = label.angle || 0;
        Builders.buildQuadsForPoints([label.position], Utils.scaleInt16(size[0], 256), Utils.scaleInt16(size[1], 256), Utils.scaleInt16(Utils.radToDeg(angle), 360), Utils.scaleInt16(1, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: texcoord_scale
        });
    },

    build: function build(style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);

        for (var i in style.labels) {
            var label = style.labels[i];

            if (label.isComposite()) {
                for (var j in label.labels) {
                    var l = label.labels[j];
                    var subtexcoord_scale = this.subtexcoord_scale[l.text];
                    var size = this.subtext_size[l.text];
                    this.buildLabel(l, size, vertex_data, vertex_template, subtexcoord_scale);
                }
            } else {
                this.buildLabel(label, label.size.texture_text_size, vertex_data, vertex_template, this.texcoord_scale);
            }
        }
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPolygons: function buildPolygons(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var text = feature.text;

        var style = this.feature_style;
        var tile = context.tile.key;
        var style_key = this.feature_style_key[tile].get(feature);
        var text_info = this.texts[tile] && this.texts[tile][style_key] && this.texts[tile][style_key][text];

        if (!text_info || !this.feature_labels[tile].has(feature)) {
            return;
        }

        this.texcoord_scale = text_info.texcoords;
        this.subtexcoord_scale = text_info.subtexcoords;
        this.subtext_size = text_info.subtext_size;
        style.text = text;
        style.labels = this.feature_labels[tile].get(feature);

        // TODO: point style (parent class) requires a color, setting it to white for now,
        // but could be made conditional in the vertex layout to save space
        style.color = [1, 1, 1, 1];

        // tell the point style (base class) that we want to render polygon labels at the polygon's centroid
        style.centroid = true;

        return style;
    }

});

TextStyle.texture_id = 0;

},{"../../gl/texture":73,"../../utils/utils":102,"../../utils/worker_broker":104,"../builders":85,"../points/points":87,"../style_parser":92,"./label_builder":94,"loglevel":53}],98:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Tile */

var Geo = _interopRequire(require("./geo"));

var StyleParser = require("./styles/style_parser").StyleParser;

var StyleManager = require("./styles/style_manager").StyleManager;

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var Texture = _interopRequire(require("./gl/texture"));

var log = _interopRequire(require("loglevel"));

var Tile = (function () {

    /**
        Tile
        @constructor
        Required properties:
        coords: object with {x, y, z} properties identifying tile coordinate location
        worker: web worker to handle tile construction
    */

    function Tile(_ref) {
        var coords = _ref.coords;
        var source = _ref.source;
        var worker = _ref.worker;
        var style_zoom = _ref.style_zoom;

        _classCallCheck(this, Tile);

        Object.assign(this, {
            coords: {
                x: null,
                y: null,
                z: null
            },
            debug: {},
            loading: false,
            loaded: false,
            error: null,
            worker: null,
            generation: null,
            visible: false,
            center_dist: 0
        });

        this.worker = worker;
        this.source = source;
        this.style_zoom = style_zoom; // zoom level to be used for styling

        this.coords = coords;
        this.coords = Tile.overZoomedCoordinate(this.coords, this.source.max_zoom);
        this.coord_key = Tile.coordKey(this.coords);
        this.key = Tile.key(this.coords, this.source, this.style_zoom);
        this.min = Geo.metersForTile(this.coords);
        this.max = Geo.metersForTile({ x: this.coords.x + 1, y: this.coords.y + 1, z: this.coords.z }), this.span = { x: this.max.x - this.min.x, y: this.max.y - this.min.y };
        this.bounds = { sw: { x: this.min.x, y: this.max.y }, ne: { x: this.max.x, y: this.min.y } };

        this.meshes = {}; // renderable VBO meshes keyed by style
        this.textures = []; // textures that the tile owns (labels, etc.)
    }

    _createClass(Tile, {
        freeResources: {
            value: function freeResources() {
                if (this.meshes) {
                    for (var m in this.meshes) {
                        this.meshes[m].destroy();
                    }
                }

                if (this.textures) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = this.textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var t = _step.value;

                            var texture = Texture.textures[t];
                            if (texture) {
                                texture.destroy();
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"]) {
                                _iterator["return"]();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }

                this.meshes = {};
                this.textures = [];
            }
        },
        destroy: {
            value: function destroy() {
                this.workerMessage("removeTile", this.key);
                this.freeResources();
                this.worker = null;
            }
        },
        buildAsMessage: {
            value: function buildAsMessage() {
                return {
                    key: this.key,
                    coord_key: this.coord_key,
                    source: this.source.name,
                    coords: this.coords,
                    min: this.min,
                    max: this.max,
                    style_zoom: this.style_zoom,
                    generation: this.generation,
                    debug: this.debug
                };
            }
        },
        workerMessage: {
            value: function workerMessage() {
                for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
                    message[_key] = arguments[_key];
                }

                return WorkerBroker.postMessage.apply(WorkerBroker, [this.worker].concat(message));
            }
        },
        build: {
            value: function build(generation) {
                this.generation = generation;
                if (!this.loaded) {
                    this.loading = true;
                }
                return this.workerMessage("buildTile", { tile: this.buildAsMessage() })["catch"](function (e) {
                    throw e;
                });
            }
        },
        buildMeshes: {

            /**
               Called on main thread when a web worker completes processing
               for a single tile.
            */

            value: function buildMeshes(styles) {
                if (this.error) {
                    return;
                }

                // Cleanup existing VBOs
                this.freeResources();

                // Debug
                this.debug.geometries = 0;
                this.debug.buffer_size = 0;

                // Create VBOs
                var mesh_data = this.mesh_data;
                if (mesh_data) {
                    for (var s in mesh_data) {
                        if (mesh_data[s].vertex_data) {
                            this.debug.buffer_size += mesh_data[s].vertex_data.byteLength;
                            if (!styles[s]) {
                                log.warn("Could not create mesh because style '" + s + "' not found, for tile " + this.key + ", aborting tile");
                                this.meshes = {};
                                break;
                            }
                            this.meshes[s] = styles[s].makeMesh(mesh_data[s].vertex_data, mesh_data[s]);
                            this.debug.geometries += this.meshes[s].geometry_count;
                        }

                        // Assign ownership to textures if needed
                        if (mesh_data[s].textures) {
                            var _textures;

                            (_textures = this.textures).push.apply(_textures, _toConsumableArray(mesh_data[s].textures));
                        }
                    }
                }

                this.debug.geom_ratio = (this.debug.geometries / this.debug.features).toFixed(1);
                this.mesh_data = null; // TODO: might want to preserve this for rebuilding geometries when styles/etc. change?
                this.printDebug();
            }
        },
        printDebug: {
            value: function printDebug() {
                log.debug("Tile: debug for " + this.key + ": [  " + JSON.stringify(this.debug) + " ]");
            }
        },
        update: {
            value: function update(scene) {
                var coords = this.coords;
                if (coords.z !== scene.center_tile.z) {
                    coords = Tile.coordinateAtZoom(coords, scene.center_tile.z);
                }
                this.center_dist = Math.abs(scene.center_tile.x - coords.x) + Math.abs(scene.center_tile.y - coords.y);
            }
        },
        merge: {
            value: function merge(other) {
                for (var key in other) {
                    if (key !== "key") {
                        this[key] = other[key];
                    }
                }
                return this;
            }
        }
    }, {
        create: {
            value: function create(spec) {
                return new Tile(spec);
            }
        },
        coordKey: {
            value: function coordKey(_ref) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                return [x, y, z].join("/");
            }
        },
        key: {
            value: function key(coords, source, style_zoom) {
                coords = Tile.overZoomedCoordinate(coords, source.max_zoom);
                return [source.name, style_zoom, coords.x, coords.y, coords.z].join("/");
            }
        },
        coordinateAtZoom: {
            value: function coordinateAtZoom(_ref, zoom) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                if (z !== zoom) {
                    var zscale = Math.pow(2, z - zoom);
                    x = Math.floor(x / zscale);
                    y = Math.floor(y / zscale);
                }
                return { x: x, y: y, z: zoom };
            }
        },
        isChild: {
            value: function isChild(parent, child) {
                if (child.z > parent.z) {
                    var _Tile$coordinateAtZoom = Tile.coordinateAtZoom(child, parent.z);

                    var x = _Tile$coordinateAtZoom.x;
                    var y = _Tile$coordinateAtZoom.y;

                    return parent.x === x && parent.y === y;
                }
                return false;
            }
        },
        overZoomedCoordinate: {
            value: function overZoomedCoordinate(_ref, max_zoom) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                if (z > max_zoom) {
                    return Tile.coordinateAtZoom({ x: x, y: y, z: z }, max_zoom);
                }
                return { x: x, y: y, z: z };
            }
        },
        sort: {

            // Sort a set of tile instances (which already have a distance from center tile computed)

            value: function sort(tiles) {
                return tiles.sort(function (a, b) {
                    var ad = a.center_dist;
                    var bd = b.center_dist;
                    return bd > ad ? -1 : bd === ad ? 0 : 1;
                });
            }
        },
        buildGeometry: {

            // Process geometry for tile - called by web worker
            // Returns a set of tile keys that should be sent to the main thread (so that we can minimize data exchange between worker and main thread)

            value: function buildGeometry(tile, layers, rules, styles) {
                tile.debug.rendering = +new Date();
                tile.debug.features = 0;

                var data = tile.source_data;

                // Treat top-level style rules as 'layers'
                for (var layer_name in layers) {
                    var layer = layers[layer_name];
                    // Skip layers with no data source defined
                    if (!layer.data) {
                        log.warn("Layer " + layer + " was defined without a geometry data source and will not be rendered.");
                        continue;
                    }

                    // Source names don't match
                    if (layer.data.source !== tile.source) {
                        continue;
                    }

                    var geom = Tile.getDataForSource(data, layer.data, layer_name);
                    if (!geom) {
                        continue;
                    }

                    // Render features in layer
                    var num_features = geom.features.length;
                    for (var f = num_features - 1; f >= 0; f--) {
                        var feature = geom.features[f];
                        var context = StyleParser.getFeatureParseContext(feature, tile);

                        // Get draw groups for this feature
                        var layer_rules = rules[layer_name];
                        var draw_groups = layer_rules.buildDrawGroups(context, true);
                        if (!draw_groups) {
                            continue;
                        }

                        // Render draw groups
                        for (var group_name in draw_groups) {
                            var group = draw_groups[group_name];
                            if (!group.visible) {
                                continue;
                            }

                            // Add to style
                            var style_name = group.style || group_name;
                            var style = styles[style_name];

                            if (!style) {
                                log.warn("Style '" + style_name + "' not found for rule in layer '" + layer_name + "':", group, feature);
                                continue;
                            }

                            context.properties = group.properties; // add rule-specific properties to context

                            style.addFeature(feature, group, context);

                            context.properties = null; // clear group-specific properties
                        }

                        tile.debug.features++;
                    }
                }
                tile.debug.rendering = +new Date() - tile.debug.rendering;

                // Finalize array buffer for each render style
                var tile_styles = StyleManager.stylesForTile(tile.key);
                tile.mesh_data = {};
                var queue = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = tile_styles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        (function () {
                            var style_name = _step.value;

                            var style = styles[style_name];
                            queue.push(style.endData(tile.key).then(function (style_data) {
                                if (style_data) {
                                    tile.mesh_data[style_name] = {
                                        vertex_data: style_data.vertex_data,
                                        uniforms: style_data.uniforms,
                                        textures: style_data.textures
                                    };
                                }
                            }));
                        })();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return Promise.all(queue).then(function () {
                    // Return keys to be transfered to main thread
                    return ["mesh_data"];
                });
            }
        },
        getDataForSource: {

            /**
                Retrieves geometry from a tile according to a data source definition
            */

            value: function getDataForSource(source_data, source_config) {
                var default_layer = arguments[2] === undefined ? null : arguments[2];

                var geom;

                if (source_config != null) {
                    // If no layer specified, and a default source layer exists
                    if (!source_config.layer && source_data.layers._default) {
                        geom = source_data.layers._default;
                    }
                    // If no layer specified, and a default requested layer exists
                    else if (!source_config.layer && default_layer) {
                        geom = source_data.layers[default_layer];
                    }
                    // If a layer is specified by name, use it
                    else if (typeof source_config.layer === "string") {
                        geom = source_data.layers[source_config.layer];
                    }
                    // Assemble a custom layer via a function, which is called with all source layers
                    else if (typeof source_config.layer === "function") {
                        geom = source_config.layer(source_data.layers);
                    }
                }

                return geom;
            }
        },
        abortBuild: {

            /**
                Called on main thread when web worker completes processing, but tile has since been discarded
                Frees resources that would have been transferred to the tile object.
                Static method because the tile object no longer exists (the tile data returned by the worker is passed instead).
            */

            value: function abortBuild(tile) {
                if (tile.mesh_data) {
                    for (var s in tile.mesh_data) {
                        var textures = tile.mesh_data[s].textures;
                        if (textures) {
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var t = _step.value;

                                    var texture = Texture.textures[t];
                                    if (texture) {
                                        log.trace("destroying texture " + t + " for tile " + tile.key);
                                        texture.destroy();
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        slice: {

            // Slice a subset of keys out of a tile
            // Includes a minimum set of pre-defined keys for load state, debug. etc.
            // We use this to send a subset of the tile back to the main thread, to minimize unnecessary data transfer
            // (e.g. very large items like feature geometry are not needed on the main thread)

            value: function slice(tile, keys) {
                var keep = ["key", "loading", "loaded", "generation", "error", "debug"];
                if (Array.isArray(keys)) {
                    keep.push.apply(keep, _toConsumableArray(keys));
                }

                // Build the tile subset
                var tile_subset = {};
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = keep[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var key = _step.value;

                        tile_subset[key] = tile[key];
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return tile_subset;
            }
        },
        cancel: {

            /**
                Called on worker to cancel loading
                Static method because the worker only has object representations of tile data, there is no
                tile instance created yet.
            */

            value: function cancel(tile) {
                if (tile && tile.source_data && tile.source_data.request) {
                    tile.source_data.request.abort();
                }
            }
        }
    });

    return Tile;
})();

module.exports = Tile;

},{"./geo":67,"./gl/texture":73,"./styles/style_manager":91,"./styles/style_parser":92,"./utils/worker_broker":104,"loglevel":53}],99:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var Tile = _interopRequire(require("./tile"));

var Utils = _interopRequire(require("./utils/utils"));

var log = _interopRequire(require("loglevel"));

var TileManager;

module.exports = TileManager = {

    init: function init(scene) {
        this.scene = scene;
        this.tiles = {};
        this.visible_coords = {};
        this.queued_coords = [];
        this.building_tiles = null;
    },

    destroy: function destroy() {
        this.forEachTile(function (tile) {
            return tile.destroy();
        });
        this.tiles = {};
        this.visible_coords = {};
        this.queued_coords = [];
        this.scene = null;
    },

    keepTile: function keepTile(tile) {
        this.tiles[tile.key] = tile;
    },

    hasTile: function hasTile(key) {
        return this.tiles[key] !== undefined;
    },

    forgetTile: function forgetTile(key) {
        delete this.tiles[key];
        this.tileBuildStop(key);
    },

    // Remove a single tile
    removeTile: function removeTile(key) {
        log.trace("tile unload for " + key);

        var tile = this.tiles[key];

        if (tile != null) {
            tile.destroy();
        }

        this.forgetTile(tile.key);
        this.scene.requestRedraw();
    },

    // Run a function on each tile
    forEachTile: function forEachTile(func) {
        for (var t in this.tiles) {
            func(this.tiles[t]);
        }
    },

    // Remove tiles that pass a filter condition
    removeTiles: function removeTiles(filter) {
        var remove_tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (filter(tile)) {
                remove_tiles.push(t);
            }
        }
        for (var r = 0; r < remove_tiles.length; r++) {
            var key = remove_tiles[r];
            this.removeTile(key);
        }
    },

    updateTilesForView: function updateTilesForView() {
        var _this = this;

        // Find visible tiles and load new ones
        this.visible_coords = {};
        var tile_coords = this.scene.findVisibleTileCoordinates();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = tile_coords[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var coords = _step.value;

                this.queueCoordinate(coords);
                this.visible_coords[Tile.coordKey(coords)] = coords;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        // Remove tiles too far outside of view
        this.scene.pruneTileCoordinatesForView(); // TODO: return list to prune?

        this.forEachTile(function (tile) {
            _this.updateVisibility(tile);
            tile.update(_this.scene);
        });
    },

    updateVisibility: function updateVisibility(tile) {
        if (tile.style_zoom !== this.scene.tile_zoom) {
            tile.visible = false;
            return;
        }

        if (this.visible_coords[tile.coord_key]) {
            tile.visible = true;
        } else {
            // brute force
            for (var key in this.visible_coords) {
                if (Tile.isChild(tile.coords, this.visible_coords[key])) {
                    tile.visible = true;
                    return;
                }
            }

            tile.visible = false;
        }
    },

    getRenderableTiles: function getRenderableTiles() {
        var tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (tile.visible && tile.loaded) {
                tiles.push(tile);
            }
        }
        return tiles;
    },

    // Queue a tile for load
    queueCoordinate: function queueCoordinate(coords) {
        this.queued_coords[this.queued_coords.length] = coords;
    },

    // Load all queued tiles
    loadQueuedCoordinates: function loadQueuedCoordinates() {
        var _this = this;

        if (this.queued_coords.length === 0) {
            return;
        }

        // Sort queued tiles from center tile
        this.queued_coords.sort(function (a, b) {
            var ad = Math.abs(_this.scene.center_tile.x - a.x) + Math.abs(_this.scene.center_tile.y - a.y);
            var bd = Math.abs(_this.scene.center_tile.x - b.x) + Math.abs(_this.scene.center_tile.y - b.y);
            return bd > ad ? -1 : bd === ad ? 0 : 1;
        });
        this.queued_coords.forEach(function (coords) {
            return _this.loadCoordinate(coords);
        });
        this.queued_coords = [];
    },

    // Load all tiles to cover a given logical tile coordinate
    loadCoordinate: function loadCoordinate(coords) {
        // Skip if not at current scene zoom
        if (coords.z !== this.scene.center_tile.z) {
            return;
        }

        // Determine necessary tiles for each source
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Utils.values(this.scene.sources)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var source = _step.value;

                var key = Tile.key(coords, source, this.scene.tile_zoom);
                if (!this.hasTile(key)) {
                    var tile = Tile.create({
                        source: source,
                        coords: coords,
                        // max_zoom: this.scene.findMaxZoom(), // TODO: replace with better max zoom handling
                        worker: this.scene.nextWorker(),
                        style_zoom: this.scene.styleZoom(coords.z) // TODO: replace?
                    });

                    this.keepTile(tile);
                    this.buildTile(tile);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    },

    // Sort and build a list of tiles
    buildTiles: function buildTiles(tiles) {
        var _this = this;

        Tile.sort(tiles).forEach(function (tile) {
            return _this.buildTile(tile);
        });
        this.checkBuildQueue();
    },

    buildTile: function buildTile(tile) {
        var _this = this;

        this.tileBuildStart(tile.key);
        this.updateVisibility(tile);
        tile.update(this.scene);
        tile.build(this.scene.generation).then(function (message) {
            return _this.buildTileCompleted(message);
        })["catch"](function () {
            _this.forgetTile(tile.key);
            Tile.abortBuild(tile);
        });
    },

    // Called on main thread when a web worker completes processing for a single tile (initial load, or rebuild)
    buildTileCompleted: function buildTileCompleted(_ref) {
        var tile = _ref.tile;

        // Removed this tile during load?
        if (this.tiles[tile.key] == null) {
            log.trace("discarded tile " + tile.key + " in TileManager.buildTileCompleted because previously removed");
            Tile.abortBuild(tile);
        }
        // Built with an outdated scene configuration?
        else if (tile.generation !== this.scene.generation) {
            log.debug("discarded tile " + tile.key + " in TileManager.buildTileCompleted because built with " + ("scene config gen " + tile.generation + ", current " + this.scene.generation));
            this.forgetTile(tile.key);
            Tile.abortBuild(tile);
        } else {
            // Update tile with properties from worker
            if (this.tiles[tile.key]) {
                tile = this.tiles[tile.key].merge(tile);
            }

            this.updateVisibility(tile);
            tile.update(this.scene);
            tile.buildMeshes(this.scene.styles);
            this.scene.requestRedraw();
        }

        this.tileBuildStop(tile.key);
    },

    // Track tile build state
    tileBuildStart: function tileBuildStart(key) {
        this.building_tiles = this.building_tiles || {};
        this.building_tiles[key] = true;
        log.trace("tileBuildStart for " + key + ": " + Object.keys(this.building_tiles).length);
    },

    tileBuildStop: function tileBuildStop(key) {
        // Done building?
        if (this.building_tiles) {
            log.trace("tileBuildStop for " + key + ": " + Object.keys(this.building_tiles).length);
            delete this.building_tiles[key];
            this.checkBuildQueue();
        }
    },

    // Check status of tile building queue and notify scene when we're done
    checkBuildQueue: function checkBuildQueue() {
        if (!this.building_tiles || Object.keys(this.building_tiles).length === 0) {
            this.building_tiles = null;
            this.scene.tileManagerBuildDone();
        }
    }

};

},{"./tile":98,"./utils/utils":102,"loglevel":53}],100:[function(require,module,exports){
"use strict";

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var MethodNotImplemented = exports.MethodNotImplemented = (function (_Error) {
    function MethodNotImplemented(methodName) {
        _classCallCheck(this, MethodNotImplemented);

        _get(Object.getPrototypeOf(MethodNotImplemented.prototype), "constructor", this).call(this);
        this.name = "MethodNotImplemented";
        this.message = "Method " + methodName + " must be implemented in subclass";
    }

    _inherits(MethodNotImplemented, _Error);

    return MethodNotImplemented;
})(Error);

},{}],101:[function(require,module,exports){
"use strict";

module.exports = subscribeMixin;

function subscribeMixin(target) {

    var listeners = new Set();
    // var listeners = [];

    return Object.assign(target, {

        subscribe: function subscribe(listener) {
            listeners.add(listener);
            // listeners.push(listener);
        },

        unsubscribe: function unsubscribe(listener) {
            listeners["delete"](listener);
            // var index = listeners.indexOf(listener);
            // if (index > -1) {
            //     listeners.splice(index, 1);
            // }
        },

        unsubscribeAll: function unsubscribeAll() {
            listeners.clear();
            // listeners = [];
        },

        trigger: function trigger(event) {
            for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                data[_key - 1] = arguments[_key];
            }

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var listener = _step.value;

                    if (typeof listener[event] === "function") {
                        listener[event].apply(listener, data);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

    });
}

},{}],102:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// Miscellaneous utilities
/*jshint worker: true*/

var log = _interopRequire(require("loglevel"));

var yaml = _interopRequire(require("js-yaml"));

var Geo = _interopRequire(require("../geo"));

var Utils;
module.exports = Utils = {};

// Add a base URL for schemeless or protocol-less URLs
// Defaults to adding current window protocol and base, or adds a custom base if specified
// Maybe use https://github.com/medialize/URI.js if more robust functionality is needed
Utils.addBaseURL = function (url, base) {
    if (!url) {
        return;
    }

    // Schemeless, add protocol
    if (url.substr(0, 2) === "//") {
        url = window.location.protocol + url;
    }
    // No http(s) or data, add base
    else if (url.search(/(http|https|data):\/\//) < 0) {
        var relative = url[0] !== "/";
        var base_info;
        if (base) {
            base_info = document.createElement("a"); // use a temporary element to parse URL
            base_info.href = base;
        } else {
            base_info = window.location;
        }
        if (!base_info.origin) {
            base_info.origin = base_info.protocol + "//" + base_info.hostname + (base_info.port ? ":" + base_info.port : "") + "/";
        }
        url = base_info.origin + (relative ? base_info.pathname : "") + url;
    }
    return url;
};

Utils.pathForURL = function (url) {
    return url.substr(0, url.lastIndexOf("/") + 1);
};

Utils.cacheBusterForUrl = function (url) {
    return url + "?" + +new Date();
};

Utils.io = function (url) {
    var timeout = arguments[1] === undefined ? 60000 : arguments[1];
    var responseType = arguments[2] === undefined ? "text" : arguments[2];
    var method = arguments[3] === undefined ? "GET" : arguments[3];
    var headers = arguments[4] === undefined ? {} : arguments[4];

    var request = new XMLHttpRequest();
    var promise = new Promise(function (resolve, reject) {
        request.open(method, url, true);
        request.timeout = timeout;
        request.responseType = responseType;
        request.onload = function () {
            if (request.status === 200) {
                if (["text", "json"].indexOf(request.responseType) > -1) {
                    resolve(request.responseText);
                } else {
                    resolve(request.response);
                }
            } else {
                reject(Error("Request error with a status of " + request.statusText));
            }
        };
        request.onerror = function (evt) {
            reject(Error("There was a network error" + evt.toString()));
        };
        request.ontimeout = function (evt) {
            reject(Error("timeout " + evt.toString()));
        };
        request.send();
    });

    Object.defineProperty(promise, "request", {
        value: request
    });

    return promise;
};

Utils.parseResource = function (body) {
    var data = null;
    try {
        eval("data = " + body); // jshint ignore:line
    } catch (e) {
        try {
            data = yaml.safeLoad(body);
        } catch (e) {
            log.error("Utils.parseResource: failed to parse", e);
            throw e;
        }
    }
    return data;
};

Utils.loadResource = function (source) {
    return new Promise(function (resolve, reject) {
        if (typeof source === "string") {
            Utils.io(Utils.cacheBusterForUrl(source)).then(function (body) {
                var data = Utils.parseResource(body);
                resolve(data);
            }, reject);
        } else {
            resolve(source);
        }
    });
};

// Needed for older browsers that still support WebGL (Safari 6 etc.)
Utils.requestAnimationFramePolyfill = function () {
    if (typeof window.requestAnimationFrame !== "function") {
        window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (cb) {
            setTimeout(cb, 1000 / 60);
        };
    }
};

// Stringify an object into JSON, but convert functions to strings
Utils.serializeWithFunctions = function (obj) {
    var serialized = JSON.stringify(obj, function (k, v) {
        // Convert functions to strings
        if (typeof v === "function") {
            return v.toString();
        }
        return v;
    });

    return serialized;
};

// Parse a JSON string, but convert function-like strings back into functions
Utils.deserializeWithFunctions = function (serialized, wrap) {
    var obj = JSON.parse(serialized);
    obj = Utils.stringsToFunctions(obj, wrap);
    return obj;
};

// Recursively parse an object, attempting to convert string properties that look like functions back into functions
Utils.stringsToFunctions = function (obj, wrap) {
    // Convert string
    if (typeof obj === "string") {
        obj = Utils.stringToFunction(obj, wrap);
    }
    // Loop through object properties
    else if (typeof obj === "object") {
        for (var p in obj) {
            obj[p] = Utils.stringsToFunctions(obj[p], wrap);
        }
    }
    return obj;
};

// Convert string back into a function
// TODO: make function matching tolerant of whitespace and multilines
Utils.stringToFunction = function (val, wrap) {
    // Convert strings back into functions
    if (val.match(/^\s*function\s*\w*\s*\([\s\S]*\)\s*\{[\s\S]*\}/m) != null) {
        var f;
        try {
            if (typeof wrap === "function") {
                eval("f = " + wrap(val)); // jshint ignore:line
            } else {
                eval("f = " + val); // jshint ignore:line
            }
            return f;
        } catch (e) {
            // fall-back to original value if parsing failed
            return val;
        }
    }
    return val;
};

// Log wrapper, sends message to main thread for display, and includes worker id #
Utils.log = function (level) {
    for (var _len = arguments.length, msg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msg[_key - 1] = arguments[_key];
    }

    level = level || "info";
    if (Utils.isWorkerThread) {
        self.postMessage({
            type: "log",
            level: level,
            worker_id: self._worker_id,
            msg: msg
        });
    } else if (typeof log[level] === "function") {
        log[level].apply(log, msg);
    }
};

// Default to allowing high pixel density
Utils.use_high_density_display = true;
Utils.updateDevicePixelRatio = function () {
    Utils.device_pixel_ratio = Utils.use_high_density_display && window.devicePixelRatio || 1;
};

// Mark thread as main or worker
(function () {
    try {
        if (window.document !== undefined) {
            Utils.isWorkerThread = false;
            Utils.isMainThread = true;
            Utils.updateDevicePixelRatio();
        }
    } catch (e) {
        if (self !== undefined) {
            Utils.isWorkerThread = true;
            Utils.isMainThread = false;
        }
    }
})();

// Get URL that the current script was loaded from
// If currentScript is not available, loops through <script> elements searching for a list of provided paths
// e.g. Utils.findCurrentURL('tangram.debug.js', 'tangram.min.js');
Utils.findCurrentURL = function () {
    for (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {
        paths[_key] = arguments[_key];
    }

    // Find currently executing script
    var script = document.currentScript;
    if (script) {
        return script.src;
    } else if (Array.isArray(paths)) {
        // Fallback on looping through <script> elements if document.currentScript is not supported
        var scripts = document.getElementsByTagName("script");
        for (var s = 0; s < scripts.length; s++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var path = _step.value;

                    if (scripts[s].src.indexOf(path) > -1) {
                        return scripts[s].src;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
};

// Used for differentiating between power-of-2 and non-power-of-2 textures
// Via: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
Utils.isPowerOf2 = function (value) {
    return (value & value - 1) === 0;
};

Utils.nextPowerOf2 = function (value) {
    return Math.pow(2, Math.ceil(Math.log2(value)));
};

// Interpolate 'x' along a series of control points
// 'points' is an array of control points in the form [x, y]
//
// Example:
//     Control points:
//         [0, 5]:  when x=0, y=5
//         [4, 10]: when x=4, y=10
//
//     Utils.interpolate(2, [[0, 5], [4, 10]]);
//     -> computes x=2, halfway between x=0 and x=4: (10 - 5) / 2 +5
//     -> returns 7.5
//
// TODO: add other interpolation methods besides linear
//
Utils.interpolate = function (x, points) {
    // If this doesn't resemble a list of control points, just return the original value
    if (!Array.isArray(points) || !Array.isArray(points[0])) {
        return points;
    } else if (points.length < 1) {
        return points;
    }

    var x1, x2, d, y;

    // Min bounds
    if (x <= points[0][0]) {
        y = points[0][1];
    }
    // Max bounds
    else if (x >= points[points.length - 1][0]) {
        y = points[points.length - 1][1];
    }
    // Find which control points x is between
    else {
        for (var i = 0; i < points.length - 1; i++) {
            if (x >= points[i][0] && x < points[i + 1][0]) {
                // Linear interpolation
                x1 = points[i][0];
                x2 = points[i + 1][0];

                // Multiple values
                if (Array.isArray(points[i][1])) {
                    y = [];
                    for (var c = 0; c < points[i][1].length; c++) {
                        d = points[i + 1][1][c] - points[i][1][c];
                        y[c] = d * (x - x1) / (x2 - x1) + points[i][1][c];
                    }
                }
                // Single value
                else {
                    d = points[i + 1][1] - points[i][1];
                    y = d * (x - x1) / (x2 - x1) + points[i][1];
                }
                break;
            }
        }
    }
    return y;
};

// Iterators (ES6 generators)

// Iterator for key/value pairs of an object
Utils.entries = regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 3;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step.value;
                context$1$0.next = 9;
                return [key, obj[key]];

            case 9:
                _iteratorNormalCompletion = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t0 = context$1$0["catch"](3);
                _didIteratorError = true;
                _iteratorError = context$1$0.t0;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Iterator for values of an object
Utils.values = regeneratorRuntime.mark(function callee$0$1(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$1$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 3;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step.value;
                context$1$0.next = 9;
                return obj[key];

            case 9:
                _iteratorNormalCompletion = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t1 = context$1$0["catch"](3);
                _didIteratorError = true;
                _iteratorError = context$1$0.t1;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$1, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Recursive iterators for all properties of an object, no matter how deeply nested
// TODO: fix for circular structures
Utils.recurseEntries = regeneratorRuntime.mark(function callee$0$2(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$2$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt("return");

            case 2:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 5;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 7:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return [key, obj[key], obj];

            case 12:
                if (!(typeof obj[key] === "object")) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseEntries(obj[key]), "t2", 14);

            case 14:
                _iteratorNormalCompletion = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t3 = context$1$0["catch"](5);
                _didIteratorError = true;
                _iteratorError = context$1$0.t3;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$2, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

Utils.recurseValues = regeneratorRuntime.mark(function callee$0$3(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$3$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt("return");

            case 2:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 5;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 7:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return obj[key];

            case 12:
                if (!(typeof obj[key] === "object")) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseValues(obj[key]), "t4", 14);

            case 14:
                _iteratorNormalCompletion = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t5 = context$1$0["catch"](5);
                _didIteratorError = true;
                _iteratorError = context$1$0.t5;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$3, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

Utils.scaleInt16 = function (val, max) {
    return val / max * 32768;
};

Utils.degToRad = function (degrees) {
    return degrees * Math.PI / 180;
};

Utils.radToDeg = function (radians) {
    return radians * 180 / Math.PI;
};

Utils.toCanvasColor = function (color) {
    return "rgb(" + Math.round(color[0] * 255) + "," + Math.round(color[1] * 255) + "," + Math.round(color[2] * 255) + ")";
};

Utils.centroid = function (polygon) {
    var n = polygon.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygon.length; p++) {
        centroid[0] += polygon[p][0];
        centroid[1] += polygon[p][1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Utils.multiCentroid = function (polygons) {
    var n = polygons.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        var c = Utils.centroid(polygon);
        centroid[0] += c[0];
        centroid[1] += c[1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Utils.polygonArea = function (polygon) {
    var area = 0;
    var n = polygon.length;

    for (var i = 0; i < n - 1; i++) {
        var p0 = polygon[i];
        var p1 = polygon[i + 1];

        area += p0[0] * p1[1] - p1[0] * p0[1];
    }

    area += polygon[n - 1][0] * polygon[0][1] - polygon[0][0] * polygon[n - 1][1];

    return Math.abs(area) / 2;
};

Utils.multiPolygonArea = function (polygons) {
    var area = 0;

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        area += Utils.polygonArea(polygon);
    }

    return area;
};

Utils.toPixelSize = function (size, kind) {
    if (kind === "px") {
        return size;
    } else if (kind === "em") {
        return 16 * size;
    } else if (kind === "pt") {
        return size / 0.75;
    } else if (kind === "%") {
        return size / 6.25;
    }
};

Utils.pointInTile = function (point) {
    return point[0] > 0 && point[1] > -Geo.tile_scale && point[0] < Geo.tile_scale && point[1] < 0;
};

Utils.pixelToMercator = function (size) {
    return size * Geo.units_per_pixel;
};

},{"../geo":67,"js-yaml":22,"loglevel":53}],103:[function(require,module,exports){
"use strict";

var version;
module.exports = version = {
    string: "v0.1.2",
    major: 0,
    minor: 1,
    patch: 2
};

},{}],104:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/*jshint worker: true*/

// WorkerBroker routes messages between web workers and the main thread, allowing for simpler
// async code via promises. Example usage:
//
// In web worker, define a method:
//
//     self.square = function (x) {
//         return x * x;
//     };
//
// In main thread, invoke that method and receive the result (if any) as a promise:
//
//     worker = new Worker(...);
//     WorkerBroker.addWorker(worker);
//
//     WorkerBroker.postMessage(worker, 'square', 5).then(function(y) {
//         console.log(y);
//     });
//
//     -> prints 25
//
// Async code:
//
// For synchronous code that must pass a return value to the main thread, the function can simply
// return an immediate value (see example above). For cases where the worker method needs to run
// asynchronous code, the function can return a promise, and the resolved or rejected value will
// be sent back to the main thread when the promise is fulfilled.
//
// Error handling:
//
// If the worker method either throws an error, or returns a promise that is rejected, it will be
// sent back to the main thread as a promise rejection. These two examples are equivalent:
//
//     In worker, throwing an error:
//
//         self.broken = function () {
//             throw new Error('error in worker!');
//         };
//
//     In worker, returning a rejected promise:
//
//         self.broken = function () {
//             return Promise.reject(new Error('error in worker!'));
//         };
//
//     In main thread, both errors are received as a promise rejection:
//
//         WorkerBroker.postMessage(worker, 'broken').then(
//             // Promise resolved
//             function() {
//                 console.log('success!');
//             },
//             // Promise rejected
//             function(error) {
//                 console.log('error!', error);
//             });
//
//         -> prints 'error! error in worker'
//
// TODO: add documentation for invoking main thread methods from a worker (basically same API, but in reverse)

var Utils = _interopRequire(require("./utils"));

var WorkerBroker;
module.exports = WorkerBroker = {};

// Global list of all worker messages
// Uniquely tracks every call made between main thread and a worker
var message_id = 0;
var messages = {};

// Main thread:
// - Send messages to workers, and optionally receive an async response as a promise
// - Receive messages from workers, and optionally send an async response back as a promise
function setupMainThread() {

    // Send a message to a worker, and optionally get an async response
    // Arguments:
    //   - worker: the web worker instance
    //   - method: the method with this name will be invoked in the worker
    //   - message: will be passed to the method call in the worker
    // Returns:
    //   - a promise that will be fulfilled if the worker method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (worker, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // Track state of this message
        var promise = new Promise(function (resolve, reject) {
            messages[message_id] = { method: method, message: message, resolve: resolve, reject: reject };
        });

        worker.postMessage({
            type: "main_send", // mark message as method invocation from main thread
            message_id: message_id, // unique id for this message, for life of program
            method: method, // will dispatch to a function of this name within the worker
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Add a worker to communicate with - each worker must be registered from the main thread
    var worker_id = 0;
    var workers = {};

    WorkerBroker.addWorker = function (worker) {

        // Keep track of all registered workers
        // TODO: adding a property directly to the worker, would be better to track non-instrusively,
        // maybe with an ES6 Map
        worker._worker_broker_id = worker_id++;
        workers[worker._worker_broker_id] = worker;

        // Listen for messages coming back from the worker, and fulfill that message's promise
        worker.addEventListener("message", function (event) {
            if (event.data.type !== "worker_reply") {
                return;
            }

            // Pass the result to the promise
            var id = event.data.message_id;
            if (messages[id]) {
                if (event.data.error) {
                    messages[id].reject(event.data.error);
                } else {
                    messages[id].resolve(event.data.message);
                }
                delete messages[id];
            }
        });

        // Listen for messages initiating a call from the worker, dispatch them,
        // and send any return value back to the worker
        worker.addEventListener("message", function (event) {
            // Unique id for this message & return call to main thread
            var id = event.data.message_id;
            if (event.data.type !== "worker_send" || id == null) {
                return;
            }

            // Call the requested method and save the return value
            var target = targets[event.data.target];
            if (!target) {
                throw Error("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because no object with that name is registered on main thread");
            }

            var method = typeof target[event.data.method] === "function" && target[event.data.method];
            if (!method) {
                throw Error("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because object has no method with that name");
            }

            var result, error;
            try {
                result = method.apply(target, event.data.message);
            } catch (e) {
                // Thrown errors will be passed back (in string form) to worker
                error = e;
            }

            // Send return value to worker
            // Async result
            if (result instanceof Promise) {
                result.then(function (value) {
                    worker.postMessage({
                        type: "main_reply",
                        message_id: id,
                        message: value
                    });
                }, function (error) {
                    worker.postMessage({
                        type: "main_reply",
                        message_id: id,
                        error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                    });
                });
            }
            // Immediate result
            else {
                worker.postMessage({
                    type: "main_reply",
                    message_id: id,
                    message: result,
                    error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                });
            }
        });
    };

    // Register an object to receive calls from the worker
    var targets = {};
    WorkerBroker.addTarget = function (name, target) {
        targets[name] = target;
    };

    // Expose for debugging
    WorkerBroker.getMessages = function () {
        return messages;
    };

    WorkerBroker.getMessageId = function () {
        return message_id;
    };
}

// Worker threads:
// - Receive messages from main thread, and optionally send an async response back as a promise
// - Send messages to main thread, and optionally receive an async response as a promise
function setupWorkerThread() {

    // Send a message to the main thread, and optionally get an async response as a promise
    // Arguments:
    //   - target: the name of the object in the main thread to be called
    //   - method: the method with this name will be invoked on the main thread target object
    //   - message: will be passed to the method call in the main thread
    // Returns:
    //   - a promise that will be fulfilled if the main thread method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (target, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // Track state of this message
        var promise = new Promise(function (resolve, reject) {
            messages[message_id] = { target: target, method: method, message: message, resolve: resolve, reject: reject };
        });

        self.postMessage({
            type: "worker_send", // mark message as method invocation from worker
            message_id: message_id, // unique id for this message, for life of program
            target: target, // name of the object to be called on main thread
            method: method, // will dispatch to a method of this name on the main thread
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Listen for messages coming back from the main thread, and fulfill that message's promise
    self.addEventListener("message", function (event) {
        if (event.data.type !== "main_reply") {
            return;
        }

        // Pass the result to the promise
        var id = event.data.message_id;
        if (messages[id]) {
            if (event.data.error) {
                messages[id].reject(event.data.error);
            } else {
                messages[id].resolve(event.data.message);
            }
            delete messages[id];
        }
    });

    // Receive messages from main thread, dispatch them, and send back a reply
    self.addEventListener("message", function (event) {
        // Unique id for this message & return call to main thread
        var id = event.data.message_id;
        if (event.data.type !== "main_send" || id == null) {
            return;
        }

        // Call the requested worker method and save the return value
        var method_name = event.data.method;
        var method = typeof self[method_name] === "function" && self[method_name];
        if (!method) {
            throw Error("Worker broker could not dispatch message type " + method_name + " because worker has no method with that name");
        }

        var result, error;
        try {
            result = method.apply(self, event.data.message);
        } catch (e) {
            // Thrown errors will be passed back (in string form) to main thread
            error = e;
        }

        // Send return value to main thread
        var transferables = undefined;
        // Async result
        if (result instanceof Promise) {
            result.then(function (value) {
                transferables = findTransferables(value);

                self.postMessage({
                    type: "worker_reply",
                    message_id: id,
                    message: value
                }, transferables);

                if (transferables.length > 0) {
                    Utils.log("trace", "'" + method_name + "' transferred " + transferables.length + " objects to main thread");
                }
            }, function (error) {
                self.postMessage({
                    type: "worker_reply",
                    message_id: id,
                    error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                });
            });
        }
        // Immediate result
        else {
            transferables = findTransferables(result);

            self.postMessage({
                type: "worker_reply",
                message_id: id,
                message: result,
                error: error instanceof Error ? "" + error.message + ": " + error.stack : error
            }, transferables);

            if (transferables.length > 0) {
                Utils.log("trace", "'" + method_name + "' transferred " + transferables.length + " objects to main thread");
            }
        }
    });
}

// Build a list of transferable objects from a source object
// TODO: add option in case you DON'T want to transfer objects
function findTransferables(source) {
    var list = arguments[1] === undefined ? [] : arguments[1];

    if (!source) {
        return list;
    }

    if (Array.isArray(source)) {
        // Check each array element
        source.forEach(function (x) {
            return findTransferables(x, list);
        });
    } else if (typeof source === "object") {
        // Is the object a transferable array buffer?
        if (source instanceof ArrayBuffer) {
            list.push(source);
        }
        // Or looks like a typed array (has an array buffer property)?
        else if (source.buffer instanceof ArrayBuffer) {
            list.push(source.buffer);
        }
        // Otherwise check each property
        else {
            for (var p in source) {
                findTransferables(source[p], list);
            }
        }
    }
    return list;
}

// Setup this thread as appropriate
if (Utils.isMainThread) {
    setupMainThread();
}

if (Utils.isWorkerThread) {
    setupWorkerThread();
}

},{"./utils":102}],105:[function(require,module,exports){
"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

/*** Vector functions - vectors provided as [x, y, z] arrays ***/

var Vector;
module.exports = Vector = {};

Vector.set = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i];
    }
    return V;
};

Vector.neg = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i] * -1;
    }
    return V;
};

// Addition of two vectors
Vector.add = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] + v2[i];
    }
    return v;
};

// Substraction of two vectors
Vector.sub = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);

    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] - v2[i];
    }
    return v;
};

Vector.signed_area = function (v1, v2, v3) {
    return (v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1]);
};

// Multiplication of two vectors
Vector.mult = function (v1, v2) {
    var v = [],
        len = v1.length,
        i;

    if (typeof v2 === "number") {
        // Mulitply by scalar
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2;
        }
    } else {
        // Multiply two vectors
        len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2[i];
        }
    }
    return v;
};

// Division of two vectors
Vector.div = function (v1, v2) {
    var v = [],
        i;
    if (typeof v2 === "number") {
        // Divide by scalar
        for (i = 0; i < v1.length; i++) {
            v[i] = v1[i] / v2;
        }
    } else {
        // Divide to vectors
        var len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] / v2[i];
        }
    }
    return v;
};

// Get 2D perpendicular
Vector.perp = function (v1, v2) {
    return [v2[1] - v1[1], v1[0] - v2[0]];
};

// Get 2D vector rotated
Vector.rot = function (v, a) {
    var vr = Vector.length(v);
    var va = Vector.angle(v);
    return [vr * Math.cos(va + a), vr * Math.sin(va + a)];
};

// Get 2D heading angle
Vector.angle = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return Math.atan2(y, x);
};

// Compare two points
Vector.isEqual = function (v1, v2) {
    var len = v1.length;
    for (var i = 0; i < len; i++) {
        if (v1[i] !== v2[i]) {
            return false;
        }
    }
    return true;
};

// Vector length squared
Vector.lengthSq = function (v) {
    if (v.length === 2) {
        return v[0] * v[0] + v[1] * v[1];
    } else {
        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    }
};

// Vector length
Vector.length = function (v) {
    return Math.sqrt(Vector.lengthSq(v));
};

// Normalize a vector
Vector.normalize = function (v) {
    var d;
    if (v.length === 2) {
        d = v[0] * v[0] + v[1] * v[1];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d];
        }
        return [0, 0];
    } else {
        d = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d, v[2] / d];
        }
        return [0, 0, 0];
    }
};

// Cross product of two vectors
Vector.cross = function (v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
};

// Dot product of two vectors
Vector.dot = function (v1, v2) {
    var n = 0;
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        n += v1[i] * v2[i];
    }
    return n;
};

// Find the intersection of two lines specified as segments from points (p1, p2) and (p3, p4)
// http://en.wikipedia.org/wiki/Line-line_intersection
// http://en.wikipedia.org/wiki/Cramer's_rule
Vector.lineIntersection = function (p1, p2, p3, p4, parallel_tolerance) {
    parallel_tolerance = parallel_tolerance || 0.01;

    // a1*x + b1*y = c1 for line (x1, y1) to (x2, y2)
    // a2*x + b2*y = c2 for line (x3, y3) to (x4, y4)
    var a1 = p1[1] - p2[1]; // y1 - y2
    var b1 = p1[0] - p2[0]; // x1 - x2
    var a2 = p3[1] - p4[1]; // y3 - y4
    var b2 = p3[0] - p4[0]; // x3 - x4
    var c1 = p1[0] * p2[1] - p1[1] * p2[0]; // x1*y2 - y1*x2
    var c2 = p3[0] * p4[1] - p3[1] * p4[0]; // x3*y4 - y3*x4
    var denom = b1 * a2 - a1 * b2;

    if (Math.abs(denom) > parallel_tolerance) {
        return [(c1 * b2 - b1 * c2) / denom, (c1 * a2 - a1 * c2) / denom];
    }
    return null; // return null if lines are (close to) parallel
};

},{}],106:[function(require,module,exports){
module.exports = require("./lib/babel/polyfill");

},{"./lib/babel/polyfill":1}]},{},[106,81])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLWJhYmVsL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9icnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvbWVkaWFuLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3BhcnRpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3N3ZWVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL25vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pcy1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Njb2xvcnBhcnNlci9jc3Njb2xvcnBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZGlzdC9nbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbWFyay5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYm9vbC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvZmxvYXQuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL3JlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvdW5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9udWxsLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9vbWFwLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9wYWlycy5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2VxLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3N0ci5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbm9kZV9tb2R1bGVzL2VzcHJpbWEvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJub2RlX21vZHVsZXMvbWF0Y2gtZmVhdHVyZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYmYvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3BiZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpcC1jb21tZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90b3BvanNvbi90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGVsYXllci5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9ub2RlX21vZHVsZXMvcG9pbnQtZ2VvbWV0cnkvaW5kZXguanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2NhbWVyYS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZGF0YV9zb3VyY2UuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dlby5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvY29uc3RhbnRzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9jb250ZXh0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9nbHNsLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9zaGFkZXJfcHJvZ3JhbS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvc2hhZGVyX3NvdXJjZXMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3RleHR1cmUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3Zhby5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdmJvX21lc2guanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3ZlcnRleF9kYXRhLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC92ZXJ0ZXhfbGF5b3V0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9sZWFmbGV0X2xheWVyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9saWdodC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbWF0ZXJpYWwuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL21vZHVsZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc2NlbmUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NjZW5lX3dvcmtlci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc2VsZWN0aW9uLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvYnVpbGRlcnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9saW5lcy9saW5lcy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3BvaW50cy9wb2ludHMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29ucy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3J1bGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9zdHlsZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3N0eWxlX21hbmFnZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9zdHlsZV9wYXJzZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L2xhYmVsLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvdGV4dC9sYWJlbF9idWlsZGVyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvdGV4dC9sYWJlbF9saW5lLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvdGV4dC9sYWJlbF9wb2ludC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3RleHQvdGV4dC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdGlsZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdGlsZV9tYW5hZ2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy9lcnJvcnMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3N1YnNjcmliZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdXRpbHMvdXRpbHMuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3ZlcnNpb24uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3dvcmtlcl9icm9rZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3ZlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9wb2x5ZmlsbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6N0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDemhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDck5BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1aENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGhCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QixRQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNyQyxRQUFJLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUNsQixtQkFBVyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0FBQ0QsZUFBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUMsWUFBWSxDQUFDOztBQUVsRCxRQUFJLENBQUMsTUFBTSxFQUFFO0FBQ1QsbUJBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUNyQjs7QUFFRCxRQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzVCLFFBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUMsRUFBRSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUM7Ozs7QUFJM0QsYUFBUyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDOzs7QUFHcEMsYUFBUyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDOzs7QUFHMUMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNuQyxnQkFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdEMsZ0JBQVEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7O0FBRWhFLFlBQUksWUFBWSxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxZQUFZLEdBQUcsQ0FBQyxDQUFBLEFBQUMsRUFBRTtBQUMzRCxnQkFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUEsQUFBQyxDQUFDO0FBQy9ELG9CQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxHQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2pEOztBQUVELGNBQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBQyxRQUFRLENBQUMsQ0FBQzs7QUFFckMsaUJBQVMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztLQUNqRDs7QUFFRCxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ25DLFlBQUksTUFBTSxFQUFFO0FBQ1Isb0JBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3pCLG9CQUFRLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3ZCLG9CQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUM1QixNQUFNO0FBQ0gsb0JBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3pCLG9CQUFRLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3ZCLG9CQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUM1QjtLQUNKOzs7QUFHRCxhQUFTLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUN4QixRQUFJLFNBQVMsQ0FBQyxXQUFXLEVBQUU7QUFDdkIsaUJBQVMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0tBQzlCO0FBQ0QsUUFBSSxTQUFTLENBQUMsU0FBUyxFQUFFO0FBQ3JCLGlCQUFTLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztLQUM1QjtDQUNKOzs7O0FBSUQsU0FBUyxPQUFPLENBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRTs7QUFFN0QsUUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pGLFFBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRXJFLFFBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7O0FBQ1QsTUFBRSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUNyQixNQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVkLFFBQUksRUFBRSxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUEsR0FBRSxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBQ3pFLEVBQUUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFBLEdBQUUsU0FBUyxDQUFDLEtBQUssR0FBRyxLQUFLLEdBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztRQUN6RSxFQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFOUUsUUFBSSxNQUFNLEVBQUU7QUFDUixpQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLGlCQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDM0MsTUFBTTtBQUNILFVBQUUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLFVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVixVQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixVQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRSxVQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRSxVQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRSxpQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLGlCQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDM0M7O0FBRUQsVUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFD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QUMxRCx1QkFBZSxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0Q7OztBQUdELFFBQUksYUFBYSxFQUFFO0FBQ2YsdUJBQWUsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNELHVCQUFlLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRCx1QkFBZSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7S0FDbEQ7OztBQUdELGVBQVcsQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7Q0FDMUM7OztBQUdELFNBQVMsVUFBVSxDQUFFLFNBQVMsRUFBRTs7QUFFNUIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdkMsZ0JBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMzQixnQkFBUSxDQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzNCLGdCQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7O0FBRTNCLGdCQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDM0IsZ0JBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMzQixnQkFBUSxDQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQzlCOztBQUVELGFBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FB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LFlBQVk7QUFDbEIsdUJBQVcsRUFBRSxDQUNULENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFDMUQsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUN4RCxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQzFELENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFDMUQsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUN0RCxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQ3hELENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJ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R0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMvQyxZQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQy9DLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDL0MsWUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQzs7O0FBR2hELFlBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDMUQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMxRCxZQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQzFELFlBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7OztBQUcxRCxZQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7OztBQUd2QyxZQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDaEIsZ0JBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLGdCQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNoQzs7QUFFRCxlQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7S0FDL0I7O0FB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QUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7O0FBR3ZDLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7QUFHNUIsWUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ3pDLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUN6QyxZQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDekMsWUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDOzs7QUFHMUMsWUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMxRCxZQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQzFELFlBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDMUQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQzs7O0FB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LENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1QixZQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1QixZQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHdkMsWUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDNUIsWUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDNUIsWUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7OztBQUc1QixZQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQy9DLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDL0MsWUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMvQyxZQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDOzs7QUFHL0MsWUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMxRCxZQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQzFELFlBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxH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QyxDQUFDO0tBQ3hCO0FBQ0QsV0FBTyxDQUFDLENBQUM7Q0FDWixDQUFDOzs7QUFHRixNQUFNLENBQUMsR0FBRyxHQUFHLFVBQVUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixRQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDWCxRQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV4QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFCLFNBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hCO0FBQ0QsV0FBTyxDQUFDLENBQUM7Q0FDWixDQUFDOztBQUVGLE1BQU0sQ0FBQyxXQUFXLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN2QyxXQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxJQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUEsQUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxJQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUEsQUFBQyxDQUFDO0NBQ3BFLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxJQUFJLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzVCLFFBQUksQ0FBQyxHQUFHLEVBQUU7UUFDTixHQUFHLEdBQUcsRUFBRSxDQUFDLE1BQU07UUFDZixDQUFDLENBQUM7O0FBRU4sUUFBSSxPQUFPLEVBQUUsS0FBSyxRQUFRLEVBQUU7O0FBRXhCLGFBQUssQ0FBQyxH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QUMsQ0FBQyxHQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEFBQUMsQ0FBQztBQUMzQyxRQUFJLEVBQUUsR0FBRyxBQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQUFBQyxDQUFDO0FBQzNDLFFBQUksS0FBSyxHQUFHLEFBQUMsRUFBRSxHQUFHLEVBQUUsR0FBSyxFQUFFLEdBQUcsRUFBRSxBQUFDLENBQUM7O0FBRWxDLFFBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxrQkFBa0IsRUFBRTtBQUN0QyxlQUFPLENBQ0gsQ0FBQyxBQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFJLEtBQUssRUFDL0IsQ0FBQyxBQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFJLEtBQUssQ0FDbEMsQ0FBQztLQUNMO0FBQ0QsV0FBTyxJQUFJLENBQUM7Q0FDZixDQUFDOzs7QUN6TUY7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC9wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLWJhYmVsL3J1bnRpbWVcIik7IiwiLyoqXG4gKiBDb3JlLmpzIDAuNi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qc1xuICogTGljZW5zZTogaHR0cDovL3JvY2subWl0LWxpY2Vuc2Uub3JnXG4gKiDCqSAyMDE1IERlbmlzIFB1c2hrYXJldlxuICovXG4hZnVuY3Rpb24oZ2xvYmFsLCBmcmFtZXdvcmssIHVuZGVmaW5lZCl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gU2hvcnRjdXRzIGZvciBbW0NsYXNzXV0gJiBwcm9wZXJ0eSBuYW1lc1xyXG52YXIgT0JKRUNUICAgICAgICAgID0gJ09iamVjdCdcclxuICAsIEZVTkNUSU9OICAgICAgICA9ICdGdW5jdGlvbidcclxuICAsIEFSUkFZICAgICAgICAgICA9ICdBcnJheSdcclxuICAsIFNUUklORyAgICAgICAgICA9ICdTdHJpbmcnXHJcbiAgLCBOVU1CRVIgICAgICAgICAgPSAnTnVtYmVyJ1xyXG4gICwgUkVHRVhQICAgICAgICAgID0gJ1JlZ0V4cCdcclxuICAsIERBVEUgICAgICAgICAgICA9ICdEYXRlJ1xyXG4gICwgTUFQICAgICAgICAgICAgID0gJ01hcCdcclxuICAsIFNFVCAgICAgICAgICAgICA9ICdTZXQnXHJcbiAgLCBXRUFLTUFQICAgICAgICAgPSAnV2Vha01hcCdcclxuICAsIFdFQUtTRVQgICAgICAgICA9ICdXZWFrU2V0J1xyXG4gICwgU1lNQk9MICAgICAgICAgID0gJ1N5bWJvbCdcclxuICAsIFBST01JU0UgICAgICAgICA9ICdQcm9taXNlJ1xyXG4gICwgTUFUSCAgICAgICAgICAgID0gJ01hdGgnXHJcbiAgLCBBUkdVTUVOVFMgICAgICAgPSAnQXJndW1lbnRzJ1xyXG4gICwgUFJPVE9UWVBFICAgICAgID0gJ3Byb3RvdHlwZSdcclxuICAsIENPTlNUUlVDVE9SICAgICA9ICdjb25zdHJ1Y3RvcidcclxuICAsIFRPX1NUUklORyAgICAgICA9ICd0b1N0cmluZydcclxuICAsIFRPX1NUUklOR19UQUcgICA9IFRPX1NUUklORyArICdUYWcnXHJcbiAgLCBUT19MT0NBTEUgICAgICAgPSAndG9Mb2NhbGVTdHJpbmcnXHJcbiAgLCBIQVNfT1dOICAgICAgICAgPSAnaGFzT3duUHJvcGVydHknXHJcbiAgLCBGT1JfRUFDSCAgICAgICAgPSAnZm9yRWFjaCdcclxuICAsIElURVJBVE9SICAgICAgICA9ICdpdGVyYXRvcidcclxuICAsIEZGX0lURVJBVE9SICAgICA9ICdAQCcgKyBJVEVSQVRPUlxyXG4gICwgUFJPQ0VTUyAgICAgICAgID0gJ3Byb2Nlc3MnXHJcbiAgLCBDUkVBVEVfRUxFTUVOVCAgPSAnY3JlYXRlRWxlbWVudCdcclxuICAvLyBBbGlhc2VzIGdsb2JhbCBvYmplY3RzIGFuZCBwcm90b3R5cGVzXHJcbiAgLCBGdW5jdGlvbiAgICAgICAgPSBnbG9iYWxbRlVOQ1RJT05dXHJcbiAgLCBPYmplY3QgICAgICAgICAgPSBnbG9iYWxbT0JKRUNUXVxyXG4gICwgQXJyYXkgICAgICAgICAgID0gZ2xvYmFsW0FSUkFZXVxyXG4gICwgU3RyaW5nICAgICAgICAgID0gZ2xvYmFsW1NUUklOR11cclxuICAsIE51bWJlciAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXHJcbiAgLCBSZWdFeHAgICAgICAgICAgPSBnbG9iYWxbUkVHRVhQXVxyXG4gICwgRGF0ZSAgICAgICAgICAgID0gZ2xvYmFsW0RBVEVdXHJcbiAgLCBNYXAgICAgICAgICAgICAgPSBnbG9iYWxbTUFQXVxyXG4gICwgU2V0ICAgICAgICAgICAgID0gZ2xvYmFsW1NFVF1cclxuICAsIFdlYWtNYXAgICAgICAgICA9IGdsb2JhbFtXRUFLTUFQXVxyXG4gICwgV2Vha1NldCAgICAgICAgID0gZ2xvYmFsW1dFQUtTRVRdXHJcbiAgLCBTeW1ib2wgICAgICAgICAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICwgTWF0aCAgICAgICAgICAgID0gZ2xvYmFsW01BVEhdXHJcbiAgLCBUeXBlRXJyb3IgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXHJcbiAgLCBSYW5nZUVycm9yICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxyXG4gICwgc2V0VGltZW91dCAgICAgID0gZ2xvYmFsLnNldFRpbWVvdXRcclxuICAsIHNldEltbWVkaWF0ZSAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcclxuICAsIGNsZWFySW1tZWRpYXRlICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxyXG4gICwgcGFyc2VJbnQgICAgICAgID0gZ2xvYmFsLnBhcnNlSW50XHJcbiAgLCBpc0Zpbml0ZSAgICAgICAgPSBnbG9iYWwuaXNGaW5pdGVcclxuICAsIHByb2Nlc3MgICAgICAgICA9IGdsb2JhbFtQUk9DRVNTXVxyXG4gICwgbmV4dFRpY2sgICAgICAgID0gcHJvY2VzcyAmJiBwcm9jZXNzLm5leHRUaWNrXHJcbiAgLCBkb2N1bWVudCAgICAgICAgPSBnbG9iYWwuZG9jdW1lbnRcclxuICAsIGh0bWwgICAgICAgICAgICA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICwgbmF2aWdhdG9yICAgICAgID0gZ2xvYmFsLm5hdmlnYXRvclxyXG4gICwgZGVmaW5lICAgICAgICAgID0gZ2xvYmFsLmRlZmluZVxyXG4gICwgY29uc29sZSAgICAgICAgID0gZ2xvYmFsLmNvbnNvbGUgfHwge31cclxuICAsIEFycmF5UHJvdG8gICAgICA9IEFycmF5W1BST1RPVFlQRV1cclxuICAsIE9iamVjdFByb3RvICAgICA9IE9iamVjdFtQUk9UT1RZUEVdXHJcbiAgLCBGdW5jdGlvblByb3RvICAgPSBGdW5jdGlvbltQUk9UT1RZUEVdXHJcbiAgLCBJbmZpbml0eSAgICAgICAgPSAxIC8gMFxyXG4gICwgRE9UICAgICAgICAgICAgID0gJy4nO1xyXG5cclxuLy8gaHR0cDovL2pzcGVyZi5jb20vY29yZS1qcy1pc29iamVjdFxyXG5mdW5jdGlvbiBpc09iamVjdChpdCl7XHJcbiAgcmV0dXJuIGl0ICE9PSBudWxsICYmICh0eXBlb2YgaXQgPT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ID09ICdmdW5jdGlvbicpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaXQpe1xyXG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJztcclxufVxyXG4vLyBOYXRpdmUgZnVuY3Rpb24/XHJcbnZhciBpc05hdGl2ZSA9IGN0eCgvLi8udGVzdCwgL1xcW25hdGl2ZSBjb2RlXFxdXFxzKlxcfVxccyokLywgMSk7XHJcblxyXG4vLyBPYmplY3QgaW50ZXJuYWwgW1tDbGFzc11dIG9yIHRvU3RyaW5nVGFnXHJcbi8vIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcclxudmFyIHRvU3RyaW5nID0gT2JqZWN0UHJvdG9bVE9fU1RSSU5HXTtcclxuZnVuY3Rpb24gc2V0VG9TdHJpbmdUYWcoaXQsIHRhZywgc3RhdCl7XHJcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0W1BST1RPVFlQRV0sIFNZTUJPTF9UQUcpKWhpZGRlbihpdCwgU1lNQk9MX1RBRywgdGFnKTtcclxufVxyXG5mdW5jdGlvbiBjb2YoaXQpe1xyXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XHJcbn1cclxuZnVuY3Rpb24gY2xhc3NvZihpdCl7XHJcbiAgdmFyIE8sIFQ7XHJcbiAgcmV0dXJuIGl0ID09IHVuZGVmaW5lZCA/IGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6ICdOdWxsJ1xyXG4gICAgOiB0eXBlb2YgKFQgPSAoTyA9IE9iamVjdChpdCkpW1NZTUJPTF9UQUddKSA9PSAnc3RyaW5nJyA/IFQgOiBjb2YoTyk7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uXHJcbnZhciBjYWxsICA9IEZ1bmN0aW9uUHJvdG8uY2FsbFxyXG4gICwgYXBwbHkgPSBGdW5jdGlvblByb3RvLmFwcGx5XHJcbiAgLCBSRUZFUkVOQ0VfR0VUO1xyXG4vLyBQYXJ0aWFsIGFwcGx5XHJcbmZ1bmN0aW9uIHBhcnQoLyogLi4uYXJncyAqLyl7XHJcbiAgdmFyIGZuICAgICA9IGFzc2VydEZ1bmN0aW9uKHRoaXMpXHJcbiAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICwgYXJncyAgID0gQXJyYXkobGVuZ3RoKVxyXG4gICAgLCBpICAgICAgPSAwXHJcbiAgICAsIF8gICAgICA9IHBhdGguX1xyXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcclxuICB3aGlsZShsZW5ndGggPiBpKWlmKChhcmdzW2ldID0gYXJndW1lbnRzW2krK10pID09PSBfKWhvbGRlciA9IHRydWU7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG4gICAgdmFyIHRoYXQgICAgPSB0aGlzXHJcbiAgICAgICwgX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgLCBpID0gMCwgaiA9IDAsIF9hcmdzO1xyXG4gICAgaWYoIWhvbGRlciAmJiAhX2xlbmd0aClyZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcclxuICAgIF9hcmdzID0gYXJncy5zbGljZSgpO1xyXG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gaTsgaSsrKWlmKF9hcmdzW2ldID09PSBfKV9hcmdzW2ldID0gYXJndW1lbnRzW2orK107XHJcbiAgICB3aGlsZShfbGVuZ3RoID4gailfYXJncy5wdXNoKGFyZ3VtZW50c1tqKytdKTtcclxuICAgIHJldHVybiBpbnZva2UoZm4sIF9hcmdzLCB0aGF0KTtcclxuICB9XHJcbn1cclxuLy8gT3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXHJcbmZ1bmN0aW9uIGN0eChmbiwgdGhhdCwgbGVuZ3RoKXtcclxuICBhc3NlcnRGdW5jdGlvbihmbik7XHJcbiAgaWYofmxlbmd0aCAmJiB0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xyXG4gIHN3aXRjaChsZW5ndGgpe1xyXG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xyXG4gICAgfVxyXG4gIH0gcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcclxuICB9XHJcbn1cclxuLy8gRmFzdCBhcHBseVxyXG4vLyBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcclxuZnVuY3Rpb24gaW52b2tlKGZuLCBhcmdzLCB0aGF0KXtcclxuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XHJcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoIHwgMCl7XHJcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcclxuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcclxuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICAgIGNhc2UgNTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcclxuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XHJcbn1cclxuXHJcbi8vIE9iamVjdDpcclxudmFyIGNyZWF0ZSAgICAgICAgICAgPSBPYmplY3QuY3JlYXRlXHJcbiAgLCBnZXRQcm90b3R5cGVPZiAgID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXHJcbiAgLCBzZXRQcm90b3R5cGVPZiAgID0gT2JqZWN0LnNldFByb3RvdHlwZU9mXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XHJcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcclxuICAsIGdldE93bkRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXHJcbiAgLCBnZXRLZXlzICAgICAgICAgID0gT2JqZWN0LmtleXNcclxuICAsIGdldE5hbWVzICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xyXG4gICwgZ2V0U3ltYm9scyAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcclxuICAsIGlzRnJvemVuICAgICAgICAgPSBPYmplY3QuaXNGcm96ZW5cclxuICAsIGhhcyAgICAgICAgICAgICAgPSBjdHgoY2FsbCwgT2JqZWN0UHJvdG9bSEFTX09XTl0sIDIpXHJcbiAgLy8gRHVtbXksIGZpeCBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZyBpbiBlczUgbW9kdWxlXHJcbiAgLCBFUzVPYmplY3QgICAgICAgID0gT2JqZWN0XHJcbiAgLCBEaWN0O1xyXG5mdW5jdGlvbiB0b09iamVjdChpdCl7XHJcbiAgcmV0dXJuIEVTNU9iamVjdChhc3NlcnREZWZpbmVkKGl0KSk7XHJcbn1cclxuZnVuY3Rpb24gcmV0dXJuSXQoaXQpe1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiByZXR1cm5UaGlzKCl7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0KG9iamVjdCwga2V5KXtcclxuICBpZihoYXMob2JqZWN0LCBrZXkpKXJldHVybiBvYmplY3Rba2V5XTtcclxufVxyXG5mdW5jdGlvbiBvd25LZXlzKGl0KXtcclxuICBhc3NlcnRPYmplY3QoaXQpO1xyXG4gIHJldHVybiBnZXRTeW1ib2xzID8gZ2V0TmFtZXMoaXQpLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBnZXROYW1lcyhpdCk7XHJcbn1cclxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxyXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSl7XHJcbiAgdmFyIFQgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZCh0YXJnZXQpKVxyXG4gICAgLCBsID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgLCBpID0gMTtcclxuICB3aGlsZShsID4gaSl7XHJcbiAgICB2YXIgUyAgICAgID0gRVM1T2JqZWN0KGFyZ3VtZW50c1tpKytdKVxyXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoUylcclxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgICAsIGogICAgICA9IDBcclxuICAgICAgLCBrZXk7XHJcbiAgICB3aGlsZShsZW5ndGggPiBqKVRba2V5ID0ga2V5c1tqKytdXSA9IFNba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIFQ7XHJcbn1cclxuZnVuY3Rpb24ga2V5T2Yob2JqZWN0LCBlbCl7XHJcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxyXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgLCBpbmRleCAgPSAwXHJcbiAgICAsIGtleTtcclxuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xyXG59XHJcblxyXG4vLyBBcnJheVxyXG4vLyBhcnJheSgnc3RyMSxzdHIyLHN0cjMnKSA9PiBbJ3N0cjEnLCAnc3RyMicsICdzdHIzJ11cclxuZnVuY3Rpb24gYXJyYXkoaXQpe1xyXG4gIHJldHVybiBTdHJpbmcoaXQpLnNwbGl0KCcsJyk7XHJcbn1cclxudmFyIHB1c2ggICAgPSBBcnJheVByb3RvLnB1c2hcclxuICAsIHVuc2hpZnQgPSBBcnJheVByb3RvLnVuc2hpZnRcclxuICAsIHNsaWNlICAgPSBBcnJheVByb3RvLnNsaWNlXHJcbiAgLCBzcGxpY2UgID0gQXJyYXlQcm90by5zcGxpY2VcclxuICAsIGluZGV4T2YgPSBBcnJheVByb3RvLmluZGV4T2ZcclxuICAsIGZvckVhY2ggPSBBcnJheVByb3RvW0ZPUl9FQUNIXTtcclxuLypcclxuICogMCAtPiBmb3JFYWNoXHJcbiAqIDEgLT4gbWFwXHJcbiAqIDIgLT4gZmlsdGVyXHJcbiAqIDMgLT4gc29tZVxyXG4gKiA0IC0+IGV2ZXJ5XHJcbiAqIDUgLT4gZmluZFxyXG4gKiA2IC0+IGZpbmRJbmRleFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlNZXRob2QodHlwZSl7XHJcbiAgdmFyIGlzTWFwICAgICAgID0gdHlwZSA9PSAxXHJcbiAgICAsIGlzRmlsdGVyICAgID0gdHlwZSA9PSAyXHJcbiAgICAsIGlzU29tZSAgICAgID0gdHlwZSA9PSAzXHJcbiAgICAsIGlzRXZlcnkgICAgID0gdHlwZSA9PSA0XHJcbiAgICAsIGlzRmluZEluZGV4ID0gdHlwZSA9PSA2XHJcbiAgICAsIG5vaG9sZXMgICAgID0gdHlwZSA9PSA1IHx8IGlzRmluZEluZGV4O1xyXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xyXG4gICAgdmFyIE8gICAgICA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAsIHRoYXQgICA9IGFyZ3VtZW50c1sxXVxyXG4gICAgICAsIHNlbGYgICA9IEVTNU9iamVjdChPKVxyXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxyXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxyXG4gICAgICAsIGluZGV4ICA9IDBcclxuICAgICAgLCByZXN1bHQgPSBpc01hcCA/IEFycmF5KGxlbmd0aCkgOiBpc0ZpbHRlciA/IFtdIDogdW5kZWZpbmVkXHJcbiAgICAgICwgdmFsLCByZXM7XHJcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKG5vaG9sZXMgfHwgaW5kZXggaW4gc2VsZil7XHJcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xyXG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xyXG4gICAgICBpZih0eXBlKXtcclxuICAgICAgICBpZihpc01hcClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgICAvLyBtYXBcclxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxyXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcclxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcclxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcclxuICAgICAgICB9IGVsc2UgaWYoaXNFdmVyeSlyZXR1cm4gZmFsc2U7ICAgICAgICAgICAvLyBldmVyeVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNGaW5kSW5kZXggPyAtMSA6IGlzU29tZSB8fCBpc0V2ZXJ5ID8gaXNFdmVyeSA6IHJlc3VsdDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlDb250YWlucyhpc0NvbnRhaW5zKXtcclxuICByZXR1cm4gZnVuY3Rpb24oZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xyXG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXHJcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXHJcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChhcmd1bWVudHNbMV0sIGxlbmd0aCk7XHJcbiAgICBpZihpc0NvbnRhaW5zICYmIGVsICE9IGVsKXtcclxuICAgICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihzYW1lTmFOKE9baW5kZXhdKSlyZXR1cm4gaXNDb250YWlucyB8fCBpbmRleDtcclxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKGlzQ29udGFpbnMgfHwgaW5kZXggaW4gTyl7XHJcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gaXNDb250YWlucyB8fCBpbmRleDtcclxuICAgIH0gcmV0dXJuICFpc0NvbnRhaW5zICYmIC0xO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBnZW5lcmljKEEsIEIpe1xyXG4gIC8vIHN0cmFuZ2UgSUUgcXVpcmtzIG1vZGUgYnVnIC0+IHVzZSB0eXBlb2YgdnMgaXNGdW5jdGlvblxyXG4gIHJldHVybiB0eXBlb2YgQSA9PSAnZnVuY3Rpb24nID8gQSA6IEI7XHJcbn1cclxuXHJcbi8vIE1hdGhcclxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmIC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcclxuICAsIHBvdyAgICA9IE1hdGgucG93XHJcbiAgLCBhYnMgICAgPSBNYXRoLmFic1xyXG4gICwgY2VpbCAgID0gTWF0aC5jZWlsXHJcbiAgLCBmbG9vciAgPSBNYXRoLmZsb29yXHJcbiAgLCBtYXggICAgPSBNYXRoLm1heFxyXG4gICwgbWluICAgID0gTWF0aC5taW5cclxuICAsIHJhbmRvbSA9IE1hdGgucmFuZG9tXHJcbiAgLCB0cnVuYyAgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgcmV0dXJuIChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcclxuICAgIH1cclxuLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcclxuZnVuY3Rpb24gc2FtZU5hTihudW1iZXIpe1xyXG4gIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xyXG59XHJcbi8vIDcuMS40IFRvSW50ZWdlclxyXG5mdW5jdGlvbiB0b0ludGVnZXIoaXQpe1xyXG4gIHJldHVybiBpc05hTihpdCkgPyAwIDogdHJ1bmMoaXQpO1xyXG59XHJcbi8vIDcuMS4xNSBUb0xlbmd0aFxyXG5mdW5jdGlvbiB0b0xlbmd0aChpdCl7XHJcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCBNQVhfU0FGRV9JTlRFR0VSKSA6IDA7XHJcbn1cclxuZnVuY3Rpb24gdG9JbmRleChpbmRleCwgbGVuZ3RoKXtcclxuICB2YXIgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xyXG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xyXG59XHJcbmZ1bmN0aW9uIGx6KG51bSl7XHJcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlcGxhY2VyKHJlZ0V4cCwgcmVwbGFjZSwgaXNTdGF0aWMpe1xyXG4gIHZhciByZXBsYWNlciA9IGlzT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XHJcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcclxuICB9IDogcmVwbGFjZTtcclxuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuIFN0cmluZyhpc1N0YXRpYyA/IGl0IDogdGhpcykucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUG9pbnRBdCh0b1N0cmluZyl7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHBvcyl7XHJcbiAgICB2YXIgcyA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxyXG4gICAgICAsIGwgPSBzLmxlbmd0aFxyXG4gICAgICAsIGEsIGI7XHJcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIHRvU3RyaW5nID8gJycgOiB1bmRlZmluZWQ7XHJcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcclxuICAgICAgPyB0b1N0cmluZyA/IHMuY2hhckF0KGkpIDogYVxyXG4gICAgICA6IHRvU3RyaW5nID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQXNzZXJ0aW9uICYgZXJyb3JzXHJcbnZhciBSRURVQ0VfRVJST1IgPSAnUmVkdWNlIG9mIGVtcHR5IG9iamVjdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xyXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cxLCBtc2cyKXtcclxuICBpZighY29uZGl0aW9uKXRocm93IFR5cGVFcnJvcihtc2cyID8gbXNnMSArIG1zZzIgOiBtc2cxKTtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnREZWZpbmVkKGl0KXtcclxuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24oaXQpe1xyXG4gIGFzc2VydChpc0Z1bmN0aW9uKGl0KSwgaXQsICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XHJcbiAgcmV0dXJuIGl0O1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydE9iamVjdChpdCl7XHJcbiAgYXNzZXJ0KGlzT2JqZWN0KGl0KSwgaXQsICcgaXMgbm90IGFuIG9iamVjdCEnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2UoaXQsIENvbnN0cnVjdG9yLCBuYW1lKXtcclxuICBhc3NlcnQoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgbmFtZSwgXCI6IHVzZSB0aGUgJ25ldycgb3BlcmF0b3IhXCIpO1xyXG59XHJcblxyXG4vLyBQcm9wZXJ0eSBkZXNjcmlwdG9ycyAmIFN5bWJvbFxyXG5mdW5jdGlvbiBkZXNjcmlwdG9yKGJpdG1hcCwgdmFsdWUpe1xyXG4gIHJldHVybiB7XHJcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXHJcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXHJcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXHJcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNpbXBsZVNldChvYmplY3QsIGtleSwgdmFsdWUpe1xyXG4gIG9iamVjdFtrZXldID0gdmFsdWU7XHJcbiAgcmV0dXJuIG9iamVjdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVEZWZpbmVyKGJpdG1hcCl7XHJcbiAgcmV0dXJuIERFU0MgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xyXG4gICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCBkZXNjcmlwdG9yKGJpdG1hcCwgdmFsdWUpKTtcclxuICB9IDogc2ltcGxlU2V0O1xyXG59XHJcbmZ1bmN0aW9uIHVpZChrZXkpe1xyXG4gIHJldHVybiBTWU1CT0wgKyAnKCcgKyBrZXkgKyAnKV8nICsgKCsrc2lkICsgcmFuZG9tKCkpW1RPX1NUUklOR10oMzYpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFdlbGxLbm93blN5bWJvbChuYW1lLCBzZXR0ZXIpe1xyXG4gIHJldHVybiAoU3ltYm9sICYmIFN5bWJvbFtuYW1lXSkgfHwgKHNldHRlciA/IFN5bWJvbCA6IHNhZmVTeW1ib2wpKFNZTUJPTCArIERPVCArIG5hbWUpO1xyXG59XHJcbi8vIFRoZSBlbmdpbmUgd29ya3MgZmluZSB3aXRoIGRlc2NyaXB0b3JzPyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5LlxyXG52YXIgREVTQyA9ICEhZnVuY3Rpb24oKXtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDIgfX0pLmEgPT0gMjtcclxuICAgICAgfSBjYXRjaChlKXt9XHJcbiAgICB9KClcclxuICAsIHNpZCAgICA9IDBcclxuICAsIGhpZGRlbiA9IGNyZWF0ZURlZmluZXIoMSlcclxuICAsIHNldCAgICA9IFN5bWJvbCA/IHNpbXBsZVNldCA6IGhpZGRlblxyXG4gICwgc2FmZVN5bWJvbCA9IFN5bWJvbCB8fCB1aWQ7XHJcbmZ1bmN0aW9uIGFzc2lnbkhpZGRlbih0YXJnZXQsIHNyYyl7XHJcbiAgZm9yKHZhciBrZXkgaW4gc3JjKWhpZGRlbih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbnZhciBTWU1CT0xfVU5TQ09QQUJMRVMgPSBnZXRXZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJylcclxuICAsIEFycmF5VW5zY29wYWJsZXMgICA9IEFycmF5UHJvdG9bU1lNQk9MX1VOU0NPUEFCTEVTXSB8fCB7fVxyXG4gICwgU1lNQk9MX1RBRyAgICAgICAgID0gZ2V0V2VsbEtub3duU3ltYm9sKFRPX1NUUklOR19UQUcpXHJcbiAgLCBTWU1CT0xfU1BFQ0lFUyAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKVxyXG4gICwgU1lNQk9MX0lURVJBVE9SO1xyXG5mdW5jdGlvbiBzZXRTcGVjaWVzKEMpe1xyXG4gIGlmKERFU0MgJiYgKGZyYW1ld29yayB8fCAhaXNOYXRpdmUoQykpKWRlZmluZVByb3BlcnR5KEMsIFNZTUJPTF9TUEVDSUVTLCB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IHJldHVyblRoaXNcclxuICB9KTtcclxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBjb21tb24uZXhwb3J0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgTk9ERSA9IGNvZihwcm9jZXNzKSA9PSBQUk9DRVNTXHJcbiAgLCBjb3JlID0ge31cclxuICAsIHBhdGggPSBmcmFtZXdvcmsgPyBnbG9iYWwgOiBjb3JlXHJcbiAgLCBvbGQgID0gZ2xvYmFsLmNvcmVcclxuICAsIGV4cG9ydEdsb2JhbFxyXG4gIC8vIHR5cGUgYml0bWFwXHJcbiAgLCBGT1JDRUQgPSAxXHJcbiAgLCBHTE9CQUwgPSAyXHJcbiAgLCBTVEFUSUMgPSA0XHJcbiAgLCBQUk9UTyAgPSA4XHJcbiAgLCBCSU5EICAgPSAxNlxyXG4gICwgV1JBUCAgID0gMzI7XHJcbmZ1bmN0aW9uICRkZWZpbmUodHlwZSwgbmFtZSwgc291cmNlKXtcclxuICB2YXIga2V5LCBvd24sIG91dCwgZXhwXHJcbiAgICAsIGlzR2xvYmFsID0gdHlwZSAmIEdMT0JBTFxyXG4gICAgLCB0YXJnZXQgICA9IGlzR2xvYmFsID8gZ2xvYmFsIDogKHR5cGUgJiBTVEFUSUMpXHJcbiAgICAgICAgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IE9iamVjdFByb3RvKVtQUk9UT1RZUEVdXHJcbiAgICAsIGV4cG9ydHMgID0gaXNHbG9iYWwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcclxuICBpZihpc0dsb2JhbClzb3VyY2UgPSBuYW1lO1xyXG4gIGZvcihrZXkgaW4gc291cmNlKXtcclxuICAgIC8vIHRoZXJlIGlzIGEgc2ltaWxhciBuYXRpdmVcclxuICAgIG93biA9ICEodHlwZSAmIEZPUkNFRCkgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXRcclxuICAgICAgJiYgKCFpc0Z1bmN0aW9uKHRhcmdldFtrZXldKSB8fCBpc05hdGl2ZSh0YXJnZXRba2V5XSkpO1xyXG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcclxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XHJcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcclxuICAgIGlmKCFmcmFtZXdvcmsgJiYgaXNHbG9iYWwgJiYgIWlzRnVuY3Rpb24odGFyZ2V0W2tleV0pKWV4cCA9IHNvdXJjZVtrZXldO1xyXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcclxuICAgIGVsc2UgaWYodHlwZSAmIEJJTkQgJiYgb3duKWV4cCA9IGN0eChvdXQsIGdsb2JhbCk7XHJcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxyXG4gICAgZWxzZSBpZih0eXBlICYgV1JBUCAmJiAhZnJhbWV3b3JrICYmIHRhcmdldFtrZXldID09IG91dCl7XHJcbiAgICAgIGV4cCA9IGZ1bmN0aW9uKHBhcmFtKXtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG91dCA/IG5ldyBvdXQocGFyYW0pIDogb3V0KHBhcmFtKTtcclxuICAgICAgfVxyXG4gICAgICBleHBbUFJPVE9UWVBFXSA9IG91dFtQUk9UT1RZUEVdO1xyXG4gICAgfSBlbHNlIGV4cCA9IHR5cGUgJiBQUk9UTyAmJiBpc0Z1bmN0aW9uKG91dCkgPyBjdHgoY2FsbCwgb3V0KSA6IG91dDtcclxuICAgIC8vIGV4dGVuZCBnbG9iYWxcclxuICAgIGlmKGZyYW1ld29yayAmJiB0YXJnZXQgJiYgIW93bil7XHJcbiAgICAgIGlmKGlzR2xvYmFsKXRhcmdldFtrZXldID0gb3V0O1xyXG4gICAgICBlbHNlIGRlbGV0ZSB0YXJnZXRba2V5XSAmJiBoaWRkZW4odGFyZ2V0LCBrZXksIG91dCk7XHJcbiAgICB9XHJcbiAgICAvLyBleHBvcnRcclxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZGVuKGV4cG9ydHMsIGtleSwgZXhwKTtcclxuICB9XHJcbn1cclxuLy8gQ29tbW9uSlMgZXhwb3J0XHJcbmlmKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpbW9kdWxlLmV4cG9ydHMgPSBjb3JlO1xyXG4vLyBSZXF1aXJlSlMgZXhwb3J0XHJcbmVsc2UgaWYoaXNGdW5jdGlvbihkZWZpbmUpICYmIGRlZmluZS5hbWQpZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGNvcmV9KTtcclxuLy8gRXhwb3J0IHRvIGdsb2JhbCBvYmplY3RcclxuZWxzZSBleHBvcnRHbG9iYWwgPSB0cnVlO1xyXG5pZihleHBvcnRHbG9iYWwgfHwgZnJhbWV3b3JrKXtcclxuICBjb3JlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpe1xyXG4gICAgZ2xvYmFsLmNvcmUgPSBvbGQ7XHJcbiAgICByZXR1cm4gY29yZTtcclxuICB9XHJcbiAgZ2xvYmFsLmNvcmUgPSBjb3JlO1xyXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbi5pdGVyYXRvcnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblNZTUJPTF9JVEVSQVRPUiA9IGdldFdlbGxLbm93blN5bWJvbChJVEVSQVRPUik7XHJcbnZhciBJVEVSICA9IHNhZmVTeW1ib2woJ2l0ZXInKVxyXG4gICwgS0VZICAgPSAxXHJcbiAgLCBWQUxVRSA9IDJcclxuICAsIEl0ZXJhdG9ycyA9IHt9XHJcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9XHJcbiAgICAvLyBTYWZhcmkgaGFzIGJ5Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXHJcbiAgLCBCVUdHWV9JVEVSQVRPUlMgPSAna2V5cycgaW4gQXJyYXlQcm90byAmJiAhKCduZXh0JyBpbiBbXS5rZXlzKCkpO1xyXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxyXG5zZXRJdGVyYXRvcihJdGVyYXRvclByb3RvdHlwZSwgcmV0dXJuVGhpcyk7XHJcbmZ1bmN0aW9uIHNldEl0ZXJhdG9yKE8sIHZhbHVlKXtcclxuICBoaWRkZW4oTywgU1lNQk9MX0lURVJBVE9SLCB2YWx1ZSk7XHJcbiAgLy8gQWRkIGl0ZXJhdG9yIGZvciBGRiBpdGVyYXRvciBwcm90b2NvbFxyXG4gIEZGX0lURVJBVE9SIGluIEFycmF5UHJvdG8gJiYgaGlkZGVuKE8sIEZGX0lURVJBVE9SLCB2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIHByb3RvKXtcclxuICBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gY3JlYXRlKHByb3RvIHx8IEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xyXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBOQU1FLCB2YWx1ZSwgREVGQVVMVCl7XHJcbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3JbUFJPVE9UWVBFXVxyXG4gICAgLCBpdGVyICA9IGdldChwcm90bywgU1lNQk9MX0lURVJBVE9SKSB8fCBnZXQocHJvdG8sIEZGX0lURVJBVE9SKSB8fCAoREVGQVVMVCAmJiBnZXQocHJvdG8sIERFRkFVTFQpKSB8fCB2YWx1ZTtcclxuICBpZihmcmFtZXdvcmspe1xyXG4gICAgLy8gRGVmaW5lIGl0ZXJhdG9yXHJcbiAgICBzZXRJdGVyYXRvcihwcm90bywgaXRlcik7XHJcbiAgICBpZihpdGVyICE9PSB2YWx1ZSl7XHJcbiAgICAgIHZhciBpdGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihpdGVyLmNhbGwobmV3IENvbnN0cnVjdG9yKSk7XHJcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcclxuICAgICAgc2V0VG9TdHJpbmdUYWcoaXRlclByb3RvLCBOQU1FICsgJyBJdGVyYXRvcicsIHRydWUpO1xyXG4gICAgICAvLyBGRiBmaXhcclxuICAgICAgaGFzKHByb3RvLCBGRl9JVEVSQVRPUikgJiYgc2V0SXRlcmF0b3IoaXRlclByb3RvLCByZXR1cm5UaGlzKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxyXG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGl0ZXI7XHJcbiAgLy8gRkYgJiB2OCBmaXhcclxuICBJdGVyYXRvcnNbTkFNRSArICcgSXRlcmF0b3InXSA9IHJldHVyblRoaXM7XHJcbiAgcmV0dXJuIGl0ZXI7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lU3RkSXRlcmF0b3JzKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQpe1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXIoa2luZCl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcclxuICAgIH1cclxuICB9XHJcbiAgY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xyXG4gIHZhciBlbnRyaWVzID0gY3JlYXRlSXRlcihLRVkrVkFMVUUpXHJcbiAgICAsIHZhbHVlcyAgPSBjcmVhdGVJdGVyKFZBTFVFKTtcclxuICBpZihERUZBVUxUID09IFZBTFVFKXZhbHVlcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIHZhbHVlcywgJ3ZhbHVlcycpO1xyXG4gIGVsc2UgZW50cmllcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIGVudHJpZXMsICdlbnRyaWVzJyk7XHJcbiAgaWYoREVGQVVMVCl7XHJcbiAgICAkZGVmaW5lKFBST1RPICsgRk9SQ0VEICogQlVHR1lfSVRFUkFUT1JTLCBOQU1FLCB7XHJcbiAgICAgIGVudHJpZXM6IGVudHJpZXMsXHJcbiAgICAgIGtleXM6IElTX1NFVCA/IHZhbHVlcyA6IGNyZWF0ZUl0ZXIoS0VZKSxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXNcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpdGVyUmVzdWx0KGRvbmUsIHZhbHVlKXtcclxuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcclxufVxyXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKGl0KXtcclxuICB2YXIgTyAgICAgID0gT2JqZWN0KGl0KVxyXG4gICAgLCBTeW1ib2wgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBoYXNFeHQgPSAoU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1IpIGluIE87XHJcbiAgcmV0dXJuIGhhc0V4dCB8fCBTWU1CT0xfSVRFUkFUT1IgaW4gTyB8fCBoYXMoSXRlcmF0b3JzLCBjbGFzc29mKE8pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdCl7XHJcbiAgdmFyIFN5bWJvbCAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBleHQgICAgID0gaXRbU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1JdXHJcbiAgICAsIGdldEl0ZXIgPSBleHQgfHwgaXRbU1lNQk9MX0lURVJBVE9SXSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xyXG4gIHJldHVybiBhc3NlcnRPYmplY3QoZ2V0SXRlci5jYWxsKGl0KSk7XHJcbn1cclxuZnVuY3Rpb24gc3RlcENhbGwoZm4sIHZhbHVlLCBlbnRyaWVzKXtcclxuICByZXR1cm4gZW50cmllcyA/IGludm9rZShmbiwgdmFsdWUpIDogZm4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrRGFuZ2VySXRlckNsb3NpbmcoZm4pe1xyXG4gIHZhciBkYW5nZXIgPSB0cnVlO1xyXG4gIHZhciBPID0ge1xyXG4gICAgbmV4dDogZnVuY3Rpb24oKXsgdGhyb3cgMSB9LFxyXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uKCl7IGRhbmdlciA9IGZhbHNlIH1cclxuICB9O1xyXG4gIE9bU1lNQk9MX0lURVJBVE9SXSA9IHJldHVyblRoaXM7XHJcbiAgdHJ5IHtcclxuICAgIGZuKE8pO1xyXG4gIH0gY2F0Y2goZSl7fVxyXG4gIHJldHVybiBkYW5nZXI7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VJdGVyYXRvcihpdGVyYXRvcil7XHJcbiAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcclxuICBpZihyZXQgIT09IHVuZGVmaW5lZClyZXQuY2FsbChpdGVyYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUl0ZXJDbG9zZShleGVjLCBpdGVyYXRvcil7XHJcbiAgdHJ5IHtcclxuICAgIGV4ZWMoaXRlcmF0b3IpO1xyXG4gIH0gY2F0Y2goZSl7XHJcbiAgICBjbG9zZUl0ZXJhdG9yKGl0ZXJhdG9yKTtcclxuICAgIHRocm93IGU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGZvck9mKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XHJcbiAgc2FmZUl0ZXJDbG9zZShmdW5jdGlvbihpdGVyYXRvcil7XHJcbiAgICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxyXG4gICAgICAsIHN0ZXA7XHJcbiAgICB3aGlsZSghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpaWYoc3RlcENhbGwoZiwgc3RlcC52YWx1ZSwgZW50cmllcykgPT09IGZhbHNlKXtcclxuICAgICAgcmV0dXJuIGNsb3NlSXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgfVxyXG4gIH0sIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSk7XHJcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnN5bWJvbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxyXG4hZnVuY3Rpb24oVEFHLCBTeW1ib2xSZWdpc3RyeSwgQWxsU3ltYm9scywgc2V0dGVyKXtcclxuICAvLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcclxuICBpZighaXNOYXRpdmUoU3ltYm9sKSl7XHJcbiAgICBTeW1ib2wgPSBmdW5jdGlvbihkZXNjcmlwdGlvbil7XHJcbiAgICAgIGFzc2VydCghKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpLCBTWU1CT0wgKyAnIGlzIG5vdCBhICcgKyBDT05TVFJVQ1RPUik7XHJcbiAgICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pXHJcbiAgICAgICAgLCBzeW0gPSBzZXQoY3JlYXRlKFN5bWJvbFtQUk9UT1RZUEVdKSwgVEFHLCB0YWcpO1xyXG4gICAgICBBbGxTeW1ib2xzW3RhZ10gPSBzeW07XHJcbiAgICAgIERFU0MgJiYgc2V0dGVyICYmIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCB0YWcsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICBoaWRkZW4odGhpcywgdGFnLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHN5bTtcclxuICAgIH1cclxuICAgIGhpZGRlbihTeW1ib2xbUFJPVE9UWVBFXSwgVE9fU1RSSU5HLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gdGhpc1tUQUddO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gICRkZWZpbmUoR0xPQkFMICsgV1JBUCwge1N5bWJvbDogU3ltYm9sfSk7XHJcbiAgXHJcbiAgdmFyIHN5bWJvbFN0YXRpY3MgPSB7XHJcbiAgICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcclxuICAgICdmb3InOiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXHJcbiAgICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXHJcbiAgICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gU3ltYm9sKGtleSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXHJcbiAgICBpdGVyYXRvcjogU1lNQk9MX0lURVJBVE9SIHx8IGdldFdlbGxLbm93blN5bWJvbChJVEVSQVRPUiksXHJcbiAgICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcclxuICAgIGtleUZvcjogcGFydC5jYWxsKGtleU9mLCBTeW1ib2xSZWdpc3RyeSksXHJcbiAgICAvLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcclxuICAgIHNwZWNpZXM6IFNZTUJPTF9TUEVDSUVTLFxyXG4gICAgLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xyXG4gICAgdG9TdHJpbmdUYWc6IFNZTUJPTF9UQUcgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRywgdHJ1ZSksXHJcbiAgICAvLyAxOS40LjIuMTQgU3ltYm9sLnVuc2NvcGFibGVzXHJcbiAgICB1bnNjb3BhYmxlczogU1lNQk9MX1VOU0NPUEFCTEVTLFxyXG4gICAgcHVyZTogc2FmZVN5bWJvbCxcclxuICAgIHNldDogc2V0LFxyXG4gICAgdXNlU2V0dGVyOiBmdW5jdGlvbigpe3NldHRlciA9IHRydWV9LFxyXG4gICAgdXNlU2ltcGxlOiBmdW5jdGlvbigpe3NldHRlciA9IGZhbHNlfVxyXG4gIH07XHJcbiAgLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXHJcbiAgLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxyXG4gIC8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxyXG4gIC8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXHJcbiAgLy8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxyXG4gIC8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcclxuICAvLyAxOS40LjIuMTIgU3ltYm9sLnRvUHJpbWl0aXZlXHJcbiAgZm9yRWFjaC5jYWxsKGFycmF5KCdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BsaXQsdG9QcmltaXRpdmUnKSxcclxuICAgIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgc3ltYm9sU3RhdGljc1tpdF0gPSBnZXRXZWxsS25vd25TeW1ib2woaXQpO1xyXG4gICAgfVxyXG4gICk7XHJcbiAgJGRlZmluZShTVEFUSUMsIFNZTUJPTCwgc3ltYm9sU3RhdGljcyk7XHJcbiAgXHJcbiAgc2V0VG9TdHJpbmdUYWcoU3ltYm9sLCBTWU1CT0wpO1xyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDICsgRk9SQ0VEICogIWlzTmF0aXZlKFN5bWJvbCksIE9CSkVDVCwge1xyXG4gICAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxuICAgIGdldE93blByb3BlcnR5TmFtZXM6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgdmFyIG5hbWVzID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKSwgcmVzdWx0ID0gW10sIGtleSwgaSA9IDA7XHJcbiAgICAgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxyXG4gICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHZhciBuYW1lcyA9IGdldE5hbWVzKHRvT2JqZWN0KGl0KSksIHJlc3VsdCA9IFtdLCBrZXksIGkgPSAwO1xyXG4gICAgICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cclxuICBzZXRUb1N0cmluZ1RhZyhNYXRoLCBNQVRILCB0cnVlKTtcclxuICAvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxyXG4gIHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xyXG59KHNhZmVTeW1ib2woJ3RhZycpLCB7fSwge30sIHRydWUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYub2JqZWN0LnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICB2YXIgb2JqZWN0U3RhdGljID0ge1xyXG4gICAgLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcclxuICAgIGFzc2lnbjogYXNzaWduLFxyXG4gICAgLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcclxuICAgIGlzOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxyXG4gIC8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrcyB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cclxuICAnX19wcm90b19fJyBpbiBPYmplY3RQcm90byAmJiBmdW5jdGlvbihidWdneSwgc2V0KXtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNldCA9IGN0eChjYWxsLCBnZXRPd25EZXNjcmlwdG9yKE9iamVjdFByb3RvLCAnX19wcm90b19fJykuc2V0LCAyKTtcclxuICAgICAgc2V0KHt9LCBBcnJheVByb3RvKTtcclxuICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZSB9XHJcbiAgICBvYmplY3RTdGF0aWMuc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8sIHByb3RvKXtcclxuICAgICAgYXNzZXJ0T2JqZWN0KE8pO1xyXG4gICAgICBhc3NlcnQocHJvdG8gPT09IG51bGwgfHwgaXNPYmplY3QocHJvdG8pLCBwcm90bywgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xyXG4gICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xyXG4gICAgICBlbHNlIHNldChPLCBwcm90byk7XHJcbiAgICAgIHJldHVybiBPO1xyXG4gICAgfVxyXG4gIH0oKTtcclxuICAkZGVmaW5lKFNUQVRJQywgT0JKRUNULCBvYmplY3RTdGF0aWMpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5vYmplY3QucHJvdG90eXBlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbih0bXApe1xyXG4gIC8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxyXG4gIHRtcFtTWU1CT0xfVEFHXSA9IERPVDtcclxuICBpZihjb2YodG1wKSAhPSBET1QpaGlkZGVuKE9iamVjdFByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XHJcbiAgfSk7XHJcbn0oe30pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAvLyBPYmplY3Qgc3RhdGljIG1ldGhvZHMgYWNjZXB0IHByaW1pdGl2ZXNcclxuICBmdW5jdGlvbiB3cmFwT2JqZWN0TWV0aG9kKGtleSwgTU9ERSl7XHJcbiAgICB2YXIgZm4gID0gT2JqZWN0W2tleV1cclxuICAgICAgLCBleHAgPSBjb3JlW09CSkVDVF1ba2V5XVxyXG4gICAgICAsIGYgICA9IDBcclxuICAgICAgLCBvICAgPSB7fTtcclxuICAgIGlmKCFleHAgfHwgaXNOYXRpdmUoZXhwKSl7XHJcbiAgICAgIG9ba2V5XSA9IE1PREUgPT0gMSA/IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogaXQ7XHJcbiAgICAgIH0gOiBNT0RFID09IDIgPyBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IHRydWU7XHJcbiAgICAgIH0gOiBNT0RFID09IDMgPyBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGZhbHNlO1xyXG4gICAgICB9IDogTU9ERSA9PSA0ID8gZnVuY3Rpb24oaXQsIGtleSl7XHJcbiAgICAgICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSwga2V5KTtcclxuICAgICAgfSA6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpKTtcclxuICAgICAgfTtcclxuICAgICAgdHJ5IHsgZm4oRE9UKSB9XHJcbiAgICAgIGNhdGNoKGUpeyBmID0gMSB9XHJcbiAgICAgICRkZWZpbmUoU1RBVElDICsgRk9SQ0VEICogZiwgT0JKRUNULCBvKTtcclxuICAgIH1cclxuICB9XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnZnJlZXplJywgMSk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnc2VhbCcsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ3ByZXZlbnRFeHRlbnNpb25zJywgMSk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnaXNGcm96ZW4nLCAyKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdpc1NlYWxlZCcsIDIpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2lzRXh0ZW5zaWJsZScsIDMpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIDQpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2dldFByb3RvdHlwZU9mJyk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgna2V5cycpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2dldE93blByb3BlcnR5TmFtZXMnKTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuZnVuY3Rpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oTkFNRSl7XHJcbiAgLy8gMTkuMi40LjIgbmFtZVxyXG4gIE5BTUUgaW4gRnVuY3Rpb25Qcm90byB8fCAoREVTQyAmJiBkZWZpbmVQcm9wZXJ0eShGdW5jdGlvblByb3RvLCBOQU1FLCB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBtYXRjaCA9IFN0cmluZyh0aGlzKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoW14gKF0qKS8pXHJcbiAgICAgICAgLCBuYW1lICA9IG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcclxuICAgICAgaGFzKHRoaXMsIE5BTUUpIHx8IGRlZmluZVByb3BlcnR5KHRoaXMsIE5BTUUsIGRlc2NyaXB0b3IoNSwgbmFtZSkpO1xyXG4gICAgICByZXR1cm4gbmFtZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgaGFzKHRoaXMsIE5BTUUpIHx8IGRlZmluZVByb3BlcnR5KHRoaXMsIE5BTUUsIGRlc2NyaXB0b3IoMCwgdmFsdWUpKTtcclxuICAgIH1cclxuICB9KSk7XHJcbn0oJ25hbWUnKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm51bWJlci5jb25zdHJ1Y3RvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuTnVtYmVyKCcwbzEnKSAmJiBOdW1iZXIoJzBiMScpIHx8IGZ1bmN0aW9uKF9OdW1iZXIsIE51bWJlclByb3RvKXtcclxuICBmdW5jdGlvbiB0b051bWJlcihpdCl7XHJcbiAgICBpZihpc09iamVjdChpdCkpaXQgPSB0b1ByaW1pdGl2ZShpdCk7XHJcbiAgICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMiAmJiBpdC5jaGFyQ29kZUF0KDApID09IDQ4KXtcclxuICAgICAgdmFyIGJpbmFyeSA9IGZhbHNlO1xyXG4gICAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XHJcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogYmluYXJ5ID0gdHJ1ZTtcclxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByZXR1cm4gcGFyc2VJbnQoaXQuc2xpY2UoMiksIGJpbmFyeSA/IDIgOiA4KTtcclxuICAgICAgfVxyXG4gICAgfSByZXR1cm4gK2l0O1xyXG4gIH1cclxuICBmdW5jdGlvbiB0b1ByaW1pdGl2ZShpdCl7XHJcbiAgICB2YXIgZm4sIHZhbDtcclxuICAgIGlmKGlzRnVuY3Rpb24oZm4gPSBpdC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XHJcbiAgICBpZihpc0Z1bmN0aW9uKGZuID0gaXRbVE9fU1RSSU5HXSkgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xyXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gbnVtYmVyXCIpO1xyXG4gIH1cclxuICBOdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIoaXQpe1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBOdW1iZXIgPyBuZXcgX051bWJlcih0b051bWJlcihpdCkpIDogdG9OdW1iZXIoaXQpO1xyXG4gIH1cclxuICBmb3JFYWNoLmNhbGwoREVTQyA/IGdldE5hbWVzKF9OdW1iZXIpXHJcbiAgOiBhcnJheSgnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFknKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgIGtleSBpbiBOdW1iZXIgfHwgZGVmaW5lUHJvcGVydHkoTnVtYmVyLCBrZXksIGdldE93bkRlc2NyaXB0b3IoX051bWJlciwga2V5KSk7XHJcbiAgfSk7XHJcbiAgTnVtYmVyW1BST1RPVFlQRV0gPSBOdW1iZXJQcm90bztcclxuICBOdW1iZXJQcm90b1tDT05TVFJVQ1RPUl0gPSBOdW1iZXI7XHJcbiAgaGlkZGVuKGdsb2JhbCwgTlVNQkVSLCBOdW1iZXIpO1xyXG59KE51bWJlciwgTnVtYmVyW1BST1RPVFlQRV0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYubnVtYmVyLnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oaXNJbnRlZ2VyKXtcclxuICAkZGVmaW5lKFNUQVRJQywgTlVNQkVSLCB7XHJcbiAgICAvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxyXG4gICAgRVBTSUxPTjogcG93KDIsIC01MiksXHJcbiAgICAvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxyXG4gICAgaXNGaW5pdGU6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShpdCk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXHJcbiAgICBpc0ludGVnZXI6IGlzSW50ZWdlcixcclxuICAgIC8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXHJcbiAgICBpc05hTjogc2FtZU5hTixcclxuICAgIC8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcclxuICAgIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uKG51bWJlcil7XHJcbiAgICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSOiBNQVhfU0FGRV9JTlRFR0VSLFxyXG4gICAgLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXHJcbiAgICBNSU5fU0FGRV9JTlRFR0VSOiAtTUFYX1NBRkVfSU5URUdFUixcclxuICAgIC8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXHJcbiAgICBwYXJzZUZsb2F0OiBwYXJzZUZsb2F0LFxyXG4gICAgLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxyXG4gICAgcGFyc2VJbnQ6IHBhcnNlSW50XHJcbiAgfSk7XHJcbi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxyXG59KE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24oaXQpe1xyXG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xyXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm1hdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRUNNQVNjcmlwdCA2IHNoaW1cclxuIWZ1bmN0aW9uKCl7XHJcbiAgLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxyXG4gIHZhciBFICAgID0gTWF0aC5FXHJcbiAgICAsIGV4cCAgPSBNYXRoLmV4cFxyXG4gICAgLCBsb2cgID0gTWF0aC5sb2dcclxuICAgICwgc3FydCA9IE1hdGguc3FydFxyXG4gICAgLCBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcclxuICAgICAgfTtcclxuICBcclxuICAvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXHJcbiAgZnVuY3Rpb24gYXNpbmgoeCl7XHJcbiAgICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcclxuICB9XHJcbiAgLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcclxuICBmdW5jdGlvbiBleHBtMSh4KXtcclxuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBleHAoeCkgLSAxO1xyXG4gIH1cclxuICAgIFxyXG4gICRkZWZpbmUoU1RBVElDLCBNQVRILCB7XHJcbiAgICAvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXHJcbiAgICBhY29zaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiBpc0Zpbml0ZSh4KSA/IGxvZyh4IC8gRSArIHNxcnQoeCArIDEpICogc3FydCh4IC0gMSkgLyBFKSArIDEgOiB4O1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcclxuICAgIGFzaW5oOiBhc2luaCxcclxuICAgIC8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcclxuICAgIGF0YW5oOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogbG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXHJcbiAgICBjYnJ0OiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIHBvdyhhYnMoeCksIDEgLyAzKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxyXG4gICAgY2x6MzI6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMyIC0geFtUT19TVFJJTkddKDIpLmxlbmd0aCA6IDMyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcclxuICAgIGNvc2g6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXHJcbiAgICBleHBtMTogZXhwbTEsXHJcbiAgICAvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcclxuICAgIC8vIFRPRE86IGZhbGxiYWNrIGZvciBJRTktXHJcbiAgICBmcm91bmQ6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbeF0pWzBdO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxyXG4gICAgaHlwb3Q6IGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKXtcclxuICAgICAgdmFyIHN1bSAgPSAwXHJcbiAgICAgICAgLCBsZW4xID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgbGVuMiA9IGxlbjFcclxuICAgICAgICAsIGFyZ3MgPSBBcnJheShsZW4xKVxyXG4gICAgICAgICwgbGFyZyA9IC1JbmZpbml0eVxyXG4gICAgICAgICwgYXJnO1xyXG4gICAgICB3aGlsZShsZW4xLS0pe1xyXG4gICAgICAgIGFyZyA9IGFyZ3NbbGVuMV0gPSArYXJndW1lbnRzW2xlbjFdO1xyXG4gICAgICAgIGlmKGFyZyA9PSBJbmZpbml0eSB8fCBhcmcgPT0gLUluZmluaXR5KXJldHVybiBJbmZpbml0eTtcclxuICAgICAgICBpZihhcmcgPiBsYXJnKWxhcmcgPSBhcmc7XHJcbiAgICAgIH1cclxuICAgICAgbGFyZyA9IGFyZyB8fCAxO1xyXG4gICAgICB3aGlsZShsZW4yLS0pc3VtICs9IHBvdyhhcmdzW2xlbjJdIC8gbGFyZywgMik7XHJcbiAgICAgIHJldHVybiBsYXJnICogc3FydChzdW0pO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcclxuICAgIGltdWw6IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICB2YXIgVUludDE2ID0gMHhmZmZmXHJcbiAgICAgICAgLCB4biA9ICt4XHJcbiAgICAgICAgLCB5biA9ICt5XHJcbiAgICAgICAgLCB4bCA9IFVJbnQxNiAmIHhuXHJcbiAgICAgICAgLCB5bCA9IFVJbnQxNiAmIHluO1xyXG4gICAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJbnQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJbnQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXHJcbiAgICBsb2cxcDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IGxvZygxICsgeCk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcclxuICAgIGxvZzEwOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4xMDtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXHJcbiAgICBsb2cyOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4yO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcclxuICAgIHNpZ246IHNpZ24sXHJcbiAgICAvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXHJcbiAgICBzaW5oOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIChhYnMoeCA9ICt4KSA8IDEpID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDIgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChFIC8gMik7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxyXG4gICAgdGFuaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxyXG4gICAgICAgICwgYiA9IGV4cG0xKC14KTtcclxuICAgICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxyXG4gICAgdHJ1bmM6IHRydW5jXHJcbiAgfSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnN0cmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGZyb21DaGFyQ29kZSl7XHJcbiAgZnVuY3Rpb24gYXNzZXJ0Tm90UmVnRXhwKGl0KXtcclxuICAgIGlmKGNvZihpdCkgPT0gUkVHRVhQKXRocm93IFR5cGVFcnJvcigpO1xyXG4gIH1cclxuICBcclxuICAkZGVmaW5lKFNUQVRJQywgU1RSSU5HLCB7XHJcbiAgICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxyXG4gICAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHZhciByZXMgPSBbXVxyXG4gICAgICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgaSAgID0gMFxyXG4gICAgICAgICwgY29kZVxyXG4gICAgICB3aGlsZShsZW4gPiBpKXtcclxuICAgICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xyXG4gICAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xyXG4gICAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXHJcbiAgICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxyXG4gICAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxyXG4gICAgcmF3OiBmdW5jdGlvbihjYWxsU2l0ZSl7XHJcbiAgICAgIHZhciByYXcgPSB0b09iamVjdChjYWxsU2l0ZS5yYXcpXHJcbiAgICAgICAgLCBsZW4gPSB0b0xlbmd0aChyYXcubGVuZ3RoKVxyXG4gICAgICAgICwgc2xuID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgcmVzID0gW11cclxuICAgICAgICAsIGkgICA9IDA7XHJcbiAgICAgIHdoaWxlKGxlbiA+IGkpe1xyXG4gICAgICAgIHJlcy5wdXNoKFN0cmluZyhyYXdbaSsrXSkpO1xyXG4gICAgICAgIGlmKGkgPCBzbG4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICB9IHJldHVybiByZXMuam9pbignJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgJGRlZmluZShQUk9UTywgU1RSSU5HLCB7XHJcbiAgICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcclxuICAgIGNvZGVQb2ludEF0OiBjcmVhdGVQb2ludEF0KGZhbHNlKSxcclxuICAgIC8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcclxuICAgIGVuZHNXaXRoOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XHJcbiAgICAgIGFzc2VydE5vdFJlZ0V4cChzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgdGhhdCA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHNbMV1cclxuICAgICAgICAsIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxyXG4gICAgICAgICwgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IG1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XHJcbiAgICAgIHNlYXJjaFN0cmluZyArPSAnJztcclxuICAgICAgcmV0dXJuIHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoU3RyaW5nLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoU3RyaW5nO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXHJcbiAgICBpbmNsdWRlczogZnVuY3Rpb24oc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xyXG4gICAgICBhc3NlcnROb3RSZWdFeHAoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgcmV0dXJuICEhflN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKS5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXHJcbiAgICByZXBlYXQ6IGZ1bmN0aW9uKGNvdW50KXtcclxuICAgICAgdmFyIHN0ciA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgcmVzID0gJydcclxuICAgICAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XHJcbiAgICAgIGlmKDAgPiBuIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xyXG4gICAgICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXHJcbiAgICBzdGFydHNXaXRoOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XHJcbiAgICAgIGFzc2VydE5vdFJlZ0V4cChzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgdGhhdCAgPSBTdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGluZGV4ID0gdG9MZW5ndGgobWluKGFyZ3VtZW50c1sxXSwgdGhhdC5sZW5ndGgpKTtcclxuICAgICAgc2VhcmNoU3RyaW5nICs9ICcnO1xyXG4gICAgICByZXR1cm4gdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KFN0cmluZy5mcm9tQ2hhckNvZGUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuYXJyYXkuc3RhdGljcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAkZGVmaW5lKFNUQVRJQyArIEZPUkNFRCAqIGNoZWNrRGFuZ2VySXRlckNsb3NpbmcoQXJyYXkuZnJvbSksIEFSUkFZLCB7XHJcbiAgICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICBmcm9tOiBmdW5jdGlvbihhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XHJcbiAgICAgIHZhciBPICAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQoYXJyYXlMaWtlKSlcclxuICAgICAgICAsIG1hcGZuICAgPSBhcmd1bWVudHNbMV1cclxuICAgICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgLCBmICAgICAgID0gbWFwcGluZyA/IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICwgaW5kZXggICA9IDBcclxuICAgICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwO1xyXG4gICAgICBpZihpc0l0ZXJhYmxlKE8pKXtcclxuICAgICAgICByZXN1bHQgPSBuZXcgKGdlbmVyaWModGhpcywgQXJyYXkpKTtcclxuICAgICAgICBzYWZlSXRlckNsb3NlKGZ1bmN0aW9uKGl0ZXJhdG9yKXtcclxuICAgICAgICAgIGZvcig7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gZihzdGVwLnZhbHVlLCBpbmRleCkgOiBzdGVwLnZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIGdldEl0ZXJhdG9yKE8pKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSBuZXcgKGdlbmVyaWModGhpcywgQXJyYXkpKShsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCkpO1xyXG4gICAgICAgIGZvcig7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcclxuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gZihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICAkZGVmaW5lKFNUQVRJQywgQVJSQVksIHtcclxuICAgIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcclxuICAgIG9mOiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgICAgdmFyIGluZGV4ICA9IDBcclxuICAgICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIHJlc3VsdCA9IG5ldyAoZ2VuZXJpYyh0aGlzLCBBcnJheSkpKGxlbmd0aCk7XHJcbiAgICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgc2V0U3BlY2llcyhBcnJheSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LmFycmF5LnByb3RvdHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgJGRlZmluZShQUk9UTywgQVJSQVksIHtcclxuICAgIC8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxyXG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcclxuICAgICAgdmFyIE8gICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxyXG4gICAgICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxyXG4gICAgICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXHJcbiAgICAgICAgLCBlbmQgICA9IGFyZ3VtZW50c1syXVxyXG4gICAgICAgICwgZmluICAgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pXHJcbiAgICAgICAgLCBjb3VudCA9IG1pbihmaW4gLSBmcm9tLCBsZW4gLSB0bylcclxuICAgICAgICAsIGluYyAgID0gMTtcclxuICAgICAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcclxuICAgICAgICBpbmMgID0gLTE7XHJcbiAgICAgICAgZnJvbSA9IGZyb20gKyBjb3VudCAtIDE7XHJcbiAgICAgICAgdG8gICA9IHRvICsgY291bnQgLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlKGNvdW50LS0gPiAwKXtcclxuICAgICAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xyXG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xyXG4gICAgICAgIHRvICs9IGluYztcclxuICAgICAgICBmcm9tICs9IGluYztcclxuICAgICAgfSByZXR1cm4gTztcclxuICAgIH0sXHJcbiAgICAvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcclxuICAgIGZpbGw6IGZ1bmN0aW9uKHZhbHVlIC8qLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xyXG4gICAgICB2YXIgTyAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgICAsIGluZGV4ICA9IHRvSW5kZXgoYXJndW1lbnRzWzFdLCBsZW5ndGgpXHJcbiAgICAgICAgLCBlbmQgICAgPSBhcmd1bWVudHNbMl1cclxuICAgICAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XHJcbiAgICAgIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIE87XHJcbiAgICB9LFxyXG4gICAgLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZmluZDogY3JlYXRlQXJyYXlNZXRob2QoNSksXHJcbiAgICAvLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIGZpbmRJbmRleDogY3JlYXRlQXJyYXlNZXRob2QoNilcclxuICB9KTtcclxuICBcclxuICBpZihmcmFtZXdvcmspe1xyXG4gICAgLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KCdmaW5kLGZpbmRJbmRleCxmaWxsLGNvcHlXaXRoaW4sZW50cmllcyxrZXlzLHZhbHVlcycpLCBmdW5jdGlvbihpdCl7XHJcbiAgICAgIEFycmF5VW5zY29wYWJsZXNbaXRdID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgU1lNQk9MX1VOU0NPUEFCTEVTIGluIEFycmF5UHJvdG8gfHwgaGlkZGVuKEFycmF5UHJvdG8sIFNZTUJPTF9VTlNDT1BBQkxFUywgQXJyYXlVbnNjb3BhYmxlcyk7XHJcbiAgfVxyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5pdGVyYXRvcnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihhdCl7XHJcbiAgLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxyXG4gIC8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXHJcbiAgLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxyXG4gIC8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxyXG4gIGRlZmluZVN0ZEl0ZXJhdG9ycyhBcnJheSwgQVJSQVksIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcclxuICAgIHNldCh0aGlzLCBJVEVSLCB7bzogdG9PYmplY3QoaXRlcmF0ZWQpLCBpOiAwLCBrOiBraW5kfSk7XHJcbiAgLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXHJcbiAgfSwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cclxuICAgICAgLCBPICAgICA9IGl0ZXIub1xyXG4gICAgICAsIGtpbmQgID0gaXRlci5rXHJcbiAgICAgICwgaW5kZXggPSBpdGVyLmkrKztcclxuICAgIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcclxuICAgICAgaXRlci5vID0gdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIH1cclxuICAgIGlmKGtpbmQgPT0gS0VZKSAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgaW5kZXgpO1xyXG4gICAgaWYoa2luZCA9PSBWQUxVRSlyZXR1cm4gaXRlclJlc3VsdCgwLCBPW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDAsIFtpbmRleCwgT1tpbmRleF1dKTtcclxuICB9LCBWQUxVRSk7XHJcbiAgXHJcbiAgLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxyXG4gIEl0ZXJhdG9yc1tBUkdVTUVOVFNdID0gSXRlcmF0b3JzW0FSUkFZXTtcclxuICBcclxuICAvLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXHJcbiAgZGVmaW5lU3RkSXRlcmF0b3JzKFN0cmluZywgU1RSSU5HLCBmdW5jdGlvbihpdGVyYXRlZCl7XHJcbiAgICBzZXQodGhpcywgSVRFUiwge286IFN0cmluZyhpdGVyYXRlZCksIGk6IDB9KTtcclxuICAvLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXHJcbiAgfSwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cclxuICAgICAgLCBPICAgICA9IGl0ZXIub1xyXG4gICAgICAsIGluZGV4ID0gaXRlci5pXHJcbiAgICAgICwgcG9pbnQ7XHJcbiAgICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIHBvaW50ID0gYXQuY2FsbChPLCBpbmRleCk7XHJcbiAgICBpdGVyLmkgKz0gcG9pbnQubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgcG9pbnQpO1xyXG4gIH0pO1xyXG59KGNyZWF0ZVBvaW50QXQodHJ1ZSkpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYucmVnZXhwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5ERVNDICYmICFmdW5jdGlvbihSZWdFeHBQcm90bywgX1JlZ0V4cCl7ICBcclxuICAvLyBSZWdFeHAgYWxsb3dzIGEgcmVnZXggd2l0aCBmbGFncyBhcyB0aGUgcGF0dGVyblxyXG4gIGlmKCFmdW5jdGlvbigpe3RyeXtyZXR1cm4gUmVnRXhwKC9hL2csICdpJykgPT0gJy9hL2knfWNhdGNoKGUpe319KCkpe1xyXG4gICAgUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHBhdHRlcm4sIGZsYWdzKXtcclxuICAgICAgcmV0dXJuIG5ldyBfUmVnRXhwKGNvZihwYXR0ZXJuKSA9PSBSRUdFWFAgJiYgZmxhZ3MgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gcGF0dGVybi5zb3VyY2UgOiBwYXR0ZXJuLCBmbGFncyk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoLmNhbGwoZ2V0TmFtZXMoX1JlZ0V4cCksIGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGtleSBpbiBSZWdFeHAgfHwgZGVmaW5lUHJvcGVydHkoUmVnRXhwLCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gX1JlZ0V4cFtrZXldIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IF9SZWdFeHBba2V5XSA9IGl0IH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFJlZ0V4cFByb3RvW0NPTlNUUlVDVE9SXSA9IFJlZ0V4cDtcclxuICAgIFJlZ0V4cFtQUk9UT1RZUEVdID0gUmVnRXhwUHJvdG87XHJcbiAgICBoaWRkZW4oZ2xvYmFsLCBSRUdFWFAsIFJlZ0V4cCk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcclxuICBpZigvLi9nLmZsYWdzICE9ICdnJylkZWZpbmVQcm9wZXJ0eShSZWdFeHBQcm90bywgJ2ZsYWdzJywge1xyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBjcmVhdGVSZXBsYWNlcigvXi4qXFwvKFxcdyopJC8sICckMScpXHJcbiAgfSk7XHJcbiAgXHJcbiAgc2V0U3BlY2llcyhSZWdFeHApO1xyXG59KFJlZ0V4cFtQUk9UT1RZUEVdLCBSZWdFeHApO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiB3ZWIuaW1tZWRpYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBzZXRJbW1lZGlhdGUgc2hpbVxyXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBlbHNlOlxyXG5pc0Z1bmN0aW9uKHNldEltbWVkaWF0ZSkgJiYgaXNGdW5jdGlvbihjbGVhckltbWVkaWF0ZSkgfHwgZnVuY3Rpb24oT05SRUFEWVNUQVRFQ0hBTkdFKXtcclxuICB2YXIgcG9zdE1lc3NhZ2UgICAgICA9IGdsb2JhbC5wb3N0TWVzc2FnZVxyXG4gICAgLCBhZGRFdmVudExpc3RlbmVyID0gZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXJcclxuICAgICwgTWVzc2FnZUNoYW5uZWwgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxyXG4gICAgLCBjb3VudGVyICAgICAgICAgID0gMFxyXG4gICAgLCBxdWV1ZSAgICAgICAgICAgID0ge31cclxuICAgICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XHJcbiAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZm4pe1xyXG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XHJcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGludm9rZShpc0Z1bmN0aW9uKGZuKSA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGRlZmVyKGNvdW50ZXIpO1xyXG4gICAgcmV0dXJuIGNvdW50ZXI7XHJcbiAgfVxyXG4gIGNsZWFySW1tZWRpYXRlID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcnVuKGlkKXtcclxuICAgIGlmKGhhcyhxdWV1ZSwgaWQpKXtcclxuICAgICAgdmFyIGZuID0gcXVldWVbaWRdO1xyXG4gICAgICBkZWxldGUgcXVldWVbaWRdO1xyXG4gICAgICBmbigpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBsaXN0bmVyKGV2ZW50KXtcclxuICAgIHJ1bihldmVudC5kYXRhKTtcclxuICB9XHJcbiAgLy8gTm9kZS5qcyAwLjgtXHJcbiAgaWYoTk9ERSl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgbmV4dFRpY2socGFydC5jYWxsKHJ1biwgaWQpKTtcclxuICAgIH1cclxuICAvLyBNb2Rlcm4gYnJvd3NlcnMsIHNraXAgaW1wbGVtZW50YXRpb24gZm9yIFdlYldvcmtlcnNcclxuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyBvYmplY3RcclxuICB9IGVsc2UgaWYoYWRkRXZlbnRMaXN0ZW5lciAmJiBpc0Z1bmN0aW9uKHBvc3RNZXNzYWdlKSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XHJcbiAgICAgIHBvc3RNZXNzYWdlKGlkLCAnKicpO1xyXG4gICAgfVxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcclxuICAvLyBXZWJXb3JrZXJzXHJcbiAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oTWVzc2FnZUNoYW5uZWwpKXtcclxuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XHJcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcclxuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcclxuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xyXG4gIC8vIElFOC1cclxuICB9IGVsc2UgaWYoZG9jdW1lbnQgJiYgT05SRUFEWVNUQVRFQ0hBTkdFIGluIGRvY3VtZW50W0NSRUFURV9FTEVNRU5UXSgnc2NyaXB0Jykpe1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XHJcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnRbQ1JFQVRFX0VMRU1FTlRdKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICBydW4oaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcclxuICB9IGVsc2Uge1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XHJcbiAgICAgIHNldFRpbWVvdXQocnVuLCAwLCBpZCk7XHJcbiAgICB9XHJcbiAgfVxyXG59KCdvbnJlYWR5c3RhdGVjaGFuZ2UnKTtcclxuJGRlZmluZShHTE9CQUwgKyBCSU5ELCB7XHJcbiAgc2V0SW1tZWRpYXRlOiAgIHNldEltbWVkaWF0ZSxcclxuICBjbGVhckltbWVkaWF0ZTogY2xlYXJJbW1lZGlhdGVcclxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5wcm9taXNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEVTNiBwcm9taXNlcyBzaGltXHJcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRpZnkvbmF0aXZlLXByb21pc2Utb25seS9cclxuIWZ1bmN0aW9uKFByb21pc2UsIHRlc3Qpe1xyXG4gIGlzRnVuY3Rpb24oUHJvbWlzZSkgJiYgaXNGdW5jdGlvbihQcm9taXNlLnJlc29sdmUpXHJcbiAgJiYgUHJvbWlzZS5yZXNvbHZlKHRlc3QgPSBuZXcgUHJvbWlzZShmdW5jdGlvbigpe30pKSA9PSB0ZXN0XHJcbiAgfHwgZnVuY3Rpb24oYXNhcCwgUkVDT1JEKXtcclxuICAgIGZ1bmN0aW9uIGlzVGhlbmFibGUoaXQpe1xyXG4gICAgICB2YXIgdGhlbjtcclxuICAgICAgaWYoaXNPYmplY3QoaXQpKXRoZW4gPSBpdC50aGVuO1xyXG4gICAgICByZXR1cm4gaXNGdW5jdGlvbih0aGVuKSA/IHRoZW4gOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhbmRsZWRSZWplY3Rpb25Pckhhc09uUmVqZWN0ZWQocHJvbWlzZSl7XHJcbiAgICAgIHZhciByZWNvcmQgPSBwcm9taXNlW1JFQ09SRF1cclxuICAgICAgICAsIGNoYWluICA9IHJlY29yZC5jXHJcbiAgICAgICAgLCBpICAgICAgPSAwXHJcbiAgICAgICAgLCByZWFjdDtcclxuICAgICAgaWYocmVjb3JkLmgpcmV0dXJuIHRydWU7XHJcbiAgICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xyXG4gICAgICAgIHJlYWN0ID0gY2hhaW5baSsrXTtcclxuICAgICAgICBpZihyZWFjdC5mYWlsIHx8IGhhbmRsZWRSZWplY3Rpb25Pckhhc09uUmVqZWN0ZWQocmVhY3QuUCkpcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG5vdGlmeShyZWNvcmQsIHJlamVjdCl7XHJcbiAgICAgIHZhciBjaGFpbiA9IHJlY29yZC5jO1xyXG4gICAgICBpZihyZWplY3QgfHwgY2hhaW4ubGVuZ3RoKWFzYXAoZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IHJlY29yZC5wXHJcbiAgICAgICAgICAsIHZhbHVlICAgPSByZWNvcmQudlxyXG4gICAgICAgICAgLCBvayAgICAgID0gcmVjb3JkLnMgPT0gMVxyXG4gICAgICAgICAgLCBpICAgICAgID0gMDtcclxuICAgICAgICBpZihyZWplY3QgJiYgIWhhbmRsZWRSZWplY3Rpb25Pckhhc09uUmVqZWN0ZWQocHJvbWlzZSkpe1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZighaGFuZGxlZFJlamVjdGlvbk9ySGFzT25SZWplY3RlZChwcm9taXNlKSl7XHJcbiAgICAgICAgICAgICAgaWYoTk9ERSl7XHJcbiAgICAgICAgICAgICAgICBpZighcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSkpe1xyXG4gICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG5vZGUuanMgYmVoYXZpb3JcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYoaXNGdW5jdGlvbihjb25zb2xlLmVycm9yKSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCAxZTMpO1xyXG4gICAgICAgIH0gZWxzZSB3aGlsZShjaGFpbi5sZW5ndGggPiBpKSFmdW5jdGlvbihyZWFjdCl7XHJcbiAgICAgICAgICB2YXIgY2IgPSBvayA/IHJlYWN0Lm9rIDogcmVhY3QuZmFpbFxyXG4gICAgICAgICAgICAsIHJldCwgdGhlbjtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmKGNiKXtcclxuICAgICAgICAgICAgICBpZighb2spcmVjb3JkLmggPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHJldCA9IGNiID09PSB0cnVlID8gdmFsdWUgOiBjYih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgaWYocmV0ID09PSByZWFjdC5QKXtcclxuICAgICAgICAgICAgICAgIHJlYWN0LnJlaihUeXBlRXJyb3IoUFJPTUlTRSArICctY2hhaW4gY3ljbGUnKSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJldCkpe1xyXG4gICAgICAgICAgICAgICAgdGhlbi5jYWxsKHJldCwgcmVhY3QucmVzLCByZWFjdC5yZWopO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSByZWFjdC5yZXMocmV0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHJlYWN0LnJlaih2YWx1ZSk7XHJcbiAgICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIHJlYWN0LnJlaihlcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0oY2hhaW5baSsrXSk7XHJcbiAgICAgICAgY2hhaW4ubGVuZ3RoID0gMDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKXtcclxuICAgICAgdmFyIHJlY29yZCA9IHRoaXNcclxuICAgICAgICAsIHRoZW4sIHdyYXBwZXI7XHJcbiAgICAgIGlmKHJlY29yZC5kKXJldHVybjtcclxuICAgICAgcmVjb3JkLmQgPSB0cnVlO1xyXG4gICAgICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XHJcbiAgICAgICAgICB3cmFwcGVyID0ge3I6IHJlY29yZCwgZDogZmFsc2V9OyAvLyB3cmFwXHJcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eChyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KHJlamVjdCwgd3JhcHBlciwgMSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZWNvcmQudiA9IHZhbHVlO1xyXG4gICAgICAgICAgcmVjb3JkLnMgPSAxO1xyXG4gICAgICAgICAgbm90aWZ5KHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgcmVqZWN0LmNhbGwod3JhcHBlciB8fCB7cjogcmVjb3JkLCBkOiBmYWxzZX0sIGVycik7IC8vIHdyYXBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKXtcclxuICAgICAgdmFyIHJlY29yZCA9IHRoaXM7XHJcbiAgICAgIGlmKHJlY29yZC5kKXJldHVybjtcclxuICAgICAgcmVjb3JkLmQgPSB0cnVlO1xyXG4gICAgICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxyXG4gICAgICByZWNvcmQudiA9IHZhbHVlO1xyXG4gICAgICByZWNvcmQucyA9IDI7XHJcbiAgICAgIG5vdGlmeShyZWNvcmQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IoQyl7XHJcbiAgICAgIHZhciBTID0gYXNzZXJ0T2JqZWN0KEMpW1NZTUJPTF9TUEVDSUVTXTtcclxuICAgICAgcmV0dXJuIFMgIT0gdW5kZWZpbmVkID8gUyA6IEM7XHJcbiAgICB9XHJcbiAgICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxyXG4gICAgUHJvbWlzZSA9IGZ1bmN0aW9uKGV4ZWN1dG9yKXtcclxuICAgICAgYXNzZXJ0RnVuY3Rpb24oZXhlY3V0b3IpO1xyXG4gICAgICBhc3NlcnRJbnN0YW5jZSh0aGlzLCBQcm9taXNlLCBQUk9NSVNFKTtcclxuICAgICAgdmFyIHJlY29yZCA9IHtcclxuICAgICAgICBwOiB0aGlzLCAgICAgIC8vIHByb21pc2VcclxuICAgICAgICBjOiBbXSwgICAgICAgIC8vIGNoYWluXHJcbiAgICAgICAgczogMCwgICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIGQ6IGZhbHNlLCAgICAgLy8gZG9uZVxyXG4gICAgICAgIHY6IHVuZGVmaW5lZCwgLy8gdmFsdWVcclxuICAgICAgICBoOiBmYWxzZSAgICAgIC8vIGhhbmRsZWQgcmVqZWN0aW9uXHJcbiAgICAgIH07XHJcbiAgICAgIGhpZGRlbih0aGlzLCBSRUNPUkQsIHJlY29yZCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXhlY3V0b3IoY3R4KHJlc29sdmUsIHJlY29yZCwgMSksIGN0eChyZWplY3QsIHJlY29yZCwgMSkpO1xyXG4gICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgcmVqZWN0LmNhbGwocmVjb3JkLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NpZ25IaWRkZW4oUHJvbWlzZVtQUk9UT1RZUEVdLCB7XHJcbiAgICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXHJcbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcclxuICAgICAgICB2YXIgUyA9IGFzc2VydE9iamVjdChhc3NlcnRPYmplY3QodGhpcylbQ09OU1RSVUNUT1JdKVtTWU1CT0xfU1BFQ0lFU107XHJcbiAgICAgICAgdmFyIHJlYWN0ID0ge1xyXG4gICAgICAgICAgb2s6ICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXHJcbiAgICAgICAgICBmYWlsOiBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpICA/IG9uUmVqZWN0ZWQgIDogZmFsc2VcclxuICAgICAgICB9ICwgUCA9IHJlYWN0LlAgPSBuZXcgKFMgIT0gdW5kZWZpbmVkID8gUyA6IFByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICByZWFjdC5yZXMgPSBhc3NlcnRGdW5jdGlvbihyZXNvbHZlKTtcclxuICAgICAgICAgIHJlYWN0LnJlaiA9IGFzc2VydEZ1bmN0aW9uKHJlamVjdCk7XHJcbiAgICAgICAgfSksIHJlY29yZCA9IHRoaXNbUkVDT1JEXTtcclxuICAgICAgICByZWNvcmQuYy5wdXNoKHJlYWN0KTtcclxuICAgICAgICByZWNvcmQucyAmJiBub3RpZnkocmVjb3JkKTtcclxuICAgICAgICByZXR1cm4gUDtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcclxuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGFzc2lnbkhpZGRlbihQcm9taXNlLCB7XHJcbiAgICAgIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxyXG4gICAgICBhbGw6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICB2YXIgUHJvbWlzZSA9IGdldENvbnN0cnVjdG9yKHRoaXMpXHJcbiAgICAgICAgICAsIHZhbHVlcyAgPSBbXTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgcHVzaCwgdmFsdWVzKTtcclxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICwgcmVzdWx0cyAgID0gQXJyYXkocmVtYWluaW5nKTtcclxuICAgICAgICAgIGlmKHJlbWFpbmluZylmb3JFYWNoLmNhbGwodmFsdWVzLCBmdW5jdGlvbihwcm9taXNlLCBpbmRleCl7XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGVsc2UgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxyXG4gICAgICByYWNlOiBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICAgICAgdmFyIFByb21pc2UgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcclxuICAgICAgcmVqZWN0OiBmdW5jdGlvbihyKXtcclxuICAgICAgICByZXR1cm4gbmV3IChnZXRDb25zdHJ1Y3Rvcih0aGlzKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgIHJlamVjdChyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXHJcbiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdCh4KSAmJiBSRUNPUkQgaW4geCAmJiBnZXRQcm90b3R5cGVPZih4KSA9PT0gdGhpc1tQUk9UT1RZUEVdXHJcbiAgICAgICAgICA/IHggOiBuZXcgKGdldENvbnN0cnVjdG9yKHRoaXMpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgICByZXNvbHZlKHgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0obmV4dFRpY2sgfHwgc2V0SW1tZWRpYXRlLCBzYWZlU3ltYm9sKCdyZWNvcmQnKSk7XHJcbiAgc2V0VG9TdHJpbmdUYWcoUHJvbWlzZSwgUFJPTUlTRSk7XHJcbiAgc2V0U3BlY2llcyhQcm9taXNlKTtcclxuICAkZGVmaW5lKEdMT0JBTCArIEZPUkNFRCAqICFpc05hdGl2ZShQcm9taXNlKSwge1Byb21pc2U6IFByb21pc2V9KTtcclxufShnbG9iYWxbUFJPTUlTRV0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuY29sbGVjdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFQ01BU2NyaXB0IDYgY29sbGVjdGlvbnMgc2hpbVxyXG4hZnVuY3Rpb24oKXtcclxuICB2YXIgVUlEICAgPSBzYWZlU3ltYm9sKCd1aWQnKVxyXG4gICAgLCBPMSAgICA9IHNhZmVTeW1ib2woJ08xJylcclxuICAgICwgV0VBSyAgPSBzYWZlU3ltYm9sKCd3ZWFrJylcclxuICAgICwgTEVBSyAgPSBzYWZlU3ltYm9sKCdsZWFrJylcclxuICAgICwgTEFTVCAgPSBzYWZlU3ltYm9sKCdsYXN0JylcclxuICAgICwgRklSU1QgPSBzYWZlU3ltYm9sKCdmaXJzdCcpXHJcbiAgICAsIFNJWkUgID0gREVTQyA/IHNhZmVTeW1ib2woJ3NpemUnKSA6ICdzaXplJ1xyXG4gICAgLCB1aWQgICA9IDBcclxuICAgICwgdG1wICAgPSB7fTtcclxuICBcclxuICBmdW5jdGlvbiBnZXRDb2xsZWN0aW9uKEMsIE5BTUUsIG1ldGhvZHMsIGNvbW1vbk1ldGhvZHMsIGlzTWFwLCBpc1dlYWspe1xyXG4gICAgdmFyIEFEREVSID0gaXNNYXAgPyAnc2V0JyA6ICdhZGQnXHJcbiAgICAgICwgcHJvdG8gPSBDICYmIENbUFJPVE9UWVBFXVxyXG4gICAgICAsIE8gICAgID0ge307XHJcbiAgICBmdW5jdGlvbiBpbml0RnJvbUl0ZXJhYmxlKHRoYXQsIGl0ZXJhYmxlKXtcclxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBpc01hcCwgdGhhdFtBRERFUl0sIHRoYXQpO1xyXG4gICAgICByZXR1cm4gdGhhdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpeFNWWihrZXksIGNoYWluKXtcclxuICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XHJcbiAgICAgIGlmKGZyYW1ld29yaylwcm90b1trZXldID0gZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7XHJcbiAgICAgICAgcmV0dXJuIGNoYWluID8gdGhpcyA6IHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmKCFpc05hdGl2ZShDKSB8fCAhKGlzV2VhayB8fCAoIUJVR0dZX0lURVJBVE9SUyAmJiBoYXMocHJvdG8sIEZPUl9FQUNIKSAmJiBoYXMocHJvdG8sICdlbnRyaWVzJykpKSl7XHJcbiAgICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXHJcbiAgICAgIEMgPSBpc1dlYWtcclxuICAgICAgICA/IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2UodGhpcywgQywgTkFNRSk7XHJcbiAgICAgICAgICAgIHNldCh0aGlzLCBVSUQsIHVpZCsrKTtcclxuICAgICAgICAgICAgaW5pdEZyb21JdGVyYWJsZSh0aGlzLCBpdGVyYWJsZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgOiBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2UodGhhdCwgQywgTkFNRSk7XHJcbiAgICAgICAgICAgIHNldCh0aGF0LCBPMSwgY3JlYXRlKG51bGwpKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIFNJWkUsIDApO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgTEFTVCwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIEZJUlNULCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBpbml0RnJvbUl0ZXJhYmxlKHRoYXQsIGl0ZXJhYmxlKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgIGFzc2lnbkhpZGRlbihhc3NpZ25IaWRkZW4oQ1tQUk9UT1RZUEVdLCBtZXRob2RzKSwgY29tbW9uTWV0aG9kcyk7XHJcbiAgICAgIGlzV2VhayB8fCAhREVTQyB8fCBkZWZpbmVQcm9wZXJ0eShDW1BST1RPVFlQRV0sICdzaXplJywge2dldDogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gYXNzZXJ0RGVmaW5lZCh0aGlzW1NJWkVdKTtcclxuICAgICAgfX0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIE5hdGl2ZSA9IENcclxuICAgICAgICAsIGluc3QgICA9IG5ldyBDXHJcbiAgICAgICAgLCBjaGFpbiAgPSBpbnN0W0FEREVSXShpc1dlYWsgPyB7fSA6IC0wLCAxKVxyXG4gICAgICAgICwgYnVnZ3laZXJvO1xyXG4gICAgICAvLyB3cmFwIHRvIGluaXQgY29sbGVjdGlvbnMgZnJvbSBpdGVyYWJsZVxyXG4gICAgICBpZihjaGVja0Rhbmdlckl0ZXJDbG9zaW5nKGZ1bmN0aW9uKE8peyBuZXcgQyhPKSB9KSl7XHJcbiAgICAgICAgQyA9IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIEMsIE5BTUUpO1xyXG4gICAgICAgICAgcmV0dXJuIGluaXRGcm9tSXRlcmFibGUobmV3IE5hdGl2ZSwgaXRlcmFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDW1BST1RPVFlQRV0gPSBwcm90bztcclxuICAgICAgICBpZihmcmFtZXdvcmspcHJvdG9bQ09OU1RSVUNUT1JdID0gQztcclxuICAgICAgfVxyXG4gICAgICBpc1dlYWsgfHwgaW5zdFtGT1JfRUFDSF0oZnVuY3Rpb24odmFsLCBrZXkpe1xyXG4gICAgICAgIGJ1Z2d5WmVybyA9IDEgLyBrZXkgPT09IC1JbmZpbml0eTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIGZpeCBjb252ZXJ0aW5nIC0wIGtleSB0byArMFxyXG4gICAgICBpZihidWdneVplcm8pe1xyXG4gICAgICAgIGZpeFNWWignZGVsZXRlJyk7XHJcbiAgICAgICAgZml4U1ZaKCdoYXMnKTtcclxuICAgICAgICBpc01hcCAmJiBmaXhTVlooJ2dldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vICsgZml4IC5hZGQgJiAuc2V0IGZvciBjaGFpbmluZ1xyXG4gICAgICBpZihidWdneVplcm8gfHwgY2hhaW4gIT09IGluc3QpZml4U1ZaKEFEREVSLCB0cnVlKTtcclxuICAgIH1cclxuICAgIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xyXG4gICAgc2V0U3BlY2llcyhDKTtcclxuICAgIFxyXG4gICAgT1tOQU1FXSA9IEM7XHJcbiAgICAkZGVmaW5lKEdMT0JBTCArIFdSQVAgKyBGT1JDRUQgKiAhaXNOYXRpdmUoQyksIE8pO1xyXG4gICAgXHJcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cclxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcclxuICAgIGlzV2VhayB8fCBkZWZpbmVTdGRJdGVyYXRvcnMoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xyXG4gICAgICBzZXQodGhpcywgSVRFUiwge286IGl0ZXJhdGVkLCBrOiBraW5kfSk7XHJcbiAgICB9LCBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICAgLCBraW5kICA9IGl0ZXIua1xyXG4gICAgICAgICwgZW50cnkgPSBpdGVyLmw7XHJcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcclxuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcclxuICAgICAgaWYoIWl0ZXIubyB8fCAhKGl0ZXIubCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogaXRlci5vW0ZJUlNUXSkpe1xyXG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXHJcbiAgICAgICAgaXRlci5vID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcclxuICAgICAgaWYoa2luZCA9PSBLRVkpICByZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS5rKTtcclxuICAgICAgaWYoa2luZCA9PSBWQUxVRSlyZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS52KTtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBbZW50cnkuaywgZW50cnkudl0pOyAgIFxyXG4gICAgfSwgaXNNYXAgPyBLRVkrVkFMVUUgOiBWQUxVRSwgIWlzTWFwKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIEM7XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIGZhc3RLZXkoaXQsIGNyZWF0ZSl7XHJcbiAgICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XHJcbiAgICBpZighaXNPYmplY3QoaXQpKXJldHVybiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xyXG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcclxuICAgIGlmKGlzRnJvemVuKGl0KSlyZXR1cm4gJ0YnO1xyXG4gICAgaWYoIWhhcyhpdCwgVUlEKSl7XHJcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXHJcbiAgICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcclxuICAgICAgLy8gYWRkIG1pc3Npbmcgb2JqZWN0IGlkXHJcbiAgICAgIGhpZGRlbihpdCwgVUlELCArK3VpZCk7XHJcbiAgICAvLyByZXR1cm4gb2JqZWN0IGlkIHdpdGggcHJlZml4XHJcbiAgICB9IHJldHVybiAnTycgKyBpdFtVSURdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRFbnRyeSh0aGF0LCBrZXkpe1xyXG4gICAgLy8gZmFzdCBjYXNlXHJcbiAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xyXG4gICAgaWYoaW5kZXggIT0gJ0YnKXJldHVybiB0aGF0W08xXVtpbmRleF07XHJcbiAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcclxuICAgIGZvcihlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcclxuICAgICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBkZWYodGhhdCwga2V5LCB2YWx1ZSl7XHJcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXHJcbiAgICAgICwgcHJldiwgaW5kZXg7XHJcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcclxuICAgIGlmKGVudHJ5KWVudHJ5LnYgPSB2YWx1ZTtcclxuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGF0W0xBU1RdID0gZW50cnkgPSB7XHJcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XHJcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxyXG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxyXG4gICAgICAgIHA6IHByZXYgPSB0aGF0W0xBU1RdLCAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxyXG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XHJcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcclxuICAgICAgfTtcclxuICAgICAgaWYoIXRoYXRbRklSU1RdKXRoYXRbRklSU1RdID0gZW50cnk7XHJcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XHJcbiAgICAgIHRoYXRbU0laRV0rKztcclxuICAgICAgLy8gYWRkIHRvIGluZGV4XHJcbiAgICAgIGlmKGluZGV4ICE9ICdGJyl0aGF0W08xXVtpbmRleF0gPSBlbnRyeTtcclxuICAgIH0gcmV0dXJuIHRoYXQ7XHJcbiAgfVxyXG5cclxuICB2YXIgY29sbGVjdGlvbk1ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcclxuICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0W08xXSwgZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XHJcbiAgICAgICAgZW50cnkuciA9IHRydWU7XHJcbiAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xyXG4gICAgICB9XHJcbiAgICAgIHRoYXRbRklSU1RdID0gdGhhdFtMQVNUXSA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhhdFtTSVpFXSA9IDA7XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXHJcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIHRoYXQgID0gdGhpc1xyXG4gICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xyXG4gICAgICBpZihlbnRyeSl7XHJcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXHJcbiAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xyXG4gICAgICAgIGRlbGV0ZSB0aGF0W08xXVtlbnRyeS5pXTtcclxuICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcclxuICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XHJcbiAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xyXG4gICAgICAgIGlmKHRoYXRbRklSU1RdID09IGVudHJ5KXRoYXRbRklSU1RdID0gbmV4dDtcclxuICAgICAgICBpZih0aGF0W0xBU1RdID09IGVudHJ5KXRoYXRbTEFTVF0gPSBwcmV2O1xyXG4gICAgICAgIHRoYXRbU0laRV0tLTtcclxuICAgICAgfSByZXR1cm4gISFlbnRyeTtcclxuICAgIH0sXHJcbiAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSwgMylcclxuICAgICAgICAsIGVudHJ5O1xyXG4gICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXNbRklSU1RdKXtcclxuICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xyXG4gICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXHJcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjEgTWFwIE9iamVjdHNcclxuICBNYXAgPSBnZXRDb2xsZWN0aW9uKE1hcCwgTUFQLCB7XHJcbiAgICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xyXG4gICAgfSxcclxuICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCBjb2xsZWN0aW9uTWV0aG9kcywgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gMjMuMiBTZXQgT2JqZWN0c1xyXG4gIFNldCA9IGdldENvbGxlY3Rpb24oU2V0LCBTRVQsIHtcclxuICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sIGNvbGxlY3Rpb25NZXRob2RzKTtcclxuICBcclxuICBmdW5jdGlvbiBkZWZXZWFrKHRoYXQsIGtleSwgdmFsdWUpe1xyXG4gICAgaWYoaXNGcm96ZW4oYXNzZXJ0T2JqZWN0KGtleSkpKWxlYWtTdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaGFzKGtleSwgV0VBSykgfHwgaGlkZGVuKGtleSwgV0VBSywge30pO1xyXG4gICAgICBrZXlbV0VBS11bdGhhdFtVSURdXSA9IHZhbHVlO1xyXG4gICAgfSByZXR1cm4gdGhhdDtcclxuICB9XHJcbiAgZnVuY3Rpb24gbGVha1N0b3JlKHRoYXQpe1xyXG4gICAgcmV0dXJuIHRoYXRbTEVBS10gfHwgaGlkZGVuKHRoYXQsIExFQUssIG5ldyBNYXApW0xFQUtdO1xyXG4gIH1cclxuICBcclxuICB2YXIgd2Vha01ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxyXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcclxuICAgICAgaWYoaXNGcm96ZW4oa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xyXG4gICAgICByZXR1cm4gaGFzKGtleSwgV0VBSykgJiYgaGFzKGtleVtXRUFLXSwgdGhpc1tVSURdKSAmJiBkZWxldGUga2V5W1dFQUtdW3RoaXNbVUlEXV07XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcclxuICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcclxuICAgIGhhczogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuaGFzKGtleSk7XHJcbiAgICAgIHJldHVybiBoYXMoa2V5LCBXRUFLKSAmJiBoYXMoa2V5W1dFQUtdLCB0aGlzW1VJRF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcclxuICBXZWFrTWFwID0gZ2V0Q29sbGVjdGlvbihXZWFrTWFwLCBXRUFLTUFQLCB7XHJcbiAgICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxyXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihpc09iamVjdChrZXkpKXtcclxuICAgICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYoaGFzKGtleSwgV0VBSykpcmV0dXJuIGtleVtXRUFLXVt0aGlzW1VJRF1dO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmV2Vhayh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgdHJ1ZSwgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxyXG4gIGlmKGZyYW1ld29yayAmJiBuZXcgV2Vha01hcCgpLnNldChPYmplY3QuZnJlZXplKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KCdkZWxldGUsaGFzLGdldCxzZXQnKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIG1ldGhvZCA9IFdlYWtNYXBbUFJPVE9UWVBFXVtrZXldO1xyXG4gICAgICBXZWFrTWFwW1BST1RPVFlQRV1ba2V5XSA9IGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGxlYWt5IG1hcFxyXG4gICAgICAgIGlmKGlzT2JqZWN0KGEpICYmIGlzRnJvemVuKGEpKXtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSBsZWFrU3RvcmUodGhpcylba2V5XShhLCBiKTtcclxuICAgICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xyXG4gICAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxyXG4gICAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjQgV2Vha1NldCBPYmplY3RzXHJcbiAgV2Vha1NldCA9IGdldENvbGxlY3Rpb24oV2Vha1NldCwgV0VBS1NFVCwge1xyXG4gICAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWZXZWFrKHRoaXMsIHZhbHVlLCB0cnVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgZmFsc2UsIHRydWUpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5yZWZsZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIGZ1bmN0aW9uIEVudW1lcmF0ZShpdGVyYXRlZCl7XHJcbiAgICB2YXIga2V5cyA9IFtdLCBrZXk7XHJcbiAgICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgYToga2V5cywgaTogMH0pO1xyXG4gIH1cclxuICBjcmVhdGVJdGVyYXRvcihFbnVtZXJhdGUsIE9CSkVDVCwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIGtleXMgPSBpdGVyLmFcclxuICAgICAgLCBrZXk7XHJcbiAgICBkbyB7XHJcbiAgICAgIGlmKGl0ZXIuaSA+PSBrZXlzLmxlbmd0aClyZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIH0gd2hpbGUoISgoa2V5ID0ga2V5c1tpdGVyLmkrK10pIGluIGl0ZXIubykpO1xyXG4gICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwga2V5KTtcclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiB3cmFwKGZuKXtcclxuICAgIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIGFzc2VydE9iamVjdChpdCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSwgdHJ1ZTtcclxuICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgZnVuY3Rpb24gcmVmbGVjdEdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xyXG4gICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cclxuICAgICAgLCBkZXNjID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpLCBwcm90bztcclxuICAgIGlmKGRlc2MpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxyXG4gICAgICA/IGRlc2MudmFsdWVcclxuICAgICAgOiBkZXNjLmdldCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICA6IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSlcclxuICAgICAgPyByZWZsZWN0R2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZWZsZWN0U2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XHJcbiAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxyXG4gICAgICAsIG93bkRlc2MgID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXHJcbiAgICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcclxuICAgIGlmKCFvd25EZXNjKXtcclxuICAgICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XHJcbiAgICAgICAgcmV0dXJuIHJlZmxlY3RTZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XHJcbiAgICAgIH1cclxuICAgICAgb3duRGVzYyA9IGRlc2NyaXB0b3IoMCk7XHJcbiAgICB9XHJcbiAgICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xyXG4gICAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcclxuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ2V0T3duRGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGRlc2NyaXB0b3IoMCk7XHJcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XHJcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvciksIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZFxyXG4gICAgICA/IGZhbHNlXHJcbiAgICAgIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcclxuICB9XHJcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgcmV0dXJuSXQ7XHJcbiAgXHJcbiAgdmFyIHJlZmxlY3QgPSB7XHJcbiAgICAvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcclxuICAgIGFwcGx5OiBjdHgoY2FsbCwgYXBwbHksIDMpLFxyXG4gICAgLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxyXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbih0YXJnZXQsIGFyZ3VtZW50c0xpc3QgLyosIG5ld1RhcmdldCovKXtcclxuICAgICAgdmFyIHByb3RvICAgID0gYXNzZXJ0RnVuY3Rpb24oYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl0pW1BST1RPVFlQRV1cclxuICAgICAgICAsIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0UHJvdG8pXHJcbiAgICAgICAgLCByZXN1bHQgICA9IGFwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcclxuICAgIGRlZmluZVByb3BlcnR5OiB3cmFwKGRlZmluZVByb3BlcnR5KSxcclxuICAgIC8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXHJcbiAgICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eUtleSl7XHJcbiAgICAgIHZhciBkZXNjID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xyXG4gICAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXHJcbiAgICBlbnVtZXJhdGU6IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICAgIHJldHVybiBuZXcgRW51bWVyYXRlKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXHJcbiAgICBnZXQ6IHJlZmxlY3RHZXQsXHJcbiAgICAvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eUtleSl7XHJcbiAgICAgIHJldHVybiBnZXRPd25EZXNjcmlwdG9yKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxyXG4gICAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICAgIHJldHVybiBnZXRQcm90b3R5cGVPZihhc3NlcnRPYmplY3QodGFyZ2V0KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXHJcbiAgICBoYXM6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHlLZXkpe1xyXG4gICAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxyXG4gICAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgICByZXR1cm4gISFpc0V4dGVuc2libGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcclxuICAgIG93bktleXM6IG93bktleXMsXHJcbiAgICAvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxyXG4gICAgcHJldmVudEV4dGVuc2lvbnM6IHdyYXAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIHx8IHJldHVybkl0KSxcclxuICAgIC8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXHJcbiAgICBzZXQ6IHJlZmxlY3RTZXRcclxuICB9XHJcbiAgLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXHJcbiAgaWYoc2V0UHJvdG90eXBlT2YpcmVmbGVjdC5zZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvdG8pe1xyXG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm90byksIHRydWU7XHJcbiAgfTtcclxuICBcclxuICAkZGVmaW5lKEdMT0JBTCwge1JlZmxlY3Q6IHt9fSk7XHJcbiAgJGRlZmluZShTVEFUSUMsICdSZWZsZWN0JywgcmVmbGVjdCk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM3LnByb3Bvc2FscyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgJGRlZmluZShQUk9UTywgQVJSQVksIHtcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xyXG4gICAgaW5jbHVkZXM6IGNyZWF0ZUFycmF5Q29udGFpbnModHJ1ZSlcclxuICB9KTtcclxuICAkZGVmaW5lKFBST1RPLCBTVFJJTkcsIHtcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcclxuICAgIGF0OiBjcmVhdGVQb2ludEF0KHRydWUpXHJcbiAgfSk7XHJcbiAgXHJcbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0VG9BcnJheShpc0VudHJpZXMpe1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgICAgIHZhciBPICAgICAgPSB0b09iamVjdChvYmplY3QpXHJcbiAgICAgICAgLCBrZXlzICAgPSBnZXRLZXlzKG9iamVjdClcclxuICAgICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICAgLCBpICAgICAgPSAwXHJcbiAgICAgICAgLCByZXN1bHQgPSBBcnJheShsZW5ndGgpXHJcbiAgICAgICAgLCBrZXk7XHJcbiAgICAgIGlmKGlzRW50cmllcyl3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IFtrZXkgPSBrZXlzW2krK10sIE9ba2V5XV07XHJcbiAgICAgIGVsc2Ugd2hpbGUobGVuZ3RoID4gaSlyZXN1bHRbaV0gPSBPW2tleXNbaSsrXV07XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gICRkZWZpbmUoU1RBVElDLCBPQkpFQ1QsIHtcclxuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vOTM1Mzc4MVxyXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24ob2JqZWN0KXtcclxuICAgICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICAgICAsIHJlc3VsdCA9IHt9O1xyXG4gICAgICBmb3JFYWNoLmNhbGwob3duS2V5cyhPKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzY3JpcHRvcigwLCBnZXRPd25EZXNjcmlwdG9yKE8sIGtleSkpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDQvYXByLTkubWQjNTEtb2JqZWN0ZW50cmllcy1vYmplY3R2YWx1ZXNcclxuICAgIHZhbHVlczogIGNyZWF0ZU9iamVjdFRvQXJyYXkoZmFsc2UpLFxyXG4gICAgZW50cmllczogY3JlYXRlT2JqZWN0VG9BcnJheSh0cnVlKVxyXG4gIH0pO1xyXG4gICRkZWZpbmUoU1RBVElDLCBSRUdFWFAsIHtcclxuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2thbmdheC85Njk4MTAwXHJcbiAgICBlc2NhcGU6IGNyZWF0ZVJlcGxhY2VyKC8oW1xcXFxcXC1bXFxde30oKSorPy4sXiR8XSkvZywgJ1xcXFwkMScsIHRydWUpXHJcbiAgfSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM3LmFic3RyYWN0LXJlZnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtYWJzdHJhY3QtcmVmc1xyXG4hZnVuY3Rpb24oUkVGRVJFTkNFKXtcclxuICBSRUZFUkVOQ0VfR0VUID0gZ2V0V2VsbEtub3duU3ltYm9sKFJFRkVSRU5DRSsnR2V0JywgdHJ1ZSk7XHJcbiAgdmFyIFJFRkVSRU5DRV9TRVQgPSBnZXRXZWxsS25vd25TeW1ib2woUkVGRVJFTkNFK1NFVCwgdHJ1ZSlcclxuICAgICwgUkVGRVJFTkNFX0RFTEVURSA9IGdldFdlbGxLbm93blN5bWJvbChSRUZFUkVOQ0UrJ0RlbGV0ZScsIHRydWUpO1xyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDLCBTWU1CT0wsIHtcclxuICAgIHJlZmVyZW5jZUdldDogUkVGRVJFTkNFX0dFVCxcclxuICAgIHJlZmVyZW5jZVNldDogUkVGRVJFTkNFX1NFVCxcclxuICAgIHJlZmVyZW5jZURlbGV0ZTogUkVGRVJFTkNFX0RFTEVURVxyXG4gIH0pO1xyXG4gIFxyXG4gIGhpZGRlbihGdW5jdGlvblByb3RvLCBSRUZFUkVOQ0VfR0VULCByZXR1cm5UaGlzKTtcclxuICBcclxuICBmdW5jdGlvbiBzZXRNYXBNZXRob2RzKENvbnN0cnVjdG9yKXtcclxuICAgIGlmKENvbnN0cnVjdG9yKXtcclxuICAgICAgdmFyIE1hcFByb3RvID0gQ29uc3RydWN0b3JbUFJPVE9UWVBFXTtcclxuICAgICAgaGlkZGVuKE1hcFByb3RvLCBSRUZFUkVOQ0VfR0VULCBNYXBQcm90by5nZXQpO1xyXG4gICAgICBoaWRkZW4oTWFwUHJvdG8sIFJFRkVSRU5DRV9TRVQsIE1hcFByb3RvLnNldCk7XHJcbiAgICAgIGhpZGRlbihNYXBQcm90bywgUkVGRVJFTkNFX0RFTEVURSwgTWFwUHJvdG9bJ2RlbGV0ZSddKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2V0TWFwTWV0aG9kcyhNYXApO1xyXG4gIHNldE1hcE1ldGhvZHMoV2Vha01hcCk7XHJcbn0oJ3JlZmVyZW5jZScpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBqcy5hcnJheS5zdGF0aWNzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBKYXZhU2NyaXB0IDEuNiAvIFN0cmF3bWFuIGFycmF5IHN0YXRpY3Mgc2hpbVxyXG4hZnVuY3Rpb24oYXJyYXlTdGF0aWNzKXtcclxuICBmdW5jdGlvbiBzZXRBcnJheVN0YXRpY3Moa2V5cywgbGVuZ3RoKXtcclxuICAgIGZvckVhY2guY2FsbChhcnJheShrZXlzKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoa2V5IGluIEFycmF5UHJvdG8pYXJyYXlTdGF0aWNzW2tleV0gPSBjdHgoY2FsbCwgQXJyYXlQcm90b1trZXldLCBsZW5ndGgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldEFycmF5U3RhdGljcygncG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcycsIDEpO1xyXG4gIHNldEFycmF5U3RhdGljcygnaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcycsIDMpO1xyXG4gIHNldEFycmF5U3RhdGljcygnam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLCcgK1xyXG4gICAgICAgICAgICAgICAgICAncmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbCx0dXJuJyk7XHJcbiAgJGRlZmluZShTVEFUSUMsIEFSUkFZLCBhcnJheVN0YXRpY3MpO1xyXG59KHt9KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogd2ViLmRvbS5pdGFyYWJsZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKE5vZGVMaXN0KXtcclxuICBpZihmcmFtZXdvcmsgJiYgTm9kZUxpc3QgJiYgIShTWU1CT0xfSVRFUkFUT1IgaW4gTm9kZUxpc3RbUFJPVE9UWVBFXSkpe1xyXG4gICAgaGlkZGVuKE5vZGVMaXN0W1BST1RPVFlQRV0sIFNZTUJPTF9JVEVSQVRPUiwgSXRlcmF0b3JzW0FSUkFZXSk7XHJcbiAgfVxyXG4gIEl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9yc1tBUlJBWV07XHJcbn0oZ2xvYmFsLk5vZGVMaXN0KTtcbn0odHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCksIHRydWUpOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID1cbiAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHJldHVybiBuZXcgR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYgfHwgbnVsbCwgdHJ5TG9jc0xpc3QgfHwgW10pO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCk7XG4gICAgICB2YXIgY2FsbE5leHQgPSBzdGVwLmJpbmQoZ2VuZXJhdG9yLm5leHQpO1xuICAgICAgdmFyIGNhbGxUaHJvdyA9IHN0ZXAuYmluZChnZW5lcmF0b3JbXCJ0aHJvd1wiXSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoYXJnKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaCh0aGlzLCBudWxsLCBhcmcpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKGluZm8udmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShpbmZvLnZhbHVlKS50aGVuKGNhbGxOZXh0LCBjYWxsVGhyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxOZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGdlbmVyYXRvciA9IG91dGVyRm4gPyBPYmplY3QuY3JlYXRlKG91dGVyRm4ucHJvdG90eXBlKSA6IHRoaXM7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCk7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgXCJhdHRlbXB0IHRvIHNlbmQgXCIgKyBKU09OLnN0cmluZ2lmeShhcmcpICsgXCIgdG8gbmV3Ym9ybiBnZW5lcmF0b3JcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQuc2VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG5cbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihyZWNvcmQuYXJnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0b3IubmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIGdlbmVyYXRvcltcInRocm93XCJdID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIGdlbmVyYXRvcltcInJldHVyblwiXSA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICAvLyBQcmUtaW5pdGlhbGl6ZSBhdCBsZWFzdCAyMCB0ZW1wb3JhcnkgdmFyaWFibGVzIHRvIGVuYWJsZSBoaWRkZW5cbiAgICAgIC8vIGNsYXNzIG9wdGltaXphdGlvbnMgZm9yIHNpbXBsZSBnZW5lcmF0b3JzLlxuICAgICAgZm9yICh2YXIgdGVtcEluZGV4ID0gMCwgdGVtcE5hbWU7XG4gICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIHRlbXBOYW1lID0gXCJ0XCIgKyB0ZW1wSW5kZXgpIHx8IHRlbXBJbmRleCA8IDIwO1xuICAgICAgICAgICArK3RlbXBJbmRleCkge1xuICAgICAgICB0aGlzW3RlbXBOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0aGlzXG4pO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYm94SW50ZXJzZWN0V3JhcHBlclxuXG52YXIgcG9vbCA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgc3dlZXAgPSByZXF1aXJlKCcuL2xpYi9zd2VlcCcpXG52YXIgYm94SW50ZXJzZWN0SXRlciA9IHJlcXVpcmUoJy4vbGliL2ludGVyc2VjdCcpXG5cbmZ1bmN0aW9uIGJveEVtcHR5KGQsIGJveCkge1xuICBmb3IodmFyIGo9MDsgajxkOyArK2opIHtcbiAgICBpZighKGJveFtqXSA8PSBib3hbaitkXSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vL1VucGFjayBib3hlcyBpbnRvIGEgZmxhdCB0eXBlZCBhcnJheSwgcmVtb3ZlIGVtcHR5IGJveGVzXG5mdW5jdGlvbiBjb252ZXJ0Qm94ZXMoYm94ZXMsIGQsIGRhdGEsIGlkcykge1xuICB2YXIgcHRyID0gMFxuICB2YXIgY291bnQgPSAwXG4gIGZvcih2YXIgaT0wLCBuPWJveGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgYiA9IGJveGVzW2ldXG4gICAgaWYoYm94RW1wdHkoZCwgYikpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGZvcih2YXIgaj0wOyBqPDIqZDsgKytqKSB7XG4gICAgICBkYXRhW3B0cisrXSA9IGJbal1cbiAgICB9XG4gICAgaWRzW2NvdW50KytdID0gaVxuICB9XG4gIHJldHVybiBjb3VudFxufVxuXG4vL1BlcmZvcm0gdHlwZSBjb252ZXJzaW9ucywgY2hlY2sgYm91bmRzXG5mdW5jdGlvbiBib3hJbnRlcnNlY3QocmVkLCBibHVlLCB2aXNpdCwgZnVsbCkge1xuICB2YXIgbiA9IHJlZC5sZW5ndGhcbiAgdmFyIG0gPSBibHVlLmxlbmd0aFxuXG4gIC8vSWYgZWl0aGVyIGFycmF5IGlzIGVtcHR5LCB0aGVuIHdlIGNhbiBza2lwIHRoaXMgd2hvbGUgdGhpbmdcbiAgaWYobiA8PSAwIHx8IG0gPD0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvbiwgaWYgaXQgaXMgMCB0aGVuIHdlIHNraXBcbiAgdmFyIGQgPSAocmVkWzBdLmxlbmd0aCk+Pj4xXG4gIGlmKGQgPD0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHJldHZhbFxuXG4gIC8vQ29udmVydCByZWQgYm94ZXNcbiAgdmFyIHJlZExpc3QgID0gcG9vbC5tYWxsb2NEb3VibGUoMipkKm4pXG4gIHZhciByZWRJZHMgICA9IHBvb2wubWFsbG9jSW50MzIobilcbiAgbiA9IGNvbnZlcnRCb3hlcyhyZWQsIGQsIHJlZExpc3QsIHJlZElkcylcblxuICBpZihuID4gMCkge1xuICAgIGlmKGQgPT09IDEgJiYgZnVsbCkge1xuICAgICAgLy9TcGVjaWFsIGNhc2U6IDFkIGNvbXBsZXRlXG4gICAgICBzd2VlcC5pbml0KG4pXG4gICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICBkLCB2aXNpdCwgXG4gICAgICAgIDAsIG4sIHJlZExpc3QsIHJlZElkcyxcbiAgICAgICAgMCwgbiwgcmVkTGlzdCwgcmVkSWRzKVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vQ29udmVydCBibHVlIGJveGVzXG4gICAgICB2YXIgYmx1ZUxpc3QgPSBwb29sLm1hbGxvY0RvdWJsZSgyKmQqbSlcbiAgICAgIHZhciBibHVlSWRzICA9IHBvb2wubWFsbG9jSW50MzIobSlcbiAgICAgIG0gPSBjb252ZXJ0Qm94ZXMoYmx1ZSwgZCwgYmx1ZUxpc3QsIGJsdWVJZHMpXG5cbiAgICAgIGlmKG0gPiAwKSB7XG4gICAgICAgIHN3ZWVwLmluaXQobittKVxuXG4gICAgICAgIGlmKGQgPT09IDEpIHtcbiAgICAgICAgICAvL1NwZWNpYWwgY2FzZTogMWQgYmlwYXJ0aXRlXG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCwgXG4gICAgICAgICAgICAwLCBuLCByZWRMaXN0LCAgcmVkSWRzLFxuICAgICAgICAgICAgMCwgbSwgYmx1ZUxpc3QsIGJsdWVJZHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9HZW5lcmFsIGNhc2U6ICBkPjFcbiAgICAgICAgICByZXR2YWwgPSBib3hJbnRlcnNlY3RJdGVyKFxuICAgICAgICAgICAgZCwgdmlzaXQsICAgIGZ1bGwsXG4gICAgICAgICAgICBuLCByZWRMaXN0LCAgcmVkSWRzLFxuICAgICAgICAgICAgbSwgYmx1ZUxpc3QsIGJsdWVJZHMpXG4gICAgICAgIH1cblxuICAgICAgICBwb29sLmZyZWUoYmx1ZUxpc3QpXG4gICAgICAgIHBvb2wuZnJlZShibHVlSWRzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHBvb2wuZnJlZShyZWRMaXN0KVxuICAgIHBvb2wuZnJlZShyZWRJZHMpXG4gIH1cblxuICByZXR1cm4gcmV0dmFsXG59XG5cblxudmFyIFJFU1VMVFxuXG5mdW5jdGlvbiBhcHBlbmRJdGVtKGksaikge1xuICBSRVNVTFQucHVzaChbaSxqXSlcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0RnVsbEFycmF5KHgpIHtcbiAgUkVTVUxUID0gW11cbiAgYm94SW50ZXJzZWN0KHgsIHgsIGFwcGVuZEl0ZW0sIHRydWUpXG4gIHJldHVybiBSRVNVTFRcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0QmlwYXJ0aXRlQXJyYXkoeCwgeSkge1xuICBSRVNVTFQgPSBbXVxuICBib3hJbnRlcnNlY3QoeCwgeSwgYXBwZW5kSXRlbSwgZmFsc2UpXG4gIHJldHVybiBSRVNVTFRcbn1cblxuLy9Vc2VyLWZyaWVuZGx5IHdyYXBwZXIsIGhhbmRsZSBmdWxsIGlucHV0IGFuZCBuby12aXNpdG9yIGNhc2VzXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RXcmFwcGVyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgdmFyIHJlc3VsdFxuICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBpbnRlcnNlY3RGdWxsQXJyYXkoYXJnMClcbiAgICBjYXNlIDI6XG4gICAgICBpZih0eXBlb2YgYXJnMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzAsIGFyZzEsIHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0QmlwYXJ0aXRlQXJyYXkoYXJnMCwgYXJnMSlcbiAgICAgIH1cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzEsIGFyZzIsIGZhbHNlKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JveC1pbnRlcnNlY3Q6IEludmFsaWQgYXJndW1lbnRzJylcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgRElNRU5TSU9OICAgPSAnZCdcbnZhciBBWElTICAgICAgICA9ICdheCdcbnZhciBWSVNJVCAgICAgICA9ICd2didcbnZhciBGTElQICAgICAgICA9ICdmcCdcblxudmFyIEVMRU1fU0laRSAgID0gJ2VzJ1xuXG52YXIgUkVEX1NUQVJUICAgPSAncnMnXG52YXIgUkVEX0VORCAgICAgPSAncmUnXG52YXIgUkVEX0JPWEVTICAgPSAncmInXG52YXIgUkVEX0lOREVYICAgPSAncmknXG52YXIgUkVEX1BUUiAgICAgPSAncnAnXG5cbnZhciBCTFVFX1NUQVJUICA9ICdicydcbnZhciBCTFVFX0VORCAgICA9ICdiZSdcbnZhciBCTFVFX0JPWEVTICA9ICdiYidcbnZhciBCTFVFX0lOREVYICA9ICdiaSdcbnZhciBCTFVFX1BUUiAgICA9ICdicCdcblxudmFyIFJFVFZBTCAgICAgID0gJ3J2J1xuXG52YXIgSU5ORVJfTEFCRUwgPSAnUSdcblxudmFyIEFSR1MgPSBbXG4gIERJTUVOU0lPTixcbiAgQVhJUyxcbiAgVklTSVQsXG4gIFJFRF9TVEFSVCxcbiAgUkVEX0VORCxcbiAgUkVEX0JPWEVTLFxuICBSRURfSU5ERVgsXG4gIEJMVUVfU1RBUlQsXG4gIEJMVUVfRU5ELFxuICBCTFVFX0JPWEVTLFxuICBCTFVFX0lOREVYXG5dXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyBcbiAgICAocmVkTWFqb3IgPyAnUmVkJyA6ICdCbHVlJykgKyBcbiAgICAoZmxpcCA/ICdGbGlwJyA6ICcnKSArXG4gICAgKGZ1bGwgPyAnRnVsbCcgOiAnJylcblxuICB2YXIgY29kZSA9IFsnZnVuY3Rpb24gJywgZnVuY05hbWUsICcoJywgQVJHUy5qb2luKCksICcpeycsXG4gICAgJ3ZhciAnLCBFTEVNX1NJWkUsICc9MionLCBESU1FTlNJT04sICc7J11cblxuICB2YXIgcmVkTG9vcCA9IFxuICAgICdmb3IodmFyIGk9JyArIFJFRF9TVEFSVCArICcsJyArIFJFRF9QVFIgKyAnPScgKyBFTEVNX1NJWkUgKyAnKicgKyBSRURfU1RBUlQgKyAnOycgK1xuICAgICAgICAnaTwnICsgUkVEX0VORCArJzsnICtcbiAgICAgICAgJysraSwnICsgUkVEX1BUUiArICcrPScgKyBFTEVNX1NJWkUgKyAnKXsnICtcbiAgICAgICAgJ3ZhciB4MD0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnXSwnICtcbiAgICAgICAgICAgICd4MT0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnKycgKyBESU1FTlNJT04gKyAnXSwnICtcbiAgICAgICAgICAgICd4aT0nICsgUkVEX0lOREVYICsgJ1tpXTsnXG5cbiAgdmFyIGJsdWVMb29wID0gXG4gICAgJ2Zvcih2YXIgaj0nICsgQkxVRV9TVEFSVCArICcsJyArIEJMVUVfUFRSICsgJz0nICsgRUxFTV9TSVpFICsgJyonICsgQkxVRV9TVEFSVCArICc7JyArXG4gICAgICAgICdqPCcgKyBCTFVFX0VORCArICc7JyArXG4gICAgICAgICcrK2osJyArIEJMVUVfUFRSICsgJys9JyArIEVMRU1fU0laRSArICcpeycgK1xuICAgICAgICAndmFyIHkwPScgKyBCTFVFX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIEJMVUVfUFRSICsgJ10sJyArXG4gICAgICAgICAgICAoZnVsbCA/ICd5MT0nICsgQkxVRV9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBCTFVFX1BUUiArICcrJyArIERJTUVOU0lPTiArICddLCcgOiAnJykgK1xuICAgICAgICAgICAgJ3lpPScgKyBCTFVFX0lOREVYICsgJ1tqXTsnXG5cbiAgaWYocmVkTWFqb3IpIHtcbiAgICBjb2RlLnB1c2gocmVkTG9vcCwgSU5ORVJfTEFCRUwsICc6JywgYmx1ZUxvb3ApXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGJsdWVMb29wLCBJTk5FUl9MQUJFTCwgJzonLCByZWRMb29wKVxuICB9XG5cbiAgaWYoZnVsbCkge1xuICAgIGNvZGUucHVzaCgnaWYoeTE8eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSBpZihmbGlwKSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDw9eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDx4MHx8eDE8eTApY29udGludWU7JylcbiAgfVxuXG4gIGNvZGUucHVzaCgnZm9yKHZhciBrPScrQVhJUysnKzE7azwnK0RJTUVOU0lPTisnOysrayl7JytcbiAgICAndmFyIHIwPScrUkVEX0JPWEVTKydbaysnK1JFRF9QVFIrJ10sJytcbiAgICAgICAgJ3IxPScrUkVEX0JPWEVTKydbaysnK0RJTUVOU0lPTisnKycrUkVEX1BUUisnXSwnK1xuICAgICAgICAnYjA9JytCTFVFX0JPWEVTKydbaysnK0JMVUVfUFRSKyddLCcrXG4gICAgICAgICdiMT0nK0JMVUVfQk9YRVMrJ1trKycrRElNRU5TSU9OKycrJytCTFVFX1BUUisnXTsnK1xuICAgICAgJ2lmKHIxPGIwfHxiMTxyMCljb250aW51ZSAnICsgSU5ORVJfTEFCRUwgKyAnO30nICtcbiAgICAgICd2YXIgJyArIFJFVFZBTCArICc9JyArIFZJU0lUICsgJygnKVxuXG4gIGlmKGZsaXApIHtcbiAgICBjb2RlLnB1c2goJ3lpLHhpJylcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ3hpLHlpJylcbiAgfVxuXG4gIGNvZGUucHVzaCgnKTtpZignICsgUkVUVkFMICsgJyE9PXZvaWQgMClyZXR1cm4gJyArIFJFVFZBTCArICc7fX19JylcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGZ1bmNOYW1lLCBcbiAgICBjb2RlOiBjb2RlLmpvaW4oJycpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnJ1dGVGb3JjZVBsYW5uZXIoZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyAoZnVsbCA/ICdGdWxsJyA6ICdQYXJ0aWFsJylcbiAgdmFyIHByZWZpeCA9IFtdXG4gIHZhciBmYXJncyA9IEFSR1Muc2xpY2UoKVxuICBpZighZnVsbCkge1xuICAgIGZhcmdzLnNwbGljZSgzLCAwLCBGTElQKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbJ2Z1bmN0aW9uICcgKyBmdW5jTmFtZSArICcoJyArIGZhcmdzLmpvaW4oKSArICcpeyddXG5cbiAgZnVuY3Rpb24gaW52b2tlKHJlZE1ham9yLCBmbGlwKSB7XG4gICAgdmFyIHJlcyA9IGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbClcbiAgICBwcmVmaXgucHVzaChyZXMuY29kZSlcbiAgICBjb2RlLnB1c2goJ3JldHVybiAnICsgcmVzLm5hbWUgKyAnKCcgKyBBUkdTLmpvaW4oKSArICcpOycpXG4gIH1cblxuICBjb2RlLnB1c2goJ2lmKCcgKyBSRURfRU5EICsgJy0nICsgUkVEX1NUQVJUICsgJz4nICtcbiAgICAgICAgICAgICAgICAgICAgQkxVRV9FTkQgKyAnLScgKyBCTFVFX1NUQVJUICsgJyl7JylcblxuICBpZihmdWxsKSB7XG4gICAgaW52b2tlKHRydWUsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UoZmFsc2UsIGZhbHNlKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgnaWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZSh0cnVlLCB0cnVlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UodHJ1ZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9fWVsc2V7aWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZShmYWxzZSwgdHJ1ZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKGZhbHNlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ30nKVxuICB9XG4gIGNvZGUucHVzaCgnfX1yZXR1cm4gJyArIGZ1bmNOYW1lKVxuXG4gIHZhciBjb2RlU3RyID0gcHJlZml4LmpvaW4oJycpICsgY29kZS5qb2luKCcnKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihjb2RlU3RyKVxuICByZXR1cm4gcHJvYygpXG59XG5cblxuZXhwb3J0cy5wYXJ0aWFsID0gYnJ1dGVGb3JjZVBsYW5uZXIoZmFsc2UpXG5leHBvcnRzLmZ1bGwgICAgPSBicnV0ZUZvcmNlUGxhbm5lcih0cnVlKSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJveEludGVyc2VjdEl0ZXJcblxudmFyIHBvb2wgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgYnJ1dGVGb3JjZSA9IHJlcXVpcmUoJy4vYnJ1dGUnKVxudmFyIGJydXRlRm9yY2VQYXJ0aWFsID0gYnJ1dGVGb3JjZS5wYXJ0aWFsXG52YXIgYnJ1dGVGb3JjZUZ1bGwgPSBicnV0ZUZvcmNlLmZ1bGxcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vc3dlZXAnKVxudmFyIGZpbmRNZWRpYW4gPSByZXF1aXJlKCcuL21lZGlhbicpXG52YXIgZ2VuUGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKVxuXG4vL1R3aWRkbGUgcGFyYW1ldGVyc1xudmFyIEJSVVRFX0ZPUkNFX0NVVE9GRiAgICA9IDEyOCAgICAgICAvL0N1dCBvZmYgZm9yIGJydXRlIGZvcmNlIHNlYXJjaFxudmFyIFNDQU5fQ1VUT0ZGICAgICAgICAgICA9ICgxPDwyMikgICAvL0N1dCBvZmYgZm9yIHR3byB3YXkgc2NhblxudmFyIFNDQU5fQ09NUExFVEVfQ1VUT0ZGICA9ICgxPDwyMikgIFxuXG4vL1BhcnRpdGlvbiBmdW5jdGlvbnNcbnZhciBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwgPSBnZW5QYXJ0aXRpb24oXG4gICchKGxvPj1wMCkmJiEocDE+PWhpKScsIFxuICBbJ3AwJywgJ3AxJ10pXG5cbnZhciBwYXJ0aXRpb25TdGFydEVxdWFsID0gZ2VuUGFydGl0aW9uKFxuICAnbG89PT1wMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oXG4gICdsbzxwMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkVuZExlc3NUaGFuRXF1YWwgPSBnZW5QYXJ0aXRpb24oXG4gICdoaTw9cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50ID0gZ2VuUGFydGl0aW9uKFxuICAnbG88PXAwJiZwMDw9aGknLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50UHJvcGVyID0gZ2VuUGFydGl0aW9uKFxuICAnbG88cDAmJnAwPD1oaScsXG4gIFsncDAnXSlcblxuLy9GcmFtZSBzaXplIGZvciBpdGVyYXRpdmUgbG9vcFxudmFyIElGUkFNRV9TSVpFID0gNlxudmFyIERGUkFNRV9TSVpFID0gMlxuXG4vL0RhdGEgZm9yIGJveCBzdGF0Y2tcbnZhciBJTklUX0NBUEFDSVRZID0gMTAyNFxudmFyIEJPWF9JU1RBQ0sgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJPWF9EU1RBQ0sgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSlcblxuLy9Jbml0aWFsaXplIGl0ZXJhdGl2ZSBsb29wIHF1ZXVlXG5mdW5jdGlvbiBpdGVySW5pdChkLCBjb3VudCkge1xuICB2YXIgbGV2ZWxzID0gKDggKiBiaXRzLmxvZzIoY291bnQrMSkgKiAoZCsxKSl8MFxuICB2YXIgbWF4SW50cyA9IGJpdHMubmV4dFBvdzIoSUZSQU1FX1NJWkUqbGV2ZWxzKVxuICBpZihCT1hfSVNUQUNLLmxlbmd0aCA8IG1heEludHMpIHtcbiAgICBwb29sLmZyZWUoQk9YX0lTVEFDSylcbiAgICBCT1hfSVNUQUNLID0gcG9vbC5tYWxsb2NJbnQzMihtYXhJbnRzKVxuICB9XG4gIHZhciBtYXhEb3VibGVzID0gYml0cy5uZXh0UG93MihERlJBTUVfU0laRSpsZXZlbHMpXG4gIGlmKEJPWF9EU1RBQ0sgPCBtYXhEb3VibGVzKSB7XG4gICAgcG9vbC5mcmVlKEJPWF9EU1RBQ0spXG4gICAgQk9YX0RTVEFDSyA9IHBvb2wubWFsbG9jRG91YmxlKG1heERvdWJsZXMpXG4gIH1cbn1cblxuLy9BcHBlbmQgaXRlbSB0byBxdWV1ZVxuZnVuY3Rpb24gaXRlclB1c2gocHRyLFxuICBheGlzLCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgXG4gIHN0YXRlLCBcbiAgbG8sIGhpKSB7XG5cbiAgdmFyIGlwdHIgPSBJRlJBTUVfU0laRSAqIHB0clxuICBCT1hfSVNUQUNLW2lwdHJdICAgPSBheGlzXG4gIEJPWF9JU1RBQ0tbaXB0cisxXSA9IHJlZFN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cisyXSA9IHJlZEVuZFxuICBCT1hfSVNUQUNLW2lwdHIrM10gPSBibHVlU3RhcnRcbiAgQk9YX0lTVEFDS1tpcHRyKzRdID0gYmx1ZUVuZFxuICBCT1hfSVNUQUNLW2lwdHIrNV0gPSBzdGF0ZVxuXG4gIHZhciBkcHRyID0gREZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0RTVEFDS1tkcHRyXSAgID0gbG9cbiAgQk9YX0RTVEFDS1tkcHRyKzFdID0gaGlcbn1cblxuLy9TcGVjaWFsIGNhc2U6ICBJbnRlcnNlY3Qgc2luZ2xlIHBvaW50IHdpdGggbGlzdCBvZiBpbnRlcnZhbHNcbmZ1bmN0aW9uIG9uZVBvaW50UGFydGlhbChcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVPZmZzZXQsIGJsdWUsIGJsdWVJZCkge1xuXG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciBibHVlUHRyICA9IGJsdWVPZmZzZXQgKiBlbGVtU2l6ZVxuICB2YXIgYmx1ZVggICAgPSBibHVlW2JsdWVQdHIgKyBheGlzXVxuXG5yZWRfbG9vcDpcbiAgZm9yKHZhciBpPXJlZFN0YXJ0LCByZWRQdHI9cmVkU3RhcnQqZWxlbVNpemU7IGk8cmVkRW5kOyArK2ksIHJlZFB0cis9ZWxlbVNpemUpIHtcbiAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2F4aXNdXG4gICAgdmFyIHIxID0gcmVkW3JlZFB0citheGlzK2RdXG4gICAgaWYoYmx1ZVggPCByMCB8fCByMSA8IGJsdWVYKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZihmbGlwICYmIGJsdWVYID09PSByMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHJlZElkID0gcmVkSW5kZXhbaV1cbiAgICBmb3IodmFyIGo9YXhpcysxOyBqPGQ7ICsraikge1xuICAgICAgdmFyIHIwID0gcmVkW3JlZFB0citqXVxuICAgICAgdmFyIHIxID0gcmVkW3JlZFB0citqK2RdXG4gICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIral1cbiAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citqK2RdXG4gICAgICBpZihyMSA8IGIwIHx8IGIxIDwgcjApIHtcbiAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldHZhbFxuICAgIGlmKGZsaXApIHtcbiAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgfVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IG9uZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludEZ1bGwoXG4gIGQsIGF4aXMsIHZpc2l0LFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHJlZElkID0gcmVkSW5kZXhbaV1cbiAgICBpZihyZWRJZCA9PT0gYmx1ZUlkKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2F4aXNdXG4gICAgdmFyIHIxID0gcmVkW3JlZFB0citheGlzK2RdXG4gICAgaWYoYmx1ZVggPCByMCB8fCByMSA8IGJsdWVYKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBmb3IodmFyIGo9YXhpcysxOyBqPGQ7ICsraikge1xuICAgICAgdmFyIHIwID0gcmVkW3JlZFB0citqXVxuICAgICAgdmFyIHIxID0gcmVkW3JlZFB0citqK2RdXG4gICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIral1cbiAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citqK2RdXG4gICAgICBpZihyMSA8IGIwIHx8IGIxIDwgcjApIHtcbiAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByZXR2YWxcbiAgICB9XG4gIH1cbn1cblxuLy9UaGUgbWFpbiBib3ggaW50ZXJzZWN0aW9uIHJvdXRpbmVcbmZ1bmN0aW9uIGJveEludGVyc2VjdEl0ZXIoXG4gIGQsIHZpc2l0LCBpbml0RnVsbCxcbiAgeFNpemUsIHhCb3hlcywgeEluZGV4LFxuICB5U2l6ZSwgeUJveGVzLCB5SW5kZXgpIHtcblxuICAvL1Jlc2VydmUgbWVtb3J5IGZvciBzdGFja1xuICBpdGVySW5pdChkLCB4U2l6ZSArIHlTaXplKVxuXG4gIHZhciB0b3AgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgcmV0dmFsXG5cbiAgaXRlclB1c2godG9wKyssXG4gICAgICAwLFxuICAgICAgMCwgeFNpemUsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIGluaXRGdWxsID8gMTYgOiAwLCBcbiAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gIGlmKCFpbml0RnVsbCkge1xuICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHlTaXplLFxuICAgICAgMCwgeFNpemUsXG4gICAgICAxLCBcbiAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gIH1cblxuICB3aGlsZSh0b3AgPiAwKSB7XG4gICAgdG9wICAtPSAxXG5cbiAgICB2YXIgaXB0ciA9IHRvcCAqIElGUkFNRV9TSVpFXG4gICAgdmFyIGF4aXMgICAgICA9IEJPWF9JU1RBQ0tbaXB0cl1cbiAgICB2YXIgcmVkU3RhcnQgID0gQk9YX0lTVEFDS1tpcHRyKzFdXG4gICAgdmFyIHJlZEVuZCAgICA9IEJPWF9JU1RBQ0tbaXB0cisyXVxuICAgIHZhciBibHVlU3RhcnQgPSBCT1hfSVNUQUNLW2lwdHIrM11cbiAgICB2YXIgYmx1ZUVuZCAgID0gQk9YX0lTVEFDS1tpcHRyKzRdXG4gICAgdmFyIHN0YXRlICAgICA9IEJPWF9JU1RBQ0tbaXB0cis1XVxuXG4gICAgdmFyIGRwdHIgPSB0b3AgKiBERlJBTUVfU0laRVxuICAgIHZhciBsbyAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHJdXG4gICAgdmFyIGhpICAgICAgICA9IEJPWF9EU1RBQ0tbZHB0cisxXVxuXG4gICAgLy9VbnBhY2sgc3RhdGUgaW5mb1xuICAgIHZhciBmbGlwICAgICAgPSAoc3RhdGUgJiAxKVxuICAgIHZhciBmdWxsICAgICAgPSAhIShzdGF0ZSAmIDE2KVxuXG4gICAgLy9VbnBhY2sgaW5kaWNlc1xuICAgIHZhciByZWQgICAgICAgPSB4Qm94ZXNcbiAgICB2YXIgcmVkSW5kZXggID0geEluZGV4XG4gICAgdmFyIGJsdWUgICAgICA9IHlCb3hlc1xuICAgIHZhciBibHVlSW5kZXggPSB5SW5kZXhcbiAgICBpZihmbGlwKSB7XG4gICAgICByZWQgICAgICAgICA9IHlCb3hlc1xuICAgICAgcmVkSW5kZXggICAgPSB5SW5kZXhcbiAgICAgIGJsdWUgICAgICAgID0geEJveGVzXG4gICAgICBibHVlSW5kZXggICA9IHhJbmRleFxuICAgIH1cblxuICAgIGlmKHN0YXRlICYgMikge1xuICAgICAgcmVkRW5kID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgaGkpXG4gICAgICBpZihyZWRTdGFydCA+PSByZWRFbmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoc3RhdGUgJiA0KSB7XG4gICAgICByZWRTdGFydCA9IHBhcnRpdGlvbkVuZExlc3NUaGFuRXF1YWwoXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGxvKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciByZWRDb3VudCAgPSByZWRFbmQgIC0gcmVkU3RhcnRcbiAgICB2YXIgYmx1ZUNvdW50ID0gYmx1ZUVuZCAtIGJsdWVTdGFydFxuXG4gICAgaWYoZnVsbCkge1xuICAgICAgaWYoZCAqIHJlZENvdW50ICogKHJlZENvdW50ICsgYmx1ZUNvdW50KSA8IFNDQU5fQ09NUExFVEVfQ1VUT0ZGKSB7XG4gICAgICAgIHJldHZhbCA9IHN3ZWVwLnNjYW5Db21wbGV0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZCAqIE1hdGgubWluKHJlZENvdW50LCBibHVlQ291bnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgc21hbGwsIHRoZW4gdXNlIGJydXRlIGZvcmNlXG4gICAgICAgIHJldHZhbCA9IGJydXRlRm9yY2VQYXJ0aWFsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gICAgICAgICAgICByZWRTdGFydCwgIHJlZEVuZCwgIHJlZCwgIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYoZCAqIHJlZENvdW50ICogYmx1ZUNvdW50IDwgU0NBTl9DVVRPRkYpIHtcbiAgICAgICAgLy9JZiBpbnB1dCBtZWRpdW0gc2l6ZWQsIHRoZW4gdXNlIHN3ZWVwIGFuZCBwcnVuZVxuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQmlwYXJ0aXRlKFxuICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLCBcbiAgICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvL0ZpcnN0LCBmaW5kIGFsbCByZWQgaW50ZXJ2YWxzIHdob3NlIGludGVyaW9yIGNvbnRhaW5zIChsbyxoaSlcbiAgICB2YXIgcmVkMCA9IHBhcnRpdGlvbkludGVyaW9yQ29udGFpbnNJbnRlcnZhbChcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgIGxvLCBoaSlcblxuICAgIC8vTG93ZXIgZGltZW5zaW9uYWwgY2FzZVxuICAgIGlmKHJlZFN0YXJ0IDwgcmVkMCkge1xuXG4gICAgICBpZihkICogKHJlZDAgLSByZWRTdGFydCkgPCBCUlVURV9GT1JDRV9DVVRPRkYpIHtcbiAgICAgICAgLy9TcGVjaWFsIGNhc2UgZm9yIHNtYWxsIGlucHV0czogdXNlIGJydXRlIGZvcmNlXG4gICAgICAgIHJldHZhbCA9IGJydXRlRm9yY2VGdWxsKFxuICAgICAgICAgIGQsIGF4aXMrMSwgdmlzaXQsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgICAgICByZWRTdGFydCwgcmVkMCwgcmVkLCByZWRJbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgfVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcysxLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCxcbiAgICAgICAgICBmbGlwLFxuICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsXG4gICAgICAgICAgZmxpcF4xLFxuICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9EaXZpZGUgYW5kIGNvbnF1ZXIgcGhhc2VcbiAgICBpZihyZWQwIDwgcmVkRW5kKSB7XG5cbiAgICAgIC8vQ3V0IGJsdWUgaW50byAzIHBhcnRzOlxuICAgICAgLy9cbiAgICAgIC8vICBQb2ludHMgPCBtaWQgcG9pbnRcbiAgICAgIC8vICBQb2ludHMgPSBtaWQgcG9pbnRcbiAgICAgIC8vICBQb2ludHMgPiBtaWQgcG9pbnRcbiAgICAgIC8vXG4gICAgICB2YXIgYmx1ZTAgPSBmaW5kTWVkaWFuKFxuICAgICAgICBkLCBheGlzLCBcbiAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICB2YXIgbWlkID0gYmx1ZVtlbGVtU2l6ZSAqIGJsdWUwICsgYXhpc11cbiAgICAgIHZhciBibHVlMSA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIGJsdWUwLCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgIG1pZClcblxuICAgICAgLy9SaWdodCBjYXNlXG4gICAgICBpZihibHVlMSA8IGJsdWVFbmQpIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcyxcbiAgICAgICAgICByZWQwLCByZWRFbmQsXG4gICAgICAgICAgYmx1ZTEsIGJsdWVFbmQsXG4gICAgICAgICAgKGZsaXB8NCkgKyAoZnVsbCA/IDE2IDogMCksXG4gICAgICAgICAgbWlkLCBoaSlcbiAgICAgIH1cblxuICAgICAgLy9MZWZ0IGNhc2VcbiAgICAgIGlmKGJsdWVTdGFydCA8IGJsdWUwKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZTAsXG4gICAgICAgICAgKGZsaXB8MikgKyAoZnVsbCA/IDE2IDogMCksXG4gICAgICAgICAgbG8sIG1pZClcbiAgICAgIH1cblxuICAgICAgLy9DZW50ZXIgY2FzZSAodGhlIGhhcmQgcGFydClcbiAgICAgIGlmKGJsdWUwICsgMSA9PT0gYmx1ZTEpIHtcbiAgICAgICAgLy9PcHRpbWl6YXRpb246IFJhbmdlIHdpdGggZXhhY3RseSAxIHBvaW50LCB1c2UgYSBicnV0ZSBmb3JjZSBzY2FuXG4gICAgICAgIGlmKGZ1bGwpIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludEZ1bGwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHZhbCA9IG9uZVBvaW50UGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZTAsIGJsdWUsIGJsdWVJbmRleFtibHVlMF0pXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihibHVlMCA8IGJsdWUxKSB7XG4gICAgICAgIHZhciByZWQxXG4gICAgICAgIGlmKGZ1bGwpIHtcbiAgICAgICAgICAvL0lmIGZ1bGwgaW50ZXJzZWN0aW9uLCBuZWVkIHRvIGhhbmRsZSBzcGVjaWFsIGNhc2VcbiAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBtaWQpXG4gICAgICAgICAgaWYocmVkMCA8IHJlZDEpIHtcbiAgICAgICAgICAgIHZhciByZWRYID0gcGFydGl0aW9uU3RhcnRFcXVhbChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgICAgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgICAgICAgIC8vRGVnZW5lcmF0ZSBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkMCwgcmVkWF0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWQwIDwgcmVkWCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQ29tcGxldGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZFgsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vTm9ybWFsIHN3ZWVwIGludGVyc2VjdGlvbjpcbiAgICAgICAgICAgICAgLy8gIFtyZWRYLCByZWQxXSB3aXRoIFtibHVlMCwgYmx1ZTFdXG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZFgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICAxNixcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYocmVkWCA8IHJlZDEpIHtcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICAgIHJlZFgsIHJlZDEsXG4gICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludFByb3BlcihcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZDEgPSBwYXJ0aXRpb25Db250YWluc1BvaW50KFxuICAgICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVkMCA8IHJlZDEpIHtcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgcmVkMCwgcmVkMSxcbiAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgZmxpcCxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgZmxpcF4xLFxuICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZmluZE1lZGlhblxuXG52YXIgZ2VuUGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKVxuXG52YXIgcGFydGl0aW9uU3RhcnRMZXNzVGhhbiA9IGdlblBhcnRpdGlvbignbG88cDAnLCBbJ3AwJ10pXG5cbnZhciBQQVJUSVRJT05fVEhSRVNIT0xEID0gOCAgIC8vQ3V0IG9mZiBmb3IgdXNpbmcgaW5zZXJ0aW9uIHNvcnQgaW4gZmluZE1lZGlhblxuXG4vL0Jhc2UgY2FzZSBmb3IgbWVkaWFuIGZpbmRpbmc6ICBVc2UgaW5zZXJ0aW9uIHNvcnRcbmZ1bmN0aW9uIGluc2VydGlvblNvcnQoZCwgYXhpcywgc3RhcnQsIGVuZCwgYm94ZXMsIGlkcykge1xuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYm94UHRyID0gZWxlbVNpemUgKiAoc3RhcnQrMSkgKyBheGlzXG4gIGZvcih2YXIgaT1zdGFydCsxOyBpPGVuZDsgKytpLCBib3hQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHggPSBib3hlc1tib3hQdHJdXG4gICAgZm9yKHZhciBqPWksIHB0cj1lbGVtU2l6ZSooaS0xKTsgXG4gICAgICAgIGo+c3RhcnQgJiYgYm94ZXNbcHRyK2F4aXNdID4geDsgXG4gICAgICAgIC0taiwgcHRyLT1lbGVtU2l6ZSkge1xuICAgICAgLy9Td2FwXG4gICAgICB2YXIgYVB0ciA9IHB0clxuICAgICAgdmFyIGJQdHIgPSBwdHIrZWxlbVNpemVcbiAgICAgIGZvcih2YXIgaz0wOyBrPGVsZW1TaXplOyArK2ssICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICAgIHZhciB5ID0gYm94ZXNbYVB0cl1cbiAgICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgICBib3hlc1tiUHRyXSA9IHlcbiAgICAgIH1cbiAgICAgIHZhciB0bXAgPSBpZHNbal1cbiAgICAgIGlkc1tqXSA9IGlkc1tqLTFdXG4gICAgICBpZHNbai0xXSA9IHRtcFxuICAgIH1cbiAgfVxufVxuXG4vL0ZpbmQgbWVkaWFuIHVzaW5nIHF1aWNrIHNlbGVjdCBhbGdvcml0aG1cbi8vICB0YWtlcyBPKG4pIHRpbWUgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG5mdW5jdGlvbiBmaW5kTWVkaWFuKGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgaWYoZW5kIDw9IHN0YXJ0KzEpIHtcbiAgICByZXR1cm4gc3RhcnRcbiAgfVxuXG4gIHZhciBsbyAgICAgICA9IHN0YXJ0XG4gIHZhciBoaSAgICAgICA9IGVuZFxuICB2YXIgbWlkICAgICAgPSAoKGVuZCArIHN0YXJ0KSA+Pj4gMSlcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBwaXZvdCAgICA9IG1pZFxuICB2YXIgdmFsdWUgICAgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgXG4gIHdoaWxlKGxvIDwgaGkpIHtcbiAgICBpZihoaSAtIGxvIDwgUEFSVElUSU9OX1RIUkVTSE9MRCkge1xuICAgICAgaW5zZXJ0aW9uU29ydChkLCBheGlzLCBsbywgaGksIGJveGVzLCBpZHMpXG4gICAgICB2YWx1ZSA9IGJveGVzW2VsZW1TaXplKm1pZCtheGlzXVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgLy9TZWxlY3QgcGl2b3QgdXNpbmcgbWVkaWFuLW9mLTNcbiAgICB2YXIgY291bnQgID0gaGkgLSBsb1xuICAgIHZhciBwaXZvdDAgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTAgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDAgKyBheGlzXVxuICAgIHZhciBwaXZvdDEgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTEgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDEgKyBheGlzXVxuICAgIHZhciBwaXZvdDIgPSAoTWF0aC5yYW5kb20oKSpjb3VudCtsbyl8MFxuICAgIHZhciB2YWx1ZTIgPSBib3hlc1tlbGVtU2l6ZSpwaXZvdDIgKyBheGlzXVxuICAgIGlmKHZhbHVlMCA8PSB2YWx1ZTEpIHtcbiAgICAgIGlmKHZhbHVlMiA+PSB2YWx1ZTEpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTFcbiAgICAgIH0gZWxzZSBpZih2YWx1ZTAgPj0gdmFsdWUyKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QwXG4gICAgICAgIHZhbHVlID0gdmFsdWUwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXZvdCA9IHBpdm90MlxuICAgICAgICB2YWx1ZSA9IHZhbHVlMlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih2YWx1ZTEgPj0gdmFsdWUyKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUyID49IHZhbHVlMCkge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1N3YXAgcGl2b3QgdG8gZW5kIG9mIGFycmF5XG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vUGFydGl0aW9uIHVzaW5nIHBpdm90XG4gICAgcGl2b3QgPSBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgICAgZCwgYXhpcywgXG4gICAgICBsbywgaGktMSwgYm94ZXMsIGlkcyxcbiAgICAgIHZhbHVlKVxuXG4gICAgLy9Td2FwIHBpdm90IGJhY2tcbiAgICB2YXIgYVB0ciA9IGVsZW1TaXplICogKGhpLTEpXG4gICAgdmFyIGJQdHIgPSBlbGVtU2l6ZSAqIHBpdm90XG4gICAgZm9yKHZhciBpPTA7IGk8ZWxlbVNpemU7ICsraSwgKythUHRyLCArK2JQdHIpIHtcbiAgICAgIHZhciB4ID0gYm94ZXNbYVB0cl1cbiAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgIGJveGVzW2JQdHJdID0geFxuICAgIH1cbiAgICB2YXIgeSA9IGlkc1toaS0xXVxuICAgIGlkc1toaS0xXSA9IGlkc1twaXZvdF1cbiAgICBpZHNbcGl2b3RdID0geVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGxhc3QgcGl2b3RcbiAgICBpZihtaWQgPCBwaXZvdCkge1xuICAgICAgaGkgPSBwaXZvdC0xXG4gICAgICB3aGlsZShsbyA8IGhpICYmIFxuICAgICAgICBib3hlc1tlbGVtU2l6ZSooaGktMSkrYXhpc10gPT09IHZhbHVlKSB7XG4gICAgICAgIGhpIC09IDFcbiAgICAgIH1cbiAgICAgIGhpICs9IDFcbiAgICB9IGVsc2UgaWYocGl2b3QgPCBtaWQpIHtcbiAgICAgIGxvID0gcGl2b3QgKyAxXG4gICAgICB3aGlsZShsbyA8IGhpICYmXG4gICAgICAgIGJveGVzW2VsZW1TaXplKmxvK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBsbyArPSAxXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy9NYWtlIHN1cmUgcGl2b3QgaXMgYXQgc3RhcnRcbiAgcmV0dXJuIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgZCwgYXhpcywgXG4gICAgc3RhcnQsIG1pZCwgYm94ZXMsIGlkcyxcbiAgICBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc10pXG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuUGFydGl0aW9uXG5cbnZhciBjb2RlID0gJ2Zvcih2YXIgaj0yKmEsaz1qKmMsbD1rLG09YyxuPWIsbz1hK2IscD1jO2Q+cDsrK3Asays9ail7dmFyIF87aWYoJClpZihtPT09cCltKz0xLGwrPWo7ZWxzZXtmb3IodmFyIHM9MDtqPnM7KytzKXt2YXIgdD1lW2src107ZVtrK3NdPWVbbF0sZVtsKytdPXR9dmFyIHU9ZltwXTtmW3BdPWZbbV0sZlttKytdPXV9fXJldHVybiBtJ1xuXG5mdW5jdGlvbiBnZW5QYXJ0aXRpb24ocHJlZGljYXRlLCBhcmdzKSB7XG4gIHZhciBmYXJncyA9J2FiY2RlZicuc3BsaXQoJycpLmNvbmNhdChhcmdzKVxuICB2YXIgcmVhZHMgPSBbXVxuICBpZihwcmVkaWNhdGUuaW5kZXhPZignbG8nKSA+PSAwKSB7XG4gICAgcmVhZHMucHVzaCgnbG89ZVtrK25dJylcbiAgfVxuICBpZihwcmVkaWNhdGUuaW5kZXhPZignaGknKSA+PSAwKSB7XG4gICAgcmVhZHMucHVzaCgnaGk9ZVtrK29dJylcbiAgfVxuICBmYXJncy5wdXNoKFxuICAgIGNvZGUucmVwbGFjZSgnXycsIHJlYWRzLmpvaW4oKSlcbiAgICAgICAgLnJlcGxhY2UoJyQnLCBwcmVkaWNhdGUpKVxuICByZXR1cm4gRnVuY3Rpb24uYXBwbHkodm9pZCAwLCBmYXJncylcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBjb2RlIGlzIGV4dHJhY3RlZCBmcm9tIG5kYXJyYXktc29ydFxuLy9JdCBpcyBpbmxpbmVkIGhlcmUgYXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZFxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZXI7XG5cbnZhciBJTlNFUlRfU09SVF9DVVRPRkYgPSAzMlxuXG5mdW5jdGlvbiB3cmFwcGVyKGRhdGEsIG4wKSB7XG4gIGlmIChuMCA8PSA0KklOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoMCwgbjAgLSAxLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoMCwgbjAgLSAxLCBkYXRhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGxlZnQsIHJpZ2h0LCBkYXRhKSB7XG4gIHZhciBwdHIgPSAyKihsZWZ0KzEpXG4gIGZvcih2YXIgaT1sZWZ0KzE7IGk8PXJpZ2h0OyArK2kpIHtcbiAgICB2YXIgYSA9IGRhdGFbcHRyKytdXG4gICAgdmFyIGIgPSBkYXRhW3B0cisrXVxuICAgIHZhciBqID0gaVxuICAgIHZhciBqcHRyID0gcHRyLTJcbiAgICB3aGlsZShqLS0gPiBsZWZ0KSB7XG4gICAgICB2YXIgeCA9IGRhdGFbanB0ci0yXVxuICAgICAgdmFyIHkgPSBkYXRhW2pwdHItMV1cbiAgICAgIGlmKHggPCBhKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYoeCA9PT0gYSAmJiB5IDwgYikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGF0YVtqcHRyXSAgID0geFxuICAgICAgZGF0YVtqcHRyKzFdID0geVxuICAgICAganB0ciAtPSAyXG4gICAgfVxuICAgIGRhdGFbanB0cl0gICA9IGFcbiAgICBkYXRhW2pwdHIrMV0gPSBiXG4gIH1cbn1cblxuZnVuY3Rpb24gc3dhcChpLCBqLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0geFxuICBkYXRhW2orMV0gPSB5XG59XG5cbmZ1bmN0aW9uIG1vdmUoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxufVxuXG5mdW5jdGlvbiByb3RhdGUoaSwgaiwgaywgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGsgKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgdmFyIHkgPSBkYXRhW2krMV1cbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbal0gPSBkYXRhW2tdXG4gIGRhdGFbaisxXSA9IGRhdGFbaysxXVxuICBkYXRhW2tdID0geFxuICBkYXRhW2srMV0gPSB5XG59XG5cbmZ1bmN0aW9uIHNodWZmbGVQaXZvdChpLCBqLCBweCwgcHksIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2pdID0gcHhcbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbaisxXSA9IHB5XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXSxcbiAgICAgIHkgPSBkYXRhW2pdXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZih4ID09PSB5KSB7XG4gICAgcmV0dXJuIGRhdGFbaSsxXSA+IGRhdGFbaisxXVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVQaXZvdChpLCB5LCBiLCBkYXRhKSB7XG4gIGkgKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgaWYoeCA8IHkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPCBiXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHF1aWNrU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgc2l4dGggPSAocmlnaHQgLSBsZWZ0ICsgMSkgLyA2IHwgMCwgXG4gICAgICBpbmRleDEgPSBsZWZ0ICsgc2l4dGgsIFxuICAgICAgaW5kZXg1ID0gcmlnaHQgLSBzaXh0aCwgXG4gICAgICBpbmRleDMgPSBsZWZ0ICsgcmlnaHQgPj4gMSwgXG4gICAgICBpbmRleDIgPSBpbmRleDMgLSBzaXh0aCwgXG4gICAgICBpbmRleDQgPSBpbmRleDMgKyBzaXh0aCwgXG4gICAgICBlbDEgPSBpbmRleDEsIFxuICAgICAgZWwyID0gaW5kZXgyLCBcbiAgICAgIGVsMyA9IGluZGV4MywgXG4gICAgICBlbDQgPSBpbmRleDQsIFxuICAgICAgZWw1ID0gaW5kZXg1LCBcbiAgICAgIGxlc3MgPSBsZWZ0ICsgMSwgXG4gICAgICBncmVhdCA9IHJpZ2h0IC0gMSwgXG4gICAgICB0bXAgPSAwXG4gIGlmKGNvbXBhcmUoZWwxLCBlbDIsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWwyXG4gICAgZWwyID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMSwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMywgZWw0LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsM1xuICAgIGVsMyA9IGVsNFxuICAgIGVsNCA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDIsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDJcbiAgICBlbDIgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsNCwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsNFxuICAgIGVsNCA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG5cbiAgdmFyIHBpdm90MVggPSBkYXRhWzIqZWwyXVxuICB2YXIgcGl2b3QxWSA9IGRhdGFbMiplbDIrMV1cbiAgdmFyIHBpdm90MlggPSBkYXRhWzIqZWw0XVxuICB2YXIgcGl2b3QyWSA9IGRhdGFbMiplbDQrMV1cblxuICB2YXIgcHRyMCA9IDIgKiBlbDE7XG4gIHZhciBwdHIyID0gMiAqIGVsMztcbiAgdmFyIHB0cjQgPSAyICogZWw1O1xuICB2YXIgcHRyNSA9IDIgKiBpbmRleDE7XG4gIHZhciBwdHI2ID0gMiAqIGluZGV4MztcbiAgdmFyIHB0cjcgPSAyICogaW5kZXg1O1xuICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgMjsgKytpMSkge1xuICAgIHZhciB4ID0gZGF0YVtwdHIwK2kxXTtcbiAgICB2YXIgeSA9IGRhdGFbcHRyMitpMV07XG4gICAgdmFyIHogPSBkYXRhW3B0cjQraTFdO1xuICAgIGRhdGFbcHRyNStpMV0gPSB4O1xuICAgIGRhdGFbcHRyNitpMV0gPSB5O1xuICAgIGRhdGFbcHRyNytpMV0gPSB6O1xuICB9XG5cbiAgbW92ZShpbmRleDIsIGxlZnQsIGRhdGEpXG4gIG1vdmUoaW5kZXg0LCByaWdodCwgZGF0YSlcbiAgZm9yICh2YXIgayA9IGxlc3M7IGsgPD0gZ3JlYXQ7ICsraykge1xuICAgIGlmIChjb21wYXJlUGl2b3QoaywgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgIGlmIChrICE9PSBsZXNzKSB7XG4gICAgICAgIHN3YXAoaywgbGVzcywgZGF0YSlcbiAgICAgIH1cbiAgICAgICsrbGVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjb21wYXJlUGl2b3QoaywgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSkpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoIWNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICgtLWdyZWF0IDwgaykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVBpdm90KGdyZWF0LCBwaXZvdDFYLCBwaXZvdDFZLCBkYXRhKSkge1xuICAgICAgICAgICAgICByb3RhdGUoaywgbGVzcywgZ3JlYXQsIGRhdGEpXG4gICAgICAgICAgICAgICsrbGVzcztcbiAgICAgICAgICAgICAgLS1ncmVhdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3YXAoaywgZ3JlYXQsIGRhdGEpXG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2h1ZmZsZVBpdm90KGxlZnQsIGxlc3MtMSwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSlcbiAgc2h1ZmZsZVBpdm90KHJpZ2h0LCBncmVhdCsxLCBwaXZvdDJYLCBwaXZvdDJZLCBkYXRhKVxuICBpZiAobGVzcyAtIDIgLSBsZWZ0IDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydChsZWZ0LCBsZXNzIC0gMiwgZGF0YSk7XG4gIH1cbiAgaWYgKHJpZ2h0IC0gKGdyZWF0ICsgMikgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChncmVhdCArIDIsIHJpZ2h0LCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH1cbiAgaWYgKGdyZWF0IC0gbGVzcyA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVzcywgZ3JlYXQsIGRhdGEpO1xuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiAgICAgICAgICAgc3FJbml0LFxuICBzd2VlcEJpcGFydGl0ZTogc3dlZXBCaXBhcnRpdGUsXG4gIHN3ZWVwQ29tcGxldGU6ICBzd2VlcENvbXBsZXRlLFxuICBzY2FuQmlwYXJ0aXRlOiAgc2NhbkJpcGFydGl0ZSxcbiAgc2NhbkNvbXBsZXRlOiAgIHNjYW5Db21wbGV0ZVxufVxuXG52YXIgcG9vbCAgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIGJpdHMgID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGlzb3J0ID0gcmVxdWlyZSgnLi9zb3J0JylcblxuLy9GbGFnIGZvciBibHVlXG52YXIgQkxVRV9GTEFHID0gKDE8PDI4KVxuXG4vLzFEIHN3ZWVwIGV2ZW50IHF1ZXVlIHN0dWZmICh1c2UgcG9vbCB0byBzYXZlIHNwYWNlKVxudmFyIElOSVRfQ0FQQUNJVFkgICAgICA9IDEwMjRcbnZhciBSRURfU1dFRVBfUVVFVUUgICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgUkVEX1NXRUVQX0lOREVYICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJMVUVfU1dFRVBfUVVFVUUgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX0lOREVYICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQ09NTU9OX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBTV0VFUF9FVkVOVFMgICAgICAgPSBwb29sLm1hbGxvY0RvdWJsZShJTklUX0NBUEFDSVRZICogOClcblxuLy9SZXNlcnZlcyBtZW1vcnkgZm9yIHRoZSAxRCBzd2VlcCBkYXRhIHN0cnVjdHVyZXNcbmZ1bmN0aW9uIHNxSW5pdChjb3VudCkge1xuICB2YXIgcmNvdW50ID0gYml0cy5uZXh0UG93Mihjb3VudClcbiAgaWYoUkVEX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShSRURfU1dFRVBfUVVFVUUpXG4gICAgUkVEX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoUkVEX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShSRURfU1dFRVBfSU5ERVgpXG4gICAgUkVEX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQkxVRV9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQkxVRV9TV0VFUF9RVUVVRSlcbiAgICBCTFVFX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQkxVRV9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQkxVRV9TV0VFUF9JTkRFWClcbiAgICBCTFVFX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQ09NTU9OX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShDT01NT05fU1dFRVBfUVVFVUUpXG4gICAgQ09NTU9OX1NXRUVQX1FVRVVFID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgaWYoQ09NTU9OX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShDT01NT05fU1dFRVBfSU5ERVgpXG4gICAgQ09NTU9OX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihyY291bnQpXG4gIH1cbiAgdmFyIGV2ZW50TGVuZ3RoID0gOCAqIHJjb3VudFxuICBpZihTV0VFUF9FVkVOVFMubGVuZ3RoIDwgZXZlbnRMZW5ndGgpIHtcbiAgICBwb29sLmZyZWUoU1dFRVBfRVZFTlRTKVxuICAgIFNXRUVQX0VWRU5UUyA9IHBvb2wubWFsbG9jRG91YmxlKGV2ZW50TGVuZ3RoKVxuICB9XG59XG5cbi8vUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUG9wKHF1ZXVlLCBpbmRleCwgY291bnQsIGl0ZW0pIHtcbiAgdmFyIGlkeCA9IGluZGV4W2l0ZW1dXG4gIHZhciB0b3AgPSBxdWV1ZVtjb3VudC0xXVxuICBxdWV1ZVtpZHhdID0gdG9wXG4gIGluZGV4W3RvcF0gPSBpZHhcbn1cblxuLy9JbnNlcnQgYW4gaXRlbSBpbnRvIHRoZSBhY3RpdmUgcXVldWUgaW4gTygxKVxuZnVuY3Rpb24gc3FQdXNoKHF1ZXVlLCBpbmRleCwgY291bnQsIGl0ZW0pIHtcbiAgcXVldWVbY291bnRdID0gaXRlbVxuICBpbmRleFtpdGVtXSAgPSBjb3VudFxufVxuXG4vL1JlY3Vyc2lvbiBiYXNlIGNhc2U6IHVzZSAxRCBzd2VlcCBhbGdvcml0aG1cbmZ1bmN0aW9uIHN3ZWVwQmlwYXJ0aXRlKFxuICAgIGQsIHZpc2l0LFxuICAgIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgLy9zdG9yZSBldmVudHMgYXMgcGFpcnMgW2Nvb3JkaW5hdGUsIGlkeF1cbiAgLy9cbiAgLy8gIHJlZCBjcmVhdGU6ICAtKGlkeCsxKVxuICAvLyAgcmVkIGRlc3Ryb3k6IGlkeFxuICAvLyAgYmx1ZSBjcmVhdGU6IC0oaWR4K0JMVUVfRkxBRylcbiAgLy8gIGJsdWUgZGVzdHJveTogaWR4K0JMVUVfRkxBR1xuICAvL1xuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSByZWRJbmRleFtpXVxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtKGlkeCsxKVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gYmx1ZUluZGV4W2ldK0JMVUVfRkxBR1xuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICA9IDBcbiAgdmFyIGJsdWVBY3RpdmUgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgIC8vYmx1ZSBkZXN0cm95IGV2ZW50XG4gICAgICBlID0gKGUtQkxVRV9GTEFHKXwwXG4gICAgICBzcVBvcChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlLS0sIGUpXG4gICAgfSBlbHNlIGlmKGUgPj0gMCkge1xuICAgICAgLy9yZWQgZGVzdHJveSBldmVudFxuICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlIDw9IC1CTFVFX0ZMQUcpIHtcbiAgICAgIC8vYmx1ZSBjcmVhdGUgZXZlbnRcbiAgICAgIGUgPSAoLWUtQkxVRV9GTEFHKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBlKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3FQdXNoKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUrKywgZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy9yZWQgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLTEpfDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPGJsdWVBY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoZSwgQkxVRV9TV0VFUF9RVUVVRVtqXSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGUpXG4gICAgfVxuICB9XG59XG5cbi8vQ29tcGxldGUgc3dlZXBcbmZ1bmN0aW9uIHN3ZWVwQ29tcGxldGUoZCwgdmlzaXQsIFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGQtMVxuICB2YXIgaWVuZCAgICAgPSBlbGVtU2l6ZS0xXG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChyZWRJbmRleFtpXSsxKTw8MVxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAoYmx1ZUluZGV4W2ldKzEpPDwxXG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9ICgtaWR4KXwxXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHh8MVxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIHZhciBibHVlQWN0aXZlICAgPSAwXG4gIHZhciBjb21tb25BY3RpdmUgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlICAgICA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIHZhciBjb2xvciA9IGUmMVxuICAgIGlmKGkgPCBuLTEgJiYgKGU+PjEpID09PSAoU1dFRVBfRVZFTlRTWzIqaSszXT4+MSkpIHtcbiAgICAgIGNvbG9yID0gMlxuICAgICAgaSArPSAxXG4gICAgfVxuICAgIFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICAvL0NyZWF0ZSBldmVudFxuICAgICAgdmFyIGlkID0gLShlPj4xKSAtIDFcblxuICAgICAgLy9JbnRlcnNlY3Qgd2l0aCBjb21tb25cbiAgICAgIGZvcih2YXIgaj0wOyBqPGNvbW1vbkFjdGl2ZTsgKytqKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChDT01NT05fU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMCkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIHJlZFxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChSRURfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yICE9PSAxKSB7XG4gICAgICAgIC8vSW50ZXJzZWN0IHdpdGggYmx1ZVxuICAgICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQkxVRV9TV0VFUF9RVUVVRVtqXSwgaWQpXG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDEpIHtcbiAgICAgICAgLy9CbHVlXG4gICAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAyKSB7XG4gICAgICAgIC8vQm90aFxuICAgICAgICBzcVB1c2goQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZSsrLCBpZClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9EZXN0cm95IGV2ZW50XG4gICAgICB2YXIgaWQgPSAoZT4+MSkgLSAxXG4gICAgICBpZihjb2xvciA9PT0gMCkge1xuICAgICAgICAvL1JlZFxuICAgICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVBvcChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlLS0sIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAyKSB7XG4gICAgICAgIC8vQm90aFxuICAgICAgICBzcVBvcChDT01NT05fU1dFRVBfUVVFVUUsIENPTU1PTl9TV0VFUF9JTkRFWCwgY29tbW9uQWN0aXZlLS0sIGlkKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL1N3ZWVwIGFuZCBwcnVuZS9zY2FubGluZSBhbGdvcml0aG06XG4vLyAgU2NhbiBhbG9uZyBheGlzLCBkZXRlY3QgaW50ZXJzZWN0aW9uc1xuLy8gIEJydXRlIGZvcmNlIGFsbCBib3hlcyBhbG9uZyBheGlzXG5mdW5jdGlvbiBzY2FuQmlwYXJ0aXRlKFxuICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG4gIFxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBheGlzXG4gIHZhciBpZW5kICAgICA9IGF4aXMrZFxuXG4gIHZhciByZWRTaGlmdCAgPSAxXG4gIHZhciBibHVlU2hpZnQgPSAxXG4gIGlmKGZsaXApIHtcbiAgICBibHVlU2hpZnQgPSBCTFVFX0ZMQUdcbiAgfSBlbHNlIHtcbiAgICByZWRTaGlmdCAgPSBCTFVFX0ZMQUdcbiAgfVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgcmVkU2hpZnRcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyBibHVlU2hpZnRcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICB2YXIgaXNSZWQgPSBmYWxzZVxuICAgICAgaWYoaWR4ID49IEJMVUVfRkxBRykge1xuICAgICAgICBpc1JlZCA9ICFmbGlwXG4gICAgICAgIGlkeCAtPSBCTFVFX0ZMQUcgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1JlZCA9ICEhZmxpcFxuICAgICAgICBpZHggLT0gMVxuICAgICAgfVxuICAgICAgaWYoaXNSZWQpIHtcbiAgICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgaWR4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJsdWVJZCAgPSBibHVlSW5kZXhbaWR4XVxuICAgICAgICB2YXIgYmx1ZVB0ciA9IGVsZW1TaXplICogaWR4XG4gICAgICAgIFxuICAgICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIrYXhpcysxXVxuICAgICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIrYXhpcysxK2RdXG5cbnJlZF9sb29wOlxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciBvaWR4ICAgPSBSRURfU1dFRVBfUVVFVUVbal1cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG5cbiAgICAgICAgICBpZihiMSA8IHJlZFtyZWRQdHIrYXhpcysxXSB8fCBcbiAgICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcih2YXIgaz1heGlzKzI7IGs8ZDsgKytrKSB7XG4gICAgICAgICAgICBpZihibHVlW2JsdWVQdHIgKyBrICsgZF0gPCByZWRbcmVkUHRyICsga10gfHwgXG4gICAgICAgICAgICAgICByZWRbcmVkUHRyICsgayArIGRdIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkSWQgID0gcmVkSW5kZXhbb2lkeF1cbiAgICAgICAgICB2YXIgcmV0dmFsXG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmV0dmFsID0gdmlzaXQoYmx1ZUlkLCByZWRJZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWwgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSAtIHJlZFNoaWZ0KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FuQ29tcGxldGUoXG4gIGQsIGF4aXMsIHZpc2l0LFxuICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBheGlzXG4gIHZhciBpZW5kICAgICA9IGF4aXMrZFxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgQkxVRV9GTEFHXG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgMVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgICA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICBpZihlIDwgMCkge1xuICAgICAgdmFyIGlkeCAgID0gLWVcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgUkVEX1NXRUVQX1FVRVVFW3JlZEFjdGl2ZSsrXSA9IGlkeCAtIEJMVUVfRkxBR1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4IC09IDFcbiAgICAgICAgdmFyIGJsdWVJZCAgPSBibHVlSW5kZXhbaWR4XVxuICAgICAgICB2YXIgYmx1ZVB0ciA9IGVsZW1TaXplICogaWR4XG5cbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG5cbiAgICAgICAgICBpZihyZWRJZCA9PT0gYmx1ZUlkKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWRQdHIgPSBlbGVtU2l6ZSAqIG9pZHhcbiAgICAgICAgICBpZihiMSA8IHJlZFtyZWRQdHIrYXhpcysxXSB8fCBcbiAgICAgICAgICAgIHJlZFtyZWRQdHIrYXhpcysxK2RdIDwgYjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcih2YXIgaz1heGlzKzI7IGs8ZDsgKytrKSB7XG4gICAgICAgICAgICBpZihibHVlW2JsdWVQdHIgKyBrICsgZF0gPCByZWRbcmVkUHRyICsga10gfHwgXG4gICAgICAgICAgICAgICByZWRbcmVkUHRyICsgayArIGRdICAgPCBibHVlW2JsdWVQdHIgKyBrXSkge1xuICAgICAgICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWR4ID0gZSAtIEJMVUVfRkxBR1xuICAgICAgZm9yKHZhciBqPXJlZEFjdGl2ZS0xOyBqPj0wOyAtLWopIHtcbiAgICAgICAgaWYoUkVEX1NXRUVQX1FVRVVFW2pdID09PSBpZHgpIHtcbiAgICAgICAgICBmb3IodmFyIGs9aisxOyBrPHJlZEFjdGl2ZTsgKytrKSB7XG4gICAgICAgICAgICBSRURfU1dFRVBfUVVFVUVbay0xXSA9IFJFRF9TV0VFUF9RVUVVRVtrXVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAtLXJlZEFjdGl2ZVxuICAgIH1cbiAgfVxufSIsIi8qKlxuICogQml0IHR3aWRkbGluZyBoYWNrcyBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBBdXRob3I6IE1pa29sYSBMeXNlbmtvXG4gKlxuICogUG9ydGVkIGZyb20gU3RhbmZvcmQgYml0IHR3aWRkbGluZyBoYWNrIGxpYnJhcnk6XG4gKiAgICBodHRwOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxuLy9OdW1iZXIgb2YgYml0cyBpbiBhbiBpbnRlZ2VyXG52YXIgSU5UX0JJVFMgPSAzMjtcblxuLy9Db25zdGFudHNcbmV4cG9ydHMuSU5UX0JJVFMgID0gSU5UX0JJVFM7XG5leHBvcnRzLklOVF9NQVggICA9ICAweDdmZmZmZmZmO1xuZXhwb3J0cy5JTlRfTUlOICAgPSAtMTw8KElOVF9CSVRTLTEpO1xuXG4vL1JldHVybnMgLTEsIDAsICsxIGRlcGVuZGluZyBvbiBzaWduIG9mIHhcbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICh2ID4gMCkgLSAodiA8IDApO1xufVxuXG4vL0NvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGludGVnZXJcbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24odikge1xuICB2YXIgbWFzayA9IHYgPj4gKElOVF9CSVRTLTEpO1xuICByZXR1cm4gKHYgXiBtYXNrKSAtIG1hc2s7XG59XG5cbi8vQ29tcHV0ZXMgbWluaW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHkgXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9Db21wdXRlcyBtYXhpbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geCBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xuZXhwb3J0cy5pc1BvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAhKHYgJiAodi0xKSkgJiYgKCEhdik7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMiBvZiB2XG5leHBvcnRzLmxvZzIgPSBmdW5jdGlvbih2KSB7XG4gIHZhciByLCBzaGlmdDtcbiAgciA9ICAgICAodiA+IDB4RkZGRikgPDwgNDsgdiA+Pj49IHI7XG4gIHNoaWZ0ID0gKHYgPiAweEZGICApIDw8IDM7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4RiAgICkgPDwgMjsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHgzICAgKSA8PCAxOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgKHYgPj4gMSk7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMTAgb2YgdlxuZXhwb3J0cy5sb2cxMCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAodiA+PSAxMDAwMDAwMDAwKSA/IDkgOiAodiA+PSAxMDAwMDAwMDApID8gOCA6ICh2ID49IDEwMDAwMDAwKSA/IDcgOlxuICAgICAgICAgICh2ID49IDEwMDAwMDApID8gNiA6ICh2ID49IDEwMDAwMCkgPyA1IDogKHYgPj0gMTAwMDApID8gNCA6XG4gICAgICAgICAgKHYgPj0gMTAwMCkgPyAzIDogKHYgPj0gMTAwKSA/IDIgOiAodiA+PSAxMCkgPyAxIDogMDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIGJpdHNcbmV4cG9ydHMucG9wQ291bnQgPSBmdW5jdGlvbih2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3Modikge1xuICB2YXIgYyA9IDMyO1xuICB2ICY9IC12O1xuICBpZiAodikgYy0tO1xuICBpZiAodiAmIDB4MDAwMEZGRkYpIGMgLT0gMTY7XG4gIGlmICh2ICYgMHgwMEZGMDBGRikgYyAtPSA4O1xuICBpZiAodiAmIDB4MEYwRjBGMEYpIGMgLT0gNDtcbiAgaWYgKHYgJiAweDMzMzMzMzMzKSBjIC09IDI7XG4gIGlmICh2ICYgMHg1NTU1NTU1NSkgYyAtPSAxO1xuICByZXR1cm4gYztcbn1cbmV4cG9ydHMuY291bnRUcmFpbGluZ1plcm9zID0gY291bnRUcmFpbGluZ1plcm9zO1xuXG4vL1JvdW5kcyB0byBuZXh0IHBvd2VyIG9mIDJcbmV4cG9ydHMubmV4dFBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgKz0gdiA9PT0gMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cblxuLy9Sb3VuZHMgZG93biB0byBwcmV2aW91cyBwb3dlciBvZiAyXG5leHBvcnRzLnByZXZQb3cyID0gZnVuY3Rpb24odikge1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2IC0gKHY+Pj4xKTtcbn1cblxuLy9Db21wdXRlcyBwYXJpdHkgb2Ygd29yZFxuZXhwb3J0cy5wYXJpdHkgPSBmdW5jdGlvbih2KSB7XG4gIHYgXj0gdiA+Pj4gMTY7XG4gIHYgXj0gdiA+Pj4gODtcbiAgdiBePSB2ID4+PiA0O1xuICB2ICY9IDB4ZjtcbiAgcmV0dXJuICgweDY5OTYgPj4+IHYpICYgMTtcbn1cblxudmFyIFJFVkVSU0VfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuKGZ1bmN0aW9uKHRhYikge1xuICBmb3IodmFyIGk9MDsgaTwyNTY7ICsraSkge1xuICAgIHZhciB2ID0gaSwgciA9IGksIHMgPSA3O1xuICAgIGZvciAodiA+Pj49IDE7IHY7IHYgPj4+PSAxKSB7XG4gICAgICByIDw8PSAxO1xuICAgICAgciB8PSB2ICYgMTtcbiAgICAgIC0tcztcbiAgICB9XG4gICAgdGFiW2ldID0gKHIgPDwgcykgJiAweGZmO1xuICB9XG59KShSRVZFUlNFX1RBQkxFKTtcblxuLy9SZXZlcnNlIGJpdHMgaW4gYSAzMiBiaXQgd29yZFxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gIChSRVZFUlNFX1RBQkxFWyB2ICAgICAgICAgJiAweGZmXSA8PCAyNCkgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiA4KSAgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiAxNikgJiAweGZmXSA8PCA4KSAgfFxuICAgICAgICAgICBSRVZFUlNFX1RBQkxFWyh2ID4+PiAyNCkgJiAweGZmXTtcbn1cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMiBjb29yZGluYXRlcyB3aXRoIDE2IGJpdHMuICBVc2VmdWwgZm9yIGZhc3QgcXVhZHRyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHggJj0gMHhGRkZGO1xuICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHkgJj0gMHhGRkZGO1xuICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vRXh0cmFjdHMgdGhlIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnRcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAmIDB4NTU1NTU1NTU7XG4gIHYgPSAodiB8ICh2ID4+PiAxKSkgICYgMHgzMzMzMzMzMztcbiAgdiA9ICh2IHwgKHYgPj4+IDIpKSAgJiAweDBGMEYwRjBGO1xuICB2ID0gKHYgfCAodiA+Pj4gNCkpICAmIDB4MDBGRjAwRkY7XG4gIHYgPSAodiB8ICh2ID4+PiAxNikpICYgMHgwMDBGRkZGO1xuICByZXR1cm4gKHYgPDwgMTYpID4+IDE2O1xufVxuXG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDMgY29vcmRpbmF0ZXMsIGVhY2ggd2l0aCAxMCBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IG9jdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgeCAmPSAweDNGRjtcbiAgeCAgPSAoeCB8ICh4PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeCAgPSAoeCB8ICh4PDw4KSkgICYgMjUxNzE5Njk1O1xuICB4ICA9ICh4IHwgKHg8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB4ICA9ICh4IHwgKHg8PDIpKSAgJiAxMjI3MTMzNTEzO1xuXG4gIHkgJj0gMHgzRkY7XG4gIHkgID0gKHkgfCAoeTw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHkgID0gKHkgfCAoeTw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeSAgPSAoeSB8ICh5PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeSAgPSAoeSB8ICh5PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgeCB8PSAoeSA8PCAxKTtcbiAgXG4gIHogJj0gMHgzRkY7XG4gIHogID0gKHogfCAoejw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHogID0gKHogfCAoejw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeiAgPSAoeiB8ICh6PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeiAgPSAoeiB8ICh6PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgXG4gIHJldHVybiB4IHwgKHogPDwgMik7XG59XG5cbi8vRXh0cmFjdHMgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudCBvZiBhIDMtdHVwbGVcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAgICAgICAmIDEyMjcxMzM1MTM7XG4gIHYgPSAodiB8ICh2Pj4+MikpICAgJiAzMjcyMzU2MDM1O1xuICB2ID0gKHYgfCAodj4+PjQpKSAgICYgMjUxNzE5Njk1O1xuICB2ID0gKHYgfCAodj4+PjgpKSAgICYgNDI3ODE5MDMzNTtcbiAgdiA9ICh2IHwgKHY+Pj4xNikpICAmIDB4M0ZGO1xuICByZXR1cm4gKHY8PDIyKT4+MjI7XG59XG5cbi8vQ29tcHV0ZXMgbmV4dCBjb21iaW5hdGlvbiBpbiBjb2xleGljb2dyYXBoaWMgb3JkZXIgKHRoaXMgaXMgbWlzdGFrZW5seSBjYWxsZWQgbmV4dFBlcm11dGF0aW9uIG9uIHRoZSBiaXQgdHdpZGRsaW5nIGhhY2tzIHBhZ2UpXG5leHBvcnRzLm5leHRDb21iaW5hdGlvbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHQgPSB2IHwgKHYgLSAxKTtcbiAgcmV0dXJuICh0ICsgMSkgfCAoKCh+dCAmIC1+dCkgLSAxKSA+Pj4gKGNvdW50VHJhaWxpbmdaZXJvcyh2KSArIDEpKTtcbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkpIHtcbiAgdmFyIGMgPSBjb3VudFtpXXwwXG4gIGlmKGMgPD0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYyksIGpcbiAgaWYoaSA9PT0gY291bnQubGVuZ3RoLTEpIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKzEpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZV9udW1iZXIoY291bnQsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQsIGlcbiAgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IoaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB2YWx1ZVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZShjb3VudCwgdmFsdWUpIHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsdWUgPSAwXG4gIH1cbiAgc3dpdGNoKHR5cGVvZiBjb3VudCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmKGNvdW50ID4gMCkge1xuICAgICAgICByZXR1cm4gZHVwZV9udW1iZXIoY291bnR8MCwgdmFsdWUpXG4gICAgICB9XG4gICAgYnJlYWtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZih0eXBlb2YgKGNvdW50Lmxlbmd0aCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCAwKVxuICAgICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHVwZSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDE2ICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UOCAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICA6IGR1cChbMzIsIDBdKVxuICAgICwgREFUQSAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICA6IGR1cChbMzIsIDBdKVxuICB9XG59XG5cbnZhciBoYXNVaW50OEMgPSAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJVRkZFUikge1xuICBQT09MLkJVRkZFUiA9IGR1cChbMzIsIDBdKVxufVxuXG4vL05ldyB0ZWNobmlxdWU6IE9ubHkgYWxsb2NhdGUgZnJvbSBBcnJheUJ1ZmZlclZpZXcgYW5kIEJ1ZmZlclxudmFyIERBVEEgICAgPSBQT09MLkRBVEFcbiAgLCBCVUZGRVIgID0gUE9PTC5CVUZGRVJcblxuZXhwb3J0cy5mcmVlID0gZnVuY3Rpb24gZnJlZShhcnJheSkge1xuICBpZihCdWZmZXIuaXNCdWZmZXIoYXJyYXkpKSB7XG4gICAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxuICB9IGVsc2Uge1xuICAgIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgIT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkuYnVmZmVyXG4gICAgfVxuICAgIGlmKCFhcnJheSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoIHx8IGFycmF5LmJ5dGVMZW5ndGhcbiAgICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobil8MFxuICAgIERBVEFbbG9nX25dLnB1c2goYXJyYXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZnJlZUFycmF5QnVmZmVyKGJ1ZmZlcikge1xuICBpZighYnVmZmVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBidWZmZXIubGVuZ3RoIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICBEQVRBW2xvZ19uXS5wdXNoKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gZnJlZVR5cGVkQXJyYXkoYXJyYXkpIHtcbiAgZnJlZUFycmF5QnVmZmVyKGFycmF5LmJ1ZmZlcilcbn1cblxuZXhwb3J0cy5mcmVlVWludDggPVxuZXhwb3J0cy5mcmVlVWludDE2ID1cbmV4cG9ydHMuZnJlZVVpbnQzMiA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQ4Q1tpXS5sZW5ndGggPSAwXG4gICAgREFUQVtpXS5sZW5ndGggPSAwXG4gICAgQlVGRkVSW2ldLmxlbmd0aCA9IDBcbiAgfVxufSIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgMilcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgsIHVuaXRTaXplKSB7XG4gIGlmICh1bml0U2l6ZSkgbGVuZ3RoIC09IGxlbmd0aCAlIHVuaXRTaXplO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICBcInRyYW5zcGFyZW50XCI6IFswLDAsMCwwXSwgXCJhbGljZWJsdWVcIjogWzI0MCwyNDgsMjU1LDFdLFxuICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLDIzNSwyMTUsMV0sIFwiYXF1YVwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyLDFdLCBcImF6dXJlXCI6IFsyNDAsMjU1LDI1NSwxXSxcbiAgXCJiZWlnZVwiOiBbMjQ1LDI0NSwyMjAsMV0sIFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5NiwxXSxcbiAgXCJibGFja1wiOiBbMCwwLDAsMV0sIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwyMzUsMjA1LDFdLFxuICBcImJsdWVcIjogWzAsMCwyNTUsMV0sIFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNiwxXSxcbiAgXCJicm93blwiOiBbMTY1LDQyLDQyLDFdLCBcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzUsMV0sXG4gIFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwLDFdLCBcImNoYXJ0cmV1c2VcIjogWzEyNywyNTUsMCwxXSxcbiAgXCJjaG9jb2xhdGVcIjogWzIxMCwxMDUsMzAsMV0sIFwiY29yYWxcIjogWzI1NSwxMjcsODAsMV0sXG4gIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwxNDksMjM3LDFdLCBcImNvcm5zaWxrXCI6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgXCJjcmltc29uXCI6IFsyMjAsMjAsNjAsMV0sIFwiY3lhblwiOiBbMCwyNTUsMjU1LDFdLFxuICBcImRhcmtibHVlXCI6IFswLDAsMTM5LDFdLCBcImRhcmtjeWFuXCI6IFswLDEzOSwxMzksMV0sXG4gIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMSwxXSwgXCJkYXJrZ3JheVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2dyZWVuXCI6IFswLDEwMCwwLDFdLCBcImRhcmtncmV5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3LDFdLCBcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzksMV0sXG4gIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LDEwNyw0NywxXSwgXCJkYXJrb3JhbmdlXCI6IFsyNTUsMTQwLDAsMV0sXG4gIFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNCwxXSwgXCJkYXJrcmVkXCI6IFsxMzksMCwwLDFdLFxuICBcImRhcmtzYWxtb25cIjogWzIzMywxNTAsMTIyLDFdLCBcImRhcmtzZWFncmVlblwiOiBbMTQzLDE4OCwxNDMsMV0sXG4gIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5LDFdLCBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LDc5LDc5LDFdLFxuICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LDc5LDc5LDFdLCBcImRhcmt0dXJxdW9pc2VcIjogWzAsMjA2LDIwOSwxXSxcbiAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsMCwyMTEsMV0sIFwiZGVlcHBpbmtcIjogWzI1NSwyMCwxNDcsMV0sXG4gIFwiZGVlcHNreWJsdWVcIjogWzAsMTkxLDI1NSwxXSwgXCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNSwxXSxcbiAgXCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNSwxXSwgXCJkb2RnZXJibHVlXCI6IFszMCwxNDQsMjU1LDFdLFxuICBcImZpcmVicmlja1wiOiBbMTc4LDM0LDM0LDFdLCBcImZsb3JhbHdoaXRlXCI6IFsyNTUsMjUwLDI0MCwxXSxcbiAgXCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0LDFdLCBcImZ1Y2hzaWFcIjogWzI1NSwwLDI1NSwxXSxcbiAgXCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwLDFdLCBcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1LDFdLFxuICBcImdvbGRcIjogWzI1NSwyMTUsMCwxXSwgXCJnb2xkZW5yb2RcIjogWzIxOCwxNjUsMzIsMV0sXG4gIFwiZ3JheVwiOiBbMTI4LDEyOCwxMjgsMV0sIFwiZ3JlZW5cIjogWzAsMTI4LDAsMV0sXG4gIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywyNTUsNDcsMV0sIFwiZ3JleVwiOiBbMTI4LDEyOCwxMjgsMV0sXG4gIFwiaG9uZXlkZXdcIjogWzI0MCwyNTUsMjQwLDFdLCBcImhvdHBpbmtcIjogWzI1NSwxMDUsMTgwLDFdLFxuICBcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyLDFdLCBcImluZGlnb1wiOiBbNzUsMCwxMzAsMV0sXG4gIFwiaXZvcnlcIjogWzI1NSwyNTUsMjQwLDFdLCBcImtoYWtpXCI6IFsyNDAsMjMwLDE0MCwxXSxcbiAgXCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTAsMV0sIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LDI0MCwyNDUsMV0sXG4gIFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDAsMV0sIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsMjUwLDIwNSwxXSxcbiAgXCJsaWdodGJsdWVcIjogWzE3MywyMTYsMjMwLDFdLCBcImxpZ2h0Y29yYWxcIjogWzI0MCwxMjgsMTI4LDFdLFxuICBcImxpZ2h0Y3lhblwiOiBbMjI0LDI1NSwyNTUsMV0sIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwLDFdLFxuICBcImxpZ2h0Z3JheVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRncmVlblwiOiBbMTQ0LDIzOCwxNDQsMV0sXG4gIFwibGlnaHRncmV5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzLDFdLFxuICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMiwxXSwgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwxNzgsMTcwLDFdLFxuICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTAsMV0sIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwxMzYsMTUzLDFdLFxuICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksMTM2LDE1MywxXSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjIsMV0sXG4gIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwyNTUsMjI0LDFdLCBcImxpbWVcIjogWzAsMjU1LDAsMV0sXG4gIFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTAsMV0sIFwibGluZW5cIjogWzI1MCwyNDAsMjMwLDFdLFxuICBcIm1hZ2VudGFcIjogWzI1NSwwLDI1NSwxXSwgXCJtYXJvb25cIjogWzEyOCwwLDAsMV0sXG4gIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLDIwNSwxNzAsMV0sIFwibWVkaXVtYmx1ZVwiOiBbMCwwLDIwNSwxXSxcbiAgXCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTEsMV0sIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsMTEyLDIxOSwxXSxcbiAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsMTc5LDExMywxXSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywxMDQsMjM4LDFdLFxuICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTQsMV0sIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwyMDksMjA0LDFdLFxuICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LDIxLDEzMywxXSwgXCJtaWRuaWdodGJsdWVcIjogWzI1LDI1LDExMiwxXSxcbiAgXCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwLDFdLCBcIm1pc3R5cm9zZVwiOiBbMjU1LDIyOCwyMjUsMV0sXG4gIFwibW9jY2FzaW5cIjogWzI1NSwyMjgsMTgxLDFdLCBcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3MywxXSxcbiAgXCJuYXZ5XCI6IFswLDAsMTI4LDFdLCBcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwLDFdLFxuICBcIm9saXZlXCI6IFsxMjgsMTI4LDAsMV0sIFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1LDFdLFxuICBcIm9yYW5nZVwiOiBbMjU1LDE2NSwwLDFdLCBcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDAsMV0sXG4gIFwib3JjaGlkXCI6IFsyMTgsMTEyLDIxNCwxXSwgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MCwxXSxcbiAgXCJwYWxlZ3JlZW5cIjogWzE1MiwyNTEsMTUyLDFdLCBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwyMzgsMjM4LDFdLFxuICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwxMTIsMTQ3LDFdLCBcInBhcGF5YXdoaXBcIjogWzI1NSwyMzksMjEzLDFdLFxuICBcInBlYWNocHVmZlwiOiBbMjU1LDIxOCwxODUsMV0sIFwicGVydVwiOiBbMjA1LDEzMyw2MywxXSxcbiAgXCJwaW5rXCI6IFsyNTUsMTkyLDIwMywxXSwgXCJwbHVtXCI6IFsyMjEsMTYwLDIyMSwxXSxcbiAgXCJwb3dkZXJibHVlXCI6IFsxNzYsMjI0LDIzMCwxXSwgXCJwdXJwbGVcIjogWzEyOCwwLDEyOCwxXSxcbiAgXCJyZWRcIjogWzI1NSwwLDAsMV0sIFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0MywxXSxcbiAgXCJyb3lhbGJsdWVcIjogWzY1LDEwNSwyMjUsMV0sIFwic2FkZGxlYnJvd25cIjogWzEzOSw2OSwxOSwxXSxcbiAgXCJzYWxtb25cIjogWzI1MCwxMjgsMTE0LDFdLCBcInNhbmR5YnJvd25cIjogWzI0NCwxNjQsOTYsMV0sXG4gIFwic2VhZ3JlZW5cIjogWzQ2LDEzOSw4NywxXSwgXCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzgsMV0sXG4gIFwic2llbm5hXCI6IFsxNjAsODIsNDUsMV0sIFwic2lsdmVyXCI6IFsxOTIsMTkyLDE5MiwxXSxcbiAgXCJza3libHVlXCI6IFsxMzUsMjA2LDIzNSwxXSwgXCJzbGF0ZWJsdWVcIjogWzEwNiw5MCwyMDUsMV0sXG4gIFwic2xhdGVncmF5XCI6IFsxMTIsMTI4LDE0NCwxXSwgXCJzbGF0ZWdyZXlcIjogWzExMiwxMjgsMTQ0LDFdLFxuICBcInNub3dcIjogWzI1NSwyNTAsMjUwLDFdLCBcInNwcmluZ2dyZWVuXCI6IFswLDI1NSwxMjcsMV0sXG4gIFwic3RlZWxibHVlXCI6IFs3MCwxMzAsMTgwLDFdLCBcInRhblwiOiBbMjEwLDE4MCwxNDAsMV0sXG4gIFwidGVhbFwiOiBbMCwxMjgsMTI4LDFdLCBcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2LDFdLFxuICBcInRvbWF0b1wiOiBbMjU1LDk5LDcxLDFdLCBcInR1cnF1b2lzZVwiOiBbNjQsMjI0LDIwOCwxXSxcbiAgXCJ2aW9sZXRcIjogWzIzOCwxMzAsMjM4LDFdLCBcIndoZWF0XCI6IFsyNDUsMjIyLDE3OSwxXSxcbiAgXCJ3aGl0ZVwiOiBbMjU1LDI1NSwyNTUsMV0sIFwid2hpdGVzbW9rZVwiOiBbMjQ1LDI0NSwyNDUsMV0sXG4gIFwieWVsbG93XCI6IFsyNTUsMjU1LDAsMV0sIFwieWVsbG93Z3JlZW5cIjogWzE1NCwyMDUsNTAsMV19XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUludChzdHIpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSB7XG4gIGlmIChoIDwgMCkgaCArPSAxO1xuICBlbHNlIGlmIChoID4gMSkgaCAtPSAxO1xuXG4gIGlmIChoICogNiA8IDEpIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICBpZiAoaCAqIDIgPCAxKSByZXR1cm4gbTI7XG4gIGlmIChoICogMyA8IDIpIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDU1NDb2xvcihjc3Nfc3RyKSB7XG4gIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICB2YXIgc3RyID0gY3NzX3N0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cblxuICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKChpdiAmIDB4ZjAwKSA+PiA0KSB8ICgoaXYgJiAweGYwMCkgPj4gOCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZjApIHwgKChpdiAmIDB4ZjApID4+IDQpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXG4gICAgICAgICAgICAgIDFdO1xuICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCsxLCBlcC0ob3ArMSkpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gW3BhcnNlX2Nzc19pbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KHBhcmFtc1swXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzJdKTtcbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gICAgICAgIHJldHVybiBbY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKzEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaC0xLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudHJ5IHsgZXhwb3J0cy5wYXJzZUNTU0NvbG9yID0gcGFyc2VDU1NDb2xvciB9IGNhdGNoKGUpIHsgfVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KHBvaW50cykge1xuXG4gICAgdmFyIG91dGVyTm9kZSA9IGxpbmtlZExpc3QocG9pbnRzWzBdLCB0cnVlKSxcbiAgICAgICAgbm9kZSwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgc2l6ZSxcbiAgICAgICAgbGVuID0gMCxcbiAgICAgICAgdGhyZXNob2xkID0gODA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgbGVuIDwgdGhyZXNob2xkICYmIGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIGxlbiArPSBwb2ludHNbaV0ubGVuZ3RoO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGxlbiA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgbm9kZSA9IG91dGVyTm9kZS5uZXh0O1xuICAgICAgICBtaW5YID0gbWF4WCA9IG5vZGUucFswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBub2RlLnBbMV07XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHggPSBub2RlLnBbMF07XG4gICAgICAgICAgICB5ID0gbm9kZS5wWzFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKG5vZGUgIT09IG91dGVyTm9kZSk7XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgc2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhwb2ludHMsIG91dGVyTm9kZSk7XG5cbiAgICB2YXIgdHJpYW5nbGVzID0gW107XG4gICAgaWYgKG91dGVyTm9kZSkgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChwb2ludHMsIGNsb2Nrd2lzZSkge1xuICAgIHZhciBzdW0gPSAwLFxuICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBpLCBqLCBsYXN0O1xuXG4gICAgLy8gY2FsY3VsYXRlIG9yaWdpbmFsIHdpbmRpbmcgb3JkZXIgb2YgYSBwb2x5Z29uIHJpbmdcbiAgICBmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICB2YXIgcDEgPSBwb2ludHNbaV0sXG4gICAgICAgICAgICBwMiA9IHBvaW50c1tqXTtcbiAgICAgICAgc3VtICs9IChwMlswXSAtIHAxWzBdKSAqIChwMVsxXSArIHAyWzFdKTtcbiAgICB9XG5cbiAgICAvLyBsaW5rIHBvaW50cyBpbnRvIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc3VtID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSBsYXN0ID0gaW5zZXJ0Tm9kZShwb2ludHNbaV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBsYXN0ID0gaW5zZXJ0Tm9kZShwb2ludHNbaV0sIGxhc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQpIHtcbiAgICAvLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuICAgIHZhciBub2RlID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoZXF1YWxzKG5vZGUucCwgbm9kZS5uZXh0LnApIHx8IG9yaWVudChub2RlLnByZXYucCwgbm9kZS5wLCBub2RlLm5leHQucCkgPT09IDApIHtcblxuICAgICAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcblxuICAgICAgICAgICAgaWYgKG5vZGUucHJldlopIG5vZGUucHJldloubmV4dFogPSBub2RlLm5leHRaO1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFopIG5vZGUubmV4dFoucHJldlogPSBub2RlLnByZXZaO1xuXG4gICAgICAgICAgICBub2RlID0gc3RhcnQgPSBub2RlLnByZXY7XG5cbiAgICAgICAgICAgIGlmIChub2RlID09PSBub2RlLm5leHQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgbm9kZSAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIHN0YXJ0O1xufVxuXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUsIHNlY29uZFBhc3MpIHtcbiAgICBlYXIgPSBmaWx0ZXJQb2ludHMoZWFyKTtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgaWYgKCFzZWNvbmRQYXNzICYmIG1pblggIT09IHVuZGVmaW5lZCkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpc0VhcihlYXIsIG1pblgsIG1pblksIHNpemUpKSB7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LnAsIGVhci5wLCBuZXh0LnApO1xuXG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcblxuICAgICAgICAgICAgaWYgKGVhci5wcmV2WikgZWFyLnByZXZaLm5leHRaID0gZWFyLm5leHRaO1xuICAgICAgICAgICAgaWYgKGVhci5uZXh0WikgZWFyLm5leHRaLnByZXZaID0gZWFyLnByZXZaO1xuXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzLCB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgY3V0dGluZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFzZWNvbmRQYXNzKSBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUsIHRydWUpO1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIGVsc2Ugc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRWFyKGVhciwgbWluWCwgbWluWSwgc2l6ZSkge1xuXG4gICAgdmFyIGEgPSBlYXIucHJldi5wLFxuICAgICAgICBiID0gZWFyLnAsXG4gICAgICAgIGMgPSBlYXIubmV4dC5wLFxuXG4gICAgICAgIGF4ID0gYVswXSwgYnggPSBiWzBdLCBjeCA9IGNbMF0sXG4gICAgICAgIGF5ID0gYVsxXSwgYnkgPSBiWzFdLCBjeSA9IGNbMV0sXG5cbiAgICAgICAgYWJkID0gYXggKiBieSAtIGF5ICogYngsXG4gICAgICAgIGFjZCA9IGF4ICogY3kgLSBheSAqIGN4LFxuICAgICAgICBjYmQgPSBjeCAqIGJ5IC0gY3kgKiBieCxcbiAgICAgICAgQSA9IGFiZCAtIGFjZCAtIGNiZDtcblxuICAgIGlmIChBIDw9IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG5cbiAgICB2YXIgY2F5ID0gY3kgLSBheSxcbiAgICAgICAgYWN4ID0gYXggLSBjeCxcbiAgICAgICAgYWJ5ID0gYXkgLSBieSxcbiAgICAgICAgYmF4ID0gYnggLSBheCxcbiAgICAgICAgcCwgcHgsIHB5LCBzLCB0LCBrLCBub2RlO1xuXG4gICAgLy8gaWYgd2UgdXNlIHotb3JkZXIgY3VydmUgaGFzaGluZywgaXRlcmF0ZSB0aHJvdWdoIHRoZSBjdXJ2ZVxuICAgIGlmIChtaW5YICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgICAgICB2YXIgbWluVFggPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgICAgICBtaW5UWSA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgICAgIG1heFRYID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICAgICAgbWF4VFkgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSksXG5cbiAgICAgICAgICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgICAgICAgICBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgc2l6ZSksXG4gICAgICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICAgICAgLy8gZmlyc3QgbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgICAgIG5vZGUgPSBlYXIubmV4dFo7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS56IDw9IG1heFopIHtcbiAgICAgICAgICAgIHAgPSBub2RlLnA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0WjtcbiAgICAgICAgICAgIGlmIChwID09PSBhIHx8IHAgPT09IGMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBweCA9IHBbMF07XG4gICAgICAgICAgICBweSA9IHBbMV07XG5cbiAgICAgICAgICAgIHMgPSBjYXkgKiBweCArIGFjeCAqIHB5IC0gYWNkO1xuICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSBhYnkgKiBweCArIGJheCAqIHB5ICsgYWJkO1xuICAgICAgICAgICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEEgLSBzIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChrID49IDApICYmICgocyAmJiB0KSB8fCAocyAmJiBrKSB8fCAodCAmJiBrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICAgICAgbm9kZSA9IGVhci5wcmV2WjtcblxuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlLnogPj0gbWluWikge1xuICAgICAgICAgICAgcCA9IG5vZGUucDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnByZXZaO1xuICAgICAgICAgICAgaWYgKHAgPT09IGEgfHwgcCA9PT0gYykgY29udGludWU7XG5cbiAgICAgICAgICAgIHB4ID0gcFswXTtcbiAgICAgICAgICAgIHB5ID0gcFsxXTtcblxuICAgICAgICAgICAgcyA9IGNheSAqIHB4ICsgYWN4ICogcHkgLSBhY2Q7XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IGFieSAqIHB4ICsgYmF4ICogcHkgKyBhYmQ7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gQSAtIHMgLSB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGsgPj0gMCkgJiYgKChzICYmIHQpIHx8IChzICYmIGspIHx8ICh0ICYmIGspKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgdXNlIHotb3JkZXIgY3VydmUgaGFzaCwgc2ltcGx5IGl0ZXJhdGUgdGhyb3VnaCBhbGwgb3RoZXIgcG9pbnRzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IGVhci5wcmV2KSB7XG4gICAgICAgICAgICBwID0gbm9kZS5wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcblxuICAgICAgICAgICAgcHggPSBwWzBdO1xuICAgICAgICAgICAgcHkgPSBwWzFdO1xuXG4gICAgICAgICAgICBzID0gY2F5ICogcHggKyBhY3ggKiBweSAtIGFjZDtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gYWJ5ICogcHggKyBiYXggKiBweSArIGFiZDtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBBIC0gcyAtIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoayA+PSAwKSAmJiAoKHMgJiYgdCkgfHwgKHMgJiYgaykgfHwgKHQgJiYgaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICAvLyBmaW5kIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKHBvaW50cywgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZmlsdGVyUG9pbnRzKGxpbmtlZExpc3QocG9pbnRzW2ldLCBmYWxzZSkpO1xuICAgICAgICBpZiAobGlzdCkgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlTm9kZSwgb3V0ZXJOb2RlKSB7XG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZU5vZGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKG91dGVyTm9kZSkgc3BsaXRQb2x5Z29uKGhvbGVOb2RlLCBvdXRlck5vZGUpO1xufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlTm9kZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIG5vZGUgPSBvdXRlck5vZGUsXG4gICAgICAgIHAgPSBob2xlTm9kZS5wLFxuICAgICAgICBweCA9IHBbMF0sXG4gICAgICAgIHB5ID0gcFsxXSxcbiAgICAgICAgcU1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgbU5vZGUsIGEsIGI7XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgYSA9IG5vZGUucDtcbiAgICAgICAgYiA9IG5vZGUubmV4dC5wO1xuXG4gICAgICAgIGlmIChweSA8PSBhWzFdICYmIHB5ID49IGJbMV0pIHtcbiAgICAgICAgICAgIHZhciBxeCA9IGFbMF0gKyAocHkgLSBhWzFdKSAqIChiWzBdIC0gYVswXSkgLyAoYlsxXSAtIGFbMV0pO1xuICAgICAgICAgICAgaWYgKHF4IDw9IHB4ICYmIHF4ID4gcU1heCkge1xuICAgICAgICAgICAgICAgIHFNYXggPSBxeDtcbiAgICAgICAgICAgICAgICBtTm9kZSA9IGFbMF0gPCBiWzBdID8gbm9kZSA6IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW1Ob2RlKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBzdHJpY3RseSBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIGJ4ID0gbU5vZGUucFswXSxcbiAgICAgICAgYnkgPSBtTm9kZS5wWzFdLFxuICAgICAgICBwYmQgPSBweCAqIGJ5IC0gcHkgKiBieCxcbiAgICAgICAgcGNkID0gcHggKiBweSAtIHB5ICogcU1heCxcbiAgICAgICAgY3B5ID0gcHkgLSBweSxcbiAgICAgICAgcGN4ID0gcHggLSBxTWF4LFxuICAgICAgICBwYnkgPSBweSAtIGJ5LFxuICAgICAgICBicHggPSBieCAtIHB4LFxuICAgICAgICBBID0gcGJkIC0gcGNkIC0gKHFNYXggKiBieSAtIHB5ICogYngpLFxuICAgICAgICBzaWduID0gQSA8PSAwID8gLTEgOiAxLFxuICAgICAgICBzdG9wID0gbU5vZGUsXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICBteCwgbXksIGFteCwgcywgdCwgdGFuO1xuXG4gICAgbm9kZSA9IG1Ob2RlLm5leHQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gc3RvcCkge1xuXG4gICAgICAgIG14ID0gbm9kZS5wWzBdO1xuICAgICAgICBteSA9IG5vZGUucFsxXTtcbiAgICAgICAgYW14ID0gcHggLSBteDtcblxuICAgICAgICBpZiAoYW14ID49IDAgJiYgbXggPj0gYngpIHtcbiAgICAgICAgICAgIHMgPSAoY3B5ICogbXggKyBwY3ggKiBteSAtIHBjZCkgKiBzaWduO1xuICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSAocGJ5ICogbXggKyBicHggKiBteSArIHBiZCkgKiBzaWduO1xuXG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gMCAmJiBBICogc2lnbiAtIHMgLSB0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMocHkgLSBteSkgLyBhbXg7IC8vIHRhbmdlbnRpYWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhbiA8IHRhbk1pbiAmJiBsb2NhbGx5SW5zaWRlKG5vZGUsIGhvbGVOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbU5vZGU7XG59XG5cbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0O1xuXG4gICAgZG8ge1xuICAgICAgICBub2RlLnogPSBub2RlLnogfHwgek9yZGVyKG5vZGUucFswXSwgbm9kZS5wWzFdLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgbm9kZS5wcmV2WiA9IG5vZGUucHJldjtcbiAgICAgICAgbm9kZS5uZXh0WiA9IG5vZGUubmV4dDtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBzdGFydCk7XG5cbiAgICBub2RlLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBub2RlLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQobm9kZSk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFTaXplID09PSAwIHx8ICFxKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHAueiA8PSBxLnopIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuXG4gICAgICAgIGlmIChudW1NZXJnZXMgPD0gMSkgcmV0dXJuIGxpc3Q7XG5cbiAgICAgICAgaW5TaXplICo9IDI7XG4gICAgfVxufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byAoMC4uMTAwMCkgaW50ZWdlciByYW5nZVxuICAgIHggPSAxMDAwICogKHggLSBtaW5YKSAvIHNpemU7XG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAxMDAwICogKHkgLSBtaW5ZKSAvIHNpemU7XG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChub2RlLnBbMF0gPCBsZWZ0bW9zdC5wWzBdKSBsZWZ0bW9zdCA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYS5wLCBiLnApICYmXG4gICAgICAgICAgIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJlxuICAgICAgICAgICBtaWRkbGVJbnNpZGUoYSwgYS5wLCBiLnApO1xufVxuXG4vLyB3aW5kaW5nIG9yZGVyIG9mIHRyaWFuZ2xlIGZvcm1lZCBieSAzIGdpdmVuIHBvaW50c1xuZnVuY3Rpb24gb3JpZW50KHAsIHEsIHIpIHtcbiAgICB2YXIgbyA9IChxWzFdIC0gcFsxXSkgKiAoclswXSAtIHFbMF0pIC0gKHFbMF0gLSBwWzBdKSAqIChyWzFdIC0gcVsxXSk7XG4gICAgcmV0dXJuIG8gPiAwID8gMSA6XG4gICAgICAgICAgIG8gPCAwID8gLTEgOiAwO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxWzBdID09PSBwMlswXSAmJiBwMVsxXSA9PT0gcDJbMV07XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICByZXR1cm4gb3JpZW50KHAxLCBxMSwgcDIpICE9PSBvcmllbnQocDEsIHExLCBxMikgJiZcbiAgICAgICAgICAgb3JpZW50KHAyLCBxMiwgcDEpICE9PSBvcmllbnQocDIsIHEyLCBxMSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihzdGFydCwgYSwgYikge1xuICAgIHZhciBub2RlID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgcDEgPSBub2RlLnAsXG4gICAgICAgICAgICBwMiA9IG5vZGUubmV4dC5wO1xuXG4gICAgICAgIGlmIChwMSAhPT0gYSAmJiBwMiAhPT0gYSAmJiBwMSAhPT0gYiAmJiBwMiAhPT0gYiAmJiBpbnRlcnNlY3RzKHAxLCBwMiwgYSwgYikpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBvcmllbnQoYS5wcmV2LnAsIGEucCwgYS5uZXh0LnApID09PSAtMSA/XG4gICAgICAgIG9yaWVudChhLnAsIGIucCwgYS5uZXh0LnApICE9PSAtMSAmJiBvcmllbnQoYS5wLCBhLnByZXYucCwgYi5wKSAhPT0gLTEgOlxuICAgICAgICBvcmllbnQoYS5wLCBiLnAsIGEucHJldi5wKSA9PT0gLTEgfHwgb3JpZW50KGEucCwgYS5uZXh0LnAsIGIucCkgPT09IC0xO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShzdGFydCwgYSwgYikge1xuICAgIHZhciBub2RlID0gc3RhcnQsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhWzBdICsgYlswXSkgLyAyLFxuICAgICAgICBweSA9IChhWzFdICsgYlsxXSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHAxID0gbm9kZS5wLFxuICAgICAgICAgICAgcDIgPSBub2RlLm5leHQucDtcblxuICAgICAgICBpZiAoKChwMVsxXSA+IHB5KSAhPT0gKHAyWzFdID4gcHkpKSAmJlxuICAgICAgICAgICAgKHB4IDwgKHAyWzBdIC0gcDFbMF0pICogKHB5IC0gcDFbMV0pIC8gKHAyWzFdIC0gcDFbMV0pICsgcDFbMF0pKSBpbnNpZGUgPSAhaW5zaWRlO1xuXG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnBbMF0gLSBiLnBbMF07XG59XG5cbi8vIHNwbGl0IHRoZSBwb2x5Z29uIHZlcnRpY2VzIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlua2VkIGxpc3QgaW50byB0d29cbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5wKSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLnApLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYTI7XG59XG5cbmZ1bmN0aW9uIGluc2VydE5vZGUocG9pbnQsIGxhc3QpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKHBvaW50KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBub2RlLnByZXYgPSBub2RlO1xuICAgICAgICBub2RlLm5leHQgPSBub2RlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBub2RlLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IG5vZGU7XG4gICAgICAgIGxhc3QubmV4dCA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBOb2RlKHApIHtcbiAgICB0aGlzLnAgPSBwO1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIHRoaXMueiA9IG51bGw7XG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG59XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjIuMVxuICovXG5cbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG5cbihmdW5jdGlvbihfZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBzaGltID0ge307XG4gIGlmICh0eXBlb2YoZXhwb3J0cykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHt9O1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2hpbS5leHBvcnRzO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBhIGJyb3dzZXIsIGRlZmluZSBpdHMgbmFtZXNwYWNlcyBpbiBnbG9iYWxcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IF9nbG9iYWw7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBjb21tb25qcywgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGV4cG9ydHNcbiAgICBzaGltLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9XG5cbiAgKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICAvKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG5cbmlmKCFHTE1BVF9FUFNJTE9OKSB7XG4gICAgdmFyIEdMTUFUX0VQU0lMT04gPSAwLjAwMDAwMTtcbn1cblxuaWYoIUdMTUFUX0FSUkFZX1RZUEUpIHtcbiAgICB2YXIgR0xNQVRfQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbn1cblxuaWYoIUdMTUFUX1JBTkRPTSkge1xuICAgIHZhciBHTE1BVF9SQU5ET00gPSBNYXRoLnJhbmRvbTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgQ29tbW9uIHV0aWxpdGllc1xuICogQG5hbWUgZ2xNYXRyaXhcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2llc1xuICpcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgR0xNQVRfQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLmdsTWF0cml4ID0gZ2xNYXRyaXg7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBBbmdsZSBpbiBEZWdyZWVzXG4qL1xuZ2xNYXRyaXgudG9SYWRpYW4gPSBmdW5jdGlvbihhKXtcbiAgICAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjMlxuICovXG5cbnZhciB2ZWMyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMi5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICAgIHZhciByID0gR0xNQVRfUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDIgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzIgPSB2ZWMyO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzNcbiAqL1xuXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnN1YiA9IHZlYzMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubXVsID0gdmVjMy5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpc3QgPSB2ZWMzLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubGVuID0gdmVjMy5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMzLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICB2YXIgciA9IEdMTUFUX1JBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICB2YXIgeiA9IChHTE1BVF9SQU5ET00oKSAqIDIuMCkgLSAxLjA7XG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlO1xuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gICAgb3V0WzJdID0geiAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM107XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qXG4qIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4qIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiovXG52ZWMzLnJvdGF0ZVggPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICAgdmFyIHAgPSBbXSwgcj1bXTtcblx0ICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cdCAgcFswXSA9IGFbMF0gLSBiWzBdO1xuXHQgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG5cblx0ICAvL3BlcmZvcm0gcm90YXRpb25cblx0ICByWzBdID0gcFswXTtcblx0ICByWzFdID0gcFsxXSpNYXRoLmNvcyhjKSAtIHBbMl0qTWF0aC5zaW4oYyk7XG5cdCAgclsyXSA9IHBbMV0qTWF0aC5zaW4oYykgKyBwWzJdKk1hdGguY29zKGMpO1xuXG5cdCAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXHQgIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuXHQgIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuXHQgIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qXG4qIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4qIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKlxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4qIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4qIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuKiBAcmV0dXJucyB7dmVjM30gb3V0XG4qL1xudmVjMy5yb3RhdGVaID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICBcdHJbMV0gPSBwWzBdKk1hdGguc2luKGMpICsgcFsxXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzJdID0gcFsyXTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzMgPSB2ZWMzO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzRcbiAqL1xuXG52YXIgdmVjNCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnN1YiA9IHZlYzQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpc3QgPSB2ZWM0LmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyRGlzdCA9IHZlYzQuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubGVuID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJMZW4gPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAtYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgICAgICBvdXRbM10gPSBhWzNdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbM10gPSBHTE1BVF9SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWM0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjNCA9IHZlYzQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyeDIgTWF0cml4XG4gKiBAbmFtZSBtYXQyXG4gKi9cblxudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGExID0gYVsxXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYVsxXTtcbiAgICAgICAgb3V0WzNdID0gYVszXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICBcbiAgICBvdXRbMF0gPSAgYTMgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWExICogZGV0O1xuICAgIG91dFsyXSA9IC1hMiAqIGRldDtcbiAgICBvdXRbM10gPSAgYTAgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgICB2YXIgYTAgPSBhWzBdO1xuICAgIG91dFswXSA9ICBhWzNdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9ICBhMDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0Mi5tdWwgPSBtYXQyLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbm1hdDIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0Mi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDIuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59O1xuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5tYXQyLkxEVSA9IGZ1bmN0aW9uIChMLCBELCBVLCBhKSB7IFxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxuICAgIFVbMF0gPSBhWzBdOyBcbiAgICBVWzFdID0gYVsxXTsgXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXG4gICAgcmV0dXJuIFtMLCBELCBVXTsgICAgICAgXG59OyBcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MiA9IG1hdDI7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQyZFxuICogXG4gKiBAZGVzY3JpcHRpb24gXG4gKiBBIG1hdDJkIGNvbnRhaW5zIHNpeCBlbGVtZW50cyBkZWZpbmVkIGFzOlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eV1cbiAqIDwvcHJlPlxuICogVGhpcyBpcyBhIHNob3J0IGZvcm0gZm9yIHRoZSAzeDMgbWF0cml4OlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eSxcbiAqICAwLCAwLCAxXVxuICogPC9wcmU+XG4gKiBUaGUgbGFzdCByb3cgaXMgaWdub3JlZCBzbyB0aGUgYXJyYXkgaXMgc2hvcnRlciBhbmQgb3BlcmF0aW9ucyBhcmUgZmFzdGVyLlxuICovXG5cbnZhciBtYXQyZCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMDtcbiAgICBvdXRbMV0gPSBhMTtcbiAgICBvdXRbMl0gPSBhMjtcbiAgICBvdXRbM10gPSBhMztcbiAgICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICAgIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyZC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0MmQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7IFxuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSkpXG59OyBcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MmQgPSBtYXQyZDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xuXG52YXIgbWF0MyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbNF07XG4gICAgb3V0WzRdID0gYVs1XTtcbiAgICBvdXRbNV0gPSBhWzZdO1xuICAgIG91dFs2XSA9IGFbOF07XG4gICAgb3V0WzddID0gYVs5XTtcbiAgICBvdXRbOF0gPSBhWzEwXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMTIgPSBhWzVdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhMDE7XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGEwMjtcbiAgICAgICAgb3V0WzddID0gYTEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGFbMV07XG4gICAgICAgIG91dFs0XSA9IGFbNF07XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGFbMl07XG4gICAgICAgIG91dFs3XSA9IGFbNV07XG4gICAgICAgIG91dFs4XSA9IGFbOF07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMSxcbiAgICAgICAgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMCxcbiAgICAgICAgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYjAxICogZGV0O1xuICAgIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICAgIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIG91dFswXSA9IChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpO1xuICAgIG91dFsxXSA9IChhMDIgKiBhMjEgLSBhMDEgKiBhMjIpO1xuICAgIG91dFsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICAgIG91dFszXSA9IChhMTIgKiBhMjAgLSBhMTAgKiBhMjIpO1xuICAgIG91dFs0XSA9IChhMDAgKiBhMjIgLSBhMDIgKiBhMjApO1xuICAgIG91dFs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xuICAgIG91dFs2XSA9IChhMTAgKiBhMjEgLSBhMTEgKiBhMjApO1xuICAgIG91dFs3XSA9IChhMDEgKiBhMjAgLSBhMDAgKiBhMjEpO1xuICAgIG91dFs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQzLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAwID0gYlswXSwgYjAxID0gYlsxXSwgYjAyID0gYlsyXSxcbiAgICAgICAgYjEwID0gYlszXSwgYjExID0gYls0XSwgYjEyID0gYls1XSxcbiAgICAgICAgYjIwID0gYls2XSwgYjIxID0gYls3XSwgYjIyID0gYls4XTtcblxuICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gICAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuXG4gICAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICAgIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG5cbiAgICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gICAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICAgIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5tdWwgPSBtYXQzLm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG4gICAgICAgIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuXG4gICAgb3V0WzNdID0gYTEwO1xuICAgIG91dFs0XSA9IGExMTtcbiAgICBvdXRbNV0gPSBhMTI7XG5cbiAgICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICAgIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICAgIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuXG4gICAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gICAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gICAgb3V0WzVdID0gYyAqIGExMiAtIHMgKiBhMDI7XG5cbiAgICBvdXRbNl0gPSBhMjA7XG4gICAgb3V0WzddID0gYTIxO1xuICAgIG91dFs4XSA9IGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSB4ICogYVswXTtcbiAgICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgICBvdXRbMl0gPSB4ICogYVsyXTtcblxuICAgIG91dFszXSA9IHkgKiBhWzNdO1xuICAgIG91dFs0XSA9IHkgKiBhWzRdO1xuICAgIG91dFs1XSA9IHkgKiBhWzVdO1xuXG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLmZyb21NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gYVsyXTtcbiAgICBvdXRbNF0gPSBhWzNdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSBhWzRdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xuICAgIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFs1XSA9IHp5ICsgd3g7XG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5ub3JtYWxGcm9tTWF0NCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0My5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59O1xuXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDMgPSBtYXQzO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG5cbnZhciBtYXQ0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGEwMTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGEwMjtcbiAgICAgICAgb3V0WzldID0gYTEyO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhMDM7XG4gICAgICAgIG91dFsxM10gPSBhMTM7XG4gICAgICAgIG91dFsxNF0gPSBhMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGFbMV07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICBvdXRbOV0gPSBhWzZdO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbM107XG4gICAgICAgIG91dFsxM10gPSBhWzddO1xuICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICAgIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107ICBcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQubXVsID0gbWF0NC5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IEdMTUFUX0VQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQub3J0aG8gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IEdMTUFUX0VQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgR0xNQVRfRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBHTE1BVF9FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQ0LmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikgKyBNYXRoLnBvdyhhWzldLCAyKSArIE1hdGgucG93KGFbMTBdLCAyKSArIE1hdGgucG93KGFbMTFdLCAyKSArIE1hdGgucG93KGFbMTJdLCAyKSArIE1hdGgucG93KGFbMTNdLCAyKSArIE1hdGgucG93KGFbMTRdLCAyKSArIE1hdGgucG93KGFbMTVdLCAyKSApKVxufTtcblxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQ0ID0gbWF0NDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBuYW1lIHF1YXRcbiAqL1xuXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gICAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICAgICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuZ3RoKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICAgICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICAgICAgbWF0clsxXSA9IHVwWzBdO1xuICAgICAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICAgICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIHF1YXQuZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm11bCA9IHF1YXQubXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSAtTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlcnAgPSB2ZWM0LmxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2xlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgLy8gYmVuY2htYXJrczpcbiAgICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgdmFyICAgICAgICBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAgIC8vIGNhbGMgY29zaW5lXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICAgIGlmICggY29zb20gPCAwLjAgKSB7XG4gICAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgICBieCA9IC0gYng7XG4gICAgICAgIGJ5ID0gLSBieTtcbiAgICAgICAgYnogPSAtIGJ6O1xuICAgICAgICBidyA9IC0gYnc7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcbiAgICBpZiAoICgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSApIHtcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgICAgIHNpbm9tICA9IE1hdGguc2luKG9tZWdhKTtcbiAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICB9IGVsc2UgeyAgICAgICAgXG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2UgXG4gICAgICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgICAgc2NhbGUxID0gdDtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgZG90ID0gYTAqYTAgKyBhMSphMSArIGEyKmEyICsgYTMqYTMsXG4gICAgICAgIGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuICAgIFxuICAgIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICAgIG91dFsxXSA9IC1hMSppbnZEb3Q7XG4gICAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlbiA9IHF1YXQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3FyTGVuID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbU1hdDMgPSBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAgIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICAgIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gICAgdmFyIGZSb290O1xuXG4gICAgaWYgKCBmVHJhY2UgPiAwLjAgKSB7XG4gICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgIC8vIDJ3XG4gICAgICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxuICAgICAgICBvdXRbMF0gPSAobVs3XS1tWzVdKSpmUm9vdDtcbiAgICAgICAgb3V0WzFdID0gKG1bMl0tbVs2XSkqZlJvb3Q7XG4gICAgICAgIG91dFsyXSA9IChtWzNdLW1bMV0pKmZSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHx3fCA8PSAxLzJcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoIG1bNF0gPiBtWzBdIClcbiAgICAgICAgICBpID0gMTtcbiAgICAgICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxuICAgICAgICAgIGkgPSAyO1xuICAgICAgICB2YXIgaiA9IChpKzEpJTM7XG4gICAgICAgIHZhciBrID0gKGkrMiklMztcbiAgICAgICAgXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSozK2ldLW1baiozK2pdLW1bayozK2tdICsgMS4wKTtcbiAgICAgICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgICAgIG91dFszXSA9IChtW2sqMytqXSAtIG1baiozK2tdKSAqIGZSb290O1xuICAgICAgICBvdXRbal0gPSAobVtqKjMraV0gKyBtW2kqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2tdID0gKG1bayozK2ldICsgbVtpKjMra10pICogZlJvb3Q7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5xdWF0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdxdWF0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMucXVhdCA9IHF1YXQ7XG59XG47XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgfSkoc2hpbS5leHBvcnRzKTtcbn0pKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB5YW1sID0gcmVxdWlyZSgnLi9saWIvanMteWFtbC5qcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0geWFtbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgbG9hZGVyID0gcmVxdWlyZSgnLi9qcy15YW1sL2xvYWRlcicpO1xudmFyIGR1bXBlciA9IHJlcXVpcmUoJy4vanMteWFtbC9kdW1wZXInKTtcblxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uICcgKyBuYW1lICsgJyBpcyBkZXByZWNhdGVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgfTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5UeXBlICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3R5cGUnKTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hJyk7XG5tb2R1bGUuZXhwb3J0cy5GQUlMU0FGRV9TQ0hFTUEgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuSlNPTl9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvanNvbicpO1xubW9kdWxlLmV4cG9ydHMuQ09SRV9TQ0hFTUEgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvY29yZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQUZFX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgICAgICAgICAgICAgPSBsb2FkZXIubG9hZDtcbm1vZHVsZS5leHBvcnRzLmxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgICAgICAgICAgPSBsb2FkZXIuc2FmZUxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgICAgICAgICAgICA9IGR1bXBlci5kdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgICAgICAgICAgICA9IGR1bXBlci5zYWZlRHVtcDtcbm1vZHVsZS5leHBvcnRzLllBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvZXhjZXB0aW9uJyk7XG5cbi8vIERlcHJlY2FyZWQgc2NoZW1hIG5hbWVzIGZyb20gSlMtWUFNTCAyLjAueFxubW9kdWxlLmV4cG9ydHMuTUlOSU1BTF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5TQUZFX1NDSEVNQSAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cbi8vIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAxLngueFxubW9kdWxlLmV4cG9ydHMuc2NhbiAgICAgICAgICAgPSBkZXByZWNhdGVkKCdzY2FuJyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgICAgICAgICA9IGRlcHJlY2F0ZWQoJ3BhcnNlJyk7XG5tb2R1bGUuZXhwb3J0cy5jb21wb3NlICAgICAgICA9IGRlcHJlY2F0ZWQoJ2NvbXBvc2UnKTtcbm1vZHVsZS5leHBvcnRzLmFkZENvbnN0cnVjdG9yID0gZGVwcmVjYXRlZCgnYWRkQ29uc3RydWN0b3InKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKG51bGwgPT09IHN1YmplY3QpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChudWxsICE9PSBzdWJqZWN0KTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xuICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgfSBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBbIHNlcXVlbmNlIF07XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKDAgPT09IG51bWJlcikgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICAgICAgPSBpc05vdGhpbmc7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdCAgICAgICA9IGlzT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudG9BcnJheSAgICAgICAgPSB0b0FycmF5O1xubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICAgICAgPSByZXBlYXQ7XG5tb2R1bGUuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICAgICAgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0dSRUFURVJfVEhBTiAgICAgICAgID0gMHgzRTsgLyogPiAqL1xudmFyIENIQVJfUVVFU1RJT04gICAgICAgICAgICAgPSAweDNGOyAvKiA/ICovXG52YXIgQ0hBUl9DT01NRVJDSUFMX0FUICAgICAgICA9IDB4NDA7IC8qIEAgKi9cbnZhciBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgID0gMHg1QjsgLyogWyAqL1xudmFyIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgPSAweDVEOyAvKiBdICovXG52YXIgQ0hBUl9HUkFWRV9BQ0NFTlQgICAgICAgICA9IDB4NjA7IC8qIGAgKi9cbnZhciBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAgID0gMHg3QjsgLyogeyAqL1xudmFyIENIQVJfVkVSVElDQUxfTElORSAgICAgICAgPSAweDdDOyAvKiB8ICovXG52YXIgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICA9IDB4N0Q7IC8qIH0gKi9cblxudmFyIEVTQ0FQRV9TRVFVRU5DRVMgPSB7fTtcblxuRVNDQVBFX1NFUVVFTkNFU1sweDAwXSAgID0gJ1xcXFwwJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwN10gICA9ICdcXFxcYSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDhdICAgPSAnXFxcXGInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA5XSAgID0gJ1xcXFx0JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQV0gICA9ICdcXFxcbic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEJdICAgPSAnXFxcXHYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBDXSAgID0gJ1xcXFxmJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwRF0gICA9ICdcXFxccic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MUJdICAgPSAnXFxcXGUnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIyXSAgID0gJ1xcXFxcIic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4NUNdICAgPSAnXFxcXFxcXFwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDg1XSAgID0gJ1xcXFxOJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHhBMF0gICA9ICdcXFxcXyc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOF0gPSAnXFxcXEwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjldID0gJ1xcXFxQJztcblxudmFyIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYID0gW1xuICAneScsICdZJywgJ3llcycsICdZZXMnLCAnWUVTJywgJ29uJywgJ09uJywgJ09OJyxcbiAgJ24nLCAnTicsICdubycsICdObycsICdOTycsICdvZmYnLCAnT2ZmJywgJ09GRidcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG1hcCkge1xuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xuXG4gIGlmIChudWxsID09PSBtYXApIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICByZXN1bHQgPSB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHRhZyA9IGtleXNbaW5kZXhdO1xuICAgIHN0eWxlID0gU3RyaW5nKG1hcFt0YWddKTtcblxuICAgIGlmICgnISEnID09PSB0YWcuc2xpY2UoMCwgMikpIHtcbiAgICAgIHRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnLnNsaWNlKDIpO1xuICAgIH1cblxuICAgIHR5cGUgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwW3RhZ107XG5cbiAgICBpZiAodHlwZSAmJiBfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcblxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGNoYXJhY3RlciA8PSAweEZGKSB7XG4gICAgaGFuZGxlID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRikge1xuICAgIGhhbmRsZSA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkZGRkZGKSB7XG4gICAgaGFuZGxlID0gJ1UnO1xuICAgIGxlbmd0aCA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgPSBNYXRoLm1heCgxLCAob3B0aW9uc1snaW5kZW50J10gfHwgMikpO1xuICB0aGlzLnNraXBJbnZhbGlkID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG4gICAgaWYgKGxpbmUubGVuZ3RoICYmIGxpbmUgIT09ICdcXG4nKSB7XG4gICAgICByZXN1bHQgKz0gaW5kO1xuICAgIH1cbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gU3RyaW5nQnVpbGRlcihzb3VyY2UpIHtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG4gIHRoaXMuY2hlY2twb2ludCA9IDA7XG59XG5cblN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnRha2VVcFRvID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gIHZhciBlcjtcblxuICBpZiAocG9zaXRpb24gPCB0aGlzLmNoZWNrcG9pbnQpIHtcbiAgICBlciA9IG5ldyBFcnJvcigncG9zaXRpb24gc2hvdWxkIGJlID4gY2hlY2twb2ludCcpO1xuICAgIGVyLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgZXIuY2hlY2twb2ludCA9IHRoaXMuY2hlY2twb2ludDtcbiAgICB0aHJvdyBlcjtcbiAgfVxuXG4gIHRoaXMucmVzdWx0ICs9IHRoaXMuc291cmNlLnNsaWNlKHRoaXMuY2hlY2twb2ludCwgcG9zaXRpb24pO1xuICB0aGlzLmNoZWNrcG9pbnQgPSBwb3NpdGlvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5lc2NhcGVDaGFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hhcmFjdGVyLCBlc2M7XG5cbiAgY2hhcmFjdGVyID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmNoZWNrcG9pbnQpO1xuICBlc2MgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJhY3Rlcl0gfHwgZW5jb2RlSGV4KGNoYXJhY3Rlcik7XG4gIHRoaXMucmVzdWx0ICs9IGVzYztcbiAgdGhpcy5jaGVja3BvaW50ICs9IDE7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNvdXJjZS5sZW5ndGggPiB0aGlzLmNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnRha2VVcFRvKHRoaXMuc291cmNlLmxlbmd0aCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHN0YXRlLCBvYmplY3QsIGxldmVsKSB7XG4gIHZhciBzaW1wbGUsIGZpcnN0LCBzcGFjZVdyYXAsIGZvbGRlZCwgbGl0ZXJhbCwgc2luZ2xlLCBkb3VibGUsXG4gICAgICBzYXdMaW5lRmVlZCwgbGluZVBvc2l0aW9uLCBsb25nZXN0TGluZSwgaW5kZW50LCBtYXgsIGNoYXJhY3RlcixcbiAgICAgIHBvc2l0aW9uLCBlc2NhcGVTZXEsIGhleEVzYywgcHJldmlvdXMsIGxpbmVMZW5ndGgsIG1vZGlmaWVyLFxuICAgICAgdHJhaWxpbmdMaW5lQnJlYWtzLCByZXN1bHQ7XG5cbiAgaWYgKDAgPT09IG9iamVjdC5sZW5ndGgpIHtcbiAgICBzdGF0ZS5kdW1wID0gXCInJ1wiO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgtMSAhPT0gREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihvYmplY3QpKSB7XG4gICAgc3RhdGUuZHVtcCA9IFwiJ1wiICsgb2JqZWN0ICsgXCInXCI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2ltcGxlID0gdHJ1ZTtcbiAgZmlyc3QgPSBvYmplY3QubGVuZ3RoID8gb2JqZWN0LmNoYXJDb2RlQXQoMCkgOiAwO1xuICBzcGFjZVdyYXAgPSAoQ0hBUl9TUEFDRSA9PT0gZmlyc3QgfHxcbiAgICAgICAgICAgICAgIENIQVJfU1BBQ0UgPT09IG9iamVjdC5jaGFyQ29kZUF0KG9iamVjdC5sZW5ndGggLSAxKSk7XG5cbiAgLy8gU2ltcGxpZmllZCBjaGVjayBmb3IgcmVzdHJpY3RlZCBmaXJzdCBjaGFyYWN0ZXJzXG4gIC8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI25zLXBsYWluLWZpcnN0JTI4YyUyOVxuICBpZiAoQ0hBUl9NSU5VUyAgICAgICAgID09PSBmaXJzdCB8fFxuICAgICAgQ0hBUl9RVUVTVElPTiAgICAgID09PSBmaXJzdCB8fFxuICAgICAgQ0hBUl9DT01NRVJDSUFMX0FUID09PSBmaXJzdCB8fFxuICAgICAgQ0hBUl9HUkFWRV9BQ0NFTlQgID09PSBmaXJzdCkge1xuICAgIHNpbXBsZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gY2FuIG9ubHkgdXNlID4gYW5kIHwgaWYgbm90IHdyYXBwZWQgaW4gc3BhY2VzLlxuICBpZiAoc3BhY2VXcmFwKSB7XG4gICAgc2ltcGxlID0gZmFsc2U7XG4gICAgZm9sZGVkID0gZmFsc2U7XG4gICAgbGl0ZXJhbCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGZvbGRlZCA9IHRydWU7XG4gICAgbGl0ZXJhbCA9IHRydWU7XG4gIH1cblxuICBzaW5nbGUgPSB0cnVlO1xuICBkb3VibGUgPSBuZXcgU3RyaW5nQnVpbGRlcihvYmplY3QpO1xuXG4gIHNhd0xpbmVGZWVkID0gZmFsc2U7XG4gIGxpbmVQb3NpdGlvbiA9IDA7XG4gIGxvbmdlc3RMaW5lID0gMDtcblxuICBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBsZXZlbDtcbiAgbWF4ID0gODA7XG4gIGlmIChpbmRlbnQgPCA0MCkge1xuICAgIG1heCAtPSBpbmRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgbWF4ID0gNDA7XG4gIH1cblxuICBmb3IgKHBvc2l0aW9uID0gMDsgcG9zaXRpb24gPCBvYmplY3QubGVuZ3RoOyBwb3NpdGlvbisrKSB7XG4gICAgY2hhcmFjdGVyID0gb2JqZWN0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIGlmIChzaW1wbGUpIHtcbiAgICAgIC8vIENoYXJhY3RlcnMgdGhhdCBjYW4gbmV2ZXIgYXBwZWFyIGluIHRoZSBzaW1wbGUgc2NhbGFyXG4gICAgICBpZiAoIXNpbXBsZUNoYXIoY2hhcmFjdGVyKSkge1xuICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0aWxsIHNpbXBsZS4gIElmIHdlIG1ha2UgaXQgYWxsIHRoZSB3YXkgdGhyb3VnaCBsaWtlXG4gICAgICAgIC8vIHRoaXMsIHRoZW4gd2UgY2FuIGp1c3QgZHVtcCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2luZ2xlICYmIGNoYXJhY3RlciA9PT0gQ0hBUl9TSU5HTEVfUVVPVEUpIHtcbiAgICAgIHNpbmdsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGVzY2FwZVNlcSA9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXTtcbiAgICBoZXhFc2MgPSBuZWVkc0hleEVzY2FwZShjaGFyYWN0ZXIpO1xuXG4gICAgaWYgKCFlc2NhcGVTZXEgJiYgIWhleEVzYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJhY3RlciAhPT0gQ0hBUl9MSU5FX0ZFRUQgJiZcbiAgICAgICAgY2hhcmFjdGVyICE9PSBDSEFSX0RPVUJMRV9RVU9URSAmJlxuICAgICAgICBjaGFyYWN0ZXIgIT09IENIQVJfU0lOR0xFX1FVT1RFKSB7XG4gICAgICBmb2xkZWQgPSBmYWxzZTtcbiAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgIHNhd0xpbmVGZWVkID0gdHJ1ZTtcbiAgICAgIHNpbmdsZSA9IGZhbHNlO1xuICAgICAgaWYgKHBvc2l0aW9uID4gMCkge1xuICAgICAgICBwcmV2aW91cyA9IG9iamVjdC5jaGFyQ29kZUF0KHBvc2l0aW9uIC0gMSk7XG4gICAgICAgIGlmIChwcmV2aW91cyA9PT0gQ0hBUl9TUEFDRSkge1xuICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICBmb2xkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICBsaW5lTGVuZ3RoID0gcG9zaXRpb24gLSBsaW5lUG9zaXRpb247XG4gICAgICAgIGxpbmVQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICBpZiAobGluZUxlbmd0aCA+IGxvbmdlc3RMaW5lKSB7XG4gICAgICAgICAgbG9uZ2VzdExpbmUgPSBsaW5lTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYXJhY3RlciAhPT0gQ0hBUl9ET1VCTEVfUVVPVEUpIHtcbiAgICAgIHNpbmdsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvdWJsZS50YWtlVXBUbyhwb3NpdGlvbik7XG4gICAgZG91YmxlLmVzY2FwZUNoYXIoKTtcbiAgfVxuXG4gIGlmIChzaW1wbGUgJiYgdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBvYmplY3QpKSB7XG4gICAgc2ltcGxlID0gZmFsc2U7XG4gIH1cblxuICBtb2RpZmllciA9ICcnO1xuICBpZiAoZm9sZGVkIHx8IGxpdGVyYWwpIHtcbiAgICB0cmFpbGluZ0xpbmVCcmVha3MgPSAwO1xuICAgIGlmIChvYmplY3QuY2hhckNvZGVBdChvYmplY3QubGVuZ3RoIC0gMSkgPT09IENIQVJfTElORV9GRUVEKSB7XG4gICAgICB0cmFpbGluZ0xpbmVCcmVha3MgKz0gMTtcbiAgICAgIGlmIChvYmplY3QuY2hhckNvZGVBdChvYmplY3QubGVuZ3RoIC0gMikgPT09IENIQVJfTElORV9GRUVEKSB7XG4gICAgICAgIHRyYWlsaW5nTGluZUJyZWFrcyArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFpbGluZ0xpbmVCcmVha3MgPT09IDApIHtcbiAgICAgIG1vZGlmaWVyID0gJy0nO1xuICAgIH0gZWxzZSBpZiAodHJhaWxpbmdMaW5lQnJlYWtzID09PSAyKSB7XG4gICAgICBtb2RpZmllciA9ICcrJztcbiAgICB9XG4gIH1cblxuICBpZiAobGl0ZXJhbCAmJiBsb25nZXN0TGluZSA8IG1heCkge1xuICAgIGZvbGRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgaXQncyBsaXRlcmFsbHkgb25lIGxpbmUsIHRoZW4gZG9uJ3QgYm90aGVyIHdpdGggdGhlIGxpdGVyYWwuXG4gIC8vIFdlIG1heSBzdGlsbCB3YW50IHRvIGRvIGEgZm9sZCwgdGhvdWdoLCBpZiBpdCdzIGEgc3VwZXIgbG9uZyBsaW5lLlxuICBpZiAoIXNhd0xpbmVGZWVkKSB7XG4gICAgbGl0ZXJhbCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNpbXBsZSkge1xuICAgIHN0YXRlLmR1bXAgPSBvYmplY3Q7XG4gIH0gZWxzZSBpZiAoc2luZ2xlKSB7XG4gICAgc3RhdGUuZHVtcCA9ICdcXCcnICsgb2JqZWN0ICsgJ1xcJyc7XG4gIH0gZWxzZSBpZiAoZm9sZGVkKSB7XG4gICAgcmVzdWx0ID0gZm9sZChvYmplY3QsIG1heCk7XG4gICAgc3RhdGUuZHVtcCA9ICc+JyArIG1vZGlmaWVyICsgJ1xcbicgKyBpbmRlbnRTdHJpbmcocmVzdWx0LCBpbmRlbnQpO1xuICB9IGVsc2UgaWYgKGxpdGVyYWwpIHtcbiAgICBpZiAoIW1vZGlmaWVyKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3QucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICB9XG4gICAgc3RhdGUuZHVtcCA9ICd8JyArIG1vZGlmaWVyICsgJ1xcbicgKyBpbmRlbnRTdHJpbmcob2JqZWN0LCBpbmRlbnQpO1xuICB9IGVsc2UgaWYgKGRvdWJsZSkge1xuICAgIGRvdWJsZS5maW5pc2goKTtcbiAgICBzdGF0ZS5kdW1wID0gJ1wiJyArIGRvdWJsZS5yZXN1bHQgKyAnXCInO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGR1bXAgc2NhbGFyIHZhbHVlJyk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8vIFRoZSBgdHJhaWxpbmdgIHZhciBpcyBhIHJlZ2V4cCBtYXRjaCBvZiBhbnkgdHJhaWxpbmcgYFxcbmAgY2hhcmFjdGVycy5cbi8vXG4vLyBUaGVyZSBhcmUgdGhyZWUgY2FzZXMgd2UgY2FyZSBhYm91dDpcbi8vXG4vLyAxLiBPbmUgdHJhaWxpbmcgYFxcbmAgb24gdGhlIHN0cmluZy4gIEp1c3QgdXNlIGB8YCBvciBgPmAuXG4vLyAgICBUaGlzIGlzIHRoZSBhc3N1bWVkIGRlZmF1bHQuICh0cmFpbGluZyA9IG51bGwpXG4vLyAyLiBObyB0cmFpbGluZyBgXFxuYCBvbiB0aGUgc3RyaW5nLiAgVXNlIGB8LWAgb3IgYD4tYCB0byBcImNob21wXCIgdGhlIGVuZC5cbi8vIDMuIE1vcmUgdGhhbiBvbmUgdHJhaWxpbmcgYFxcbmAgb24gdGhlIHN0cmluZy4gIFVzZSBgfCtgIG9yIGA+K2AuXG4vL1xuLy8gSW4gdGhlIGNhc2Ugb2YgYD4rYCwgdGhlc2UgbGluZSBicmVha3MgYXJlICpub3QqIGRvdWJsZWQgKGxpa2UgdGhlIGxpbmVcbi8vIGJyZWFrcyB3aXRoaW4gdGhlIHN0cmluZyksIHNvIGl0J3MgaW1wb3J0YW50IHRvIG9ubHkgZW5kIHdpdGggdGhlIGV4YWN0XG4vLyBzYW1lIG51bWJlciBhcyB3ZSBzdGFydGVkLlxuZnVuY3Rpb24gZm9sZChvYmplY3QsIG1heCkge1xuICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBsZW5ndGggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgdHJhaWxpbmcgPSAvXFxuKyQvLmV4ZWMob2JqZWN0KSxcbiAgICAgIG5ld0xpbmU7XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgbGVuZ3RoID0gdHJhaWxpbmcuaW5kZXggKyAxO1xuICB9XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV3TGluZSA9IG9iamVjdC5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5ld0xpbmUgPiBsZW5ndGggfHwgbmV3TGluZSA9PT0gLTEpIHtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdcXG5cXG4nO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IGZvbGRMaW5lKG9iamVjdC5zbGljZShwb3NpdGlvbiwgbGVuZ3RoKSwgbWF4KTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCArPSAnXFxuXFxuJztcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBmb2xkTGluZShvYmplY3Quc2xpY2UocG9zaXRpb24sIG5ld0xpbmUpLCBtYXgpO1xuICAgICAgcG9zaXRpb24gPSBuZXdMaW5lICsgMTtcbiAgICB9XG4gIH1cbiAgaWYgKHRyYWlsaW5nICYmIHRyYWlsaW5nWzBdICE9PSAnXFxuJykge1xuICAgIHJlc3VsdCArPSB0cmFpbGluZ1swXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIG1heCkge1xuICBpZiAobGluZSA9PT0gJycpIHtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuXG4gIHZhciBmb2xkUmUgPSAvW15cXHNdIFteXFxzXS9nLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBwcmV2TWF0Y2ggPSAwLFxuICAgICAgZm9sZFN0YXJ0ID0gMCxcbiAgICAgIG1hdGNoID0gZm9sZFJlLmV4ZWMobGluZSksXG4gICAgICBpbmRleCxcbiAgICAgIGZvbGRFbmQsXG4gICAgICBmb2xkZWQ7XG5cbiAgd2hpbGUgKG1hdGNoKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcblxuICAgIC8vIHdoZW4gd2UgY3Jvc3MgdGhlIG1heCBsZW4sIGlmIHRoZSBwcmV2aW91cyBtYXRjaCB3b3VsZCd2ZVxuICAgIC8vIGJlZW4gb2ssIHVzZSB0aGF0IG9uZSwgYW5kIGNhcnJ5IG9uLiAgSWYgdGhlcmUgd2FzIG5vIHByZXZpb3VzXG4gICAgLy8gbWF0Y2ggb24gdGhpcyBmb2xkIHNlY3Rpb24sIHRoZW4ganVzdCBoYXZlIGEgbG9uZyBsaW5lLlxuICAgIGlmIChpbmRleCAtIGZvbGRTdGFydCA+IG1heCkge1xuICAgICAgaWYgKHByZXZNYXRjaCAhPT0gZm9sZFN0YXJ0KSB7XG4gICAgICAgIGZvbGRFbmQgPSBwcmV2TWF0Y2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2xkRW5kID0gaW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgfVxuICAgICAgZm9sZGVkID0gbGluZS5zbGljZShmb2xkU3RhcnQsIGZvbGRFbmQpO1xuICAgICAgcmVzdWx0ICs9IGZvbGRlZDtcbiAgICAgIGZvbGRTdGFydCA9IGZvbGRFbmQgKyAxO1xuICAgIH1cbiAgICBwcmV2TWF0Y2ggPSBpbmRleCArIDE7XG4gICAgbWF0Y2ggPSBmb2xkUmUuZXhlYyhsaW5lKTtcbiAgfVxuXG4gIGlmIChyZXN1bHQpIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBpZiB3ZSBlbmQgdXAgd2l0aCBvbmUgbGFzdCB3b3JkIGF0IHRoZSBlbmQsIHRoZW4gdGhlIGxhc3QgYml0IG1pZ2h0XG4gIC8vIGJlIHNsaWdodGx5IGJpZ2dlciB0aGFuIHdlIHdhbnRlZCwgYmVjYXVzZSB3ZSBleGl0ZWQgb3V0IG9mIHRoZSBsb29wLlxuICBpZiAoZm9sZFN0YXJ0ICE9PSBwcmV2TWF0Y2ggJiYgbGluZS5sZW5ndGggLSBmb2xkU3RhcnQgPiBtYXgpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShmb2xkU3RhcnQsIHByZXZNYXRjaCkgKyAnXFxuJyArXG4gICAgICAgICAgICAgIGxpbmUuc2xpY2UocHJldk1hdGNoICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoZm9sZFN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBjaGFyYWN0ZXIgY2FuIGJlIGZvdW5kIGluIGEgc2ltcGxlIHNjYWxhclxuZnVuY3Rpb24gc2ltcGxlQ2hhcihjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuIENIQVJfVEFCICAgICAgICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9MSU5FX0ZFRUQgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX1NIQVJQICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfVkVSVElDQUxfTElORSAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0NPTE9OICAgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgICFFU0NBUEVfU0VRVUVOQ0VTW2NoYXJhY3Rlcl0gICAgICAgICAgICAmJlxuICAgICAgICAgIW5lZWRzSGV4RXNjYXBlKGNoYXJhY3Rlcik7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNvZGUgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbmZ1bmN0aW9uIG5lZWRzSGV4RXNjYXBlKGNoYXJhY3Rlcikge1xuICByZXR1cm4gISgoMHgwMDAyMCA8PSBjaGFyYWN0ZXIgJiYgY2hhcmFjdGVyIDw9IDB4MDAwMDdFKSB8fFxuICAgICAgICAgICAoMHgwMDA4NSA9PT0gY2hhcmFjdGVyKSAgICAgICAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAoMHgwMDBBMCA8PSBjaGFyYWN0ZXIgJiYgY2hhcmFjdGVyIDw9IDB4MDBEN0ZGKSB8fFxuICAgICAgICAgICAoMHgwRTAwMCA8PSBjaGFyYWN0ZXIgJiYgY2hhcmFjdGVyIDw9IDB4MDBGRkZEKSB8fFxuICAgICAgICAgICAoMHgxMDAwMCA8PSBjaGFyYWN0ZXIgJiYgY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0W2luZGV4XSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgaWYgKDAgIT09IGluZGV4KSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJywgJztcbiAgICAgIH1cbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ1snICsgX3Jlc3VsdCArICddJztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFtpbmRleF0sIHRydWUsIHRydWUpKSB7XG4gICAgICBpZiAoIWNvbXBhY3QgfHwgMCAhPT0gaW5kZXgpIHtcbiAgICAgICAgX3Jlc3VsdCArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBfcmVzdWx0ICs9ICctICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcblxuICAgIGlmICgwICE9PSBpbmRleCkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnLCAnO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdEtleSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcCArICc6ICc7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IDAgIT09IGluZGV4KSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0S2V5LCB0cnVlLCB0cnVlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXkuXG4gICAgfVxuXG4gICAgZXhwbGljaXRQYWlyID0gKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnPycgIT09IHN0YXRlLnRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAoc3RhdGUuZHVtcCAmJiBzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RWYWx1ZSwgdHJ1ZSwgZXhwbGljaXRQYWlyKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6JztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOiAnO1xuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ3t9JzsgLy8gRW1wdHkgbWFwcGluZyBpZiBubyB2YWxpZCBwYWlycy5cbn1cblxuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBleHBsaWNpdCkge1xuICB2YXIgX3Jlc3VsdCwgdHlwZUxpc3QsIGluZGV4LCBsZW5ndGgsIHR5cGUsIHN0eWxlO1xuXG4gIHR5cGVMaXN0ID0gZXhwbGljaXQgPyBzdGF0ZS5leHBsaWNpdFR5cGVzIDogc3RhdGUuaW1wbGljaXRUeXBlcztcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdHlwZUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSB0eXBlTGlzdFtpbmRleF07XG5cbiAgICBpZiAoKHR5cGUuaW5zdGFuY2VPZiAgfHwgdHlwZS5wcmVkaWNhdGUpICYmXG4gICAgICAgICghdHlwZS5pbnN0YW5jZU9mIHx8ICgoJ29iamVjdCcgPT09IHR5cGVvZiBvYmplY3QpICYmIChvYmplY3QgaW5zdGFuY2VvZiB0eXBlLmluc3RhbmNlT2YpKSkgJiZcbiAgICAgICAgKCF0eXBlLnByZWRpY2F0ZSAgfHwgdHlwZS5wcmVkaWNhdGUob2JqZWN0KSkpIHtcblxuICAgICAgc3RhdGUudGFnID0gZXhwbGljaXQgPyB0eXBlLnRhZyA6ICc/JztcblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmICgnW29iamVjdCBGdW5jdGlvbl0nID09PSBfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJyE8JyArIHR5cGUudGFnICsgJz4gdGFnIHJlc29sdmVyIGFjY2VwdHMgbm90IFwiJyArIHN0eWxlICsgJ1wiIHN0eWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kdW1wID0gX3Jlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTZXJpYWxpemVzIGBvYmplY3RgIGFuZCB3cml0ZXMgaXQgdG8gZ2xvYmFsIGByZXN1bHRgLlxuLy8gUmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIG9yIGZhbHNlIG9uIGludmFsaWQgb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgYmxvY2ssIGNvbXBhY3QpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoMCA+IHN0YXRlLmZsb3dMZXZlbCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICBpZiAoKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnPycgIT09IHN0YXRlLnRhZykgfHwgKDIgIT09IHN0YXRlLmluZGVudCAmJiBsZXZlbCA+IDApKSB7XG4gICAgY29tcGFjdCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIG9iamVjdE9yQXJyYXkgPSAnW29iamVjdCBPYmplY3RdJyA9PT0gdHlwZSB8fCAnW29iamVjdCBBcnJheV0nID09PSB0eXBlLFxuICAgICAgZHVwbGljYXRlSW5kZXgsXG4gICAgICBkdXBsaWNhdGU7XG5cbiAgaWYgKG9iamVjdE9yQXJyYXkpIHtcbiAgICBkdXBsaWNhdGVJbmRleCA9IHN0YXRlLmR1cGxpY2F0ZXMuaW5kZXhPZihvYmplY3QpO1xuICAgIGR1cGxpY2F0ZSA9IGR1cGxpY2F0ZUluZGV4ICE9PSAtMTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nID09PSB0eXBlKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKDAgIT09IE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAoMCA9PT0gbGV2ZWwgPyAnXFxuJyA6ICcnKSArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnW29iamVjdCBBcnJheV0nID09PSB0eXBlKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKDAgIT09IHN0YXRlLmR1bXAubGVuZ3RoKSkge1xuICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAoMCA9PT0gbGV2ZWwgPyAnXFxuJyA6ICcnKSArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ1tvYmplY3QgU3RyaW5nXScgPT09IHR5cGUpIHtcbiAgICAgIGlmICgnPycgIT09IHN0YXRlLnRhZykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuc2tpcEludmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3VuYWNjZXB0YWJsZSBraW5kIG9mIGFuIG9iamVjdCB0byBkdW1wICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAobnVsbCAhPT0gc3RhdGUudGFnICYmICc/JyAhPT0gc3RhdGUudGFnKSB7XG4gICAgICBzdGF0ZS5kdW1wID0gJyE8JyArIHN0YXRlLnRhZyArICc+ICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChvYmplY3QpLFxuICAgICAgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChudWxsICE9PSBvYmplY3QgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmplY3QpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcbiAgICAgIGlmICgtMSA9PT0gZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgaW5wdXQsIHRydWUsIHRydWUpKSB7XG4gICAgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHNhZmVEdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkdW1wKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgPSBkdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgPSBzYWZlRHVtcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBZQU1MRXhjZXB0aW9uKHJlYXNvbiwgbWFyaykge1xuICB0aGlzLm5hbWUgICAgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uICA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrICAgID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gdGhpcy50b1N0cmluZyhmYWxzZSk7XG59XG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgcmVzdWx0ID0gJ0pTLVlBTUw6ICcgKyAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKTtcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgTWFyayAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWFyaycpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVEODAwLVxcdURGRkZcXHVGRkZFXFx1RkZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiAweDJDLyogLCAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg1Qi8qIFsgKi8gPT09IGMgfHxcbiAgICAgICAgIDB4NUQvKiBdICovID09PSBjIHx8XG4gICAgICAgICAweDdCLyogeyAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg3RC8qIH0gKi8gPT09IGM7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH1cbiAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYjQ29kZV9wb2ludHNfVS4yQjAxMDAwMF90b19VLjJCMTBGRkZGXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAtIDB4MDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDApO1xufVxuXG52YXIgc2ltcGxlRXNjYXBlQ2hlY2sgPSBuZXcgQXJyYXkoMjU2KTsgLy8gaW50ZWdlciwgZm9yIGZhc3QgYWNjZXNzXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHNpbXBsZUVzY2FwZUNoZWNrW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSkgPyAxIDogMDtcbiAgc2ltcGxlRXNjYXBlTWFwW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSk7XG59XG5cblxuZnVuY3Rpb24gU3RhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBERUZBVUxUX0ZVTExfU0NIRU1BO1xuICB0aGlzLm9uV2FybmluZyA9IG9wdGlvbnNbJ29uV2FybmluZyddIHx8IG51bGw7XG4gIHRoaXMubGVnYWN5ICAgID0gb3B0aW9uc1snbGVnYWN5J10gICAgfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihcbiAgICBtZXNzYWdlLFxuICAgIG5ldyBNYXJrKHN0YXRlLmZpbGVuYW1lLCBzdGF0ZS5pbnB1dCwgc3RhdGUucG9zaXRpb24sIHN0YXRlLmxpbmUsIChzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydCkpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHZhciBlcnJvciA9IGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpO1xuXG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgICB2YXIgbWF0Y2gsIG1ham9yLCBtaW5vcjtcblxuICAgICAgaWYgKG51bGwgIT09IHN0YXRlLnZlcnNpb24pIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoMSAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAobnVsbCA9PT0gbWF0Y2gpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgYXJndW1lbnQgb2YgdGhlIFlBTUwgZGlyZWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgIG1pbm9yID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcblxuICAgICAgaWYgKDEgIT09IG1ham9yKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgICBpZiAoMSAhPT0gbWlub3IgJiYgMiAhPT0gbWlub3IpIHtcbiAgICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgICBpZiAoMiAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiA8IF9sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoMHgwOSA9PT0gX2NoYXJhY3RlciB8fFxuICAgICAgICAgICAgICAweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAobnVsbCA9PT0gX3Jlc3VsdCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmICgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnID09PSBrZXlUYWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MEEvKiBMRiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKDB4MEQvKiBDUiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmICgweDBBLyogTEYgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiAweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIDAgIT09IGNoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKDB4MjAvKiBTcGFjZSAqLyA9PT0gY2gpIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICgtMSAhPT0gY2hlY2tJbmRlbnQgJiYgMCAhPT0gbGluZUJyZWFrcyAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoMHgyRC8qIC0gKi8gPT09IGNoIHx8IDB4MkUvKiAuICovID09PSBjaCkgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgPT09IGNoICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDIpID09PSBjaCkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmICgxID09PSBjb3VudCkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgICAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgICAgICAgIHx8XG4gICAgICAweDIzLyogIyAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI2LyogJiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDJBLyogKiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDIxLyogISAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDdDLyogfCAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDNFLyogPiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI3LyogJyAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDIyLyogXCIgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHgyNS8qICUgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHg0MC8qIEAgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHg2MC8qIGAgKi8gICAgICAgICAgID09PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgweDNGLyogPyAqLyA9PT0gY2ggfHwgMHgyRC8qIC0gKi8gPT09IGNoKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgaWYgKDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDI3LyogJyAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSkge1xuICAgIGlmICgweDI3LyogJyAqLyA9PT0gY2gpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKDB4MjcvKiAnICovID09PSBjaCkge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsIHRtcEVzYyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MjIvKiBcIiAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSkge1xuICAgIGlmICgweDIyLyogXCIgKi8gPT09IGNoKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKDB4NUMvKiBcXCAqLyA9PT0gY2gpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpO1xuXG4gICAgICAgIC8vIFRPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gc2ltcGxlRXNjYXBlTWFwW2NoXTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgIGhleFJlc3VsdCA9IDA7XG5cbiAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCh0bXAgPSBmcm9tSGV4Q29kZShjaCkpID49IDApIHtcbiAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjaGFyRnJvbUNvZGVwb2ludChoZXhSZXN1bHQpO1xuXG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIHJlYWROZXh0ID0gdHJ1ZSxcbiAgICAgIF9saW5lLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQ7LyogXSAqL1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RDsvKiB9ICovXG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKDB4M0YvKiA/ICovID09PSBjaCkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHQucHVzaChrZXlOb2RlKTtcbiAgICB9XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoMHgyQy8qICwgKi8gPT09IGNoKSB7XG4gICAgICByZWFkTmV4dCA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nICAgICAgID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKDB4MkIvKiArICovID09PSBjaCB8fCAweDJELyogLSAqLyA9PT0gY2gpIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9ICgweDJCLyogKyAqLyA9PT0gY2gpID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKDAgIT09IGNoKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgICgweDIwLyogU3BhY2UgKi8gPT09IGNoKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGV0ZWN0ZWRJbmRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmICgwID09PSBlbXB0eUxpbmVzKSB7XG4gICAgICAgIGlmIChkZXRlY3RlZEluZGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgbGluZSBpc24ndCB0aGUgZmlyc3Qgb25lIC0gY291bnQgbGluZSBicmVhayBmcm9tIHRoZSBsYXN0IGNvbnRlbnQgbGluZS5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAtIGNvdW50IG9ubHkgZW1wdHkgbGluZXMuXG4gICAgfVxuXG4gICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgIGVtcHR5TGluZXMgPSAwO1xuICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKCFpc19FT0woY2gpICYmICgwICE9PSBjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcblxuICAgIGlmICgweDJELyogLSAqLyAhPT0gY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmICghaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xuICAgICAgICBfcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoMCAhPT0gY2gpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIG5vZGVJbmRlbnQsIGZsb3dJbmRlbnQpIHtcbiAgdmFyIGZvbGxvd2luZyxcbiAgICAgIGFsbG93Q29tcGFjdCxcbiAgICAgIF9saW5lLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBrZXlUYWcgICAgICAgID0gbnVsbCxcbiAgICAgIGtleU5vZGUgICAgICAgPSBudWxsLFxuICAgICAgdmFsdWVOb2RlICAgICA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCAgICAgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKDB4M0YvKiA/ICovID09PSBjaCB8fCAweDNBLyogOiAqLyAgPT09IGNoKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuXG4gICAgICBpZiAoMHgzRi8qID8gKi8gPT09IGNoKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2UgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfT1VULCBmYWxzZSwgdHJ1ZSkpIHtcblxuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgweDNBLyogOiAqLyA9PT0gY2gpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrOyAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCAmJiAoMCAhPT0gY2gpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MjEvKiAhICovICE9PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChudWxsICE9PSBzdGF0ZS50YWcpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgzQy8qIDwgKi8gPT09IGNoKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoMHgyMS8qICEgKi8gPT09IGNoKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKDAgIT09IGNoICYmIDB4M0UvKiA+ICovICE9PSBjaCk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoMHgyMS8qICEgKi8gPT09IGNoKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKCchJyA9PT0gdGFnSGFuZGxlKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKCchIScgPT09IHRhZ0hhbmRsZSkge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDI2LyogJiAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoLFxuICAgICAgaW5wdXQgPSBzdGF0ZS5pbnB1dCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MkEvKiAqICovICE9PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFzdGF0ZS5hbmNob3JNYXAuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlLFxuICAgICAgZmxvd0luZGVudCxcbiAgICAgIGJsb2NrSW5kZW50LFxuICAgICAgX3Jlc3VsdDtcblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgxID09PSBpbmRlbnRTdGF0dXMpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmICgxID09PSBpbmRlbnRTdGF0dXMgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoMSA9PT0gaW5kZW50U3RhdHVzKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZS50YWcgfHwgbnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAobnVsbCA9PT0gc3RhdGUudGFnKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgwID09PSBpbmRlbnRTdGF0dXMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnIScgIT09IHN0YXRlLnRhZykge1xuICAgIGlmICgnPycgPT09IHN0YXRlLnRhZykge1xuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5O1xuICAgICAgICAgICB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICAgIC8vIEltcGxpY2l0IHJlc29sdmluZyBpcyBub3QgYWxsb3dlZCBmb3Igbm9uLXNjYWxhciB0eXBlcywgYW5kICc/J1xuICAgICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy4gU28sIGl0IGlzbid0XG4gICAgICAgIC8vIG5lZWRlZCB0byBjaGVjayBmb3IgJ2tpbmQnIGNvbmZvcm1pdHkuXG5cbiAgICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50eXBlTWFwLCBzdGF0ZS50YWcpKSB7XG4gICAgICB0eXBlID0gc3RhdGUudHlwZU1hcFtzdGF0ZS50YWddO1xuXG4gICAgICBpZiAobnVsbCAhPT0gc3RhdGUucmVzdWx0ICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgc3RhdGUudGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZS5raW5kICsgJ1wiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbCAhPT0gc3RhdGUudGFnIHx8IG51bGwgIT09IHN0YXRlLmFuY2hvciB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0ge307XG4gIHN0YXRlLmFuY2hvck1hcCA9IHt9O1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IDB4MjUvKiAlICovICE9PSBjaCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoMHgyMy8qICMgKi8gPT09IGNoKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKDAgIT09IGNoKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKDAgPT09IHN0YXRlLmxpbmVJbmRlbnQgJiZcbiAgICAgIDB4MkQvKiAtICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAmJlxuICAgICAgMHgyRC8qIC0gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSAmJlxuICAgICAgMHgyRC8qIC0gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSkge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKDB4MkUvKiAuICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoMHgwQS8qIExGICovICE9PSBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICYmXG4gICAgICAgIDB4MEQvKiBDUiAqLyAhPT0gaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSkge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChzdGF0ZS5pbnB1dCkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlICgweDIwLyogU3BhY2UgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyksIGluZGV4LCBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSwgaW5kZXgsIGxlbmd0aDtcblxuICBpZiAoMCA9PT0gZG9jdW1lbnRzLmxlbmd0aCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKDEgPT09IGRvY3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzWzBdO1xuICB9XG4gIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChzdGFydCAtIDEpKSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChlbmQpKSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZykge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiAtMSA9PT0gZXhjbHVkZS5pbmRleE9mKGluZGV4KTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge30sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgdGhpcy5pbmNsdWRlICA9IGRlZmluaXRpb24uaW5jbHVkZSAgfHwgW107XG4gIHRoaXMuaW1wbGljaXQgPSBkZWZpbml0aW9uLmltcGxpY2l0IHx8IFtdO1xuICB0aGlzLmV4cGxpY2l0ID0gZGVmaW5pdGlvbi5leHBsaWNpdCB8fCBbXTtcblxuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiAnc2NhbGFyJyAhPT0gdHlwZS5sb2FkS2luZCkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2ltcGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAodGhpcy5jb21waWxlZEltcGxpY2l0LCB0aGlzLmNvbXBpbGVkRXhwbGljaXQpO1xufVxuXG5cblNjaGVtYS5ERUZBVUxUID0gbnVsbDtcblxuXG5TY2hlbWEuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlU2NoZW1hKCkge1xuICB2YXIgc2NoZW1hcywgdHlwZXM7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gIGNhc2UgMTpcbiAgICBzY2hlbWFzID0gU2NoZW1hLkRFRkFVTFQ7XG4gICAgdHlwZXMgPSBhcmd1bWVudHNbMF07XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAyOlxuICAgIHNjaGVtYXMgPSBhcmd1bWVudHNbMF07XG4gICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDQ5MjNcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCBDb3JlIHNjaGVtYSBoYXMgbm8gZGlzdGluY3Rpb25zIGZyb20gSlNPTiBzY2hlbWEgaXMgSlMtWUFNTC5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2pzb24nKVxuICBdXG59KTtcbiIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYGxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIEpTLVlBTUwncyBkZWZhdWx0IHNhZmUgc2NoZW1hIGFuZCBpbmNsdWRlc1xuLy8gSmF2YVNjcmlwdC1zcGVjaWZpYyB0eXBlczogISFqcy91bmRlZmluZWQsICEhanMvcmVnZXhwIGFuZCAhIWpzL2Z1bmN0aW9uLlxuLy9cbi8vIEFsc28gdGhpcyBzY2hlbWEgaXMgdXNlZCBhcyBkZWZhdWx0IGJhc2Ugc2NoZW1hIGF0IGBTY2hlbWEuY3JlYXRlYCBmdW5jdGlvbi5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hLkRFRkFVTFQgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZGVmYXVsdF9zYWZlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL3VuZGVmaW5lZCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvcmVnZXhwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9mdW5jdGlvbicpXG4gIF1cbn0pO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxuLy8gZXh0cmEgdHlwZXMgZGVzY3JpYmVkIGF0IFlBTUwgdGFnIHJlcG9zaXRvcnkuIChodHRwOi8veWFtbC5vcmcvdHlwZS8pXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9jb3JlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWVyZ2UnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvYmluYXJ5JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9vbWFwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2V0JylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgRmFpbHNhZmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAyMzQ2XG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvc3RyJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXEnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21hcCcpXG4gIF1cbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAzMjMxXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgdGhpcyBzY2hlbWEgaXMgbm90IHN1Y2ggc3RyaWN0IGFzIGRlZmluZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vIEl0IGFsbG93cyBudW1iZXJzIGluIGJpbmFyeSBub3RhaW9uLCB1c2UgYE51bGxgIGFuZCBgTlVMTGAgYXMgYG51bGxgLCBldGMuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9mYWlsc2FmZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9udWxsJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9ib29sJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Zsb2F0JylcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFtcbiAgJ2tpbmQnLFxuICAncmVzb2x2ZScsXG4gICdjb25zdHJ1Y3QnLFxuICAnaW5zdGFuY2VPZicsXG4gICdwcmVkaWNhdGUnLFxuICAncmVwcmVzZW50JyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG51bGwgIT09IG1hcCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoLTEgPT09IFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMudGFnICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSB8fCBudWxsO1xuICB0aGlzLnN0eWxlQWxpYXNlcyA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKC0xID09PSBZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24uXG4vLyBTaW5jZSB3ZSBtYWtlIGJyb3dzZXJpZmllciB0byBpZ25vcmUgYGJ1ZmZlcmAgbW9kdWxlLCBOb2RlQnVmZmVyIHdpbGwgYmUgdW5kZWZpbmVkXG52YXIgTm9kZUJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBUeXBlICAgICAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGNvZGUsIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXIocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEJvb2xlYW5dJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopXFxcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspPycgK1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdWzAtOV0rKT8nICtcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSAnLScgPT09IHZhbHVlWzBdID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoMCA8PSAnKy0nLmluZGV4T2YodmFsdWVbMF0pKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICgnLmluZicgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuICgxID09PSBzaWduKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKCcubmFuJyA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAoMCA8PSB2YWx1ZS5pbmRleE9mKCc6JykpIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLm5hbic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLk5BTic7XG4gICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgIHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICByZXR1cm4gJy5pbmYnO1xuICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICByZXR1cm4gJy5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgcmV0dXJuICctLmluZic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLS5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoMTApO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwICE9PSBvYmplY3QgJSAxIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHM7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghaXNIZXhDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzO1xuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApIG9yIGJhc2UgNjBcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgaWYgKGNoID09PSAnOicpIHsgYnJlYWs7IH1cbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFoYXNEaWdpdHMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgIWJhc2U2MCAtIGRvbmU7XG4gIGlmIChjaCAhPT0gJzonKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gYmFzZTYwIGFsbW9zdCBub3QgdXNlZCwgbm8gbmVlZHMgdG8gb3B0aW1pemVcbiAgcmV0dXJuIC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChkYXRhLnNsaWNlKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoLCBiYXNlLCBkaWdpdHMgPSBbXTtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgeyBzaWduID0gLTE7IH1cbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAoJzAnID09PSB2YWx1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykge1xuICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgfVxuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuXG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VJbnQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwID09PSBvYmplY3QgJSAxICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMGInICsgb2JqZWN0LnRvU3RyaW5nKDIpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMCcgICsgb2JqZWN0LnRvU3RyaW5nKDgpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAgICAgICAgb2JqZWN0LnRvU3RyaW5nKDEwKTsgfSxcbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzB4JyArIG9iamVjdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlc3ByaW1hO1xuXG4vLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xudHJ5IHtcbiAgZXNwcmltYSA9IHJlcXVpcmUoJ2VzcHJpbWEnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgLypnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyBlc3ByaW1hID0gd2luZG93LmVzcHJpbWE7IH1cbn1cblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgICBwYXJhbXMgPSBbXSxcbiAgICAgICAgYm9keTtcblxuICAgIGlmICgnUHJvZ3JhbScgICAgICAgICAgICAgIT09IGFzdC50eXBlICAgICAgICAgfHxcbiAgICAgICAgMSAgICAgICAgICAgICAgICAgICAgICE9PSBhc3QuYm9keS5sZW5ndGggIHx8XG4gICAgICAgICdFeHByZXNzaW9uU3RhdGVtZW50JyAhPT0gYXN0LmJvZHlbMF0udHlwZSB8fFxuICAgICAgICAnRnVuY3Rpb25FeHByZXNzaW9uJyAgIT09IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cblxuICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmICgnUHJvZ3JhbScgICAgICAgICAgICAgIT09IGFzdC50eXBlICAgICAgICAgfHxcbiAgICAgIDEgICAgICAgICAgICAgICAgICAgICAhPT0gYXN0LmJvZHkubGVuZ3RoICB8fFxuICAgICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICE9PSBhc3QuYm9keVswXS50eXBlIHx8XG4gICAgICAnRnVuY3Rpb25FeHByZXNzaW9uJyAgIT09IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcGFyYW1zLnB1c2gocGFyYW0ubmFtZSk7XG4gIH0pO1xuXG4gIGJvZHkgPSBhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2U7XG5cbiAgLy8gRXNwcmltYSdzIHJhbmdlcyBpbmNsdWRlIHRoZSBmaXJzdCAneycgYW5kIHRoZSBsYXN0ICd9JyBjaGFyYWN0ZXJzIG9uXG4gIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb25zLiBTbyBjdXQgdGhlbSBvdXQuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMqL1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKHBhcmFtcywgc291cmNlLnNsaWNlKGJvZHlbMF0gKyAxLCBib2R5WzFdIC0gMSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9mdW5jdGlvbicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBwcmVkaWNhdGU6IGlzRnVuY3Rpb24sXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoMCA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuXG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcbiAgICBpZiAocmVnZXhwW3JlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMV0gIT09ICcvJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgZHVtbXkgPSBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGAvZm9vL2dpbWAgLSB0YWlsIGNhbiBiZSBtYXhpbXVtIDQgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcblxuICBpZiAob2JqZWN0Lmdsb2JhbCkge1xuICAgIHJlc3VsdCArPSAnZyc7XG4gIH1cblxuICBpZiAob2JqZWN0Lm11bHRpbGluZSkge1xuICAgIHJlc3VsdCArPSAnbSc7XG4gIH1cblxuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHtcbiAgICByZXN1bHQgKz0gJ2knO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiAnW29iamVjdCBSZWdFeHBdJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuICd1bmRlZmluZWQnID09PSB0eXBlb2Ygb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDoge307IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiAnPDwnID09PSBkYXRhIHx8IG51bGwgPT09IGRhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gbnVsbCA9PT0gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nICE9PSBfdG9TdHJpbmcuY2FsbChwYWlyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICAgICAgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC0xID09PSBvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkpIHtcbiAgICAgIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nICE9PSBfdG9TdHJpbmcuY2FsbChwYWlyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIGlmICgxICE9PSBrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDogW107IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG51bGwgIT09IG9iamVjdFtrZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6ICcnOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86KD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8pPyQnKTsgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobnVsbCA9PT0gbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKCctJyA9PT0gbWF0Y2hbOV0pIHtcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIH1cbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgVGhhZGRlZSBUeWwgPHRoYWRkZWUudHlsQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsXG4gICAgLy8gUmhpbm8sIGFuZCBwbGFpbiBicm93c2VyIGxvYWRpbmcuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoKHJvb3QuZXNwcmltYSA9IHt9KSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBUb2tlbixcbiAgICAgICAgVG9rZW5OYW1lLFxuICAgICAgICBGbkV4cHJUb2tlbnMsXG4gICAgICAgIFN5bnRheCxcbiAgICAgICAgUGxhY2VIb2xkZXJzLFxuICAgICAgICBNZXNzYWdlcyxcbiAgICAgICAgUmVnZXgsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBzb3VyY2VUeXBlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBoYXNMaW5lVGVybWluYXRvcixcbiAgICAgICAgbGFzdEluZGV4LFxuICAgICAgICBsYXN0TGluZU51bWJlcixcbiAgICAgICAgbGFzdExpbmVTdGFydCxcbiAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICBzdGFydExpbmVTdGFydCxcbiAgICAgICAgc2Nhbm5pbmcsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbG9va2FoZWFkLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXh0cmEsXG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQsXG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCxcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuXG4gICAgVG9rZW4gPSB7XG4gICAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgICBFT0Y6IDIsXG4gICAgICAgIElkZW50aWZpZXI6IDMsXG4gICAgICAgIEtleXdvcmQ6IDQsXG4gICAgICAgIE51bGxMaXRlcmFsOiA1LFxuICAgICAgICBOdW1lcmljTGl0ZXJhbDogNixcbiAgICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgICAgU3RyaW5nTGl0ZXJhbDogOCxcbiAgICAgICAgUmVndWxhckV4cHJlc3Npb246IDksXG4gICAgICAgIFRlbXBsYXRlOiAxMFxuICAgIH07XG5cbiAgICBUb2tlbk5hbWUgPSB7fTtcbiAgICBUb2tlbk5hbWVbVG9rZW4uQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuICAgIFRva2VuTmFtZVtUb2tlbi5FT0ZdID0gJzxlbmQ+JztcbiAgICBUb2tlbk5hbWVbVG9rZW4uSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLktleXdvcmRdID0gJ0tleXdvcmQnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdWxsTGl0ZXJhbF0gPSAnTnVsbCc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlN0cmluZ0xpdGVyYWxdID0gJ1N0cmluZyc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlRlbXBsYXRlXSA9ICdUZW1wbGF0ZSc7XG5cbiAgICAvLyBBIGZ1bmN0aW9uIGZvbGxvd2luZyBvbmUgb2YgdGhvc2UgdG9rZW5zIGlzIGFuIGV4cHJlc3Npb24uXG4gICAgRm5FeHByVG9rZW5zID0gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuJywgJ2Nhc2UnLCAnZGVsZXRlJywgJ3Rocm93JywgJ3ZvaWQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAnPScsICcrPScsICctPScsICcqPScsICcvPScsICclPScsICc8PD0nLCAnPj49JywgJz4+Pj0nLFxuICAgICAgICAgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbmFyeS91bmFyeSBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgJysnLCAnLScsICcqJywgJy8nLCAnJScsICcrKycsICctLScsICc8PCcsICc+PicsICc+Pj4nLCAnJicsXG4gICAgICAgICAgICAgICAgICAgICd8JywgJ14nLCAnIScsICd+JywgJyYmJywgJ3x8JywgJz8nLCAnOicsICc9PT0nLCAnPT0nLCAnPj0nLFxuICAgICAgICAgICAgICAgICAgICAnPD0nLCAnPCcsICc+JywgJyE9JywgJyE9PSddO1xuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46ICdBc3NpZ25tZW50UGF0dGVybicsXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50JyxcbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0U3BlY2lmaWVyOiAnRXhwb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxuICAgICAgICBTdXBlcjogJ1N1cGVyJyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnXG4gICAgfTtcblxuICAgIFBsYWNlSG9sZGVycyA9IHtcbiAgICAgICAgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcjogJ0Fycm93UGFyYW1ldGVyUGxhY2VIb2xkZXInXG4gICAgfTtcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gICAgTWVzc2FnZXMgPSB7XG4gICAgICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICAgIFVuZXhwZWN0ZWRUZW1wbGF0ZTogJ1VuZXhwZWN0ZWQgcXVhc2kgJTAnLFxuICAgICAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgICAgSW52YWxpZExIU0luRm9ySW46ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXG4gICAgICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXG4gICAgICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcbiAgICAgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcbiAgICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXG4gICAgICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdE1vZGVXaXRoOiAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0VmFyTmFtZTogJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFBhcmFtTmFtZTogJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0RGVsZXRlOiAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0TEhTQXNzaWdubWVudDogJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBUZW1wbGF0ZU9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiB0ZW1wbGF0ZSBzdHJpbmdzLicsXG4gICAgICAgIFBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcjogJ1Jlc3QgcGFyYW1ldGVyIG11c3QgYmUgbGFzdCBmb3JtYWwgcGFyYW1ldGVyJyxcbiAgICAgICAgRGVmYXVsdFJlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuID0nLFxuICAgICAgICBPYmplY3RQYXR0ZXJuQXNSZXN0UGFyYW1ldGVyOiAnVW5leHBlY3RlZCB0b2tlbiB7JyxcbiAgICAgICAgRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eTogJ0R1cGxpY2F0ZSBfX3Byb3RvX18gZmllbGRzIGFyZSBub3QgYWxsb3dlZCBpbiBvYmplY3QgbGl0ZXJhbHMnLFxuICAgICAgICBDb25zdHJ1Y3RvclNwZWNpYWxNZXRob2Q6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yJyxcbiAgICAgICAgRHVwbGljYXRlQ29uc3RydWN0b3I6ICdBIGNsYXNzIG1heSBvbmx5IGhhdmUgb25lIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgU3RhdGljUHJvdG90eXBlOiAnQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZScsXG4gICAgICAgIE1pc3NpbmdGcm9tQ2xhdXNlOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIE5vQXNBZnRlckltcG9ydE5hbWVzcGFjZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBJbnZhbGlkTW9kdWxlU3BlY2lmaWVyOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIElsbGVnYWxJbXBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBJbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJ1xuICAgIH07XG5cbiAgICAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuICAgIFJlZ2V4ID0ge1xuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEIyXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCMlxcdTA4RTQtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjlEXFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbiAgICAvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cbiAgICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSk7ICAgLy8gMC4uOVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKSA+PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9jdGFsVG9EZWNpbWFsKGNoKSB7XG4gICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIHZhciBvY3RhbCA9IChjaCAhPT0gJzAnKSwgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgyMCkgfHwgKGNoID09PSAweDA5KSB8fCAoY2ggPT09IDB4MEIpIHx8IChjaCA9PT0gMHgwQykgfHwgKGNoID09PSAweEEwKSB8fFxuICAgICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICAgIH1cblxuICAgIC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MEEpIHx8IChjaCA9PT0gMHgwRCkgfHwgKGNoID09PSAweDIwMjgpIHx8IChjaCA9PT0gMHgyMDI5KTtcbiAgICB9XG5cbiAgICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgICB9XG5cbiAgICAvLyA3LjYuMS4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxMS42LjIuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG5cbiAgICAgICAgLy8gJ2NvbnN0JyBpcyBzcGVjaWFsaXplZCBhcyBLZXl3b3JkIGluIFY4LlxuICAgICAgICAvLyAneWllbGQnIGFuZCAnbGV0JyBhcmUgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHQuXG4gICAgICAgIC8vIFNvbWUgb3RoZXJzIGFyZSBmcm9tIGZ1dHVyZSByZXNlcnZlZCB3b3Jkcy5cblxuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA3LjQgQ29tbWVudHNcblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnQodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIGxvYykge1xuICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICBhc3NlcnQodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJywgJ0NvbW1lbnQgbXVzdCBoYXZlIHZhbGlkIHBvc2l0aW9uJyk7XG5cbiAgICAgICAgc3RhdGUubGFzdENvbW1lbnRTdGFydCA9IHN0YXJ0O1xuXG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICBjb21tZW50LmxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwU2luZ2xlTGluZUNvbW1lbnQob2Zmc2V0KSB7XG4gICAgICAgIHZhciBzdGFydCwgbG9jLCBjaCwgY29tbWVudDtcblxuICAgICAgICBzdGFydCA9IGluZGV4IC0gb2Zmc2V0O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIG9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgb2Zmc2V0LCBpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAxXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXggLSAxLCBsb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIG9mZnNldCwgaW5kZXgpO1xuICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZGRDb21tZW50KCdMaW5lJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcE11bHRpTGluZUNvbW1lbnQoKSB7XG4gICAgICAgIHZhciBzdGFydCwgbG9jLCBjaCwgY29tbWVudDtcblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXggLSAyO1xuICAgICAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgwQSkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDJBKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgY29tbWVudCBlbmRzIHdpdGggJyovJy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgyRikge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdCbG9jaycsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCwgbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGZpbGUgLSB0aGUgd2hvbGUgdGhpbmcgaXMgYSBjb21tZW50XG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgMiwgaW5kZXgpO1xuICAgICAgICAgICAgYWRkQ29tbWVudCgnQmxvY2snLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIGNoLCBzdGFydDtcbiAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSBmYWxzZTtcblxuICAgICAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChpc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDJGKSB7IC8vIFUrMDAyRiBpcyAnLydcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDJGKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNraXBTaW5nbGVMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkEpIHsgIC8vIFUrMDAyQSBpcyAnKidcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2tpcE11bHRpTGluZUNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0ICYmIGNoID09PSAweDJEKSB7IC8vIFUrMDAyRCBpcyAnLSdcbiAgICAgICAgICAgICAgICAvLyBVKzAwM0UgaXMgJz4nXG4gICAgICAgICAgICAgICAgaWYgKChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDJEKSAmJiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAyKSA9PT0gMHgzRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJy0tPicgaXMgYSBzaW5nbGUtbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHNraXBTaW5nbGVMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDNDKSB7IC8vIFUrMDAzQyBpcyAnPCdcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKGluZGV4ICsgMSwgaW5kZXggKyA0KSA9PT0gJyEtLScpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYDxgXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAhYFxuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgLWBcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYC1gXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaW5nbGVMaW5lQ29tbWVudCg0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkhleEVzY2FwZShwcmVmaXgpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgY2gsIGNvZGUgPSAwO1xuXG4gICAgICAgIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICAgICAgICB2YXIgY2gsIGNvZGUsIGN1MSwgY3UyO1xuXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgY29kZSA9IDA7XG5cbiAgICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVURi0xNiBFbmNvZGluZ1xuICAgICAgICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1MSA9ICgoY29kZSAtIDB4MTAwMDApID4+IDEwKSArIDB4RDgwMDtcbiAgICAgICAgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3UxLCBjdTIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgY2gsIGlkO1xuXG4gICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gICAgICAgIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCA9IGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgaWQgPSAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDVDKSA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBzdHI7XG5cbiAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgICBzdHIgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBzd2l0Y2ggKHN0cikge1xuXG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wdXNoKCd7Jyk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICcuJyAmJiBzb3VyY2VbaW5kZXggKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yOiAuLi5cbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnfic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXG4gICAgICAgICAgICBzdHIgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcbiAgICAgICAgICAgIGlmIChzdHIgPT09ICc+Pj49Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPT09JyB8fCBzdHIgPT09ICchPT0nIHx8IHN0ciA9PT0gJz4+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPDw9JyB8fCBzdHIgPT09ICc+Pj0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKHN0cikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IHRva2VuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4uZW5kID0gaW5kZXg7XG4gICAgICAgIHRva2VuLnZhbHVlID0gc3RyO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciA9ICcnO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIGNoLCBudW1iZXI7XG5cbiAgICAgICAgbnVtYmVyID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgMGIgb3IgMEJcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwocHJlZml4LCBzdGFydCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBvY3RhbDtcblxuICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KHByZWZpeCkpIHtcbiAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9jdGFsID0gZmFsc2U7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgbnVtYmVyID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvY3RhbCAmJiBudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmx5IDBvIG9yIDBPXG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSB7XG4gICAgICAgIHZhciBpLCBjaDtcblxuICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxuICAgICAgICAvLyAoQW5uZXggQi4xLjEgb24gTnVtZXJpYyBMaXRlcmFscylcbiAgICAgICAgZm9yIChpID0gaW5kZXggKyAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnOCcgfHwgY2ggPT09ICc5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxuICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLCBxdW90ZSwgc3RhcnQsIGNoLCB1bmVzY2FwZWQsIG9jdFRvRGVjLCBvY3RhbCA9IGZhbHNlO1xuXG4gICAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZCA9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdFRvRGVjID0gb2N0YWxUb0RlY2ltYWwoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSBvY3RUb0RlYy5vY3RhbCB8fCBvY3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RUb0RlYy5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICBvY3RhbDogb2N0YWwsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5UZW1wbGF0ZSgpIHtcbiAgICAgICAgdmFyIGNvb2tlZCA9ICcnLCBjaCwgc3RhcnQsIHJhd09mZnNldCwgdGVybWluYXRlZCwgaGVhZCwgdGFpbCwgcmVzdG9yZSwgdW5lc2NhcGVkO1xuXG4gICAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGFpbCA9IGZhbHNlO1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBoZWFkID0gKHNvdXJjZVtpbmRleF0gPT09ICdgJyk7XG4gICAgICAgIHJhd09mZnNldCA9IDI7XG5cbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKCFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwwMSBcXDAyIGFuZCBzbyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwxIFxcMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5UZW1wbGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXG4gICAgICAgICAgICAgICAgcmF3OiBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCBpbmRleCAtIHJhd09mZnNldClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkOiBoZWFkLFxuICAgICAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICAgIHZhciB0bXAgPSBwYXR0ZXJuO1xuXG4gICAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBlYWNoIGFzdHJhbCBzeW1ib2wgYW5kIGV2ZXJ5IFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICAvLyB0aGF0IHBvc3NpYmx5IHJlcHJlc2VudHMgYW4gYXN0cmFsIHN5bWJvbCBvciBhIHBhaXJlZCBzdXJyb2dhdGVcbiAgICAgICAgICAgIC8vIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uIHJlZ3VsYXJcbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgYC91YFxuICAgICAgICAgICAgLy8gZmxhZy5cbiAgICAgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgICAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgICAgICAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0XG4gICAgICAgICAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICAgIHRtcCA9IHRtcFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9L2csIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgL1xcXFx1KFthLWZBLUYwLTldezR9KXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csXG4gICAgICAgICAgICAgICAgICAgICd4J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlZ0V4cCh0bXApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihudWxsLCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXG4gICAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgICAgICAgLy8gdXNlcy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICAgICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIC8vIEVDTUEtMjYyIDcuOC41XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihudWxsLCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGJvZHksXG4gICAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gICAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgZmxhZ3MgPSAnJztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgaW5kZXg7ICsrcmVzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGZsYWdzLFxuICAgICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgICAgc2Nhbm5pbmcgPSB0cnVlO1xuICAgICAgICB2YXIgc3RhcnQsIGJvZHksIGZsYWdzLCB2YWx1ZTtcblxuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAgIGJvZHkgPSBzY2FuUmVnRXhwQm9keSgpO1xuICAgICAgICBmbGFncyA9IHNjYW5SZWdFeHBGbGFncygpO1xuICAgICAgICB2YWx1ZSA9IHRlc3RSZWdFeHAoYm9keS52YWx1ZSwgZmxhZ3MudmFsdWUpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgcG9zID0gaW5kZXg7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XG5cbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy8nIHx8IHRva2VuLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUmVndWxhckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xuICAgICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgICAgY2hlY2tUb2tlbjtcbiAgICAgICAgLy8gVXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghcHJldlRva2VuKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5QYXJlblRva2VuIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2lmJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aGlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnZm9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aXRoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrVG9rZW4gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIGEgZGVjbGFyYXRpb24gb3IgYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoRm5FeHByVG9rZW5zLmluZGV4T2YoY2hlY2tUb2tlbi52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhbiBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBkZWNsYXJhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiYgcHJldlRva2VuLnZhbHVlICE9PSAndGhpcycpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICB2YXIgY2gsIHRva2VuO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICAgIGlmIChjaCA9PT0gMHgyOCB8fCBjaCA9PT0gMHgyOSB8fCBjaCA9PT0gMHgzQikge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuICAgICAgICBpZiAoY2ggPT09IDB4MjcgfHwgY2ggPT09IDB4MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNoID09PSAweDJGKSB7XG4gICAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZSBsaXRlcmFscyBzdGFydCB3aXRoIGAgKFUrMDA2MCkgZm9yIHRlbXBsYXRlIGhlYWRcbiAgICAgICAgLy8gb3IgfSAoVSswMDdEKSBmb3IgdGVtcGxhdGUgbWlkZGxlIG9yIHRlbXBsYXRlIHRhaWwuXG4gICAgICAgIGlmIChjaCA9PT0gMHg2MCB8fCAoY2ggPT09IDB4N0QgJiYgc3RhdGUuY3VybHlTdGFja1tzdGF0ZS5jdXJseVN0YWNrLmxlbmd0aCAtIDFdID09PSAnJHsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFRva2VuKCkge1xuICAgICAgICB2YXIgbG9jLCB0b2tlbiwgdmFsdWUsIGVudHJ5O1xuXG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdG9rZW4gPSBhZHZhbmNlKCk7XG4gICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICByYW5nZTogW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHRva2VuLnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiB0b2tlbi5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHNjYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICAgIHNjYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICBzY2FubmluZyA9IHRydWU7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG5cbiAgICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmUgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY29sdW1uID0gc3RhcnRJbmRleCAtIHN0YXJ0TGluZVN0YXJ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRJbmRleCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSB7XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgV3JhcHBpbmdOb2RlLnByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHByb2Nlc3NDb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdENoaWxkLFxuICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gZXh0cmEuYm90dG9tUmlnaHRTdGFjayxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICAgICAgbGFzdCA9IGJvdHRvbVJpZ2h0W2JvdHRvbVJpZ2h0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTeW50YXguUHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0cmEudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGV4dHJhLnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGV4dHJhLnRyYWlsaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzBdID49IHRoaXMucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50cmFpbGluZ0NvbW1lbnRzICYmIGxhc3QudHJhaWxpbmdDb21tZW50c1swXS5yYW5nZVswXSA+PSB0aGlzLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBsYXN0LnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXN0LnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFYXRpbmcgdGhlIHN0YWNrLlxuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGFzdCAmJiBsYXN0LnJhbmdlWzBdID49IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGJvdHRvbVJpZ2h0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzICYmIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHNbbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxXS5yYW5nZVsxXSA8PSB0aGlzLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZ0NvbW1lbnRzID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBleHRyYS5sZWFkaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAobGVhZGluZ0NvbW1lbnRzICYmIGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cyAmJiB0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3R0b21SaWdodC5wdXNoKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxhc3RMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGxhc3RJbmRleCAtIGxhc3RMaW5lU3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NDb21tZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheVBhdHRlcm47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5CbG9ja1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkJyZWFrU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDYXRjaENsYXVzZTogZnVuY3Rpb24gKHBhcmFtLCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2F0Y2hDbGF1c2U7XG4gICAgICAgICAgICB0aGlzLnBhcmFtID0gcGFyYW07XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzQm9keTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DbGFzc0JvZHk7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaERlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKGJvZHksIHRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Eb1doaWxlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FbXB0eVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvclN0YXRlbWVudDogZnVuY3Rpb24gKGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZvclN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvckluU3RhdGVtZW50OiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JJblN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaElmU3RhdGVtZW50OiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSWZTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hOZXdFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTmV3RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoT2JqZWN0UGF0dGVybjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5PYmplY3RQYXR0ZXJuO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hQb3N0Zml4RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlVwZGF0ZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnByZWZpeCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFByb2dyYW06IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvZ3JhbTtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICBpZiAoc291cmNlVHlwZSA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICAvLyB2ZXJ5IHJlc3RyaWN0aXZlIGZvciBub3dcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSBzb3VyY2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgIHRoaXMuc2hvcnRoYW5kID0gc2hvcnRoYW5kO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFJlc3RFbGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5SZXN0RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlJldHVyblN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTZXF1ZW5jZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTcHJlYWRFbGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5TcHJlYWRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFN3aXRjaENhc2U6IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU3dpdGNoQ2FzZTtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFN1cGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU3VwZXI7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAoZGlzY3JpbWluYW50LCBjYXNlcykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlN3aXRjaFN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZGlzY3JpbWluYW50ID0gZGlzY3JpbWluYW50O1xuICAgICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRhZywgcXVhc2kpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgICAgIHRoaXMucXVhc2kgPSBxdWFzaTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUZW1wbGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGFpbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGVtcGxhdGVMaXRlcmFsOiBmdW5jdGlvbiAocXVhc2lzLCBleHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRlbXBsYXRlTGl0ZXJhbDtcbiAgICAgICAgICAgIHRoaXMucXVhc2lzID0gcXVhc2lzO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGhpc0V4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRocm93U3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRyeVN0YXRlbWVudDogZnVuY3Rpb24gKGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UcnlTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB0aGlzLmd1YXJkZWRIYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXIgPyBbIGhhbmRsZXIgXSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnKysnIHx8IG9wZXJhdG9yID09PSAnLS0nKSA/IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uIDogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5raW5kID0gJ3Zhcic7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoTGV4aWNhbERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb25zLCBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChpZCwgaW5pdCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uICh0ZXN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2hpbGVTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hXaXRoU3RhdGVtZW50OiBmdW5jdGlvbiAob2JqZWN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2l0aFN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChsb2NhbCwgZXhwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnRTcGVjaWZpZXI7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkID0gZXhwb3J0ZWQgfHwgbG9jYWw7XG4gICAgICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IGZ1bmN0aW9uIChsb2NhbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb24sIHNwZWNpZmllcnMsIHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwb3J0QWxsRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnRBbGxEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc3JjO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsLCBpbXBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbCB8fCBpbXBvcnRlZDtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0ZWQgPSBpbXBvcnRlZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHNwZWNpZmllcnMsIHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc3JjO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gcmVjb3JkRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIGUsIGV4aXN0aW5nO1xuXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBleHRyYS5lcnJvcnMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgIGV4aXN0aW5nID0gZXh0cmEuZXJyb3JzW2VdO1xuICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGVkIGVycm9yLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChleGlzdGluZy5pbmRleCA9PT0gZXJyb3IuaW5kZXggJiYgZXhpc3RpbmcubWVzc2FnZSA9PT0gZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFcnJvcihsaW5lLCBwb3MsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZSArICc6ICcgKyBkZXNjcmlwdGlvbik7XG4gICAgICAgIGVycm9yLmluZGV4ID0gcG9zO1xuICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZTtcbiAgICAgICAgZXJyb3IuY29sdW1uID0gcG9zIC0gKHNjYW5uaW5nID8gbGluZVN0YXJ0IDogbGFzdExpbmVTdGFydCkgKyAxO1xuICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZztcblxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobGFzdExpbmVOdW1iZXIsIGxhc3RJbmRleCwgbXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2xlcmF0ZUVycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZywgZXJyb3I7XG5cbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csXG4gICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGVycm9yID0gY3JlYXRlRXJyb3IobGluZU51bWJlciwgbGFzdEluZGV4LCBtc2cpO1xuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICByZWNvcmRFcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgbXNnID0gbWVzc2FnZSB8fCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSA/IE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MgOlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikgPyBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpID8gTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpID8gdG9rZW4udmFsdWUucmF3IDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdJTExFR0FMJztcbiAgICAgICAgfVxuXG4gICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCclMCcsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykgP1xuICAgICAgICAgICAgY3JlYXRlRXJyb3IodG9rZW4ubGluZU51bWJlciwgdG9rZW4uc3RhcnQsIG1zZykgOlxuICAgICAgICAgICAgY3JlYXRlRXJyb3Ioc2Nhbm5pbmcgPyBsaW5lTnVtYmVyIDogbGFzdExpbmVOdW1iZXIsIHNjYW5uaW5nID8gaW5kZXggOiBsYXN0SW5kZXgsIG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgdW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgcmVjb3JkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGV4cGVjdENvbW1hU2VwYXJhdG9yXG4gICAgICogQGRlc2NyaXB0aW9uIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAgICogdG8gPGNvZGU+ZXhwZWN0KHZhbHVlKTwvY29kZT5cbiAgICAgKiBAc2luY2UgMi4wXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhwZWN0Q29tbWFTZXBhcmF0b3IoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxuICAgIC8vICh3aGVyZSBhbiBpZGVudGlmaWVyIGlzIHNvbWV0aW1lcyBhIGtleXdvcmQgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0KVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hDb250ZXh0dWFsS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gbWF0Y2hBc3NpZ24oKSB7XG4gICAgICAgIHZhciBvcDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGxvb2thaGVhZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FKGlrYXJpZW5hdG9yKTogdGhpcyBpcyBzZWVtaW5nbHkgYW4gaXNzdWUgaW4gdGhlIHByZXZpb3VzIGxvY2F0aW9uIGluZm8gY29udmVudGlvbi5cbiAgICAgICAgbGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxhc3RMaW5lU3RhcnQgPSBzdGFydExpbmVTdGFydDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvdmVyIGdyYW1tYXIgc3VwcG9ydC5cbiAgICAvL1xuICAgIC8vIFdoZW4gYW4gYXNzaWdubWVudCBleHByZXNzaW9uIHBvc2l0aW9uIHN0YXJ0cyB3aXRoIGFuIGxlZnQgcGFyZW50aGVzaXMsIHRoZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0eXBlXG4gICAgLy8gb2YgdGhlIHN5bnRheCBpcyB0byBiZSBkZWZlcnJlZCBhcmJpdHJhcmlseSBsb25nIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIgKHBsdXMgYSBsb29rYWhlYWQpXG4gICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cbiAgICAvL1xuICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBwcm9kdWN0aW9ucyB0aGF0IGNhbiBiZSBwYXJzZWQgaW4gYSBwYXJlbnRoZXNlcyBwYWlyIHRoYXQgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZFxuICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxuICAgIC8vXG4gICAgLy8gICAxLiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXG4gICAgLy8gICAzLiBBc3NpZ25tZW50VGFyZ2V0c1xuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcbiAgICAvLyBiaW5kaW5nIGVsZW1lbnQgb3IgYXNzaWdubWVudCB0YXJnZXQuXG4gICAgLy9cbiAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxuICAgIC8vXG4gICAgLy8gICBCaW5kaW5nRWxlbWVudHMg4oqGIEFzc2lnbm1lbnRUYXJnZXRzIOKKhiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vXG4gICAgLy8gd2l0aCBhIHNpbmdsZSBleGNlcHRpb24gdGhhdCBDb3ZlckluaXRpYWxpemVkTmFtZSB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYW4gRXhwcmVzc2lvbiwgZ2VuZXJhdGVzXG4gICAgLy8gYW4gZWFybHkgZXJyb3IuIFRoZXJlZm9yZSwgd2UgbmVlZCB0aGUgdGhpcmQgc3RhdGUsIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciwgdG8gdHJhY2sgdGhlXG4gICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cbiAgICAvL1xuICAgIC8vIGlzb2xhdGVDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2VyIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgZG9lcyBub3RcbiAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxuICAgIC8vIHRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBjb25kdWN0ZWQuXG4gICAgLy9cbiAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xuICAgIC8vIHRoZSBmbGFncyBvdXRzaWRlIG9mIHRoZSBwYXJzZXIuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgdXNlZCBhcyBhIHBhcnQgb2YgYSBwb3RlbnRpYWxcbiAgICAvLyBwYXR0ZXJuLiBUaGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgZGVmZXJyZWQuXG4gICAgZnVuY3Rpb24gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZXIpIHtcbiAgICAgICAgdmFyIG9sZElzQmluZGluZ0VsZW1lbnQgPSBpc0JpbmRpbmdFbGVtZW50LFxuICAgICAgICAgICAgb2xkSXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNBc3NpZ25tZW50VGFyZ2V0LFxuICAgICAgICAgICAgb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yLFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gcGFyc2VyKCk7XG4gICAgICAgIGlmIChmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IG9sZElzQmluZGluZ0VsZW1lbnQ7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IG9sZElzQXNzaWdubWVudFRhcmdldDtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VyKSB7XG4gICAgICAgIHZhciBvbGRJc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCxcbiAgICAgICAgICAgIG9sZElzQXNzaWdubWVudFRhcmdldCA9IGlzQXNzaWdubWVudFRhcmdldCxcbiAgICAgICAgICAgIG9sZEZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcixcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlcigpO1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCAmJiBvbGRJc0JpbmRpbmdFbGVtZW50O1xuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0Fzc2lnbm1lbnRUYXJnZXQgJiYgb2xkSXNBc3NpZ25tZW50VGFyZ2V0O1xuICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBvbGRGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgfHwgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlQYXR0ZXJuKCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCksIGVsZW1lbnRzID0gW10sIHJlc3QsIHJlc3ROb2RlO1xuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChyZXN0Tm9kZS5maW5pc2hSZXN0RWxlbWVudChyZXN0KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5UGF0dGVybihlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eVBhdHRlcm4oKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKSwga2V5LCBjb21wdXRlZCA9IG1hdGNoKCdbJyksIGluaXQ7XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgJ2luaXQnLCBrZXksIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXcgV3JhcHBpbmdOb2RlKGtleSkuZmluaXNoQXNzaWdubWVudFBhdHRlcm4oa2V5LCBpbml0KSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgZmFsc2UsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICBpbml0ID0gcGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCBpbml0LCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UGF0dGVybigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpLCBwcm9wZXJ0aWVzID0gW107XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocGFyc2VQcm9wZXJ0eVBhdHRlcm4oKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdFBhdHRlcm4ocHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXR0ZXJuKCkge1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5UGF0dGVybigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdFBhdHRlcm4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGF0dGVybldpdGhEZWZhdWx0KCkge1xuICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IGxvb2thaGVhZCwgcGF0dGVybiwgcmlnaHQ7XG4gICAgICAgIHBhdHRlcm4gPSBwYXJzZVBhdHRlcm4oKTtcbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmlnaHQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybiwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cblxuICAgIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCksIHJlc3RTcHJlYWQ7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3RTcHJlYWQgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJlc3RTcHJlYWQuZmluaXNoU3ByZWFkRWxlbWVudChpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHJlc3RTcHJlYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG5vZGUsIHBhcmFtSW5mbykge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIGJvZHk7XG5cbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMpO1xuXG4gICAgICAgIGlmIChzdHJpY3QgJiYgcGFyYW1JbmZvLmZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1JbmZvLmZpcnN0UmVzdHJpY3RlZCwgcGFyYW1JbmZvLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgcGFyYW1JbmZvLnN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbUluZm8uc3RyaWN0ZWQsIHBhcmFtSW5mby5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1JbmZvLnBhcmFtcywgcGFyYW1JbmZvLmRlZmF1bHRzLCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbXMsIG1ldGhvZCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXMoKTtcbiAgICAgICAgbWV0aG9kID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG5vZGUsIHBhcmFtcyk7XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpLCBleHByO1xuXG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcbiAgICAgICAgLy8gRU9GIGFuZCBQdW5jdHVhdG9yIHRva2VucyBhcmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQuXG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgVG9rZW4uU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdW1lcmljTGl0ZXJhbDpcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICBjYXNlIFRva2VuLklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgVG9rZW4uQm9vbGVhbkxpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uTnVsbExpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uS2V5d29yZDpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgICAgICBjYXNlIFRva2VuLlB1bmN0dWF0b3I6XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2thaGVhZFByb3BlcnR5TmFtZSgpIHtcbiAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudHlwZSkge1xuICAgICAgICBjYXNlIFRva2VuLklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgVG9rZW4uU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdWxsTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdW1lcmljTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5LZXl3b3JkOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgVG9rZW4uUHVuY3R1YXRvcjpcbiAgICAgICAgICAgIHJldHVybiBsb29rYWhlYWQudmFsdWUgPT09ICdbJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB0byB0cnkgdG8gcGFyc2UgYSBNZXRob2REZWZpbml0aW9uIGFzIGRlZmluZWQgaW4gMTQuMy4gQnV0IGluIHRoZSBjYXNlIG9mIG9iamVjdCBsaXRlcmFscyxcbiAgICAvLyBpdCBtaWdodCBiZSBjYWxsZWQgYXQgYSBwb3NpdGlvbiB3aGVyZSB0aGVyZSBpcyBpbiBmYWN0IGEgc2hvcnQgaGFuZCBpZGVudGlmaWVyIHBhdHRlcm4gb3IgYSBkYXRhIHByb3BlcnR5LlxuICAgIC8vIFRoaXMgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhZnRlciB3ZSBjb25zdW1lZCB1cCB0byB0aGUgbGVmdCBwYXJlbnRoZXNlcy5cbiAgICAvL1xuICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGJhY2sgdHJhY2tpbmcsIGl0IHJldHVybnMgYG51bGxgIGlmIHRoZSBwb3NpdGlvbiBpcyBub3QgYSBNZXRob2REZWZpbml0aW9uIGFuZCB0aGUgY2FsbGVyXG4gICAgLy8gaXMgcmVzcG9uc2libGUgdG8gdmlzaXQgb3RoZXIgb3B0aW9ucy5cbiAgICBmdW5jdGlvbiB0cnlQYXJzZU1ldGhvZERlZmluaXRpb24odG9rZW4sIGtleSwgY29tcHV0ZWQsIG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlLCBvcHRpb25zLCBtZXRob2ROb2RlO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYGdldGAgYW5kIGBzZXRgO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5TmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBtZXRob2ROb2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihtZXRob2ROb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdnZXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5TmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBtZXRob2ROb2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVBhcmFtKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG1ldGhvZE5vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdzZXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IGEgTWV0aG9kRGVmaW5pdGlvbi5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQcm90byhrZXksIGNvbXB1dGVkLCBoYXNQcm90bykge1xuICAgICAgICBpZiAoY29tcHV0ZWQgPT09IGZhbHNlICYmIChrZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYga2V5Lm5hbWUgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICBrZXkudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwgJiYga2V5LnZhbHVlID09PSAnX19wcm90b19fJykpIHtcbiAgICAgICAgICAgIGlmIChoYXNQcm90by52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhc1Byb3RvLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkLCBub2RlID0gbmV3IE5vZGUoKSwgY29tcHV0ZWQsIGtleSwgbWF5YmVNZXRob2QsIHZhbHVlO1xuXG4gICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICBtYXliZU1ldGhvZCA9IHRyeVBhcnNlTWV0aG9kRGVmaW5pdGlvbih0b2tlbiwga2V5LCBjb21wdXRlZCwgbm9kZSk7XG5cbiAgICAgICAgaWYgKG1heWJlTWV0aG9kKSB7XG4gICAgICAgICAgICBjaGVja1Byb3RvKG1heWJlTWV0aG9kLmtleSwgbWF5YmVNZXRob2QuY29tcHV0ZWQsIGhhc1Byb3RvKTtcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkXG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0IHByb3BlcnR5IG9yIHNob3J0IGhhbmQgcHJvcGVydHkuXG4gICAgICAgIGNoZWNrUHJvdG8oa2V5LCBjb21wdXRlZCwgaGFzUHJvdG8pO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHZhbHVlID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFdyYXBwaW5nTm9kZSh0b2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4oa2V5LCB2YWx1ZSksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIGhhc1Byb3RvID0ge3ZhbHVlOiBmYWxzZX0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LlJlc3RFbGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5TcHJlYWRFbGVtZW50OlxuICAgICAgICAgICAgZXhwci50eXBlID0gU3ludGF4LlJlc3RFbGVtZW50O1xuICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5BcnJheVBhdHRlcm47XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChleHByLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5PYmplY3RQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLnByb3BlcnRpZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgZXhwci50eXBlID0gU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xuICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIubGVmdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG5vZGUgdHlwZSBmb3IgdG9sZXJhbnQgcGFyc2luZy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZUVsZW1lbnQob3B0aW9uKSB7XG4gICAgICAgIHZhciBub2RlLCB0b2tlbjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlRlbXBsYXRlIHx8IChvcHRpb24uaGVhZCAmJiAhbG9va2FoZWFkLmhlYWQpKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0b2tlbi52YWx1ZS5yYXcsIGNvb2tlZDogdG9rZW4udmFsdWUuY29va2VkIH0sIHRva2VuLnRhaWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGVMaXRlcmFsKCkge1xuICAgICAgICB2YXIgcXVhc2ksIHF1YXNpcywgZXhwcmVzc2lvbnMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoeyBoZWFkOiB0cnVlIH0pO1xuICAgICAgICBxdWFzaXMgPSBbIHF1YXNpIF07XG4gICAgICAgIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgd2hpbGUgKCFxdWFzaS50YWlsKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoeyBoZWFkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKTtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjYgVGhlIEdyb3VwaW5nIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIGV4cHJlc3Npb25zLCBzdGFydFRva2VuLCBpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBpZiAobWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICBleHByID0gcGFyc2VSZXN0RWxlbWVudCgpO1xuICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCc9PicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xuICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblxuICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IFtleHByXTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmluZGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJzZVJlc3RFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCc9PicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG5cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAobWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgIGlmICghaXNCaW5kaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5leHByZXNzaW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBleHByLnR5cGUgPT09IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24gPyBleHByLmV4cHJlc3Npb25zIDogW2V4cHJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG5cbiAgICAvLyAxMS4xIFByaW1hcnkgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0eXBlLCB0b2tlbiwgZXhwciwgbm9kZTtcblxuICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VHcm91cEV4cHJlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXJyYXlJbml0aWFsaXNlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VPYmplY3RJbml0aWFsaXNlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwobGV4KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRoaXNFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsZXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNjYW5SZWdFeHAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICAgIGV4cGVjdCgnLicpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICB2YXIgZXhwcjtcblxuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUV4cHJlc3Npb24pO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGNhbGxlZSwgYXJncywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnbmV3Jyk7XG4gICAgICAgIGNhbGxlZSA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKTtcbiAgICAgICAgYXJncyA9IG1hdGNoKCcoJykgPyBwYXJzZUFyZ3VtZW50cygpIDogW107XG5cbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBxdWFzaSwgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW4sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiBzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBleHByLmZpbmlzaFN1cGVyKCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcoJykgJiYgIW1hdGNoKCcuJykgJiYgIW1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIobWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbiA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlRlbXBsYXRlICYmIGxvb2thaGVhZC5oZWFkKSB7XG4gICAgICAgICAgICAgICAgcXVhc2kgPSBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgcXVhc2ksIGV4cHIsIHByb3BlcnR5LCBzdGFydFRva2VuO1xuICAgICAgICBhc3NlcnQoc3RhdGUuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0gZXhwci5maW5pc2hTdXBlcigpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnWycpICYmICFtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24gOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSAmJiBsb29rYWhlYWQuaGVhZCkge1xuICAgICAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4zIFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCB0b2tlbiwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuXG4gICAgICAgIGlmICghaGFzTGluZVRlcm1pbmF0b3IgJiYgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgICAgICAgICAgIC8vIDExLjMuMSwgMTEuMy4yXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hQb3N0Zml4RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VVbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgLy8gMTEuNC40LCAxMS40LjVcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3REZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgICAgdmFyIHByZWMgPSAwO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICBwcmVjID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgIHByZWMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBwcmVjID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgcHJlYyA9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHByZWMgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICBwcmVjID0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOlxuICAgICAgICAgICAgcHJlYyA9IDc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICBwcmVjID0gYWxsb3dJbiA/IDcgOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPDwnOlxuICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgICBwcmVjID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIHByZWMgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHByZWMgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmVjO1xuICAgIH1cblxuICAgIC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4gICAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4gICAgLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuICAgIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG4gICAgLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4gICAgLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuXG4gICAgICAgIG1hcmtlciA9IGxvb2thaGVhZDtcbiAgICAgICAgbGVmdCA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBwcmVjID0gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgc3RhdGUuYWxsb3dJbik7XG4gICAgICAgIGlmIChwcmVjID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICBsZXgoKTtcblxuICAgICAgICBtYXJrZXJzID0gW21hcmtlciwgbG9va2FoZWFkXTtcbiAgICAgICAgcmlnaHQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlVW5hcnlFeHByZXNzaW9uKTtcblxuICAgICAgICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gICAgICAgIHdoaWxlICgocHJlYyA9IGJpbmFyeVByZWNlZGVuY2UobG9va2FoZWFkLCBzdGF0ZS5hbGxvd0luKSkgPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cbiAgICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gc3RhY2sucG9wKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hpZnQuXG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgICAgZXhwciA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICAgIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBleHByID0gc3RhY2tbaV07XG4gICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vycy5wb3AoKSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgZXhwcik7XG4gICAgICAgICAgICBpIC09IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VCaW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgICAgICAgY29uc2VxdWVudCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIFtFUzZdIDE0LjIgQXJyb3cgRnVuY3Rpb25cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uY2lzZUJvZHkoKSB7XG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxuICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguUmVzdEVsZW1lbnQ6XG4gICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5hcmd1bWVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguQXNzaWdubWVudFBhdHRlcm46XG4gICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5BcnJheVBhdHRlcm46XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0uZWxlbWVudHNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0KHBhcmFtLnR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuLCAnSW52YWxpZCB0eXBlJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLnByb3BlcnRpZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcikge1xuICAgICAgICB2YXIgaSwgbGVuLCBwYXJhbSwgcGFyYW1zLCBkZWZhdWx0cywgZGVmYXVsdENvdW50LCBvcHRpb25zLCB0b2tlbjtcblxuICAgICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgICBkZWZhdWx0Q291bnQgPSAwO1xuICAgICAgICBwYXJhbXMgPSBbZXhwcl07XG5cbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxuICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtLmxlZnQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMucHVzaChwYXJhbS5yaWdodCk7XG4gICAgICAgICAgICAgICAgKytkZWZhdWx0Q291bnQ7XG4gICAgICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtKTtcbiAgICAgICAgICAgICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN0cmljdCA/IG9wdGlvbnMuc3RyaWN0ZWQgOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ob3B0aW9ucywgbm9kZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIGJvZHk7XG5cbiAgICAgICAgaWYgKGhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnPT4nKTtcbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlQ29uY2lzZUJvZHkoKTtcblxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKG9wdGlvbnMuc3RyaWN0ZWQsIG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5kZWZhdWx0cywgYm9keSwgYm9keS50eXBlICE9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGV4cHIsIHJpZ2h0LCBsaXN0LCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIHx8IG1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsaXN0ID0gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcik7XG5cbiAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LCBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hBc3NpZ24oKSkge1xuICAgICAgICAgICAgaWYgKCFpc0Fzc2lnbm1lbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxMS4xMy4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdExIU0Fzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByLCByaWdodCk7XG4gICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIGV4cHJlc3Npb25zO1xuXG4gICAgICAgIGV4cHIgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IFtleHByXTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMi4xIEJsb2NrXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCkge1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlICE9PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlICE9PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbih7aW5Gb3I6IGZhbHNlfSk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuZXcgTm9kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudExpc3QoKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2ssIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VTdGF0ZW1lbnRMaXN0KCk7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQmxvY2tTdGF0ZW1lbnQoYmxvY2spO1xuICAgIH1cblxuICAgIC8vIDEyLjIgVmFyaWFibGUgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBpbml0ID0gbnVsbCwgaWQsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlkID0gcGFyc2VQYXR0ZXJuKCk7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGlkLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBsaXN0LnB1c2gocGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnM7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndmFyJyk7XG5cbiAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpbml0ID0gbnVsbCwgaWQsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlkID0gcGFyc2VQYXR0ZXJuKCk7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaWQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnPScpO1xuICAgICAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCghb3B0aW9ucy5pbkZvciAmJiBpZC50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikgfHwgbWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgZXhwZWN0KCc9Jyk7XG4gICAgICAgICAgICBpbml0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCaW5kaW5nTGlzdChraW5kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZXhpY2FsRGVjbGFyYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIga2luZCwgZGVjbGFyYXRpb25zLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG4gICAgICAgIGFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJlc3RFbGVtZW50KCkge1xuICAgICAgICB2YXIgcGFyYW0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk9iamVjdFBhdHRlcm5Bc1Jlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLkRlZmF1bHRSZXN0UGFyYW1ldGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5QYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUmVzdEVsZW1lbnQocGFyYW0pO1xuICAgIH1cblxuICAgIC8vIDEyLjMgRW1wdHkgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgZXhwZWN0KCc7Jyk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEVtcHR5U3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICAgIH1cblxuICAgIC8vIDEyLjUgSWYgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlmU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdpZicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBjb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdlbHNlJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgIH1cblxuICAgIC8vIDEyLjYgSXRlcmF0aW9uIFN0YXRlbWVudHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBib2R5LCB0ZXN0LCBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdkbycpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaERvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciB0ZXN0LCBib2R5LCBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aGlsZScpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hXaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBpbml0LCBpbml0U2VxLCBpbml0U3RhcnRUb2tlbiwgdGVzdCwgdXBkYXRlLCBsZWZ0LCByaWdodCwga2luZCwgZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAgYm9keSwgb2xkSW5JdGVyYXRpb24sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ZvcicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3ZhcicpKSB7XG4gICAgICAgICAgICAgICAgaW5pdCA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoVmFyaWFibGVEZWNsYXJhdGlvbihwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCkpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICBpbml0ID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VCaW5kaW5nTGlzdChraW5kLCB7aW5Gb3I6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgbWF0Y2hLZXl3b3JkKCdpbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaExleGljYWxEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoTGV4aWNhbERlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0U3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Fzc2lnbm1lbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VxID0gW2luaXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VxLnB1c2goaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbmV3IFdyYXBwaW5nTm9kZShpbml0U3RhcnRUb2tlbikuZmluaXNoU2VxdWVuY2VFeHByZXNzaW9uKGluaXRTZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlU3RhdGVtZW50KTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgICAgICAgICAgbm9kZS5maW5pc2hGb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSA6XG4gICAgICAgICAgICAgICAgbm9kZS5maW5pc2hGb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSk7XG4gICAgfVxuXG4gICAgLy8gMTIuNyBUaGUgY29udGludWUgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbnVsbCwga2V5O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NvbnRpbnVlJyk7XG5cbiAgICAgICAgLy8gT3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIGZvcm06ICdjb250aW51ZTsnLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hDb250aW51ZVN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ29udGludWVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbGFiZWwubmFtZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Vbmtub3duTGFiZWwsIGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcblxuICAgICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChsYXN0SW5kZXgpID09PSAweDNCKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgbGFiZWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXG4gICAgICAgICAgICBrZXkgPSAnJCcgKyBsYWJlbC5uYW1lO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlVua25vd25MYWJlbCwgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChsYWJlbCk7XG4gICAgfVxuXG4gICAgLy8gMTIuOSBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYXJndW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQobGFzdEluZGV4KSA9PT0gMHgyMCkge1xuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTAgVGhlIHdpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgb2JqZWN0LCBib2R5O1xuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIG9iamVjdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgc3dpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50ID0gW10sIHN0YXRlbWVudCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHRlc3QgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwZWN0S2V5d29yZCgnY2FzZScpO1xuICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnOicpO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSB8fCBtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSB8fCBtYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgY29uc2VxdWVudC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGRpc2NyaW1pbmFudCwgY2FzZXMsIGNsYXVzZSwgb2xkSW5Td2l0Y2gsIGRlZmF1bHRGb3VuZDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdzd2l0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBkaXNjcmltaW5hbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICBjYXNlcyA9IFtdO1xuXG4gICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZEluU3dpdGNoID0gc3RhdGUuaW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGF1c2UgPSBwYXJzZVN3aXRjaENhc2UoKTtcbiAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTMgVGhlIHRocm93IHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBhcmd1bWVudDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd0aHJvdycpO1xuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUaHJvd1N0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTQgVGhlIHRyeSBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2F0Y2hDbGF1c2UoKSB7XG4gICAgICAgIHZhciBwYXJhbSwgYm9keSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbSA9IHBhcnNlUGF0dGVybigpO1xuXG4gICAgICAgIC8vIDEyLjE0LjFcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgIGJvZHkgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaENhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRyeVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBibG9jaywgaGFuZGxlciA9IG51bGwsIGZpbmFsaXplciA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndHJ5Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaGFuZGxlciA9IHBhcnNlQ2F0Y2hDbGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBmaW5hbGl6ZXIgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhbmRsZXIgJiYgIWZpbmFsaXplcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Ob0NhdGNoT3JGaW5hbGx5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKTtcbiAgICB9XG5cbiAgICAvLyAxMi4xNSBUaGUgZGVidWdnZXIgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZGVidWdnZXInKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRGVidWdnZXJTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSxcbiAgICAgICAgICAgIGV4cHIsXG4gICAgICAgICAgICBsYWJlbGVkQm9keSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xuICAgICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJzsnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VCcmVha1N0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDb250aW51ZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEb1doaWxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZm9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGb3JTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJZlN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3JldHVybic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd0cnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRyeVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd3aGlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd3aXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICAvLyAxMi4xMiBMYWJlbGxlZCBTdGF0ZW1lbnRzXG4gICAgICAgIGlmICgoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikgJiYgbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGtleSA9ICckJyArIGV4cHIubmFtZTtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlJlZGVjbGFyYXRpb24sICdMYWJlbCcsIGV4cHIubmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmxhYmVsU2V0W2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgbGFiZWxlZEJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmxhYmVsU2V0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMYWJlbGVkU3RhdGVtZW50KGV4cHIsIGxhYmVsZWRCb2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICAgIH1cblxuICAgIC8vIDEzIEZ1bmN0aW9uIERlZmluaXRpb25cblxuICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudCwgYm9keSA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBvbGRMYWJlbFNldCwgb2xkSW5JdGVyYXRpb24sIG9sZEluU3dpdGNoLCBvbGRJbkZ1bmN0aW9uQm9keSwgb2xkUGFyZW50aGVzaXNDb3VudCxcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGFiZWxTZXQgPSBzdGF0ZS5sYWJlbFNldDtcbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgb2xkSW5GdW5jdGlvbkJvZHkgPSBzdGF0ZS5pbkZ1bmN0aW9uQm9keTtcbiAgICAgICAgb2xkUGFyZW50aGVzaXNDb3VudCA9IHN0YXRlLnBhcmVudGhlc2l6ZWRDb3VudDtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IHt9O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XG4gICAgICAgIHN0YXRlLnBhcmVudGhlc2l6ZWRDb3VudCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0ID0gb2xkTGFiZWxTZXQ7XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gb2xkSW5GdW5jdGlvbkJvZHk7XG4gICAgICAgIHN0YXRlLnBhcmVudGhlc2l6ZWRDb3VudCA9IG9sZFBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQmxvY2tTdGF0ZW1lbnQoYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgbmFtZSkge1xuICAgICAgICB2YXIga2V5ID0gJyQnICsgbmFtZTtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFyYW1TZXRba2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbShvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b2tlbiwgcGFyYW0sIGRlZjtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLi4uJykge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJzZVJlc3RFbGVtZW50KCk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50LCBwYXJhbS5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCgpO1xuICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHRva2VuLCB0b2tlbi52YWx1ZSk7XG5cbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybikge1xuICAgICAgICAgICAgZGVmID0gcGFyYW0ucmlnaHQ7XG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtLmxlZnQ7XG4gICAgICAgICAgICArK29wdGlvbnMuZGVmYXVsdENvdW50O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5wYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdHMucHVzaChkZWYpO1xuXG4gICAgICAgIHJldHVybiAhbWF0Y2goJyknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICBkZWZhdWx0Q291bnQ6IDAsXG4gICAgICAgICAgICBkZWZhdWx0czogW10sXG4gICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IGZpcnN0UmVzdHJpY3RlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldCA9IHt9O1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlUGFyYW0ob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBvcHRpb25zLmRlZmF1bHRzLFxuICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXG4gICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxuICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUsIGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XG4gICAgICAgIHZhciBpZCA9IG51bGwsIHBhcmFtcyA9IFtdLCBkZWZhdWx0cyA9IFtdLCBib2R5LCB0b2tlbiwgc3RyaWN0ZWQsIHRtcCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXJJc09wdGlvbmFsIHx8ICFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCk7XG4gICAgICAgIHBhcmFtcyA9IHRtcC5wYXJhbXM7XG4gICAgICAgIGRlZmF1bHRzID0gdG1wLmRlZmF1bHRzO1xuICAgICAgICBzdHJpY3RlZCA9IHRtcC5zdHJpY3RlZDtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgaWQgPSBudWxsLCBzdHJpY3RlZCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCB0bXAsXG4gICAgICAgICAgICBwYXJhbXMgPSBbXSwgZGVmYXVsdHMgPSBbXSwgYm9keSwgcHJldmlvdXNTdHJpY3QsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCk7XG4gICAgICAgIHBhcmFtcyA9IHRtcC5wYXJhbXM7XG4gICAgICAgIGRlZmF1bHRzID0gdG1wLmRlZmF1bHRzO1xuICAgICAgICBzdHJpY3RlZCA9IHRtcC5zdHJpY3RlZDtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NCb2R5KCkge1xuICAgICAgICB2YXIgY2xhc3NCb2R5LCB0b2tlbiwgaXNTdGF0aWMsIGhhc0NvbnN0cnVjdG9yID0gZmFsc2UsIGJvZHksIG1ldGhvZCwgY29tcHV0ZWQsIGtleTtcblxuICAgICAgICBjbGFzc0JvZHkgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBib2R5ID0gW107XG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5uYW1lID09PSAnc3RhdGljJyAmJiBsb29rYWhlYWRQcm9wZXJ0eU5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCA9IG1hdGNoKCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHJ5UGFyc2VNZXRob2REZWZpbml0aW9uKHRva2VuLCBrZXksIGNvbXB1dGVkLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kWydzdGF0aWMnXSA9IGlzU3RhdGljO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnbWV0aG9kJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAobWV0aG9kLmtleS5uYW1lIHx8IG1ldGhvZC5rZXkudmFsdWUudG9TdHJpbmcoKSkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgIT09ICdtZXRob2QnIHx8ICFtZXRob2QubWV0aG9kIHx8IG1ldGhvZC52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnY29uc3RydWN0b3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgKG1ldGhvZC5rZXkubmFtZSB8fCBtZXRob2Qua2V5LnZhbHVlLnRvU3RyaW5nKCkpID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC50eXBlID0gU3ludGF4Lk1ldGhvZERlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRob2QubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWV0aG9kLnNob3J0aGFuZDtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wdXNoKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHJldHVybiBjbGFzc0JvZHkuZmluaXNoQ2xhc3NCb2R5KGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihpZGVudGlmaWVySXNPcHRpb25hbCkge1xuICAgICAgICB2YXIgaWQgPSBudWxsLCBzdXBlckNsYXNzID0gbnVsbCwgY2xhc3NOb2RlID0gbmV3IE5vZGUoKSwgY2xhc3NCb2R5LCBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXG4gICAgICAgIGlmICghaWRlbnRpZmllcklzT3B0aW9uYWwgfHwgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGNsYXNzTm9kZSA9IG5ldyBOb2RlKCksIGNsYXNzQm9keSwgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIHN0cmljdCA9IHRydWU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpO1xuICAgIH1cblxuICAgIC8vIE1vZHVsZXMgZ3JhbW1hciBmcm9tOlxuICAgIC8vIHBlb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbFxuXG4gICAgZnVuY3Rpb24gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnRTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBleHBvcnRlZCwgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpLCBkZWY7XG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdzb21ldGhpbmcnO1xuICAgICAgICAgICAgZGVmID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbG9jYWwgPSBkZWYuZmluaXNoSWRlbnRpZmllcignZGVmYXVsdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cG9ydGVkID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIsXG4gICAgICAgICAgICBzcmMgPSBudWxsLCBzcGVjaWZpZXJzID0gW107XG5cbiAgICAgICAgLy8gbm9uLWRlZmF1bHQgZXhwb3J0XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gZXhwb3J0IHZhciBmID0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ3snKTtcbiAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgfHwgbWF0Y2hLZXl3b3JkKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHBhcnNlRXhwb3J0U3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAobWF0Y2goJywnKSAmJiBsZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgLy8gY292ZXJpbmc6XG4gICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9IGZyb20gJ2Zvbyc7XG4gICAgICAgICAgICAvLyBleHBvcnQge2Zvb30gZnJvbSAnZm9vJztcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgc3JjID0gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcbiAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0V4cG9ydEZyb21JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcmluZzpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH07IC8vIG1pc3NpbmcgZnJvbUNsYXVzZVxuICAgICAgICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQudmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBNZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZSwgbG9va2FoZWFkLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvdmVyXG4gICAgICAgICAgICAvLyBleHBvcnQge2Zvb307XG4gICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc3JjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBleHByZXNzaW9uID0gbnVsbDtcblxuICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgICAgICBleHBlY3RLZXl3b3JkKCdkZWZhdWx0Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9vICgpIHt9XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obmV3IE5vZGUoKSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VDbGFzc0RlY2xhcmF0aW9uKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCB7fTtcbiAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgW107XG4gICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0ICgxICsgMik7XG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBzcmM7XG5cbiAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAvLyBleHBvcnQgKiBmcm9tICdmb28nO1xuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnRBbGxEZWNsYXJhdGlvbihzcmMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgaWYgKHN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdleHBvcnQnKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydFNwZWNpZmllcigpIHtcbiAgICAgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBpbXBvcnRlZCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaW1wb3J0ZWQgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbG9jYWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lZEltcG9ydHMoKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XG4gICAgICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnRTcGVjaWZpZXIoKSk7XG4gICAgICAgICAgICB9IHdoaWxlIChtYXRjaCgnLCcpICYmIGxleCgpKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgICAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xuICAgICAgICB2YXIgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSB7XG4gICAgICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycywgc3JjLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAoc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ltcG9ydCcpO1xuICAgICAgICBzcGVjaWZpZXJzID0gW107XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgJ2Zvbyc7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgJiYgaXNJZGVudGlmaWVyTmFtZShsb29rYWhlYWQpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vXG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAuLi5cbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAqIGFzIGZvb1xuICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXG4gICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywge2Jhcn1cbiAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxuICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHBhcnNlTmFtZWRJbXBvcnRzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzcmMpO1xuICAgIH1cblxuICAgIC8vIDE0IFByb2dyYW1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2NyaXB0Qm9keSgpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudCwgYm9keSA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgICAgICBpZiAoc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtKCkge1xuICAgICAgICB2YXIgYm9keSwgbm9kZTtcblxuICAgICAgICBwZWVrKCk7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVNjcmlwdEJvZHkoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvZ3JhbShib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJUb2tlbkxvY2F0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGV4dHJhLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGVudHJ5LnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBlbnRyeS5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5yYW5nZSA9IGVudHJ5LnJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICAgIHRva2VuLmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICAgIHRva2VucztcblxuICAgICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xLFxuICAgICAgICAgICAgY3VybHlTdGFjazogW11cbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEVycm9yKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0sIHRvU3RyaW5nO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTEsXG4gICAgICAgICAgICBjdXJseVN0YWNrOiBbXVxuICAgICAgICB9O1xuICAgICAgICBzb3VyY2VUeXBlID0gJ3NjcmlwdCc7XG4gICAgICAgIHN0cmljdCA9IGZhbHNlO1xuXG4gICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuICAgICAgICAgICAgZXh0cmEuYXR0YWNoQ29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hDb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuYXR0YWNoQ29tbWVudDtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gdG9TdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5hdHRhY2hDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEuYm90dG9tUmlnaHRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gdmVyeSByZXN0cmljdGl2ZSBjb25kaXRpb24gZm9yIG5vd1xuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGUgPSBvcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmNvbW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uY29tbWVudHMgPSBleHRyYS5jb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxuICAgIGV4cG9ydHMudmVyc2lvbiA9ICcyLjIuMCc7XG5cbiAgICBleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG5cbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbiAgICAvLyBEZWVwIGNvcHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBleHBvcnRzLlN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lLCB0eXBlcyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChuYW1lIGluIFN5bnRheCkge1xuICAgICAgICAgICAgaWYgKFN5bnRheC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHR5cGVzW25hbWVdID0gU3ludGF4W25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9KCkpO1xuXG59KSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcclxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxyXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0ge307XHJcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gV2UgY2FuJ3QgYnVpbGQgYSByZWFsIG1ldGhvZCB3aXRob3V0IGEgY29uc29sZSB0byBsb2cgdG9cclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgc2VsZlttZXRob2ROYW1lXS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcclxuICAgICAgICBcInRyYWNlXCIsXHJcbiAgICAgICAgXCJkZWJ1Z1wiLFxyXG4gICAgICAgIFwiaW5mb1wiLFxyXG4gICAgICAgIFwid2FyblwiLFxyXG4gICAgICAgIFwiZXJyb3JcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xyXG4gICAgICAgICAgICBzZWxmW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgPyBub29wIDogc2VsZi5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xyXG4gICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVsnbG9nbGV2ZWwnXSA9IGxldmVsTmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IFwibG9nbGV2ZWw9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZFBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgIHZhciBzdG9yZWRMZXZlbDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlWydsb2dsZXZlbCddO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvbG9nbGV2ZWw9KFteO10rKS8uZXhlYyh3aW5kb3cuZG9jdW1lbnQuY29va2llKVsxXTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSBcIldBUk5cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICpcclxuICAgICAqIFB1YmxpYyBBUElcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcclxuICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xyXG5cclxuICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XHJcbiAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5UKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XHJcbiAgICBzZWxmLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxyXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBzZWxmKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn0pKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2hpdGVMaXN0ID0gWydub3QnLCAnYW55JywgJ2FsbCcsICdub25lJ107XG5cblxuZnVuY3Rpb24gbm90TnVsbCh4KSAgeyByZXR1cm4geCAhPSBudWxsOyB9XG5mdW5jdGlvbiB0b1N0cmluZyh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH1cbmZ1bmN0aW9uIHdyYXAoeCkgICAgIHsgcmV0dXJuICcoJyArIHggKyAnKSc7fVxuXG5mdW5jdGlvbiBtYXliZVF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbG9va1VwKGtleSkge1xuICAgIGlmIChrZXkubGFzdEluZGV4T2YoJyQnKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ2NvbnRleHQuJyArIGtleS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiAnY29udGV4dC5mZWF0dXJlLnByb3BlcnRpZXMuJyArIGtleTtcbn1cblxuZnVuY3Rpb24gbnVsbFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnbnVsbFZhbHVlJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyB0cnVlICc7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUVxdWFsKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncHJvcGVydHlFcXVhbCcsXG4gICAgICAgIG9wdDogJz09PScgLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAobWF5YmVRdW90ZSh0aGlzLnZhbHVlKSArICcgJyArIHRoaXMub3B0ICsgJyAnICsgbG9va1VwKGtleSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlPcihrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwcm9wZXJ0eU9yJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcHJvcGVydHlFcXVhbChrZXksIHgpOyB9KSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHRoaXMudmFsdWVzLm1hcCh0b1N0cmluZykuam9pbignIHx8ICcpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vdChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ25vdFByb3BlcnR5JyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBwYXJzZUZpbHRlcih2YWx1ZSksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyEnICsgd3JhcCh0aGlzLnZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbm9uZShrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdub25lJyxcbiAgICAgICAgdmFsdWVzOiBhbnkobnVsbCwgdmFsdWVzKSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnIScgKyB3cmFwKHRoaXMudmFsdWVzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJpbnROZXN0ZWQodmFsdWVzLCBqb2luZXIpIHtcbiAgICByZXR1cm4gd3JhcCh2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gd3JhcCh4LmpvaW4oJyAmJiAnKSk7XG4gICAgfSkuam9pbignICcgKyBqb2luZXIgKyAnICcpKTtcbn1cblxuZnVuY3Rpb24gYW55KF8sIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdhbnknLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcy5tYXAocGFyc2VGaWx0ZXIpLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50TmVzdGVkKHRoaXMudmFsdWVzLCAnfHwnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsbChfLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYWxsJyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChwYXJzZUZpbHRlciksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnROZXN0ZWQodGhpcy52YWx1ZXMsICcmJicpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlNYXRjaGVzQm9vbGVhbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5TWF0Y2hlc0Jvb2xlYW4nLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAobG9va1VwKHRoaXMua2V5KSArICh0aGlzLnZhbHVlID8gJyAhPSAnIDogJyA9PSAnKSAgKyAnbnVsbCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VNYXRjaChrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdyYW5nZU1hdGNoJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5tYXgpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnIDwgJyArIHRoaXMudmFsdWVzLm1heCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5taW4pIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnID49ICcgKyB0aGlzLnZhbHVlcy5taW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gd3JhcChleHByZXNzaW9ucy5qb2luKCcgJiYgJykpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIoZmlsdGVyKSB7XG4gICAgdmFyIGZpbHRlckFTVCA9IFtdO1xuXG4gICAgLy8gRnVuY3Rpb24gZmlsdGVyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyQVNULnB1c2god3JhcChmaWx0ZXIudG9TdHJpbmcoKSArICcoY29udGV4dCknKSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJBU1Q7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZmlsdGVyKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaWR4KSB7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZmlsdGVyW2tleV0sXG4gICAgICAgICAgICB0eXBlICA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChwcm9wZXJ0eUVxdWFsKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHByb3BlcnR5TWF0Y2hlc0Jvb2xlYW4oa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKG51bGxWYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2hpdGVMaXN0LmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnbm90JzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChub3Qoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChhbnkoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChhbGwoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gobm9uZShrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIFdoaXRlTGlzdGVkIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gocHJvcGVydHlPcihrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLm1heCB8fCB2YWx1ZS5taW4pIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChyYW5nZU1hdGNoKGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBRdWVyeSBzeXRuYXg6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBrZXlzLmxlbmd0aCA9PT0gMCA/IFsndHJ1ZSddIDogZmlsdGVyQVNUO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJUb1N0cmluZyhmaWx0ZXJBU1QpIHtcbiAgICByZXR1cm4gd3JhcChmaWx0ZXJBU1Quam9pbignICYmICcpKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PSBudWxsKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9XG4gICAgLy8ganNoaW50IGV2aWw6IHRydWVcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdjb250ZXh0JywgJ3JldHVybiAnICsgZmlsdGVyVG9TdHJpbmcocGFyc2VGaWx0ZXIoZmlsdGVyKSkgKyAnOycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgZmlsdGVyVG9TdHJpbmc6IGZpbHRlclRvU3RyaW5nLFxuICAgIHBhcnNlRmlsdGVyOiBwYXJzZUZpbHRlclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGlnaHR3ZWlnaHQgQnVmZmVyIHNoaW0gZm9yIHBiZiBicm93c2VyIGJ1aWxkXG4vLyBiYXNlZCBvbiBjb2RlIGZyb20gZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyIChNSVQtbGljZW5zZWQpXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKTtcblxudmFyIEJ1ZmZlck1ldGhvZHM7XG5cbmZ1bmN0aW9uIEJ1ZmZlcihsZW5ndGgpIHtcbiAgICB2YXIgYXJyO1xuICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoLmxlbmd0aCkge1xuICAgICAgICBhcnIgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGggfHwgMCk7XG4gICAgaWYgKGFycikgYnVmLnNldChhcnIpO1xuXG4gICAgYnVmLnJlYWRVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZFVJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZVVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEludDMyTEU7XG4gICAgYnVmLndyaXRlSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEZsb2F0TEU7XG4gICAgYnVmLndyaXRlRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVGbG9hdExFO1xuICAgIGJ1Zi5yZWFkRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLnJlYWREb3VibGVMRTtcbiAgICBidWYud3JpdGVEb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVEb3VibGVMRTtcbiAgICBidWYudG9TdHJpbmcgPSBCdWZmZXJNZXRob2RzLnRvU3RyaW5nO1xuICAgIGJ1Zi53cml0ZSA9IEJ1ZmZlck1ldGhvZHMud3JpdGU7XG4gICAgYnVmLnNsaWNlID0gQnVmZmVyTWV0aG9kcy5zbGljZTtcbiAgICBidWYuY29weSA9IEJ1ZmZlck1ldGhvZHMuY29weTtcblxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlO1xuICAgIHJldHVybiBidWY7XG59XG5cbnZhciBsYXN0U3RyLCBsYXN0U3RyRW5jb2RlZDtcblxuQnVmZmVyTWV0aG9kcyA9IHtcbiAgICByZWFkVUludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gKiAweDEwMDAwMDApO1xuICAgIH0sXG5cbiAgICB3cml0ZVVJbnQzMkxFOiBmdW5jdGlvbih2YWwsIHBvcykge1xuICAgICAgICB0aGlzW3Bvc10gPSB2YWw7XG4gICAgICAgIHRoaXNbcG9zICsgMV0gPSAodmFsID4+PiA4KTtcbiAgICAgICAgdGhpc1twb3MgKyAyXSA9ICh2YWwgPj4+IDE2KTtcbiAgICAgICAgdGhpc1twb3MgKyAzXSA9ICh2YWwgPj4+IDI0KTtcbiAgICB9LFxuXG4gICAgcmVhZEludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gPDwgMjQpO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXRMRTogIGZ1bmN0aW9uKHBvcykgeyByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHJlYWREb3VibGVMRTogZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB3cml0ZUZsb2F0TEU6ICBmdW5jdGlvbih2YWwsIHBvcykgeyByZXR1cm4gaWVlZTc1NC53cml0ZSh0aGlzLCB2YWwsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHdyaXRlRG91YmxlTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLFxuICAgICAgICAgICAgdG1wID0gJyc7XG5cbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCwgZW5kIHx8IHRoaXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdGKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGRlY29kZVVSSUNvbXBvbmVudCh0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcCArPSAnJScgKyBjaC50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHN0ciwgcG9zKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHN0ciA9PT0gbGFzdFN0ciA/IGxhc3RTdHJFbmNvZGVkIDogZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcG9zICsgaV0gPSBieXRlc1tpXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oYnVmLCBwb3MpIHtcbiAgICAgICAgcG9zID0gcG9zIHx8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGxhc3RTdHIgPSBzdHI7XG4gICAgbGFzdFN0ckVuY29kZWQgPSBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gbGFzdFN0ckVuY29kZWQubGVuZ3RoO1xufTtcblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgcmV0dXJuICEhKGJ1ZiAmJiBidWYuX2lzQnVmZmVyKTtcbn07XG5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjLCBsZWFkOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBjb2RlIHBvaW50XG5cbiAgICAgICAgaWYgKGMgPiAweEQ3RkYgJiYgYyA8IDB4RTAwMCkge1xuXG4gICAgICAgICAgICBpZiAobGVhZCkge1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBsZWFkIC0gMHhEODAwIDw8IDEwIHwgYyAtIDB4REMwMCB8IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+IDB4REJGRiB8fCAoaSArIDEgPT09IGxlbmd0aCkpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgZWxzZSBsZWFkID0gYztcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobGVhZCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSBieXRlcy5wdXNoKGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIGJ5dGVzLnB1c2goYyA+PiAweDYgfCAweEMwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHgxMDAwMCkgYnl0ZXMucHVzaChjID4+IDB4QyB8IDB4RTAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgYnl0ZXMucHVzaChjID4+IDB4MTIgfCAweEYwLCBjID4+IDB4QyAmIDB4M0YgfCAweDgwLCBjID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuIiwiLyohXG4gKiBzdHJpcC1jb21tZW50cyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvc3RyaXAtY29tbWVudHM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvbiBTY2hsaW5rZXJ0LCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpYyc7XG5cbnZhciByZUJsb2NrID0gJ1xcXFwvXFxcXConO1xudmFyIHJlQmxvY2tJZ25vcmUgPSAnXFxcXC9cXFxcKig/IVxcXFwqP1xcXFwhKSc7XG52YXIgcmVCbG9ja0VuZCA9ICcoLnxbXFxcXHJcXFxcbl18XFxcXG4pKj9cXFxcKlxcXFwvXFxcXG4/XFxcXG4/JztcbnZhciByZUxpbmUgPSAvKF58W15cXFNcXG5dKSg/OlxcL1xcLykoW1xcc1xcU10rPykkL2dtO1xudmFyIHJlTGluZUlnbm9yZSA9IC8oXnxbXlxcU1xcbl0pKD86XFwvXFwvW14hXSkoW1xcc1xcU10rPykkL2dtO1xuXG5cbi8qKlxuICogU3RyaXAgYWxsIGNvbW1lbnRzXG4gKlxuICogeyU9IGRvY3MoXCJzdHJpcFwiKSAlfVxuICpcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IGBzdHJgICBmaWxlIGNvbnRlbnRzIG9yIHN0cmluZyB0byBzdHJpcC5cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgb3B0aW9ucyBhcmUgcGFzc2VkIHRvIGAuYmxvY2tgLCBhbmQgYC5saW5lYFxuICogQHJldHVybiAge1N0cmluZ30gU3RyaW5nIHdpdGhvdXQgY29tbWVudHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBzdHJpcCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyLCBvcHRzKSB7XG4gIHJldHVybiBzdHIgPyBzdHJpcC5ibG9jayhzdHJpcC5saW5lKHN0ciwgb3B0cyksIG9wdHMpIDogJyc7XG59O1xuXG5cbi8qKlxuICogU3RyaXAgb25seSBibG9jayBjb21tZW50cywgb3B0aW9uYWxseSBsZWF2aW5nIHByb3RlY3RlZCBjb21tZW50c1xuICogKGUuZy4gYC8qIWApIGludGFjdC5cbiAqXG4gKiB7JT0gZG9jcyhcImJsb2NrXCIpICV9XG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gYHN0cmAgIGZpbGUgY29udGVudCBvciBzdHJpbmcgdG8gc3RyaXAgdG9cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgaWYgYHNhZmU6dHJ1ZWAsIHN0cmlwIG9ubHkgY29tbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBgLyohYCBvciBgLyoqIWBcbiAqIEByZXR1cm4gIHtTdHJpbmd9IFN0cmluZyB3aXRob3V0IGJsb2NrIGNvbW1lbnRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5zdHJpcC5ibG9jayA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cChyZUJsb2NrICsgcmVCbG9ja0VuZCwgJ2dtJyk7XG4gIGlmKG9wdHMuc2FmZSkge1xuICAgIHJlID0gbmV3IFJlZ0V4cChyZUJsb2NrSWdub3JlICsgcmVCbG9ja0VuZCwgJ2dtJyk7XG4gIH1cbiAgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKHJlLCAnJykgOiAnJztcbn07XG5cblxuLyoqXG4gKiBTdHJpcCBvbmx5IGxpbmUgY29tbWVudHNcbiAqXG4gKiB7JT0gZG9jcyhcImxpbmVcIikgJX1cbiAqXG4gKiBAcGFyYW0gICB7U3RyaW5nfSBgc3RyYCAgZmlsZSBjb250ZW50IG9yIHN0cmluZyB0byBzdHJpcCB0b1xuICogQHBhcmFtICAge09iamVjdH0gYG9wdHNgICBpZiBgc2FmZTp0cnVlYCwgc3RyaXAgYWxsIHRoYXQgbm90IHN0YXJ0cyB3aXRoIGAvLyFgXG4gKiBAcmV0dXJuICB7U3RyaW5nfSBTdHJpbmcgd2l0aG91dCBsaW5lIGNvbW1lbnRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5zdHJpcC5saW5lID0gZnVuY3Rpb24oc3RyLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgcmUgPSByZUxpbmU7XG4gIGlmKG9wdHMuc2FmZSkge1xuICAgIHJlID0gcmVMaW5lSWdub3JlO1xuICB9XG4gIHJldHVybiBzdHIgPyBzdHIucmVwbGFjZShyZSwgJycpIDogJyc7XG59O1xuIiwiIWZ1bmN0aW9uKCkge1xuICB2YXIgdG9wb2pzb24gPSB7XG4gICAgdmVyc2lvbjogXCIxLjYuMTlcIixcbiAgICBtZXNoOiBmdW5jdGlvbih0b3BvbG9neSkgeyByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsgfSxcbiAgICBtZXNoQXJjczogbWVzaEFyY3MsXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHRvcG9sb2d5KSB7IHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lcmdlQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsgfSxcbiAgICBtZXJnZUFyY3M6IG1lcmdlQXJjcyxcbiAgICBmZWF0dXJlOiBmZWF0dXJlT3JDb2xsZWN0aW9uLFxuICAgIG5laWdoYm9yczogbmVpZ2hib3JzLFxuICAgIHByZXNpbXBsaWZ5OiBwcmVzaW1wbGlmeVxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0aXRjaEFyY3ModG9wb2xvZ3ksIGFyY3MpIHtcbiAgICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICAgIGZyYWdtZW50QnlTdGFydCA9IHt9LFxuICAgICAgICBmcmFnbWVudEJ5RW5kID0ge30sXG4gICAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgICBlbXB0eUluZGV4ID0gLTE7XG5cbiAgICAvLyBTdGl0Y2ggZW1wdHkgYXJjcyBmaXJzdCwgc2luY2UgdGhleSBtYXkgYmUgc3Vic3VtZWQgYnkgb3RoZXIgYXJjcy5cbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCB0O1xuICAgICAgaWYgKGFyYy5sZW5ndGggPCAzICYmICFhcmNbMV1bMF0gJiYgIWFyY1sxXVsxXSkge1xuICAgICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIGUgPSBlbmRzKGkpLFxuICAgICAgICAgIHN0YXJ0ID0gZVswXSxcbiAgICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICAgIGYsIGc7XG5cbiAgICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgICBmLnB1c2goaSk7XG4gICAgICAgIGYuZW5kID0gZW5kO1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgICB2YXIgZmcgPSBnID09PSBmID8gZiA6IGYuY29uY2F0KGcpO1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgICAgZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICAgIHZhciBnZiA9IGcgPT09IGYgPyBmIDogZy5jb25jYXQoZik7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2dmLnN0YXJ0ID0gZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2dmLmVuZCA9IGYuZW5kXSA9IGdmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZiA9IFtpXTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBlbmRzKGkpIHtcbiAgICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgICAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgcDEgPSBbMCwgMF0sIGFyYy5mb3JFYWNoKGZ1bmN0aW9uKGRwKSB7IHAxWzBdICs9IGRwWzBdLCBwMVsxXSArPSBkcFsxXTsgfSk7XG4gICAgICBlbHNlIHAxID0gYXJjW2FyYy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KSB7XG4gICAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgICAgdmFyIGYgPSBmcmFnbWVudEJ5RW5kW2tdO1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgICAgZGVsZXRlIGYuZW5kO1xuICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24oaSkgeyBzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldID0gMTsgfSk7XG4gICAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gICAgZmx1c2goZnJhZ21lbnRCeVN0YXJ0LCBmcmFnbWVudEJ5RW5kKTtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkgeyBpZiAoIXN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0pIGZyYWdtZW50cy5wdXNoKFtpXSk7IH0pO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvLCBmaWx0ZXIpIHtcbiAgICB2YXIgYXJjcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgICAgIGdlb207XG5cbiAgICAgIGZ1bmN0aW9uIGFyYyhpKSB7XG4gICAgICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgICAgIChnZW9tc0J5QXJjW2pdIHx8IChnZW9tc0J5QXJjW2pdID0gW10pKS5wdXNoKHtpOiBpLCBnOiBnZW9tfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgICAgICBhcmNzLmZvckVhY2goYXJjKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcG9seWdvbihhcmNzKSB7XG4gICAgICAgIGFyY3MuZm9yRWFjaChsaW5lKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgICAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7XG4gICAgICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb20gPSBvLCBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6IHBvbHlnb24sXG4gICAgICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcykgeyBhcmNzLmZvckVhY2gocG9seWdvbik7IH1cbiAgICAgIH07XG5cbiAgICAgIGdlb21ldHJ5KG8pO1xuXG4gICAgICBnZW9tc0J5QXJjLmZvckVhY2goYXJndW1lbnRzLmxlbmd0aCA8IDNcbiAgICAgICAgICA/IGZ1bmN0aW9uKGdlb21zKSB7IGFyY3MucHVzaChnZW9tc1swXS5pKTsgfVxuICAgICAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aDsgaSA8IG47ICsraSkgYXJjcy5wdXNoKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoQXJjcyh0b3BvbG9neSwgYXJjcyl9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gICAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgICAgcG9seWdvbnMgPSBbXSxcbiAgICAgICAgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmIChvLnR5cGUgPT09IFwiUG9seWdvblwiKSByZWdpc3RlcihvLmFyY3MpO1xuICAgICAgZWxzZSBpZiAoby50eXBlID09PSBcIk11bHRpUG9seWdvblwiKSBvLmFyY3MuZm9yRWFjaChyZWdpc3Rlcik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWdpc3Rlcihwb2x5Z29uKSB7XG4gICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgKHBvbHlnb25zQnlBcmNbYXJjID0gYXJjIDwgMCA/IH5hcmMgOiBhcmNdIHx8IChwb2x5Z29uc0J5QXJjW2FyY10gPSBbXSkpLnB1c2gocG9seWdvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVyaW9yKHJpbmcpIHtcbiAgICAgIHJldHVybiBjYXJ0ZXNpYW5SaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pID4gMDsgLy8gVE9ETyBhbGxvdyBzcGhlcmljYWw/XG4gICAgfVxuXG4gICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gW10sXG4gICAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICAgIGNvbXBvbmVudC5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICAgIGFyY3M6IGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICAgIHZhciBhcmNzID0gW107XG5cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBhcmNzLnB1c2goYXJjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgICBhcmNzID0gc3RpdGNoQXJjcyh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSByaW5nIGlzIHJldHVybmVkLFxuICAgICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgICAvLyB0aGlzIGV4dGVyaW9yIHJpbmcgaGFzIHRoZSBzYW1lIHdpbmRpbmcgb3JkZXJcbiAgICAgICAgLy8gYXMgYW55IGV4dGVyaW9yIHJpbmcgaW4gdGhlIG9yaWdpbmFsIHBvbHlnb25zLlxuICAgICAgICBpZiAoKG4gPSBhcmNzLmxlbmd0aCkgPiAxKSB7XG4gICAgICAgICAgdmFyIHNnbiA9IGV4dGVyaW9yKHBvbHlnb25zWzBdWzBdKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKHNnbiA9PT0gZXh0ZXJpb3IoYXJjc1tpXSkpIHtcbiAgICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyY3M7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmZWF0dXJlT3JDb2xsZWN0aW9uKHRvcG9sb2d5LCBvKSB7XG4gICAgcmV0dXJuIG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA/IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUodG9wb2xvZ3ksIG8pOyB9KVxuICAgIH0gOiBmZWF0dXJlKHRvcG9sb2d5LCBvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgICB2YXIgZiA9IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgaWQ6IG8uaWQsXG4gICAgICBwcm9wZXJ0aWVzOiBvLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBnZW9tZXRyeTogb2JqZWN0KHRvcG9sb2d5LCBvKVxuICAgIH07XG4gICAgaWYgKG8uaWQgPT0gbnVsbCkgZGVsZXRlIGYuaWQ7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgICB2YXIgYWJzb2x1dGUgPSB0cmFuc2Zvcm1BYnNvbHV0ZSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICAgIGZ1bmN0aW9uIGFyYyhpLCBwb2ludHMpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGgsIHA7IGsgPCBuOyArK2spIHtcbiAgICAgICAgcG9pbnRzLnB1c2gocCA9IGFba10uc2xpY2UoKSk7XG4gICAgICAgIGFic29sdXRlKHAsIGspO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgICAgcCA9IHAuc2xpY2UoKTtcbiAgICAgIGFic29sdXRlKHAsIDApO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdLnNsaWNlKCkpO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nKGFyY3MpIHtcbiAgICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubWFwKHJpbmcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICAgIHZhciB0ID0gby50eXBlO1xuICAgICAgcmV0dXJuIHQgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgPyB7dHlwZTogdCwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9XG4gICAgICAgICAgOiB0IGluIGdlb21ldHJ5VHlwZSA/IHt0eXBlOiB0LCBjb29yZGluYXRlczogZ2VvbWV0cnlUeXBlW3RdKG8pfVxuICAgICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgUG9pbnQ6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIHBvaW50KG8uY29vcmRpbmF0ZXMpOyB9LFxuICAgICAgTXVsdGlQb2ludDogZnVuY3Rpb24obykgeyByZXR1cm4gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyB9LFxuICAgICAgTGluZVN0cmluZzogZnVuY3Rpb24obykgeyByZXR1cm4gbGluZShvLmFyY3MpOyB9LFxuICAgICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFyY3MubWFwKGxpbmUpOyB9LFxuICAgICAgUG9seWdvbjogZnVuY3Rpb24obykgeyByZXR1cm4gcG9seWdvbihvLmFyY3MpOyB9LFxuICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFyY3MubWFwKHBvbHlnb24pOyB9XG4gICAgfTtcblxuICAgIHJldHVybiBnZW9tZXRyeShvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXksIG4pIHtcbiAgICB2YXIgdCwgaiA9IGFycmF5Lmxlbmd0aCwgaSA9IGogLSBuOyB3aGlsZSAoaSA8IC0taikgdCA9IGFycmF5W2ldLCBhcnJheVtpKytdID0gYXJyYXlbal0sIGFycmF5W2pdID0gdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpc2VjdChhLCB4KSB7XG4gICAgdmFyIGxvID0gMCwgaGkgPSBhLmxlbmd0aDtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICBpZiAoYVttaWRdIDwgeCkgbG8gPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVpZ2hib3JzKG9iamVjdHMpIHtcbiAgICB2YXIgaW5kZXhlc0J5QXJjID0ge30sIC8vIGFyYyBpbmRleCAtPiBhcnJheSBvZiBvYmplY3QgaW5kZXhlc1xuICAgICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICAgIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgICBpZiAobykgby5wdXNoKGkpO1xuICAgICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgICAgZWxzZSBpZiAoby50eXBlIGluIGdlb21ldHJ5VHlwZSkgZ2VvbWV0cnlUeXBlW28udHlwZV0oby5hcmNzLCBpKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgTGluZVN0cmluZzogbGluZSxcbiAgICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKGFyY3MsIGkpIHsgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBwb2x5Z29uKGFyYywgaSk7IH0pOyB9XG4gICAgfTtcblxuICAgIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgICBmb3IgKHZhciBpIGluIGluZGV4ZXNCeUFyYykge1xuICAgICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgICB2YXIgaWogPSBpbmRleGVzW2pdLCBpayA9IGluZGV4ZXNba10sIG47XG4gICAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvcnM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVzaW1wbGlmeSh0b3BvbG9neSwgdHJpYW5nbGVBcmVhKSB7XG4gICAgdmFyIGFic29sdXRlID0gdHJhbnNmb3JtQWJzb2x1dGUodG9wb2xvZ3kudHJhbnNmb3JtKSxcbiAgICAgICAgcmVsYXRpdmUgPSB0cmFuc2Zvcm1SZWxhdGl2ZSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgICBoZWFwID0gbWluQXJlYUhlYXAoKTtcblxuICAgIGlmICghdHJpYW5nbGVBcmVhKSB0cmlhbmdsZUFyZWEgPSBjYXJ0ZXNpYW5UcmlhbmdsZUFyZWE7XG5cbiAgICB0b3BvbG9neS5hcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICB2YXIgdHJpYW5nbGVzID0gW10sXG4gICAgICAgICAgbWF4QXJlYSA9IDAsXG4gICAgICAgICAgdHJpYW5nbGU7XG5cbiAgICAgIC8vIFRvIHN0b3JlIGVhY2ggcG9pbnTigJlzIGVmZmVjdGl2ZSBhcmVhLCB3ZSBjcmVhdGUgYSBuZXcgYXJyYXkgcmF0aGVyIHRoYW5cbiAgICAgIC8vIGV4dGVuZGluZyB0aGUgcGFzc2VkLWluIHBvaW50IHRvIHdvcmthcm91bmQgYSBDaHJvbWUvVjggYnVnIChnZXR0aW5nXG4gICAgICAvLyBzdHVjayBpbiBzbWkgbW9kZSkuIEZvciBtaWRwb2ludHMsIHRoZSBpbml0aWFsIGVmZmVjdGl2ZSBhcmVhIG9mXG4gICAgICAvLyBJbmZpbml0eSB3aWxsIGJlIGNvbXB1dGVkIGluIHRoZSBuZXh0IHN0ZXAuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyYy5sZW5ndGgsIHA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgcCA9IGFyY1tpXTtcbiAgICAgICAgYWJzb2x1dGUoYXJjW2ldID0gW3BbMF0sIHBbMV0sIEluZmluaXR5XSwgaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBuID0gYXJjLmxlbmd0aCAtIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdHJpYW5nbGUgPSBhcmMuc2xpY2UoaSAtIDEsIGkgKyAyKTtcbiAgICAgICAgdHJpYW5nbGVbMV1bMl0gPSB0cmlhbmdsZUFyZWEodHJpYW5nbGUpO1xuICAgICAgICB0cmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XG4gICAgICAgIGhlYXAucHVzaCh0cmlhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlc1tpXTtcbiAgICAgICAgdHJpYW5nbGUucHJldmlvdXMgPSB0cmlhbmdsZXNbaSAtIDFdO1xuICAgICAgICB0cmlhbmdsZS5uZXh0ID0gdHJpYW5nbGVzW2kgKyAxXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRyaWFuZ2xlID0gaGVhcC5wb3AoKSkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSB0cmlhbmdsZS5wcmV2aW91cyxcbiAgICAgICAgICAgIG5leHQgPSB0cmlhbmdsZS5uZXh0O1xuXG4gICAgICAgIC8vIElmIHRoZSBhcmVhIG9mIHRoZSBjdXJyZW50IHBvaW50IGlzIGxlc3MgdGhhbiB0aGF0IG9mIHRoZSBwcmV2aW91cyBwb2ludFxuICAgICAgICAvLyB0byBiZSBlbGltaW5hdGVkLCB1c2UgdGhlIGxhdHRlcidzIGFyZWEgaW5zdGVhZC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgcG9pbnQgY2Fubm90IGJlIGVsaW1pbmF0ZWQgd2l0aG91dCBlbGltaW5hdGluZyBwcmV2aW91c2x5LVxuICAgICAgICAvLyBlbGltaW5hdGVkIHBvaW50cy5cbiAgICAgICAgaWYgKHRyaWFuZ2xlWzFdWzJdIDwgbWF4QXJlYSkgdHJpYW5nbGVbMV1bMl0gPSBtYXhBcmVhO1xuICAgICAgICBlbHNlIG1heEFyZWEgPSB0cmlhbmdsZVsxXVsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBwcmV2aW91c1syXSA9IHRyaWFuZ2xlWzJdO1xuICAgICAgICAgIHVwZGF0ZShwcmV2aW91cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICBuZXh0WzBdID0gdHJpYW5nbGVbMF07XG4gICAgICAgICAgdXBkYXRlKG5leHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFyYy5mb3JFYWNoKHJlbGF0aXZlKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0cmlhbmdsZSkge1xuICAgICAgaGVhcC5yZW1vdmUodHJpYW5nbGUpO1xuICAgICAgdHJpYW5nbGVbMV1bMl0gPSB0cmlhbmdsZUFyZWEodHJpYW5nbGUpO1xuICAgICAgaGVhcC5wdXNoKHRyaWFuZ2xlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9wb2xvZ3k7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FydGVzaWFuUmluZ0FyZWEocmluZykge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSByaW5nLmxlbmd0aCxcbiAgICAgICAgYSxcbiAgICAgICAgYiA9IHJpbmdbbiAtIDFdLFxuICAgICAgICBhcmVhID0gMDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSByaW5nW2ldO1xuICAgICAgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhICogLjU7XG4gIH1cblxuICBmdW5jdGlvbiBjYXJ0ZXNpYW5UcmlhbmdsZUFyZWEodHJpYW5nbGUpIHtcbiAgICB2YXIgYSA9IHRyaWFuZ2xlWzBdLCBiID0gdHJpYW5nbGVbMV0sIGMgPSB0cmlhbmdsZVsyXTtcbiAgICByZXR1cm4gTWF0aC5hYnMoKGFbMF0gLSBjWzBdKSAqIChiWzFdIC0gYVsxXSkgLSAoYVswXSAtIGJbMF0pICogKGNbMV0gLSBhWzFdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIGFbMV1bMl0gLSBiWzFdWzJdO1xuICB9XG5cbiAgZnVuY3Rpb24gbWluQXJlYUhlYXAoKSB7XG4gICAgdmFyIGhlYXAgPSB7fSxcbiAgICAgICAgYXJyYXkgPSBbXSxcbiAgICAgICAgc2l6ZSA9IDA7XG5cbiAgICBoZWFwLnB1c2ggPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHVwKGFycmF5W29iamVjdC5fID0gc2l6ZV0gPSBvYmplY3QsIHNpemUrKyk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgaGVhcC5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzaXplIDw9IDApIHJldHVybjtcbiAgICAgIHZhciByZW1vdmVkID0gYXJyYXlbMF0sIG9iamVjdDtcbiAgICAgIGlmICgtLXNpemUgPiAwKSBvYmplY3QgPSBhcnJheVtzaXplXSwgZG93bihhcnJheVtvYmplY3QuXyA9IDBdID0gb2JqZWN0LCAwKTtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG5cbiAgICBoZWFwLnJlbW92ZSA9IGZ1bmN0aW9uKHJlbW92ZWQpIHtcbiAgICAgIHZhciBpID0gcmVtb3ZlZC5fLCBvYmplY3Q7XG4gICAgICBpZiAoYXJyYXlbaV0gIT09IHJlbW92ZWQpIHJldHVybjsgLy8gaW52YWxpZCByZXF1ZXN0XG4gICAgICBpZiAoaSAhPT0gLS1zaXplKSBvYmplY3QgPSBhcnJheVtzaXplXSwgKGNvbXBhcmVBcmVhKG9iamVjdCwgcmVtb3ZlZCkgPCAwID8gdXAgOiBkb3duKShhcnJheVtvYmplY3QuXyA9IGldID0gb2JqZWN0LCBpKTtcbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cChvYmplY3QsIGkpIHtcbiAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICB2YXIgaiA9ICgoaSArIDEpID4+IDEpIC0gMSxcbiAgICAgICAgICAgIHBhcmVudCA9IGFycmF5W2pdO1xuICAgICAgICBpZiAoY29tcGFyZUFyZWEob2JqZWN0LCBwYXJlbnQpID49IDApIGJyZWFrO1xuICAgICAgICBhcnJheVtwYXJlbnQuXyA9IGldID0gcGFyZW50O1xuICAgICAgICBhcnJheVtvYmplY3QuXyA9IGkgPSBqXSA9IG9iamVjdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb3duKG9iamVjdCwgaSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHIgPSAoaSArIDEpIDw8IDEsXG4gICAgICAgICAgICBsID0gciAtIDEsXG4gICAgICAgICAgICBqID0gaSxcbiAgICAgICAgICAgIGNoaWxkID0gYXJyYXlbal07XG4gICAgICAgIGlmIChsIDwgc2l6ZSAmJiBjb21wYXJlQXJlYShhcnJheVtsXSwgY2hpbGQpIDwgMCkgY2hpbGQgPSBhcnJheVtqID0gbF07XG4gICAgICAgIGlmIChyIDwgc2l6ZSAmJiBjb21wYXJlQXJlYShhcnJheVtyXSwgY2hpbGQpIDwgMCkgY2hpbGQgPSBhcnJheVtqID0gcl07XG4gICAgICAgIGlmIChqID09PSBpKSBicmVhaztcbiAgICAgICAgYXJyYXlbY2hpbGQuXyA9IGldID0gY2hpbGQ7XG4gICAgICAgIGFycmF5W29iamVjdC5fID0gaSA9IGpdID0gb2JqZWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFwO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtQWJzb2x1dGUodHJhbnNmb3JtKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHJldHVybiBub29wO1xuICAgIHZhciB4MCxcbiAgICAgICAgeTAsXG4gICAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50LCBpKSB7XG4gICAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgICAgcG9pbnRbMF0gPSAoeDAgKz0gcG9pbnRbMF0pICoga3ggKyBkeDtcbiAgICAgIHBvaW50WzFdID0gKHkwICs9IHBvaW50WzFdKSAqIGt5ICsgZHk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVJlbGF0aXZlKHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSByZXR1cm4gbm9vcDtcbiAgICB2YXIgeDAsXG4gICAgICAgIHkwLFxuICAgICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICAgIHJldHVybiBmdW5jdGlvbihwb2ludCwgaSkge1xuICAgICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICAgIHZhciB4MSA9IChwb2ludFswXSAtIGR4KSAvIGt4IHwgMCxcbiAgICAgICAgICB5MSA9IChwb2ludFsxXSAtIGR5KSAvIGt5IHwgMDtcbiAgICAgIHBvaW50WzBdID0geDEgLSB4MDtcbiAgICAgIHBvaW50WzFdID0geTEgLSB5MDtcbiAgICAgIHgwID0geDE7XG4gICAgICB5MCA9IHkxO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIGRlZmluZSh0b3BvanNvbik7XG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gdG9wb2pzb247XG4gIGVsc2UgdGhpcy50b3BvanNvbiA9IHRvcG9qc29uO1xufSgpO1xuIiwibW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVsYXllci5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlbGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlKHBiZiwgZW5kKSB7XG4gICAgdGhpcy5sYXllcnMgPSBwYmYucmVhZEZpZWxkcyhyZWFkVGlsZSwge30sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUaWxlKHRhZywgbGF5ZXJzLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAzKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBWZWN0b3JUaWxlTGF5ZXIocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7XG4gICAgICAgIGlmIChsYXllci5sZW5ndGgpIGxheWVyc1tsYXllci5uYW1lXSA9IGxheWVyO1xuICAgIH1cbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShwYmYsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IC0xO1xuICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRGZWF0dXJlLCB0aGlzLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZSh0YWcsIGZlYXR1cmUsIHBiZikge1xuICAgIGlmICh0YWcgPT0gMSkgZmVhdHVyZS5faWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAyKSByZWFkVGFnKHBiZiwgZmVhdHVyZSk7XG4gICAgZWxzZSBpZiAodGFnID09IDMpIGZlYXR1cmUudHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDQpIGZlYXR1cmUuX2dlb21ldHJ5ID0gcGJmLnBvcztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZyhwYmYsIGZlYXR1cmUpIHtcbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIga2V5ID0gZmVhdHVyZS5fa2V5c1twYmYucmVhZFZhcmludCgpXSxcbiAgICAgICAgICAgIHZhbHVlID0gZmVhdHVyZS5fdmFsdWVzW3BiZi5yZWFkVmFyaW50KCldO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cblxuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBsaW5lcyA9IFtdLFxuICAgICAgICBsaW5lO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjbWQgPT09IDEpIHsgLy8gbW92ZVRvXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lLnB1c2gobmV3IFBvaW50KHgsIHkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gNykge1xuICAgICAgICAgICAgbGluZS5wdXNoKGxpbmVbMF0uY2xvbmUoKSk7IC8vIGNsb3NlUG9seWdvblxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCAhPT0gNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmV4dGVudCAqIE1hdGgucG93KDIsIHopLFxuICAgICAgICB4MCA9IHRoaXMuZXh0ZW50ICogeCxcbiAgICAgICAgeTAgPSB0aGlzLmV4dGVudCAqIHksXG4gICAgICAgIGNvb3JkcyA9IHRoaXMubG9hZEdlb21ldHJ5KCksXG4gICAgICAgIHR5cGUgPSBWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1t0aGlzLnR5cGVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjb29yZHNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHAgPSBsaW5lW2pdLCB5MiA9IDE4MCAtIChwLnkgKyB5MCkgKiAzNjAgLyBzaXplO1xuICAgICAgICAgICAgbGluZVtqXSA9IFtcbiAgICAgICAgICAgICAgICAocC54ICsgeDApICogMzYwIC8gc2l6ZSAtIDE4MCxcbiAgICAgICAgICAgICAgICAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50JyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXVswXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgICAgICB0eXBlID0gJ011bHRpUG9pbnQnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnICYmIGNvb3Jkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRzXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllc1xuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUxheWVyO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlTGF5ZXIocGJmLCBlbmQpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSA0MDk2O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9wYmYgPSBwYmY7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XG5cbiAgICBwYmYucmVhZEZpZWxkcyhyZWFkTGF5ZXIsIHRoaXMsIGVuZCk7XG5cbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmVhZExheWVyKHRhZywgbGF5ZXIsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDE1KSBsYXllci52ZXJzaW9uID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDEpIGxheWVyLm5hbWUgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNSkgbGF5ZXIuZXh0ZW50ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGxheWVyLl9mZWF0dXJlcy5wdXNoKHBiZi5wb3MpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgbGF5ZXIuX2tleXMucHVzaChwYmYucmVhZFN0cmluZygpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIGxheWVyLl92YWx1ZXMucHVzaChyZWFkVmFsdWVNZXNzYWdlKHBiZikpO1xufVxuXG5mdW5jdGlvbiByZWFkVmFsdWVNZXNzYWdlKHBiZikge1xuICAgIHZhciB2YWx1ZSA9IG51bGwsXG4gICAgICAgIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBiZi5yZWFkVmFyaW50KCkgPj4gMztcblxuICAgICAgICB2YWx1ZSA9IHRhZyA9PT0gMSA/IHBiZi5yZWFkU3RyaW5nKCkgOlxuICAgICAgICAgICAgdGFnID09PSAyID8gcGJmLnJlYWRGbG9hdCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMyA/IHBiZi5yZWFkRG91YmxlKCkgOlxuICAgICAgICAgICAgdGFnID09PSA0ID8gcGJmLnJlYWRWYXJpbnQ2NCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNSA/IHBiZi5yZWFkVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA2ID8gcGJmLnJlYWRTVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA3ID8gcGJmLnJlYWRCb29sZWFuKCkgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcmV0dXJuIGZlYXR1cmUgYGlgIGZyb20gdGhpcyBsYXllciBhcyBhIGBWZWN0b3JUaWxlRmVhdHVyZWBcblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZmVhdHVyZSBpbmRleCBvdXQgb2YgYm91bmRzJyk7XG5cbiAgICB0aGlzLl9wYmYucG9zID0gdGhpcy5fZmVhdHVyZXNbaV07XG5cbiAgICB2YXIgZW5kID0gdGhpcy5fcGJmLnJlYWRWYXJpbnQoKSArIHRoaXMuX3BiZi5wb3M7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlRmVhdHVyZSh0aGlzLl9wYmYsIGVuZCwgdGhpcy5leHRlbnQsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIGFkZDogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHApOyAgICAgfSxcbiAgICBzdWI6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihwKTsgICAgIH0sXG4gICAgbXVsdDogICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KGspOyAgICB9LFxuICAgIGRpdjogICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KGspOyAgICAgfSxcbiAgICByb3RhdGU6ICBmdW5jdGlvbihhKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdGF0ZShhKTsgIH0sXG4gICAgbWF0TXVsdDogZnVuY3Rpb24obSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KG0pOyB9LFxuICAgIHVuaXQ6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl91bml0KCk7IH0sXG4gICAgcGVycDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTsgfSxcbiAgICByb3VuZDogICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTsgfSxcblxuICAgIG1hZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHAueCAmJlxuICAgICAgICAgICAgICAgdGhpcy55ID09PSBwLnk7XG4gICAgfSxcblxuICAgIGRpc3Q6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIocCkpO1xuICAgIH0sXG5cbiAgICBkaXN0U3FyOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueCxcbiAgICAgICAgICAgIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVRvOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSAtIGIueSwgdGhpcy54IC0gYi54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVXaXRoOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuZ2xlV2l0aFNlcChiLngsIGIueSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGFuZ2xlIG9mIHRoZSB0d28gdmVjdG9ycywgc29sdmluZyB0aGUgZm9ybXVsYSBmb3IgdGhlIGNyb3NzIHByb2R1Y3QgYSB4IGIgPSB8YXx8YnxzaW4ozrgpIGZvciDOuC5cbiAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoXG4gICAgICAgICAgICB0aGlzLnggKiB5IC0gdGhpcy55ICogeCxcbiAgICAgICAgICAgIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5KTtcbiAgICB9LFxuXG4gICAgX21hdE11bHQ6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHggPSBtWzBdICogdGhpcy54ICsgbVsxXSAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBtWzJdICogdGhpcy54ICsgbVszXSAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54ICs9IHAueDtcbiAgICAgICAgdGhpcy55ICs9IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54IC09IHAueDtcbiAgICAgICAgdGhpcy55IC09IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tdWx0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAqPSBrO1xuICAgICAgICB0aGlzLnkgKj0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kaXY6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54IC89IGs7XG4gICAgICAgIHRoaXMueSAvPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3VuaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXYodGhpcy5tYWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcGVycDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB0aGlzLnkgPSB0aGlzLng7XG4gICAgICAgIHRoaXMueCA9IC15O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBjb3MgKiB0aGlzLnggLSBzaW4gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gc2luICogdGhpcy54ICsgY29zICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgUG9pbnQgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcblBvaW50LmNvbnZlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoYVswXSwgYVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbiIsIi8qZ2xvYmFsIENhbWVyYSAqL1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcblxuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XG52YXIgbWF0NCA9IGdsTWF0cml4Lm1hdDQ7XG52YXIgdmVjMyA9IGdsTWF0cml4LnZlYzM7XG5cbi8vIEFic3RyYWN0IGJhc2UgY2xhc3NcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY2VuZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIHRoaXMuem9vbSA9IG9wdGlvbnMuem9vbTtcbiAgICAgICAgLy8gdGhpcy51cGRhdGVTY2VuZSgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNhbWVyYSBieSB0eXBlIG5hbWUsIGZhY3Rvcnktc3R5bGVcbiAgICBzdGF0aWMgY3JlYXRlKG5hbWUsIHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaXNvbWV0cmljJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElzb21ldHJpY0NhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxhdENhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ3BlcnNwZWN0aXZlJzpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtZXRob2QgY2FsbGVkIG9uY2UgcGVyIGZyYW1lXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyB0aGlzLnVwZGF0ZVNjZW5lKCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGZyYW1lIHBlciBwcm9ncmFtIChlLmcuIGZvciBtYWluIHJlbmRlciBwYXNzLCB0aGVuIGZvciBlYWNoIGFkZGl0aW9uYWwgcGFzcyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24sIGV0Yy4pXG4gICAgc2V0dXBQcm9ncmFtKHByb2dyYW0pIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgU3luYyBjYW1lcmEgcG9zaXRpb24gYW5kL29yIHpvb20gdG8gc2NlbmVcbiAgICAgICAgcG9zaXRpb246IFtsYXQsIGxuZ10gb3IgW2xhdCwgbG5nLCB6b29tXVxuICAgICAgICB6b29tOiB6b29tXG4gICAgKi9cbiAgICB1cGRhdGVTY2VuZSAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uIHx8IHRoaXMuem9vbSkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmlldyA9IHsgbG5nOiB0aGlzLnBvc2l0aW9uWzBdLCBsYXQ6IHRoaXMucG9zaXRpb25bMV0sIHpvb206IHRoaXMucG9zaXRpb25bMl0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnpvb20pIHtcbiAgICAgICAgICAgICAgICB2aWV3Lnpvb20gPSB0aGlzLnpvb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNldFZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyoqXG4gICAgUGVyc3BlY3RpdmUgbWF0cml4IHByb2plY3Rpb25cblxuICAgIFRoaXMgaXMgYSBzcGVjaWFsaXplZCBwZXJzcGVjdGl2ZSBjYW1lcmEgdGhhdCwgZ2l2ZW4gYSBkZXNpcmVkIGNhbWVyYSBmb2NhbCBsZW5ndGggKHdoaWNoIGNhbiBhbHNvIHZhcnkgYnkgem9vbSBsZXZlbCksXG4gICAgY29uc3RyYWlucyB0aGUgY2FtZXJhIGhlaWdodCBhYm92ZSB0aGUgZ3JvdW5kIHBsYW5lIHN1Y2ggdGhhdCB0aGUgZGlzcGxheWVkIGdyb3VuZCBhcmVhIG9mIHRoZSBtYXAgbWF0Y2hlcyB0aGF0IG9mXG4gICAgYSB0cmFkaXRpb25hbCB3ZWIgbWVyY2F0b3IgbWFwLiBUaGlzIG1lYW5zIHlvdSBjYW4gc2V0IHRoZSBjYW1lcmEgbG9jYXRpb24gYnkgW2xhdCwgbG5nLCB6b29tXSBhcyB5b3Ugd291bGQgYSB0eXBpY2FsXG4gICAgd2ViIG1lcmNhdG9yIG1hcCwgdGhlbiBhZGp1c3QgdGhlIGZvY2FsIGxlbmd0aCBhcyBuZWVkZWQuXG5cbiAgICBWYW5pc2hpbmcgcG9pbnQgY2FuIGFsc28gYmUgYWRqdXN0ZWQgdG8gYWNoaWV2ZSBkaWZmZXJlbnQgXCJ2aWV3aW5nIGFuZ2xlc1wiLCBlLmcuIGluc3RlYWQgb2YgbG9va2luZyBzdHJhaWdodCBkb3duIGludG9cbiAgICB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCwgdGhlIGNhbWVyYSBhcHBlYXJzIHRvIGJlIHRpbHRlZCBhdCBhbiBhbmdsZS4gRm9yIGV4YW1wbGU6XG5cbiAgICBbMCwgMF0gPSBsb29raW5nIHRvd2FyZHMgY2VudGVyIG9mIHZpZXdwb3J0XG4gICAgWy0yNTAsIC0yNTBdID0gbG9va2luZyAyNTAgcGl4ZWxzIGZyb20gdGhlIHZpZXdwb3J0IGNlbnRlciB0byB0aGUgbG93ZXItbGVmdCBjb3JuZXJcbiAgICBbNDAwLCAwXSA9IGxvb2tpbmcgNDAwIHBpeGVscyB0byB0aGUgcmlnaHQgb2YgdGhlIHZpZXdwb3J0IGNlbnRlclxuKi9cbmNsYXNzIFBlcnNwZWN0aXZlQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgc2NlbmUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGVyc3BlY3RpdmUnO1xuXG4gICAgICAgIC8vIGEgc2luZ2xlIHNjYWxhciwgb3IgcGFpcnMgb2Ygc3RvcHMgbWFwcGluZyB6b29tIGxldmVscywgZS5nLiBbem9vbSwgZm9jYWwgbGVuZ3RoXVxuICAgICAgICB0aGlzLmZvY2FsX2xlbmd0aCA9IG9wdGlvbnMuZm9jYWxfbGVuZ3RoO1xuICAgICAgICB0aGlzLmZvdiA9IG9wdGlvbnMuZm92O1xuICAgICAgICBpZiAoIXRoaXMuZm9jYWxfbGVuZ3RoICYmICF0aGlzLmZvdikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBmb2NhbCBsZW5ndGggcmFuZ2VzIGJ5IHpvb21cbiAgICAgICAgICAgIHRoaXMuZm9jYWxfbGVuZ3RoID0gW1sxNiwgMl0sIFsxNywgMi41XSwgWzE4LCAzXSwgWzE5LCA0XSwgWzIwLCA2XV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludCA9IG9wdGlvbnMudmFuaXNoaW5nX3BvaW50IHx8IFswLCAwXTsgLy8gW3gsIHldXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXcgPSBbXTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuICAgICAgICAvLyAnY2FtZXJhJyBpcyB0aGUgbmFtZSBvZiB0aGUgc2hhZGVyIGJsb2NrLCBlLmcuIGRldGVybWluZXMgd2hlcmUgaW4gdGhlIHNoYWRlciB0aGlzIGNvZGUgaXMgaW5qZWN0ZWRcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZXBsYWNlQmxvY2soJ2NhbWVyYScsIGBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdV9leWU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV92YW5pc2hpbmdfcG9pbnQ7XG5cbiAgICAgICAgICAgIHZvaWQgY2FtZXJhUHJvamVjdGlvbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogcG9zaXRpb247XG4gICAgICAgICAgICB9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIENvbnN0cmFpbnMgdGhlIGNhbWVyYSBzbyB0aGF0IHRoZSB2aWV3YWJsZSBhcmVhIG1hdGNoZXMgZ2l2ZW4gdGhlIHZpZXdwb3J0IGhlaWdodFxuICAgIC8vIChpbiB3b3JsZCBzcGFjZSwgZS5nLiBtZXRlcnMpLCBnaXZlbiBlaXRoZXIgYSBjYW1lcmEgZm9jYWwgbGVuZ3RoIG9yIGZpZWxkLW9mLXZpZXdcbiAgICAvLyAoZm9jYWwgbGVuZ3RoIGlzIHVzZWQgaWYgYm90aCBhcmUgcGFzc2VkKS5cbiAgICBjb25zdHJhaW5DYW1lcmEoeyB2aWV3X2hlaWdodCwgaGVpZ2h0LCBmb2NhbF9sZW5ndGgsIGZvdiB9KSB7XG4gICAgICAgIC8vIFNvbHZlIGZvciBjYW1lcmEgaGVpZ2h0XG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGZvY2FsIGxlbmd0aCwgY2FsY3VsYXRlIEZPVlxuICAgICAgICAgICAgaWYgKGZvY2FsX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvdiA9IE1hdGguYXRhbigxIC8gZm9jYWxfbGVuZ3RoKSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBoYXZlIEZPViwgY2FsY3VsYXRlIGZvY2FsIGxlbmd0aFxuICAgICAgICAgICAgZWxzZSBpZiAoZm92KSB7XG4gICAgICAgICAgICAgICAgZm92ID0gZm92ICogTWF0aC5QSSAvIDE4MDsgLy8gY29udmVydCBGT1YgZGVncmVlcyB0byByYWRpYW5zXG4gICAgICAgICAgICAgICAgZm9jYWxfbGVuZ3RoID0gMSAvIE1hdGgudGFuKGZvdiAvIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXN0YW5jZSB0aGF0IGNhbWVyYSBzaG91bGQgYmUgZnJvbSBncm91bmQgc3VjaCB0aGF0IGl0IGZpdHMgdGhlIGZpZWxkIG9mIHZpZXcgZXhwZWN0ZWRcbiAgICAgICAgICAgIC8vIGZvciBhIGNvbnZlbnRpb25hbCB3ZWIgbWVyY2F0b3IgbWFwIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYW5kIGNhbWVyYSBmb2NhbCBsZW5ndGhcbiAgICAgICAgICAgIGhlaWdodCA9IHZpZXdfaGVpZ2h0IC8gMiAqIGZvY2FsX2xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb2x2ZSBmb3IgY2FtZXJhIGZvY2FsIGxlbmd0aCAvIGZpZWxkLW9mLXZpZXdcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb2NhbF9sZW5ndGggPSAyICogaGVpZ2h0IC8gdmlld19oZWlnaHQ7XG4gICAgICAgICAgICBmb3YgPSBNYXRoLmF0YW4oMSAvIGZvY2FsX2xlbmd0aCkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmlld19oZWlnaHQsIGhlaWdodCwgZm9jYWxfbGVuZ3RoLCBmb3YgfTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYXRyaWNlcygpIHtcbiAgICAgICAgLy8gVE9ETzogb25seSByZS1jYWxjdWxhdGUgdGhlc2UgdmFycyB3aGVuIG5lY2Vzc2FyeVxuXG4gICAgICAgIC8vIEhlaWdodCBvZiB0aGUgdmlld3BvcnQgaW4gbWV0ZXJzIGF0IGN1cnJlbnQgem9vbVxuICAgICAgICB2YXIgdmlld3BvcnRfaGVpZ2h0ID0gdGhpcy5zY2VuZS5jc3Nfc2l6ZS5oZWlnaHQgKiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy5zY2VuZS56b29tKTtcblxuICAgICAgICAvLyBDb21wdXRlIGNhbWVyYSBwcm9wZXJ0aWVzIHRvIGZpdCBkZXNpcmVkIHZpZXdcbiAgICAgICAgdmFyIHsgaGVpZ2h0LCBmb3YgfSA9IHRoaXMuY29uc3RyYWluQ2FtZXJhKHtcbiAgICAgICAgICAgIHZpZXdfaGVpZ2h0OiB2aWV3cG9ydF9oZWlnaHQsXG4gICAgICAgICAgICBmb2NhbF9sZW5ndGg6IFV0aWxzLmludGVycG9sYXRlKHRoaXMuc2NlbmUuem9vbSwgdGhpcy5mb2NhbF9sZW5ndGgpLFxuICAgICAgICAgICAgZm92OiBVdGlscy5pbnRlcnBvbGF0ZSh0aGlzLnNjZW5lLnpvb20sIHRoaXMuZm92KVxuICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVmlldyBtYXRyaXhcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW3RoaXMuc2NlbmUuY2VudGVyX21ldGVycy54LCB0aGlzLnNjZW5lLmNlbnRlcl9tZXRlcnMueSwgaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9tZXRlcnMgPSBwb3NpdGlvbjtcblxuICAgICAgICAvLyBtYXQ0Lmxvb2tBdCh0aGlzLnZpZXdNYXRyaXgsXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMoLi4ucG9zaXRpb24pLFxuICAgICAgICAvLyAgICAgdmVjMy5mcm9tVmFsdWVzKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgaGVpZ2h0IC0gMSksXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCkpO1xuICAgICAgICAvLyBFeGNsdWRlIGNhbWVyYSBoZWlnaHQgZnJvbSB2aWV3IG1hdHJpeFxuICAgICAgICBtYXQ0Lmxvb2tBdCh0aGlzLnZpZXdNYXRyaXgsXG4gICAgICAgICAgICB2ZWMzLmZyb21WYWx1ZXMocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCAwKSxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIC0xKSxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKSk7XG5cbiAgICAgICAgLy8gUHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgbWF0NC5wZXJzcGVjdGl2ZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIGZvdiwgdGhpcy5zY2VuZS52aWV3X2FzcGVjdCwgMSwgaGVpZ2h0ICogMik7XG5cbiAgICAgICAgLy8gQ29udmVydCB2YW5pc2hpbmcgcG9pbnQgZnJvbSBwaXhlbHMgdG8gdmlld3BvcnQgc3BhY2VcbiAgICAgICAgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXSA9IHRoaXMudmFuaXNoaW5nX3BvaW50WzBdIC8gdGhpcy5zY2VuZS5jc3Nfc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1sxXSA9IHRoaXMudmFuaXNoaW5nX3BvaW50WzFdIC8gdGhpcy5zY2VuZS5jc3Nfc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gQWRqdXN0IHByb2plY3Rpb24gbWF0cml4IHRvIGluY2x1ZGUgdmFuaXNoaW5nIHBvaW50IHNrZXdcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzhdID0gLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMF07IC8vIHogY29sdW1uIG9mIHggcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHhcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzldID0gLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV07IC8vIHogY29sdW1uIG9mIHkgcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHlcblxuICAgICAgICAvLyBUcmFuc2xhdGUgZ2VvbWV0cnkgaW50byB0aGUgZGlzdGFuY2Ugc28gdGhhdCBjYW1lcmEgaXMgYXBwcm9wcmlhdGUgaGVpZ2h0IGFib3ZlIGdyb3VuZFxuICAgICAgICAvLyBBZGRpdGlvbmFsbHksIGFkanVzdCB4eSB0byBjb21wZW5zYXRlIGZvciBhbnkgdmFuaXNoaW5nIHBvaW50IHNrZXcsIGUuZy4gbW92ZSBnZW9tZXRyeSBzbyB0aGF0IHRoZSBkaXNwbGF5ZWQgZ1xuICAgICAgICAvLyBwbGFuZSBvZiB0aGUgbWFwIG1hdGNoZXMgdGhhdCBleHBlY3RlZCBieSBhIHRyYWRpdGlvbmFsIHdlYiBtZXJjYXRvciBtYXAgYXQgdGhpcyBbbGF0LCBsbmcsIHpvb21dLlxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhcbiAgICAgICAgICAgICAgICB2aWV3cG9ydF9oZWlnaHQvMiAqIHRoaXMuc2NlbmUudmlld19hc3BlY3QgKiAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXSxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydF9oZWlnaHQvMiAqIC10aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzFdLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJbmNsdWRlIGNhbWVyYSBoZWlnaHQgaW4gcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgsIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAtaGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBzdXBlci51cGRhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaWNlcygpO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfcHJvamVjdGlvbicsIGZhbHNlLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgMCwgMCwgdGhpcy5wb3NpdGlvbl9tZXRlcnNbMl0pO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzJmdicsICd1X3ZhbmlzaGluZ19wb2ludCcsIHRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXcpO1xuICAgIH1cblxufVxuXG4vLyBJc29tZXRyaWMtc3R5bGUgcHJvamVjdGlvblxuLy8gTm90ZTogdGhpcyBpcyBhY3R1YWxseSBhbiBcImF4b25vbWV0cmljXCIgcHJvamVjdGlvbiwgYnV0IEknbSB1c2luZyB0aGUgY29sbG9xdWlhbCB0ZXJtIGlzb21ldHJpYyBiZWNhdXNlIGl0IGlzIG1vcmUgcmVjb2duaXphYmxlLlxuLy8gQW4gaXNvbWV0cmljIHByb2plY3Rpb24gaXMgYSBzcGVjaWZpYyBzdWJzZXQgb2YgYXhvbm9tZXRyaWMgcHJvamVjdGlvbnMuXG4vLyAnYXhpcycgZGV0ZXJtaW5lcyB0aGUgeHkgc2tldyBhcHBsaWVkIHRvIGEgdmVydGV4IGJhc2VkIG9uIGl0cyB6IGNvb3JkaW5hdGUsIGUuZy4gWzAsIDFdIGF4aXMgY2F1c2VzIGJ1aWxkaW5ncyB0byBiZSBkcmF3blxuLy8gc3RyYWlnaHQgdXB3YXJkcyBvbiBzY3JlZW4gYXQgdGhlaXIgdHJ1ZSBoZWlnaHQsIFswLCAuNV0gd291bGQgZHJhdyB0aGVtIHVwIGF0IGhhbGYtaGVpZ2h0LCBbMSwgMF0gd291bGQgYmUgc2lkZXdheXMsIGV0Yy5cbmNsYXNzIElzb21ldHJpY0NhbWVyYSBleHRlbmRzIENhbWVyYSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY2VuZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHNjZW5lLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2lzb21ldHJpYyc7XG4gICAgICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCB7IHg6IDAsIHk6IDEgfTtcbiAgICAgICAgaWYgKHRoaXMuYXhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXhpcyA9IHsgeDogdGhpcy5heGlzWzBdLCB5OiB0aGlzLmF4aXNbMV0gfTsgLy8gYWxsb3cgYXhpcyB0byBhbHNvIGJlIHBhc3NlZCBhcyAyLWVsZW0gYXJyYXlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zaXRpb25fbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3cG9ydF9oZWlnaHQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuICAgICAgICAvLyAnY2FtZXJhJyBpcyB0aGUgbmFtZSBvZiB0aGUgc2hhZGVyIGJsb2NrLCBlLmcuIGRldGVybWluZXMgd2hlcmUgaW4gdGhlIHNoYWRlciB0aGlzIGNvZGUgaXMgaW5qZWN0ZWRcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZXBsYWNlQmxvY2soJ2NhbWVyYScsIGBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdV9leWU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV92YW5pc2hpbmdfcG9pbnQ7XG5cbiAgICAgICAgICAgIHZvaWQgY2FtZXJhUHJvamVjdGlvbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdV9wcm9qZWN0aW9uICogcG9zaXRpb247XG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb24ueHkgKz0gcG9zaXRpb24ueiAqIHVfaXNvbWV0cmljX2F4aXM7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIHogZm9yIGRlcHRoIGJ1ZmZlciBzbyB1cCBpcyBuZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgc2NhbGUgZG93biB2YWx1ZXMgc28gb2JqZWN0cyBoaWdoZXIgdGhhbiBvbmUgc2NyZWVuIGhlaWdodCB3aWxsIG5vdCBnZXQgY2xpcHBlZFxuICAgICAgICAgICAgICAgIC8vIHB1bGwgZm9yd2FyZCBzbGlnaHRseSB0byBhdm9pZCBnb2luZyBwYXN0IGZhciBjbGlwcGluZyBwbGFuZVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnogPSAtcG9zaXRpb24ueiAvIDEwMC4gKyAxLiAtIDAuMDAxO1xuICAgICAgICAgICAgfWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuXG4gICAgICAgIHRoaXMudmlld3BvcnRfaGVpZ2h0ID0gdGhpcy5zY2VuZS5jc3Nfc2l6ZS5oZWlnaHQgKiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy5zY2VuZS56b29tKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW3RoaXMuc2NlbmUuY2VudGVyX21ldGVycy54LCB0aGlzLnNjZW5lLmNlbnRlcl9tZXRlcnMueSwgdGhpcy52aWV3cG9ydF9oZWlnaHRdO1xuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IHBvc2l0aW9uO1xuXG4gICAgICAgIC8vIFZpZXdcbiAgICAgICAgbWF0NC5pZGVudGl0eSh0aGlzLnZpZXdNYXRyaXgpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnZpZXdNYXRyaXgsIHRoaXMudmlld01hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKC1wb3NpdGlvblswXSwgLXBvc2l0aW9uWzFdLCAwKSk7XG5cbiAgICAgICAgLy8gUHJvamVjdGlvblxuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICAgICAgLy8gYXBwbHkgaXNvbWV0cmljIHNrZXdcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzhdID0gdGhpcy5heGlzLnggLyB0aGlzLnNjZW5lLnZpZXdfYXNwZWN0OyAgICAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB4XG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeFs5XSA9IHRoaXMuYXhpcy55OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geiBjb2x1bW4gb2YgeCByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeVxuXG4gICAgICAgIC8vIGNvbnZlcnQgbWV0ZXJzIHRvIHZpZXdwb3J0XG4gICAgICAgIG1hdDQuc2NhbGUodGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgsXG4gICAgICAgICAgICB2ZWMzLmZyb21WYWx1ZXMoXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMuc2NlbmUudmlld3BvcnRfbWV0ZXJzLngsXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMuc2NlbmUudmlld3BvcnRfbWV0ZXJzLnksXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMuc2NlbmUudmlld3BvcnRfbWV0ZXJzLnlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X3Byb2plY3Rpb24nLCBmYWxzZSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgMCwgMCwgdGhpcy52aWV3cG9ydF9oZWlnaHQpO1xuICAgICAgICAvLyBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgdGhpcy52aWV3cG9ydF9oZWlnaHQgKiB0aGlzLmF4aXMueCwgdGhpcy52aWV3cG9ydF9oZWlnaHQgKiB0aGlzLmF4aXMueSwgdGhpcy52aWV3cG9ydF9oZWlnaHQpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzJmJywgJ3VfdmFuaXNoaW5nX3BvaW50JywgMCwgMCk7XG4gICAgfVxuXG59XG5cbi8vIEZsYXQgcHJvamVjdGlvbiAoZS5nLiBqdXN0IHRvcC1kb3duLCBubyBwZXJzcGVjdGl2ZSkgLSBhIGRlZ2VuZXJhdGUgaXNvbWV0cmljIGNhbWVyYVxuY2xhc3MgRmxhdENhbWVyYSBleHRlbmRzIElzb21ldHJpY0NhbWVyYSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY2VuZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHNjZW5lLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZsYXQnO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gQXhpcyBpcyBmaXhlZCB0byAoMCwgMCkgZm9yIGZsYXQgY2FtZXJhXG4gICAgICAgIHRoaXMuYXhpcy54ID0gMDtcbiAgICAgICAgdGhpcy5heGlzLnkgPSAwO1xuXG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuICAgIH1cblxufVxuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlICovXG4vKmdsb2JhbHMgRGF0YVNvdXJjZSwgdG9wb2pzb24gKi9cbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IHtNZXRob2ROb3RJbXBsZW1lbnRlZH0gZnJvbSAnLi91dGlscy9lcnJvcnMnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuXG4vLyBGb3IgVG9wb0pTT04gdGlsZXNcbmltcG9ydCB0b3BvanNvbiBmcm9tICd0b3BvanNvbic7XG5cbi8vIEZvciBNVlQgdGlsZXNcbmltcG9ydCBQYmYgZnJvbSAncGJmJztcbmltcG9ydCB7VmVjdG9yVGlsZSwgVmVjdG9yVGlsZUZlYXR1cmV9IGZyb20gJ3ZlY3Rvci10aWxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YVNvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuaWQgPSBzb3VyY2UuaWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuICAgICAgICB0aGlzLnVybCA9IHNvdXJjZS51cmw7XG5cbiAgICAgICAgLy8gT3B0aW9uYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHNvdXJjZSBkYXRhXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gc291cmNlLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHRvIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAgICAgICAgdGhpcy5leHRyYV9kYXRhID0gc291cmNlLmV4dHJhX2RhdGE7XG5cbiAgICAgICAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBzY3JpcHRzIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAgICAgICAgaWYgKHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nICYmIHNvdXJjZS5zY3JpcHRzKSB7XG4gICAgICAgICAgICBzb3VyY2Uuc2NyaXB0cy5mb3JFYWNoKGZ1bmN0aW9uKHMsIHNpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhzKTtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCdpbmZvJywgJ0RhdGFTb3VyY2U6IGxvYWRlZCBsaWJyYXJ5OiAnICsgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnZXJyb3InLCAnRGF0YVNvdXJjZTogZmFpbGVkIHRvIGxvYWQgbGlicmFyeTogJyArIHMpO1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVyem9vbSB3aWxsIGFwcGx5IGZvciB6b29tcyBoaWdoZXIgdGhhbiB0aGlzXG4gICAgICAgIHRoaXMubWF4X3pvb20gPSBzb3VyY2UubWF4X3pvb20gfHwgR2VvLm1heF96b29tO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbGUgc291cmNlIGJ5IHR5cGUsIGZhY3Rvcnktc3R5bGVcbiAgICBzdGF0aWMgY3JlYXRlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKERhdGFTb3VyY2UudHlwZXNbc291cmNlLnR5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFTb3VyY2UudHlwZXNbc291cmNlLnR5cGVdKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNZXJjYXRvciBwcm9qZWN0aW9uXG4gICAgc3RhdGljIHByb2plY3REYXRhIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIHRpbWVyID0gK25ldyBEYXRlKCk7XG4gICAgICAgIGZvciAodmFyIHQgaW4gc291cmNlLmxheWVycykge1xuICAgICAgICAgICAgdmFyIG51bV9mZWF0dXJlcyA9IHNvdXJjZS5sYXllcnNbdF0uZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbnVtX2ZlYXR1cmVzOyBmKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHNvdXJjZS5sYXllcnNbdF0uZmVhdHVyZXNbZl07XG4gICAgICAgICAgICAgICAgR2VvLnRyYW5zZm9ybUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGNvb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyhjb29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzBdID0geDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSB5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZS5kZWJ1ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb3VyY2UuZGVidWcucHJvamVjdGlvbiA9ICtuZXcgRGF0ZSgpIC0gdGltZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgUmUtc2NhbGUgZ2VvbWV0cmllcyB3aXRoaW4gZWFjaCBzb3VyY2UgdG8gdGhlIHJhbmdlIFswLCBzY2FsZV1cbiAgICAgVE9ETzogY2xpcCB2ZXJ0aWNlcyBhdCBlZGdlcz8gcmlnaHQgbm93IHZlcnRpY2VzIGNhbiBoYXZlXG4gICAgIHZhbHVlcyBvdXRzaWRlIFswLCBzY2FsZV0gKG92ZXIgb3IgdW5kZXIgYm91bmRzKTsgdGhpcyB3b3VsZFxuICAgICBwb3NlIGEgcHJvYmxlbSBpZiB3ZSB3YW50ZWQgdG8gYmluYXJ5IGVuY29kZSB0aGUgdmVydGljZXMgaW5cbiAgICAgZmV3ZXIgYml0cyAoZS5nLiAxMiBiaXRzIGVhY2ggZm9yIHNjYWxlIG9mIDQwOTYpXG4gICAgKi9cbiAgICBzdGF0aWMgc2NhbGVEYXRhIChzb3VyY2UsIHtjb29yZHM6IHt6fSwgbWlufSkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHNvdXJjZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IG51bV9mZWF0dXJlczsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzBdID0gKGNvb3JkWzBdIC0gbWluLngpICogR2VvLnVuaXRzX3Blcl9tZXRlclt6XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyB3aWxsIGNyZWF0ZSBuZWdhdGl2ZSB5LWNvb3JkcywgZm9yY2UgcG9zaXRpdmUgYXMgYmVsb3cgaW5zdGVhZD8gb3IsIGlmIGxhdGVyIHN0b3JpbmcgcG9zaXRpdmUgY29vcmRzIGluIGJpdC1wYWNrZWQgdmFsdWVzLCBmbGlwIHRvIG5lZ2F0aXZlIGluIHBvc3QtcHJvY2Vzc2luZz9cbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSAoY29vcmRbMV0gLSBtaW4ueSkgKiBHZW8udW5pdHNfcGVyX21ldGVyW3pdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb29yZFsxXSA9IChjb29yZFsxXSAtIHRpbGUubWF4LnkpICogR2VvLnVuaXRzX3Blcl9tZXRlclt0aWxlLmNvb3Jkcy56XTsgLy8gYWx0ZXJuYXRlIHRvIGZvcmNlIHktY29vcmRzIHRvIGJlIHBvc2l0aXZlLCBzdWJ0cmFjdCB0aWxlIG1heCBpbnN0ZWFkIG9mIG1pblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZChkZXN0KSB7IHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZCgnbG9hZCcpOyB9XG5cbiAgICAvLyBSZWdpc3RlciBhIG5ldyBkYXRhIHNvdXJjZSB0eXBlXG4gICAgc3RhdGljIHJlZ2lzdGVyKHR5cGVfY2xhc3MpIHtcbiAgICAgICAgaWYgKCF0eXBlX2NsYXNzIHx8ICF0eXBlX2NsYXNzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIERhdGFTb3VyY2UudHlwZXNbdHlwZV9jbGFzcy50eXBlXSA9IHR5cGVfY2xhc3M7XG4gICAgfVxuXG59XG5cbkRhdGFTb3VyY2UudHlwZXMgPSB7fTsgLy8gc2V0IG9mIHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBjbGFzc2VzLCByZWZlcmVuY2VkIGJ5IHR5cGUgbmFtZVxuXG5cbi8qKiogR2VuZXJpYyBuZXR3b3JrIGxvYWRpbmcgc291cmNlIC0gYWJzdHJhY3QgY2xhc3MgKioqL1xuXG5leHBvcnQgY2xhc3MgTmV0d29ya1NvdXJjZSBleHRlbmRzIERhdGFTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlX3R5cGUgPSBcIlwiOyAvLyB1c2UgdG8gc2V0IGV4cGxpY2l0IFhIUiB0eXBlXG4gICAgfVxuXG4gICAgbG9hZCAoZGVzdCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy5mb3JtYXRVcmwoZGVzdCk7XG5cbiAgICAgICAgaWYgKGRlc3Quc291cmNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXN0LnNvdXJjZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzb3VyY2VfZGF0YSA9IGRlc3Quc291cmNlX2RhdGEgPSB7fTtcbiAgICAgICAgc291cmNlX2RhdGEudXJsID0gdXJsO1xuICAgICAgICBkZXN0LmRlYnVnID0gZGVzdC5kZWJ1ZyB8fCB7fTtcbiAgICAgICAgZGVzdC5kZWJ1Zy5uZXR3b3JrID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHNvdXJjZV9kYXRhLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEZvciB0ZXN0aW5nIG5ldHdvcmsgZXJyb3JzXG4gICAgICAgICAgICAvLyB2YXIgcHJvbWlzZSA9IFV0aWxzLmlvKHVybCwgNjAgKiAxMDAsIHRoaXMucmVzcG9uc2VfdHlwZSk7XG4gICAgICAgICAgICAvLyBpZiAoTWF0aC5yYW5kb20oKSA8IC43KSB7XG4gICAgICAgICAgICAvLyAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KEVycm9yKCdmYWtlIGRhdGEgc291cmNlIGVycm9yJykpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gcHJvbWlzZS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IFV0aWxzLmlvKHVybCwgNjAgKiAxMDAwLCB0aGlzLnJlc3BvbnNlX3R5cGUpO1xuICAgICAgICAgICAgc291cmNlX2RhdGEucmVxdWVzdCA9IHByb21pc2UucmVxdWVzdDtcblxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVzdC5kZWJ1Zy5yZXNwb25zZV9zaXplID0gYm9keS5sZW5ndGggfHwgYm9keS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRlc3QuZGVidWcubmV0d29yayA9ICtuZXcgRGF0ZSgpIC0gZGVzdC5kZWJ1Zy5uZXR3b3JrO1xuICAgICAgICAgICAgICAgIGRlc3QuZGVidWcucGFyc2luZyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTb3VyY2VEYXRhKGRlc3QsIHNvdXJjZV9kYXRhLCBib2R5KTtcbiAgICAgICAgICAgICAgICBkZXN0LmRlYnVnLnBhcnNpbmcgPSArbmV3IERhdGUoKSAtIGRlc3QuZGVidWcucGFyc2luZztcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRlc3QpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgc291cmNlX2RhdGEuZXJyb3IgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7IC8vIHJlc29sdmUgcmVxdWVzdCBidXQgcGFzcyBhbG9uZyBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50OlxuXG4gICAgZm9ybWF0VXJsIChkZXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZCgnZm9ybWF0VXJsJyk7XG4gICAgfVxuXG4gICAgcGFyc2VTb3VyY2VEYXRhIChkZXN0LCBzb3VyY2UsIHJlcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkKCdwYXJzZVNvdXJjZURhdGEnKTtcbiAgICB9XG59XG5cblxuLyoqKiBHZW5lcmljIG5ldHdvcmsgdGlsZSBsb2FkaW5nIC0gYWJzdHJhY3QgY2xhc3MgKioqL1xuXG5leHBvcnQgY2xhc3MgTmV0d29ya1RpbGVTb3VyY2UgZXh0ZW5kcyBOZXR3b3JrU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcblxuICAgICAgICB0aGlzLnRpbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cmxfaG9zdHMgPSBudWxsO1xuICAgICAgICB2YXIgaG9zdF9tYXRjaCA9IHRoaXMudXJsLm1hdGNoKC97czpcXFsoW159K10rKVxcXX0vKTtcbiAgICAgICAgaWYgKGhvc3RfbWF0Y2ggIT0gbnVsbCAmJiBob3N0X21hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMudXJsX2hvc3RzID0gaG9zdF9tYXRjaFsxXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdGhpcy5uZXh0X2hvc3QgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9ybWF0VXJsKHRpbGUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IEdlby53cmFwVGlsZSh0aWxlLmNvb3JkcywgeyB4OiB0cnVlIH0pO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwucmVwbGFjZSgne3h9JywgY29vcmRzLngpLnJlcGxhY2UoJ3t5fScsIGNvb3Jkcy55KS5yZXBsYWNlKCd7en0nLCBjb29yZHMueik7XG5cbiAgICAgICAgaWYgKHRoaXMudXJsX2hvc3RzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC97czpcXFsoW159K10rKVxcXX0vLCB0aGlzLnVybF9ob3N0c1t0aGlzLm5leHRfaG9zdF0pO1xuICAgICAgICAgICAgdGhpcy5uZXh0X2hvc3QgPSAodGhpcy5uZXh0X2hvc3QgKyAxKSAlIHRoaXMudXJsX2hvc3RzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxufVxuXG5cbi8qKlxuIEdlb0pTT04gc3RhbmRhbG9uZSAobm9uLXRpbGVkKSBzb3VyY2VcbiovXG5cbmV4cG9ydCBjbGFzcyBHZW9KU09OU291cmNlIGV4dGVuZHMgTmV0d29ya1NvdXJjZSB7XG5cbiAgICBmb3JtYXRVcmwgKGRlc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBzb3VyY2UubGF5ZXJzID0geyBfZGVmYXVsdDogSlNPTi5wYXJzZShyZXNwb25zZSkgfTtcbiAgICAgICAgRGF0YVNvdXJjZS5wcm9qZWN0RGF0YShzb3VyY2UpOyAvLyBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAgfVxufVxuXG5HZW9KU09OU291cmNlLnR5cGUgPSAnR2VvSlNPTic7XG5EYXRhU291cmNlLnJlZ2lzdGVyKEdlb0pTT05Tb3VyY2UpO1xuXG5cbi8qKlxuIE1hcHplbi9PU00uVVMtc3R5bGUgR2VvSlNPTiB2ZWN0b3IgdGlsZXNcbiBAY2xhc3MgR2VvSlNPTlRpbGVTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgR2VvSlNPTlRpbGVTb3VyY2UgZXh0ZW5kcyBOZXR3b3JrVGlsZVNvdXJjZSB7XG5cbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlR2VvSlNPTihkYXRhLCB0aWxlLCBzb3VyY2UpO1xuICAgIH1cblxuICAgIHByZXBhcmVHZW9KU09OIChkYXRhLCB0aWxlLCBzb3VyY2UpIHtcbiAgICAgICAgLy8gQXBwbHkgb3B0aW9uYWwgZGF0YSB0cmFuc2Zvcm1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMudHJhbnNmb3JtKGRhdGEsIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5nbGUgbGF5ZXIgb3IgbXVsdGktbGF5ZXJzP1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZScgfHwgZGF0YS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICBzb3VyY2UubGF5ZXJzID0geyBfZGVmYXVsdDogZGF0YSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlLmxheWVycyA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIFwic3ludGhldGljXCIgdGlsZSB0aGF0IGFkanVzdHMgdGhlIHRpbGUgbWluIGFuY2hvciB0byBhY2NvdW50IGZvciB0aWxlIGxvbmdpdHVkZSB3cmFwcGluZ1xuICAgICAgICBsZXQgYW5jaG9yID0ge1xuICAgICAgICAgICAgY29vcmRzOiB0aWxlLmNvb3JkcyxcbiAgICAgICAgICAgIG1pbjogR2VvLm1ldGVyc0ZvclRpbGUoR2VvLndyYXBUaWxlKHRpbGUuY29vcmRzLCB7IHg6IHRydWUgfSkpXG4gICAgICAgIH07XG5cbiAgICAgICAgRGF0YVNvdXJjZS5wcm9qZWN0RGF0YShzb3VyY2UpOyAvLyBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAgICAgIERhdGFTb3VyY2Uuc2NhbGVEYXRhKHNvdXJjZSwgYW5jaG9yKTsgLy8gcmUtc2NhbGUgZnJvbSBtZXRlcnMgdG8gbG9jYWwgdGlsZSBjb29yZHNcbiAgICB9XG59XG5cbkdlb0pTT05UaWxlU291cmNlLnR5cGUgPSAnR2VvSlNPTlRpbGVzJztcbkRhdGFTb3VyY2UucmVnaXN0ZXIoR2VvSlNPTlRpbGVTb3VyY2UpO1xuXG5cbi8qKlxuIE1hcHplbi9PU00uVVMtc3R5bGUgVG9wb0pTT04gdmVjdG9yIHRpbGVzXG4gQGNsYXNzIFRvcG9KU09OVGlsZVNvdXJjZVxuKi9cbmV4cG9ydCBjbGFzcyBUb3BvSlNPTlRpbGVTb3VyY2UgZXh0ZW5kcyBHZW9KU09OVGlsZVNvdXJjZSB7XG5cbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcblxuICAgICAgICAvLyBTaW5nbGUgbGF5ZXJcbiAgICAgICAgaWYgKGRhdGEub2JqZWN0cyAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YS5vYmplY3RzKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIGRhdGEub2JqZWN0cy52ZWN0aWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0b3BvanNvbi5mZWF0dXJlKGRhdGEsIGRhdGEub2JqZWN0cy52ZWN0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsZSBsYXllcnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YS5vYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzW2tleV0gPSB0b3BvanNvbi5mZWF0dXJlKGRhdGEsIGRhdGEub2JqZWN0c1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBsYXllcnM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXBhcmVHZW9KU09OKGRhdGEsIHRpbGUsIHNvdXJjZSk7XG4gICAgfVxuXG59XG5cblRvcG9KU09OVGlsZVNvdXJjZS50eXBlID0gJ1RvcG9KU09OVGlsZXMnO1xuRGF0YVNvdXJjZS5yZWdpc3RlcihUb3BvSlNPTlRpbGVTb3VyY2UpO1xuXG5cblxuLyoqXG4gTWFwYm94IFZlY3RvciBUaWxlIGZvcm1hdFxuIEBjbGFzcyBNVlRTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgTVZUU291cmNlIGV4dGVuZHMgTmV0d29ya1RpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlX3R5cGUgPSBcImFycmF5YnVmZmVyXCI7IC8vIGJpbmFyeSBkYXRhXG4gICAgICAgIHRoaXMucGFkX3NjYWxlID0gc291cmNlLnBhZF9zY2FsZSB8fCAwLjAwMTsgLy8gc2NhbGUgdGlsZSB1cCBieSB0aGlzIGZhY3RvciAoMC4xJSkgdG8gY292ZXIgc2VhbXNcbiAgICB9XG5cbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgLy8gQ29udmVydCBNYXBib3ggdmVjdG9yIHRpbGUgdG8gR2VvSlNPTlxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBQYmYoZGF0YSk7XG4gICAgICAgIHNvdXJjZS5kYXRhID0gbmV3IFZlY3RvclRpbGUoYnVmZmVyKTtcbiAgICAgICAgc291cmNlLmxheWVycyA9IHRoaXMudG9HZW9KU09OKHNvdXJjZS5kYXRhKTtcbiAgICAgICAgZGVsZXRlIHNvdXJjZS5kYXRhOyAvLyBjb21tZW50IG91dCB0byBzYXZlIHJhdyBkYXRhIGZvciBkZWJ1Z2dpbmdcblxuICAgICAgICAvLyBQb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgZm9yICh2YXIgdCBpbiBzb3VyY2UubGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbnVtX2ZlYXR1cmVzID0gc291cmNlLmxheWVyc1t0XS5mZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBmPTA7IGYgPCBudW1fZmVhdHVyZXM7IGYrKykge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gc291cmNlLmxheWVyc1t0XS5mZWF0dXJlc1tmXTtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgT1NNIGlkXG4gICAgICAgICAgICAgICAgR2VvLnRyYW5zZm9ybUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGNvb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2xpZ2h0bHkgc2NhbGUgdXAgdGlsZSB0byBjb3ZlciBzZWFtc1xuICAgICAgICAgICAgICAgICAgICBjb29yZFswXSA9IE1hdGgucm91bmQoY29vcmRbMF0gKiAoMSArIHRoaXMucGFkX3NjYWxlKSAtICg0MDk2ICogdGhpcy5wYWRfc2NhbGUvMikpO1xuICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSA9IE1hdGgucm91bmQoY29vcmRbMV0gKiAoMSArIHRoaXMucGFkX3NjYWxlKSAtICg0MDk2ICogdGhpcy5wYWRfc2NhbGUvMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZsaXAgWSBjb29yZFxuICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSA9IC1jb29yZFsxXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBsYXllcnMvZmVhdHVyZXMgdXNpbmcgTWFwYm94IGxpYiBBUEksIGNvbnZlcnQgdG8gR2VvSlNPTiBmZWF0dXJlc1xuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGgga2V5cyBmb3IgZWFjaCBsYXllciwgZS5nLiB7IGxheWVyOiBnZW9qc29uIH1cbiAgICB0b0dlb0pTT04gKHRpbGUpIHtcbiAgICAgICAgdmFyIGxheWVycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBsIGluIHRpbGUubGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aWxlLmxheWVyc1tsXTtcbiAgICAgICAgICAgIHZhciBsYXllcl9nZW9qc29uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBmPTA7IGYgPCBsYXllci5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShmKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZV9nZW9qc29uID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmVfZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmxvYWRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHI9MDsgciA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaW5nID0gY29vcmRpbmF0ZXNbcl07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYyA8IHJpbmcubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmluZ1tjXS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10ueVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdQb2ludCc7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID0gJ0xpbmVTdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdQb2x5Z29uJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXllcl9nZW9qc29uLmZlYXR1cmVzLnB1c2goZmVhdHVyZV9nZW9qc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyc1tsXSA9IGxheWVyX2dlb2pzb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG5cbn1cblxuTVZUU291cmNlLnR5cGUgPSAnTVZUJztcbkRhdGFTb3VyY2UucmVnaXN0ZXIoTVZUU291cmNlKTtcbiIsIi8vIE1pc2NlbGxhbmVvdXMgZ2VvIGZ1bmN0aW9uc1xuXG52YXIgR2VvO1xuZXhwb3J0IGRlZmF1bHQgR2VvID0ge307XG5cbi8vIFByb2plY3Rpb24gY29uc3RhbnRzXG5HZW8udGlsZV9zaXplID0gMjU2O1xuR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgPSAyMDAzNzUwOC4zNDI3ODkyNDQ7XG5HZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAqIDI7XG5HZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCA9IEdlby5jaXJjdW1mZXJlbmNlX21ldGVycyAvIEdlby50aWxlX3NpemU7IC8vIG1pbiB6b29tIGRyYXdzIHdvcmxkIGFzIDIgdGlsZXMgd2lkZVxuR2VvLm1ldGVyc19wZXJfcGl4ZWwgPSBbXTtcbkdlby5tZXRlcnNfcGVyX3RpbGUgPSBbXTtcbkdlby5tYXhfem9vbSA9IDIwO1xuZm9yICh2YXIgej0wOyB6IDw9IEdlby5tYXhfem9vbTsgeisrKSB7XG4gICAgR2VvLm1ldGVyc19wZXJfcGl4ZWxbel0gPSBHZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCAvIE1hdGgucG93KDIsIHopO1xuICAgIEdlby5tZXRlcnNfcGVyX3RpbGVbel0gPSBHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB6KTtcbn1cblxuR2VvLm1ldGVyc1BlclBpeGVsID0gZnVuY3Rpb24gKHpvb20pIHtcbiAgICByZXR1cm4gR2VvLm1pbl96b29tX21ldGVyc19wZXJfcGl4ZWwgLyBNYXRoLnBvdygyLCB6b29tKTtcbn07XG5cbi8vIENvbnZlcnNpb24gZnVuY3Rpb25zIGJhc2VkIG9uIGFuIGRlZmluZWQgdGlsZSBzY2FsZVxuR2VvLnVuaXRzX3Blcl9tZXRlciA9IFtdO1xuR2VvLnRpbGVfc2NhbGUgPSA0MDk2OyAvLyBjb29yZGluYXRlcyBhcmUgbG9jYWxseSBzY2FsZWQgdG8gdGhlIHJhbmdlIFswLCB0aWxlX3NjYWxlXVxuR2VvLnVuaXRzX3Blcl9waXhlbCA9IEdlby50aWxlX3NjYWxlIC8gR2VvLnRpbGVfc2l6ZTtcblxuZm9yIChsZXQgej0wOyB6IDw9IEdlby5tYXhfem9vbTsgeisrKSB7XG4gICAgR2VvLnVuaXRzX3Blcl9tZXRlclt6XSA9IEdlby50aWxlX3NjYWxlIC8gKEdlby50aWxlX3NpemUgKiBHZW8ubWV0ZXJzX3Blcl9waXhlbFt6XSk7XG59XG5cbi8vIENvbnZlcnQgdGlsZSBsb2NhdGlvbiB0byBtZXJjYXRvciBtZXRlcnMgLSBtdWx0aXBseSBieSBwaXhlbHMgcGVyIHRpbGUsIHRoZW4gYnkgbWV0ZXJzIHBlciBwaXhlbCwgYWRqdXN0IGZvciBtYXAgb3JpZ2luXG5HZW8ubWV0ZXJzRm9yVGlsZSA9IGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGlsZS54ICogR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gTWF0aC5wb3coMiwgdGlsZS56KSAtIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzLFxuICAgICAgICB5OiAtKHRpbGUueSAqIEdlby5jaXJjdW1mZXJlbmNlX21ldGVycyAvIE1hdGgucG93KDIsIHRpbGUueikgLSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycylcbiAgICB9O1xufTtcblxuLyoqXG4gICBHaXZlbiBhIHBvaW50IGluIG1lcmNhdG9yIG1ldGVycyBhbmQgYSB6b29tIGxldmVsLCByZXR1cm4gdGhlIHRpbGUgWC9ZL1ogdGhhdCB0aGUgcG9pbnQgbGllcyBpblxuKi9cbkdlby50aWxlRm9yTWV0ZXJzID0gZnVuY3Rpb24gKFt4LCB5XSwgem9vbSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoKHggKyBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycykgLyAoR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gTWF0aC5wb3coMiwgem9vbSkpKSxcbiAgICAgICAgeTogTWF0aC5mbG9vcigoLXkgKyBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycykgLyAoR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gTWF0aC5wb3coMiwgem9vbSkpKSxcbiAgICAgICAgejogem9vbVxuICAgIH07XG59O1xuXG4vLyBXcmFwIGEgdGlsZSB0byBwb3NpdGl2ZSAjcyBmb3Igem9vbVxuLy8gT3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBheGVzIHRvIHdyYXBcbkdlby53cmFwVGlsZSA9IGZ1bmN0aW9uKHsgeCwgeSwgeiB9LCBtYXNrID0geyB4OiB0cnVlLCB5OiBmYWxzZSB9KSB7XG4gICAgdmFyIG0gPSAoMSA8PCB6KSAtIDE7XG4gICAgaWYgKG1hc2sueCkge1xuICAgICAgICB4ID0geCAmIG07XG4gICAgfVxuICAgIGlmIChtYXNrLnkpIHtcbiAgICAgICAgeSA9IHkgJiBtO1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5LCB6IH07XG59O1xuXG4vKipcbiAgIENvbnZlcnQgbWVyY2F0b3IgbWV0ZXJzIHRvIGxhdC1sbmdcbiovXG5HZW8ubWV0ZXJzVG9MYXRMbmcgPSBmdW5jdGlvbiAoW3gsIHldKSB7XG5cbiAgICB4IC89IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzO1xuICAgIHkgLz0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnM7XG5cbiAgICB5ID0gKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoeSAqIE1hdGguUEkpKSAtIChNYXRoLlBJIC8gMikpIC8gTWF0aC5QSTtcblxuICAgIHggKj0gMTgwO1xuICAgIHkgKj0gMTgwO1xuXG4gICAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbi8qKlxuICBDb252ZXJ0IGxhdC1sbmcgdG8gbWVyY2F0b3IgbWV0ZXJzXG4qL1xuR2VvLmxhdExuZ1RvTWV0ZXJzID0gZnVuY3Rpb24oW3gsIHldKSB7XG5cbiAgICAvLyBMYXRpdHVkZVxuICAgIHkgPSBNYXRoLmxvZyhNYXRoLnRhbih5Kk1hdGguUEkvMzYwICsgTWF0aC5QSS80KSkgLyBNYXRoLlBJO1xuICAgIHkgKj0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnM7XG5cbiAgICAvLyBMb25naXR1ZGVcbiAgICB4ICo9IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gMTgwO1xuXG4gICAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbkdlby53cmFwTG5nID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID4gMTgwIHx8IHggPCAtMTgwKSB7XG4gICAgICAgIHggPSAoKHggKyAxODApICUgMzYwICsgMzYwKSAlIDM2MCAtIDE4MDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG4vLyBSdW4gYW4gaW4tcGxhY2UgdHJhbnNmb3JtIGZ1bmN0aW9uIG9uIGVhY2ggY29vb3JkaW5hdGUgaW4gYSBHZW9KU09OIGdlb21ldHJ5XG5HZW8udHJhbnNmb3JtR2VvbWV0cnkgPSBmdW5jdGlvbiAoZ2VvbWV0cnksIHRyYW5zZm9ybSkge1xuICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgIHRyYW5zZm9ybShnZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChjb29yZGluYXRlcyA9PiBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgICAgICAgICAgcG9seWdvbi5mb3JFYWNoKGNvb3JkaW5hdGVzID0+IGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvblxufTtcblxuR2VvLmJveEludGVyc2VjdCA9IGZ1bmN0aW9uIChiMSwgYjIpIHtcbiAgICByZXR1cm4gIShcbiAgICAgICAgYjIuc3cueCA+IGIxLm5lLnggfHxcbiAgICAgICAgYjIubmUueCA8IGIxLnN3LnggfHxcbiAgICAgICAgYjIuc3cueSA+IGIxLm5lLnkgfHxcbiAgICAgICAgYjIubmUueSA8IGIxLnN3LnlcbiAgICApO1xufTtcblxuLy8gRmluZHMgdGhlIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGEgcG9seWdvblxuR2VvLmZpbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgdmFyIG1pbl94ID0gSW5maW5pdHksXG4gICAgICAgIG1heF94ID0gLUluZmluaXR5LFxuICAgICAgICBtaW5feSA9IEluZmluaXR5LFxuICAgICAgICBtYXhfeSA9IC1JbmZpbml0eTtcblxuICAgIC8vIE9ubHkgbmVlZCB0byBleGFtaW5lIG91dGVyIHJpbmcgKHBvbHlnb25bMF0pXG4gICAgdmFyIG51bV9jb29yZHMgPSBwb2x5Z29uWzBdLmxlbmd0aDtcbiAgICBmb3IgKHZhciBjPTA7IGMgPCBudW1fY29vcmRzOyBjKyspIHtcbiAgICAgICAgdmFyIGNvb3JkID0gcG9seWdvblswXVtjXTtcblxuICAgICAgICBpZiAoY29vcmRbMF0gPCBtaW5feCkge1xuICAgICAgICAgICAgbWluX3ggPSBjb29yZFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmRbMV0gPCBtaW5feSkge1xuICAgICAgICAgICAgbWluX3kgPSBjb29yZFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmRbMF0gPiBtYXhfeCkge1xuICAgICAgICAgICAgbWF4X3ggPSBjb29yZFswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmRbMV0gPiBtYXhfeSkge1xuICAgICAgICAgICAgbWF4X3kgPSBjb29yZFsxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbWluX3gsIG1pbl95LCBtYXhfeCwgbWF4X3ldO1xufTtcblxuLy8gQ29udmVydCBnZW9tZXRyeSB0eXBlIHRvIG9uZSBvZjogJ3BvaW50JywgJ2xpbmUnLCAncG9seWdvbidcbkdlby5nZW9tZXRyeVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICByZXR1cm4gJ3BvbHlnb24nO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICdsaW5lJztcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcgfHwgdHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgIHJldHVybiAncG9pbnQnO1xuICAgIH1cbn07XG4iLCIvLyBXZWJHTCBjb25zdGFudHMgLSBuZWVkIHRvIGltcG9ydCB0aGVzZSBzZXBhcmF0ZWx5IHRvIG1ha2UgdGhlbSBhdmFpbGFibGUgaW4gdGhlIHdlYiB3b3JrZXJcblxudmFyIGdsO1xuZXhwb3J0IGRlZmF1bHQgZ2wgPSB7fTtcblxuLyogRGF0YVR5cGUgKi9cbmdsLkJZVEUgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMDtcbmdsLlVOU0lHTkVEX0JZVEUgICAgICAgICAgICAgICAgICA9IDB4MTQwMTtcbmdsLlNIT1JUICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMjtcbmdsLlVOU0lHTkVEX1NIT1JUICAgICAgICAgICAgICAgICA9IDB4MTQwMztcbmdsLklOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNDtcbmdsLlVOU0lHTkVEX0lOVCAgICAgICAgICAgICAgICAgICA9IDB4MTQwNTtcbmdsLkZMT0FUICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNjtcbiIsIi8vIFdlYkdMIGNvbnRleHQgd3JhcHBlclxuXG52YXIgQ29udGV4dDtcbmV4cG9ydCBkZWZhdWx0IENvbnRleHQgPSB7fTtcblxuLy8gU2V0dXAgYSBXZWJHTCBjb250ZXh0XG4vLyBJZiBubyBjYW52YXMgZWxlbWVudCBpcyBwcm92aWRlZCwgb25lIGlzIGNyZWF0ZWQgYW5kIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBib2R5XG5Db250ZXh0LmdldENvbnRleHQgPSBmdW5jdGlvbiBnZXRDb250ZXh0IChjYW52YXMsIG9wdGlvbnMpXG57XG4gICAgdmFyIGZ1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICBpZiAoY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAtMTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICBmdWxsc2NyZWVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucyk7XG4gICAgaWYgKCFnbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBjcmVhdGUgV2ViR0wgY29udGV4dC5cIik7XG4gICAgfVxuXG4gICAgQ29udGV4dC5yZXNpemUoZ2wsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQsIG9wdGlvbnMuZGV2aWNlX3BpeGVsX3JhdGlvKTtcbiAgICBpZiAoZnVsbHNjcmVlbiA9PT0gdHJ1ZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQ29udGV4dC5yZXNpemUoZ2wsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2w7XG59O1xuXG5Db250ZXh0LnJlc2l6ZSA9IGZ1bmN0aW9uIChnbCwgd2lkdGgsIGhlaWdodCwgZGV2aWNlX3BpeGVsX3JhdGlvKVxue1xuICAgIGRldmljZV9waXhlbF9yYXRpbyA9IGRldmljZV9waXhlbF9yYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIGdsLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBnbC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBnbC5jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5zdHlsZS53aWR0aCAqIGRldmljZV9waXhlbF9yYXRpbyk7XG4gICAgZ2wuY2FudmFzLmhlaWdodCA9IE1hdGgucm91bmQoZ2wuY2FudmFzLnN0eWxlLndpZHRoICogZGV2aWNlX3BpeGVsX3JhdGlvKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xufTtcbiIsInZhciBHTFNMID0ge307XG5leHBvcnQgZGVmYXVsdCBHTFNMO1xuXG4vKipcbiAgICBQYXJzZSB1bmlmb3JtcyBmcm9tIGEgSlMgb2JqZWN0LCBpbmZlcnMgdHlwZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZVxuICAgIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBzZXQgdW5pZm9ybSB2YWx1ZXMgb24gYSBHTCBwcm9ncmFtLiBFYWNoIG9iamVjdCBpbiB0aGUgcmV0dXJuZWRcbiAgICBhcnJheSBoYXMgdGhlIGZvcm06XG4gICAgeyB0eXBlLCBtZXRob2QsIG5hbWUsIHZhbHVlIH1cblxuICAgIHR5cGU6IHRoZSBHTCB1bmlmb3JtIHR5cGUsIHN1Y2ggYXMgJ3ZlYzMnLCAnZmxvYXQnLCBldGMuXG4gICAgbWV0aG9kOiB0aGUgR0wgdW5pZm9ybSBzZXR0ZXIgbWV0aG9kIHRvIHVzZSwgc3VjaCBhcyAnMWYnLCAnM2Z2JywgZXRjLlxuICAgIG5hbWU6IHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgR0wgdW5pZm9ybSBsb2NhdGlvbiwgZS5nLiAnYXJyYXlbMF0uZmllbGQnLCBldGMuXG4gICAgdmFsdWU6IHRoZSB2YWx1ZSB0byBiZSBwYXNzZWQgdG8gdGhlIEdMIHVuaWZvcm0gc2V0dGVyIGZvciB0aGF0IHR5cGUsIGUuZy4gWzEsIDIsIDNdIGZvciBhIHZlYzNcblxuICAgIFRleHR1cmVzIGhhdmUgc3BlY2lhbCBiZWhhdmlvcjogdW5pZm9ybXMgd2l0aCBzdHJpbmcgdmFsdWVzIGFyZSB0cmVhdGVkIGFzIHRleHR1cmVzLCBhbmRcbiAgICB0aGUgc3RyaW5nIGlzIHVzZWQgYXMgYSB1bmlxdWUgdGV4dHVyZSAna2V5JyB0byBiZSBpbnRlcnByZXRlZCBieSB0aGUgY2FsbGVyICh3aGljaCBpcyByZXNwb25zaWJsZVxuICAgIGZvciBhY3R1YWxseSBzZXR0aW5nIHRoZSB1bmlmb3JtcykuIEZvciBleGFtcGxlLCB0aGlzIGNvdWxkIGJlIHVzZWQgYXMgYSBrZXkgaW50byBhIGRpY3Rpb25hcnkgb2ZcbiAgICBrbm93biB0ZXh0dXJlIG5hbWVzLCBvciBpdCBjb3VsZCBzaW1wbHkgYmUgdXNlZCBhcyBhIFVSTCB0byBkeW5hbWljYWxseSBsb2FkIHRoZSB0ZXh0dXJlIGZyb20uXG4qL1xuR0xTTC5wYXJzZVVuaWZvcm1zID0gZnVuY3Rpb24gKHVuaWZvcm1zLCBwcmVmaXggPSBudWxsKSB7XG4gICAgdmFyIHBhcnNlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zW25hbWVdO1xuICAgICAgICB2YXIgdTtcblxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICBuYW1lID0gcHJlZml4ICsgJy4nICsgbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZSBmbG9hdFxuICAgICAgICBpZiAodHlwZW9mIHVuaWZvcm0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICcxZicsXG4gICAgICAgICAgICAgICAgbmFtZSwgdmFsdWU6XG4gICAgICAgICAgICAgICAgdW5pZm9ybVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXk6IHZlY3RvciwgYXJyYXkgb2YgZmxvYXRzLCBhcnJheSBvZiB0ZXh0dXJlcywgb3IgYXJyYXkgb2Ygc3RydWN0c1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm0pKSB7XG4gICAgICAgICAgICAvLyBOdW1lcmljIHZhbHVlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bmlmb3JtWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm0ubGVuZ3RoID49IDIgJiYgdW5pZm9ybS5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmVjJyArIHVuaWZvcm0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB1bmlmb3JtLmxlbmd0aCArICdmdicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZsb2F0IGFycmF5XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodW5pZm9ybS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbG9hdFtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJzFmdicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lICsgJ1swXScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYXNzdW1lIG1hdHJpeCBmb3IgKHR5cGVvZiA9PSBGbG9hdDMyQXJyYXkgJiYgbGVuZ3RoID09IDE2KT9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFycmF5IG9mIHRleHR1cmVzXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHU9MDsgdSA8IHVuaWZvcm0ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NhbXBsZXIyRCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICcxaScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lICsgJ1snICsgdSArICddJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtW3VdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFycmF5IG9mIGFycmF5cyAtIGJ1dCBvbmx5IGFycmF5cyBvZiB2ZWN0b3JzIGFyZSBhbGxvd2VkIGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1bmlmb3JtWzBdKSAmJiB0eXBlb2YgdW5pZm9ybVswXVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtWzBdLmxlbmd0aCA+PSAyICYmIHVuaWZvcm1bMF0ubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHU9MDsgdSA8IHVuaWZvcm0ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmVjJyArIHVuaWZvcm1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdW5pZm9ybVt1XS5sZW5ndGggKyAnZnYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWycgKyB1ICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtW3VdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbHNlIGVycm9yP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXJyYXkgb2Ygc3RydWN0dXJlc1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVuaWZvcm1bMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh1PTA7IHUgPCB1bmlmb3JtLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBlYWNoIHN0cnVjdCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goLi4uR0xTTC5wYXJzZVVuaWZvcm1zKHVuaWZvcm1bdV0sIG5hbWUgKyAnWycgKyB1ICsgJ10nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJvb2xlYW5cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVuaWZvcm0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICcxaScsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGV4dHVyZVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICcxaScsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0dXJlXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gU2V0IGVhY2ggZmllbGQgaW4gdGhlIHN0cnVjdFxuICAgICAgICAgICAgcGFyc2VkLnB1c2goLi4uR0xTTC5wYXJzZVVuaWZvcm1zKHVuaWZvcm0sIG5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgbm9uLWZsb2F0IHR5cGVzPyAoaW50LCBldGMuKVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vKipcbiAgICBHZW5lcmF0ZSBhIEdMU0wgdmFyaWFibGUgZGVmaW5pdGlvbiBmcm9tIGEgSlMgb2JqZWN0XG4qL1xuR0xTTC5kZWZpbmVWYXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJlZml4ID0gbnVsbCkge1xuICAgIHZhciB0eXBlLCBhcnJheTtcbiAgICB2YXIgc3RydWN0cyA9ICcnO1xuICAgIHByZWZpeCA9IHByZWZpeCA/IHByZWZpeCArICdfJyArIG5hbWUgOiBuYW1lO1xuXG4gICAgLy8gU2luZ2xlIGZsb2F0XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdHlwZSA9ICdmbG9hdCc7XG4gICAgfVxuICAgIC8vIE11bHRpcGxlIGZsb2F0cyAtIHZlY3RvciBvciBhcnJheVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIE51bWVyaWMgdmFsdWVzXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHZhbHVlLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICd2ZWMnICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmxvYXQgYXJyYXlcbiAgICAgICAgICAgIGVsc2UgeyAvL2lmICh2YWx1ZS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdmbG9hdCc7XG4gICAgICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBhc3N1bWUgbWF0cml4IGZvciAodHlwZW9mID09IEZsb2F0MzJBcnJheSAmJiBsZW5ndGggPT0gMTYpP1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHRleHR1cmVzXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIGFycmF5cyAtIGJ1dCBvbmx5IGFycmF5cyBvZiB2ZWN0b3JzIGFyZSBhbGxvd2VkIGluIHRoaXMgY2FzZVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSAmJiB0eXBlb2YgdmFsdWVbMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxuICAgICAgICAgICAgaWYgKHZhbHVlWzBdLmxlbmd0aCA+PSAyICYmIHZhbHVlWzBdLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICd2ZWMnICsgdmFsdWVbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBlcnJvcj9cbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWVbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHN0cnVjdHVyZXNcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHlwZSA9ICdfdHlwZV8nICsgcHJlZml4OyAvLyBjdXN0b20gc3RydWN0IG5hbWVcbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgc3RydWN0cyArPSBHTFNMLmRlZmluZVN0cnVjdCh0eXBlLCB2YWx1ZVswXSwgcHJlZml4KSArICdcXG4nOyAvLyBidWlsZCAmIGFkZCB0byBsaXN0IG9mIGRlcGVuZGVudCBzdHJ1Y3RzXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQm9vbGVhblxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgfVxuICAgIC8vIFRleHR1cmVcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcbiAgICB9XG4gICAgLy8gU3RydWN0dXJlXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0eXBlID0gJ190eXBlXycgKyBwcmVmaXg7IC8vIGN1c3RvbSBzdHJ1Y3QgbmFtZVxuICAgICAgICBzdHJ1Y3RzICs9IEdMU0wuZGVmaW5lU3RydWN0KHR5cGUsIHZhbHVlLCBwcmVmaXgpICsgJ1xcbic7IC8vIGJ1aWxkICYgYWRkIHRvIGxpc3Qgb2YgZGVwZW5kZW50IHN0cnVjdHNcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgdmFyaWFibGUgZGVmaW5pdGlvblxuICAgIHZhciB2YXJpYWJsZSA9ICcnO1xuICAgIHZhcmlhYmxlICs9IGAke3R5cGV9ICR7bmFtZX1gO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICB2YXJpYWJsZSArPSBgWyR7YXJyYXl9XWA7XG4gICAgfVxuICAgIHZhcmlhYmxlICs9ICc7XFxuJztcblxuICAgIC8vIFJldHVybiB0aGUgdmFyaWFibGUgZGVmaW5pdGlvbiBpdHNlbGYsIGFuZCBhbnkgZGVwZW5kZW50IHN0cnVjdCBkZWZpbml0aW9uc1xuICAgIHJldHVybiB7IHZhcmlhYmxlLCBzdHJ1Y3RzIH07XG59O1xuXG4vKipcbiAgICBHZW5lcmF0ZSBhIEdMU0wgc3RydWN0dXJlIGRlZmluaXRpb24gZnJvbSBhIEpTIG9iamVjdFxuKi9cbkdMU0wuZGVmaW5lU3RydWN0ID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBwcmVmaXggPSBudWxsKSB7XG4gICAgdmFyIHN0cnVjdCA9IGBzdHJ1Y3QgJHt0eXBlfSB7XFxuYDtcbiAgICB2YXIgZGVwZW5kZW50cyA9ICcnO1xuICAgIGZvciAodmFyIGZpZWxkIGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdWJ2YXIgPSBHTFNMLmRlZmluZVZhcmlhYmxlKGZpZWxkLCB2YWx1ZVtmaWVsZF0sIHByZWZpeCk7XG4gICAgICAgIHN0cnVjdCArPSAnICAgICcgKyBzdWJ2YXIudmFyaWFibGU7XG4gICAgICAgIGRlcGVuZGVudHMgKz0gc3VidmFyLnN0cnVjdHM7XG4gICAgfVxuICAgIHN0cnVjdCArPSAnfTtcXG4nO1xuICAgIHN0cnVjdCA9IGRlcGVuZGVudHMgKyBzdHJ1Y3Q7XG4gICAgcmV0dXJuIHN0cnVjdDtcbn07XG5cbi8qKlxuICAgIEdlbmVyYXRlIGEgR0xTTCB1bmlmb3JtIGRlZmluaXRpb24gZnJvbSBhIEpTIG9iamVjdFxuKi9cbkdMU0wuZGVmaW5lVW5pZm9ybSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBkZWYgPSBHTFNMLmRlZmluZVZhcmlhYmxlKG5hbWUsIHZhbHVlKTtcbiAgICBkZWYgPSBkZWYuc3RydWN0cyArICd1bmlmb3JtICcgKyBkZWYudmFyaWFibGU7XG4gICAgcmV0dXJuIGRlZjtcbn07XG5cbi8qKlxuICAgIENoZWNrIGZvciBhIHVuaWZvcm0gZGVmaW5pdGlvbiBvZiAnbmFtZScgaW4gdGhlIHByb3ZpZGVkIEdMU0wgc291cmNlXG4gICAgU2ltcGxlIHJlZ2V4IGNoZWNrIGZvciAndW5pZm9ybScga2V5d29yZCBhbmQgdmFyIG5hbWUsIGRvZXMgbm90IGF0dGVtcHQgdG8gcGFyc2UvZXh0cmFjdCBHTFNMXG4gICAgTk9URTogYXNzdW1lcyBjb21tZW50cyBoYXZlIGJlZW4gc3RyaXBwZWQgZnJvbSBzb3VyY2VcbiovXG5HTFNMLmlzVW5pZm9ybURlZmluZWQgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlKSB7XG4gICAgLy8gTWF0Y2gsIGluIG9yZGVyOlxuICAgIC8vIC0gdGhlIGtleXdvcmQgJ3VuaWZvcm0nXG4gICAgLy8gLSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHRoYXQgaXMgYW55dGhpbmcgZXhjZXB0IGEgc2VtaWNvbG9uLCA7XG4gICAgLy8gLSBvcHRpb25hbGx5LCBhbnl0aGluZyBlbmNsb3NlZCBpbiBjdXJseSBicmFjZXMsIHsgLi4uIH0gKGFuIGlubGluZSBzdHJ1Y3R1cmUgZGVmaW5pdGlvbiBjYW4gZ28gaGVyZSlcbiAgICAvLyAtIG9wdGlvbmFsbHksIGFueSAjIG9mIGNoYXJhY3RlcnMgdGhhdCBpcyBub3QgYSBzZW1pY29sb24sIDtcbiAgICAvLyAtIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtXG5cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCd1bmlmb3JtW147XSsoPzp7W1xcXFxzXFxcXFNdKn0pP1teO10qXFxcXGInICsgbmFtZSArICdcXFxcYicsICdnJyk7XG4gICAgaWYgKHNvdXJjZS5tYXRjaChyZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICAgIENoZWNrIHRoYXQgYSBzeW1ib2wgaXMgcmVmZXJlbmNlZCBpbiB0aGUgR0xTTCBzb3VyY2VcbiAgICBOT1RFOiBhc3N1bWVzIGNvbW1lbnRzIGhhdmUgYmVlbiBzdHJpcHBlZCBmcm9tIHNvdXJjZVxuKi9cbkdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSkge1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIG5hbWUgKyAnXFxcXGInLCAnZycpO1xuICAgIGlmIChzb3VyY2Uuc2VhcmNoKHJlKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAgICBFeHBhbmQgYSBzaW5nbGUgdmFsdWUgb3IgMi1lbGVtZW50IGFycmF5IGludG8gYSAzLWVsZW1lbnQgYXJyYXksIHdpdGggdGhlIGxhc3QgKCB6IClcbiAgICBjb29yZGluYXRlIGRlZmF1bHRpbmcgdG8gMSAod2l0aCBvcHRpb24gdG8gc3BlY2lmeSkuIEFsc28gcnVucyBwYXJzZUZsb2F0IHRvIHRyeSB0byBtYWludGFpblxuICAgIGRhdGEgaW50ZWdyaXR5LiBSZXR1cm5zIG51bGwgaWYgaW5wdXQgY291bGRuJ3QgYmUgcGFyc2VkLlxuKi9cbkdMU0wuZXhwYW5kVmVjMyA9IGZ1bmN0aW9uICh2LCB6ID0gMSkge1xuICAgIGxldCB4O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHggPSBbLi4udiwgel0ubWFwKHBhcnNlRmxvYXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeCA9IFt2LCB2LCB2XS5tYXAocGFyc2VGbG9hdCk7XG4gICAgfVxuXG4gICAgaWYgKHggJiYgeC5ldmVyeShuID0+IHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obikpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbn07XG5cbi8qKlxuICAgIEV4cGFuZCBhIHNpbmdsZSB2YWx1ZSBvciAzLWVsZW1lbnQgYXJyYXkgaW50byBhIDQtZWxlbWVudCBhcnJheSwgd2l0aCB0aGUgbGFzdCAoZS5nLiB3IG9yIGEpXG4gICAgY29vcmRpbmF0ZSBkZWZhdWx0aW5nIHRvIDEgKHdpdGggb3B0aW9uIHRvIHNwZWNpZnkpLiBBbHNvIHJ1bnMgcGFyc2VGbG9hdCB0byB0cnkgdG8gbWFpbnRhaW5cbiAgICBkYXRhIGludGVncml0eS4gUmV0dXJucyBudWxsIGlmIGlucHV0IGNvdWxkbid0IGJlIHBhcnNlZC5cbiovXG5HTFNMLmV4cGFuZFZlYzQgPSBmdW5jdGlvbiAodiwgdyA9IDEpIHtcbiAgICBsZXQgeDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICB4ID0gWy4uLnYsIHddLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHggPSBbdiwgdiwgdiwgd10ubWFwKHBhcnNlRmxvYXQpO1xuICAgIH1cblxuICAgIGlmICh4ICYmIHguZXZlcnkobiA9PiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG4pKSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG59O1xuXG5cbiIsIi8qIGdsb2JhbCBTaGFkZXJQcm9ncmFtICovXG4vLyBHTCBwcm9ncmFtIHdyYXBwZXIgdG8gY2FjaGUgdW5pZm9ybSBsb2NhdGlvbnMvdmFsdWVzLCBkbyBjb21waWxlLXRpbWUgcHJlLXByb2Nlc3Npbmdcbi8vIChpbmplY3RpbmcgI2RlZmluZXMgYW5kICNwcmFnbWEgYmxvY2tzIGludG8gc2hhZGVycyksIGV0Yy5cblxuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbHNsJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHN0cmlwIGZyb20gJ3N0cmlwLWNvbW1lbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyUHJvZ3JhbSB7XG5cbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4X3NvdXJjZSwgZnJhZ21lbnRfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcblxuICAgICAgICAvLyBrZXkvdmFsdWVzIGluc2VydGVkIGFzICNkZWZpbmVzIGludG8gc2hhZGVycyBhdCBjb21waWxlLXRpbWVcbiAgICAgICAgdGhpcy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5kZWZpbmVzfHx7fSk7XG5cbiAgICAgICAgLy8ga2V5L3ZhbHVlcyBmb3IgYmxvY2tzIHRoYXQgY2FuIGJlIGluamVjdGVkIGludG8gc2hhZGVycyBhdCBjb21waWxlLXRpbWVcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmJsb2Nrc3x8e30pO1xuXG4gICAgICAgIC8vIEpTLW9iamVjdCB1bmlmb3JtcyB0aGF0IGFyZSBleHBlY3RlZCBieSB0aGlzIHByb2dyYW1cbiAgICAgICAgLy8gSWYgdGhleSBhcmUgbm90IGZvdW5kIGluIHRoZSBleGlzdGluZyBzaGFkZXIgc291cmNlLCB0aGVpciB0eXBlcyB3aWxsIGJlIGluZmVycmVkIGFuZCBkZWZpbml0aW9uc1xuICAgICAgICAvLyBmb3IgZWFjaCB3aWxsIGJlIGluamVjdGVkLlxuICAgICAgICB0aGlzLmRlcGVuZGVudF91bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXM7XG5cbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9OyAvLyBwcm9ncmFtIGxvY2F0aW9ucyBvZiB1bmlmb3JtcywgbGF6aWx5IGFkZGVkIGFzIGVhY2ggdW5pZm9ybSBpcyBzZXRcbiAgICAgICAgdGhpcy5hdHRyaWJzID0ge307IC8vIHByb2dyYW0gbG9jYXRpb25zIG9mIHZlcnRleCBhdHRyaWJ1dGVzLCBsYXppbHkgYWRkZWQgYXMgZWFjaCBhdHRyaWJ1dGUgaXMgYWNjZXNzZWRcblxuICAgICAgICB0aGlzLnZlcnRleF9zb3VyY2UgPSB2ZXJ0ZXhfc291cmNlO1xuICAgICAgICB0aGlzLmZyYWdtZW50X3NvdXJjZSA9IGZyYWdtZW50X3NvdXJjZTtcblxuICAgICAgICB0aGlzLmlkID0gU2hhZGVyUHJvZ3JhbS5pZCsrO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLnByb2dyYW1zW3RoaXMuaWRdID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lOyAvLyBjYW4gcHJvdmlkZSBhIHByb2dyYW0gbmFtZSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcpXG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTtcbiAgICAgICAgZGVsZXRlIFNoYWRlclByb2dyYW0ucHJvZ3JhbXNbdGhpcy5pZF07XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVc2UgcHJvZ3JhbSB3cmFwcGVyIHdpdGggc2ltcGxlIHN0YXRlIGNhY2hlXG4gICAgdXNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTaGFkZXJQcm9ncmFtLmN1cnJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIFNoYWRlclByb2dyYW0uY3VycmVudCA9IHRoaXM7XG4gICAgfVxuXG4gICAgY29tcGlsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGlsaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYFNoYWRlclByb2dyYW0uY29tcGlsZSgpOiBza2lwcGluZyBmb3IgJHt0aGlzLmlkfSAoJHt0aGlzLm5hbWV9KSBiZWNhdXNlIGFscmVhZHkgY29tcGlsaW5nYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcblxuICAgICAgICAvLyBDb3B5IHNvdXJjZXMgZnJvbSBwcmUtbW9kaWZpZWQgdGVtcGxhdGVcbiAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdGhpcy52ZXJ0ZXhfc291cmNlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IHRoaXMuZnJhZ21lbnRfc291cmNlO1xuXG4gICAgICAgIC8vIE1ha2UgbGlzdCBvZiBkZWZpbmVzIHRvIGJlIGluamVjdGVkIGxhdGVyXG4gICAgICAgIHZhciBkZWZpbmVzID0gdGhpcy5idWlsZERlZmluZUxpc3QoKTtcblxuICAgICAgICAvLyBJbmplY3QgdXNlci1kZWZpbmVkIGJsb2NrcyAoYXJiaXRyYXJ5IGNvZGUgcG9pbnRzIG1hdGNoaW5nIG5hbWVkICNwcmFnbWFzKVxuICAgICAgICAvLyBSZXBsYWNlIGFjY29yZGluZyB0byB0aGlzIHBhdHRlcm46XG4gICAgICAgIC8vICNwcmFnbWEgdGFuZ3JhbTogW2tleV1cbiAgICAgICAgLy8gZS5nLiAjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxuXG4gICAgICAgIC8vIEdhdGhlciBhbGwgYmxvY2sgY29kZSBzbmlwcGV0c1xuICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5idWlsZFNoYWRlckJsb2NrTGlzdCgpO1xuICAgICAgICB2YXIgcmVnZXhwO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBibG9ja3MpIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1trZXldO1xuICAgICAgICAgICAgaWYgKCFibG9jayB8fCAoQXJyYXkuaXNBcnJheShibG9jaykgJiYgYmxvY2subGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJzdCBmaW5kIGNvZGUgcmVwbGFjZSBwb2ludHMgaW4gc2hhZGVyc1xuICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKiNwcmFnbWFcXFxccyt0YW5ncmFtOlxcXFxzKycgKyBrZXkgKyAnXFxcXHMqJCcsICdtJyk7XG4gICAgICAgICAgICB2YXIgaW5qZWN0X3ZlcnRleCA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5tYXRjaChyZWdleHApO1xuICAgICAgICAgICAgdmFyIGluamVjdF9mcmFnbWVudCA9IHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlLm1hdGNoKHJlZ2V4cCk7XG5cbiAgICAgICAgICAgIC8vIEF2b2lkIG5ldHdvcmsgcmVxdWVzdCBpZiBub3RoaW5nIHRvIHJlcGxhY2VcbiAgICAgICAgICAgIGlmIChpbmplY3RfdmVydGV4ID09IG51bGwgJiYgaW5qZWN0X2ZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWFjaCBrZXkgY2FuIGJlIGEgc2luZ2xlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgICAgICB2YXIgc291cmNlID0gYFxcbiR7YmxvY2t9XFxuYDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2NrKSkge1xuICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgYWxsIGJsb2NrcyBpbnRvIG9uZSBzdHJpbmdcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBibG9jay5yZWR1Y2UoKHByZXYsIGN1cikgPT4gYFxcbiR7cHJldn1cXG4ke2N1cn1cXG5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5qZWN0XG4gICAgICAgICAgICBpZiAoaW5qZWN0X3ZlcnRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlLnJlcGxhY2UocmVnZXhwLCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluamVjdF9mcmFnbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UgPSB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgc291cmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGEgI2RlZmluZSBmb3IgdGhpcyBpbmplY3Rpb24gcG9pbnRcbiAgICAgICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fQkxPQ0tfJyArIGtleS5yZXBsYWNlKC9bXFxzLV0rL2csICdfJykudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYW4tdXAgYW55ICNwcmFnbWFzIHRoYXQgd2VyZW4ndCByZXBsYWNlZCAodG8gcHJldmVudCBjb21waWxlciB3YXJuaW5ncylcbiAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKiNwcmFnbWEuKiQnLCAnZ20nKTtcbiAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlLnJlcGxhY2UocmVnZXhwLCAnJyk7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UucmVwbGFjZShyZWdleHAsICcnKTtcblxuICAgICAgICAvLyBCdWlsZCAmIGluamVjdCBkZWZpbmVzXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSAqYWZ0ZXIqIGNvZGUgaW5qZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBkZWZpbmVzIGZvciB3aGljaCBjb2RlIHBvaW50cyB3ZXJlIGluamVjdGVkXG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fVkVSVEVYX1NIQURFUiddID0gdHJ1ZTtcbiAgICAgICAgZGVmaW5lc1snVEFOR1JBTV9GUkFHTUVOVF9TSEFERVInXSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSBTaGFkZXJQcm9ncmFtLmJ1aWxkRGVmaW5lU3RyaW5nKGRlZmluZXMpICsgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlO1xuXG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fVkVSVEVYX1NIQURFUiddID0gZmFsc2U7XG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fRlJBR01FTlRfU0hBREVSJ10gPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IFNoYWRlclByb2dyYW0uYnVpbGREZWZpbmVTdHJpbmcoZGVmaW5lcykgKyB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZTtcblxuICAgICAgICAvLyBEZXRlY3QgdW5pZm9ybSBkZWZpbml0aW9ucywgaW5qZWN0IGFueSBtaXNzaW5nIG9uZXNcbiAgICAgICAgdGhpcy5lbnN1cmVVbmlmb3Jtcyh0aGlzLmRlcGVuZGVudF91bmlmb3Jtcyk7XG5cbiAgICAgICAgLy8gSW5jbHVkZSBwcm9ncmFtIGluZm8gdXNlZnVsIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgdmFyIGluZm8gPSAodGhpcy5uYW1lID8gKHRoaXMubmFtZSArICcgLyBpZCAnICsgdGhpcy5pZCkgOiAoJ2lkICcgKyB0aGlzLmlkKSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9ICcvLyBQcm9ncmFtOiAnICsgaW5mbyArICdcXG4nICsgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlO1xuICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9ICcvLyBQcm9ncmFtOiAnICsgaW5mbyArICdcXG4nICsgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2U7XG5cbiAgICAgICAgLy8gQ29tcGlsZSAmIHNldCB1bmlmb3JtcyB0byBjYWNoZWQgdmFsdWVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBTaGFkZXJQcm9ncmFtLnVwZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtLCB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UsIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYFNoYWRlclByb2dyYW0uY29tcGlsZSgpOiBwcm9ncmFtICR7dGhpcy5pZH0gKCR7dGhpcy5uYW1lfSkgZXJyb3I6YCwgZXJyb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaFVuaWZvcm1zKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGxpc3Qgb2YgZGVmaW5lcyAoZ2xvYmFsLCB0aGVuIHByb2dyYW0tc3BlY2lmaWMpXG4gICAgYnVpbGREZWZpbmVMaXN0KCkge1xuICAgICAgICB2YXIgZCwgZGVmaW5lcyA9IHt9O1xuICAgICAgICBmb3IgKGQgaW4gU2hhZGVyUHJvZ3JhbS5kZWZpbmVzKSB7XG4gICAgICAgICAgICBkZWZpbmVzW2RdID0gU2hhZGVyUHJvZ3JhbS5kZWZpbmVzW2RdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoZCBpbiB0aGlzLmRlZmluZXMpIHtcbiAgICAgICAgICAgIGRlZmluZXNbZF0gPSB0aGlzLmRlZmluZXNbZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZXM7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBsaXN0IG9mIHNoYWRlciBibG9ja3MgKGdsb2JhbCwgdGhlbiBwcm9ncmFtLXNwZWNpZmljKVxuICAgIGJ1aWxkU2hhZGVyQmxvY2tMaXN0KCkge1xuICAgICAgICB2YXIgZCwgYmxvY2tzID0ge307XG4gICAgICAgIGZvciAoZCBpbiBTaGFkZXJQcm9ncmFtLmJsb2Nrcykge1xuICAgICAgICAgICAgYmxvY2tzW2RdID0gW107XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFNoYWRlclByb2dyYW0uYmxvY2tzW2RdKSkge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tkXS5wdXNoKC4uLlNoYWRlclByb2dyYW0uYmxvY2tzW2RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tkXSA9IFtTaGFkZXJQcm9ncmFtLmJsb2Nrc1tkXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChkIGluIHRoaXMuYmxvY2tzKSB7XG4gICAgICAgICAgICBibG9ja3NbZF0gPSBibG9ja3NbZF0gfHwgW107XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYmxvY2tzW2RdKSkge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tkXS5wdXNoKC4uLnRoaXMuYmxvY2tzW2RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tkXS5wdXNoKHRoaXMuYmxvY2tzW2RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tzO1xuICAgIH1cblxuICAgIC8vIERldGVjdCB1bmlmb3JtIGRlZmluaXRpb25zLCBpbmplY3QgYW55IG1pc3Npbmcgb25lc1xuICAgIGVuc3VyZVVuaWZvcm1zKHVuaWZvcm1zKSB7XG4gICAgICAgIGlmICghdW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2cyA9IHN0cmlwKHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSk7XG4gICAgICAgIHZhciBmcyA9IHN0cmlwKHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlKTtcbiAgICAgICAgdmFyIGluamVjdCwgdnNfaW5qZWN0aW9ucyA9IFtdLCBmc19pbmplY3Rpb25zID0gW107XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG1pc3NpbmcgdW5pZm9ybSBkZWZpbml0aW9uc1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBpbmplY3QgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgICAgICBpZiAoIUdMU0wuaXNVbmlmb3JtRGVmaW5lZChuYW1lLCB2cykgJiYgR0xTTC5pc1N5bWJvbFJlZmVyZW5jZWQobmFtZSwgdnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ID0gR0xTTC5kZWZpbmVVbmlmb3JtKG5hbWUsIHVuaWZvcm1zW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBQcm9ncmFtICR7dGhpcy5uYW1lfTogJHtuYW1lfSBub3QgZGVmaW5lZCBpbiB2ZXJ0ZXggc2hhZGVyLCBpbmplY3Rpbmc6ICcke2luamVjdH0nYCk7XG4gICAgICAgICAgICAgICAgdnNfaW5qZWN0aW9ucy5wdXNoKGluamVjdCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZyYWdtZW50IHNoYWRlclxuICAgICAgICAgICAgaWYgKCFHTFNMLmlzVW5pZm9ybURlZmluZWQobmFtZSwgZnMpICYmIEdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkKG5hbWUsIGZzKSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdCA9IEdMU0wuZGVmaW5lVW5pZm9ybShuYW1lLCB1bmlmb3Jtc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgUHJvZ3JhbSAke3RoaXMubmFtZX06ICR7bmFtZX0gbm90IGRlZmluZWQgaW4gZnJhZ21lbnQgc2hhZGVyLCBpbmplY3Rpbmc6ICcke2luamVjdH0nYCk7XG4gICAgICAgICAgICAgICAgZnNfaW5qZWN0aW9ucy5wdXNoKGluamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmplY3QgbWlzc2luZyB1bmlmb3Jtc1xuICAgICAgICAvLyBOT1RFOiB0aGVzZSBhcmUgaW5qZWN0ZWQgYXQgdGhlIHZlcnkgdG9wIG9mIHRoZSBzaGFkZXJzLCBldmVuIGJlZm9yZSBhbnkgI2RlZmluZXMgb3IgI3ByYWdtYXMgYXJlIGFkZGVkXG4gICAgICAgIC8vIHRoaXMgY291bGQgY2F1c2Ugc29tZSBpc3N1ZXMgd2l0aCBjZXJ0YWluICNwcmFnbWFzLCBvciBvdGhlciBmdW5jdGlvbnMgdGhhdCBtaWdodCBleHBlY3QgI2RlZmluZXNcbiAgICAgICAgaWYgKHZzX2luamVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdnNfaW5qZWN0aW9ucy5qb2luKCdcXG4nKSArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmc19pbmplY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gZnNfaW5qZWN0aW9ucy5qb2luKCdcXG4nKSArIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHVuaWZvcm1zIGZyb20gYSBKUyBvYmplY3QsIHdpdGggaW5mZXJyZWQgdHlwZXNcbiAgICBzZXRVbmlmb3Jtcyh1bmlmb3JtcywgcmVzZXRfdGV4dHVyZV91bml0ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IG9ubHkgdXBkYXRlIHVuaWZvcm1zIHdoZW4gY2hhbmdlZFxuXG4gICAgICAgIC8vIFRleHR1cmUgdW5pdHMgbXVzdCBiZSB0cmFja2VkIGFuZCBpbmNyZW1lbnRlZCBlYWNoIHRpbWUgYSB0ZXh0dXJlIHNhbXBsZXIgdW5pZm9ybSBpcyBzZXQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSB0ZXh0dXJlIHVuaXQgaXMgcmVzZXQgdG8gMCBlYWNoIHRpbWUgc2V0VW5pZm9ybXMgaXMgY2FsbGVkLCBidXQgdGhleSBjYW5cbiAgICAgICAgLy8gYWxzbyBiZSBwcmVzZXJ2ZWQsIGZvciBleGFtcGxlIGluIGNhc2VzIHdoZXJlIG11bHRpcGxlIGNhbGxzIHRvIHNldFVuaWZvcm1zIGFyZSBleHBlY3RlZFxuICAgICAgICAvLyAoZS5nLiBwcm9ncmFtLXNwZWNpZmljIHVuaWZvcm1zIGZvbGxvd2VkIGJ5IG1lc2gtc3BlY2lmaWMgb25lcykuXG4gICAgICAgIGlmIChyZXNldF90ZXh0dXJlX3VuaXQpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZV91bml0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIHVuaWZvcm0gdHlwZXMgYW5kIHZhbHVlcyBmcm9tIHRoZSBKUyBvYmplY3RcbiAgICAgICAgdmFyIHBhcnNlZCA9IEdMU0wucGFyc2VVbmlmb3Jtcyh1bmlmb3Jtcyk7XG5cbiAgICAgICAgLy8gU2V0IGVhY2ggdW5pZm9ybVxuICAgICAgICBmb3IgKHZhciB1bmlmb3JtIG9mIHBhcnNlZCkge1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0udHlwZSA9PT0gJ3NhbXBsZXIyRCcpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dHVyZXMsIHdlIG5lZWQgdG8gdHJhY2sgdGV4dHVyZSB1bml0cywgc28gd2UgaGF2ZSBhIHNwZWNpYWwgc2V0dGVyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0dXJlVW5pZm9ybSh1bmlmb3JtLm5hbWUsIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtKHVuaWZvcm0ubWV0aG9kLCB1bmlmb3JtLm5hbWUsIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgc29tZSBvciBhbGwgdW5pZm9ybSB2YWx1ZXMgc28gdGhleSBjYW4gYmUgcmVzdG9yZWRcbiAgICBzYXZlVW5pZm9ybXMoc3Vic2V0KSB7XG4gICAgICAgIGxldCB1bmlmb3JtcyA9IHN1YnNldCB8fCB0aGlzLnVuaWZvcm1zO1xuICAgICAgICBmb3IgKGxldCB1IGluIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbdV07XG4gICAgICAgICAgICBpZiAodW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uc2F2ZWRfdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2F2ZWRfdGV4dHVyZV91bml0ID0gdGhpcy50ZXh0dXJlX3VuaXQgfHwgMDtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHNvbWUgb3IgYWxsIHVuaWZvcm1zIHRvIHNhdmVkIHZhbHVlc1xuICAgIHJlc3RvcmVVbmlmb3JtcyhzdWJzZXQpIHtcbiAgICAgICAgbGV0IHVuaWZvcm1zID0gc3Vic2V0IHx8IHRoaXMudW5pZm9ybXM7XG4gICAgICAgIGZvciAobGV0IHUgaW4gdW5pZm9ybXMpIHtcbiAgICAgICAgICAgIGxldCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1t1XTtcbiAgICAgICAgICAgIGlmICh1bmlmb3JtICYmIHVuaWZvcm0uc2F2ZWRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLnZhbHVlID0gdW5pZm9ybS5zYXZlZF92YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm0odSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0dXJlX3VuaXQgPSB0aGlzLnNhdmVkX3RleHR1cmVfdW5pdCB8fCAwO1xuICAgIH1cblxuICAgIC8vIFNldCBhIHRleHR1cmUgdW5pZm9ybSwgZmluZHMgdGV4dHVyZSBieSBuYW1lIG9yIGNyZWF0ZXMgYSBuZXcgb25lXG4gICAgc2V0VGV4dHVyZVVuaWZvcm0odW5pZm9ybV9uYW1lLCB0ZXh0dXJlX25hbWUpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RleHR1cmVfbmFtZV07XG4gICAgICAgIGlmICh0ZXh0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlX25hbWUpO1xuICAgICAgICAgICAgdGV4dHVyZS5sb2FkKHRleHR1cmVfbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLmJpbmQodGhpcy50ZXh0dXJlX3VuaXQpO1xuICAgICAgICB0aGlzLnVuaWZvcm0oJzFpJywgdW5pZm9ybV9uYW1lLCB0aGlzLnRleHR1cmVfdW5pdCk7XG4gICAgICAgIHRoaXMudGV4dHVyZV91bml0Kys7IC8vIFRPRE86IHRyYWNrIG1heCB0ZXh0dXJlIHVuaXRzIGFuZCBsb2cvdGhyb3cgZXJyb3JzXG4gICAgfVxuXG4gICAgLy8gZXg6IHByb2dyYW0udW5pZm9ybSgnM2YnLCAncG9zaXRpb24nLCB4LCB5LCB6KTtcbiAgICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSB1bmlmb3JtcyB3aGVuIGNoYW5nZWRcbiAgICB1bmlmb3JtKG1ldGhvZCwgbmFtZSwgLi4udmFsdWUpIHsgLy8gJ3ZhbHVlJyBpcyBhIG1ldGhvZC1hcHByb3ByaWF0ZSBhcmd1bWVudHMgbGlzdFxuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSB0aGlzLnVuaWZvcm1zW25hbWVdIHx8IHt9O1xuICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgIHVuaWZvcm0ubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmICh1bmlmb3JtLmxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVuaWZvcm0ubG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHVuaWZvcm0ubWV0aG9kID0gJ3VuaWZvcm0nICsgbWV0aG9kO1xuICAgICAgICB1bmlmb3JtLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlVW5pZm9ybShuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYSBzaW5nbGUgdW5pZm9ybVxuICAgIHVwZGF0ZVVuaWZvcm0obmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tuYW1lXTtcbiAgICAgICAgaWYgKCF1bmlmb3JtIHx8IHVuaWZvcm0ubG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51c2UoKTtcbiAgICAgICAgdGhpcy5nbFt1bmlmb3JtLm1ldGhvZF0uYXBwbHkodGhpcy5nbCwgW3VuaWZvcm0ubG9jYXRpb25dLmNvbmNhdCh1bmlmb3JtLnZhbHVlKSk7IC8vIGNhbGwgYXBwcm9wcmlhdGUgR0wgdW5pZm9ybSBtZXRob2QgYW5kIHBhc3MgdGhyb3VnaCBhcmd1bWVudHNcbiAgICB9XG5cbiAgICAvLyBSZWZyZXNoIHVuaWZvcm0gbG9jYXRpb25zIGFuZCBzZXQgdG8gbGFzdCBjYWNoZWQgdmFsdWVzXG4gICAgcmVmcmVzaFVuaWZvcm1zKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHUgaW4gdGhpcy51bmlmb3Jtcykge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtc1t1XS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm0odSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWZyZXNoQXR0cmlidXRlcygpIHtcbiAgICAgICAgLy8gdmFyIGxlbiA9IHRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIHRoaXMuZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICAgICAgICAvLyBmb3IgKHZhciBpPTA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAgICAgdmFyIGEgPSB0aGlzLmdsLmdldEFjdGl2ZUF0dHJpYih0aGlzLnByb2dyYW0sIGkpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IHt9O1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbG9jYXRpb24gb2YgYSB2ZXJ0ZXggYXR0cmlidXRlXG4gICAgYXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmliID0gKHRoaXMuYXR0cmlic1tuYW1lXSA9IHRoaXMuYXR0cmlic1tuYW1lXSB8fCB7fSk7XG4gICAgICAgIGlmIChhdHRyaWIubG9jYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYi5uYW1lID0gbmFtZTtcbiAgICAgICAgYXR0cmliLmxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuXG4gICAgICAgIC8vIHZhciBpbmZvID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBhdHRyaWIubG9jYXRpb24pO1xuICAgICAgICAvLyBhdHRyaWIudHlwZSA9IGluZm8udHlwZTtcbiAgICAgICAgLy8gYXR0cmliLnNpemUgPSBpbmZvLnNpemU7XG5cbiAgICAgICAgcmV0dXJuIGF0dHJpYjtcbiAgICB9XG5cbn1cblxuXG4vLyBTdGF0aWMgbWV0aG9kcyBhbmQgc3RhdGVcblxuU2hhZGVyUHJvZ3JhbS5pZCA9IDA7ICAgICAgICAgICAvLyBhc3NpZ24gZWFjaCBwcm9ncmFtIGEgdW5pcXVlIGlkXG5TaGFkZXJQcm9ncmFtLnByb2dyYW1zID0ge307ICAgIC8vIHByb2dyYW1zLCBieSBpZFxuU2hhZGVyUHJvZ3JhbS5jdXJyZW50ID0gbnVsbDsgICAvLyBjdXJyZW50bHkgYm91bmQgcHJvZ3JhbVxuXG4vLyBHbG9iYWwgY29uZmlnIGFwcGxpZWQgdG8gYWxsIHByb2dyYW1zIChkdXBsaWNhdGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBwcm9ncmFtIHdpbGwgdGFrZSBwcmVjZWRlbmNlKVxuU2hhZGVyUHJvZ3JhbS5kZWZpbmVzID0ge307XG5TaGFkZXJQcm9ncmFtLmJsb2NrcyA9IHt9O1xuXG4vLyBUdXJuIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgaW50byBzaW5nbGUgc3RyaW5nIG9mICNkZWZpbmUgc3RhdGVtZW50c1xuU2hhZGVyUHJvZ3JhbS5idWlsZERlZmluZVN0cmluZyA9IGZ1bmN0aW9uIChkZWZpbmVzKSB7XG4gICAgdmFyIGRlZmluZV9zdHIgPSBcIlwiO1xuICAgIGZvciAodmFyIGQgaW4gZGVmaW5lcykge1xuICAgICAgICBpZiAoZGVmaW5lc1tkXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmVzW2RdID09PSAnYm9vbGVhbicgJiYgZGVmaW5lc1tkXSA9PT0gdHJ1ZSkgeyAvLyBib29sZWFucyBhcmUgc2ltcGxlIGRlZmluZXMgd2l0aCBubyB2YWx1ZVxuICAgICAgICAgICAgZGVmaW5lX3N0ciArPSBcIiNkZWZpbmUgXCIgKyBkICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lc1tkXSA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihkZWZpbmVzW2RdKSA9PT0gZGVmaW5lc1tkXSkgeyAvLyBpbnQgdG8gZmxvYXQgY29udmVyc2lvbiB0byBzYXRpc2Z5IEdMU0wgZmxvYXRzXG4gICAgICAgICAgICBkZWZpbmVfc3RyICs9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIGRlZmluZXNbZF0udG9GaXhlZCgxKSArIFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGFueSBvdGhlciBmbG9hdCBvciBzdHJpbmcgdmFsdWVcbiAgICAgICAgICAgIGRlZmluZV9zdHIgKz0gXCIjZGVmaW5lIFwiICsgZCArIFwiIFwiICsgZGVmaW5lc1tkXSArIFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmluZV9zdHI7XG59O1xuXG5TaGFkZXJQcm9ncmFtLmFkZEJsb2NrID0gZnVuY3Rpb24gKGtleSwgLi4uYmxvY2tzKSB7XG4gICAgU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XSA9IFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0gfHwgW107XG4gICAgU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XS5wdXNoKC4uLmJsb2Nrcyk7XG59O1xuXG4vLyBSZW1vdmUgYWxsIGdsb2JhbCBzaGFkZXIgYmxvY2tzIGZvciBhIGdpdmVuIGtleVxuU2hhZGVyUHJvZ3JhbS5yZW1vdmVCbG9jayA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldID0gW107XG59O1xuXG5TaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jayA9IGZ1bmN0aW9uIChrZXksIC4uLmJsb2Nrcykge1xuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soa2V5KTtcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKGtleSwgLi4uYmxvY2tzKTtcbn07XG5cbi8vIENvbXBpbGUgJiBsaW5rIGEgV2ViR0wgcHJvZ3JhbSBmcm9tIHByb3ZpZGVkIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZXNcbi8vIHVwZGF0ZSBhIHByb2dyYW0gaWYgb25lIGlzIHBhc3NlZCBpbi4gQ3JlYXRlIG9uZSBpZiBub3QuIEFsZXJ0IGFuZCBkb24ndCB1cGRhdGUgYW55dGhpbmcgaWYgdGhlIHNoYWRlcnMgZG9uJ3QgY29tcGlsZS5cblNoYWRlclByb2dyYW0udXBkYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChnbCwgcHJvZ3JhbSwgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGZyYWdtZW50X3NoYWRlcl9zb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdmVydGV4X3NoYWRlciA9IFNoYWRlclByb2dyYW0uY3JlYXRlU2hhZGVyKGdsLCB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSwgZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIHZhciBmcmFnbWVudF9zaGFkZXIgPSBTaGFkZXJQcm9ncmFtLmNyZWF0ZVNoYWRlcihnbCwgJyNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4nICsgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICB9XG4gICAgY2F0Y2goZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcbiAgICBpZiAocHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRfc2hhZGVycyA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhwcm9ncmFtKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9sZF9zaGFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgb2xkX3NoYWRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICB9XG5cbiAgICBpZiAodmVydGV4X3NoYWRlciA9PSBudWxsIHx8IGZyYWdtZW50X3NoYWRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRfc2hhZGVyKTtcblxuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhfc2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRfc2hhZGVyKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICB2YXIgcHJvZ3JhbV9lcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBXZWJHTCBwcm9ncmFtIGVycm9yOlxuICAgICAgICAgICAgVkFMSURBVEVfU1RBVFVTOiAke2dsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKX1cbiAgICAgICAgICAgIEVSUk9SOiAke2dsLmdldEVycm9yKCl9XG4gICAgICAgICAgICAtLS0gVmVydGV4IFNoYWRlciAtLS1cbiAgICAgICAgICAgICR7dmVydGV4X3NoYWRlcl9zb3VyY2V9XG4gICAgICAgICAgICAtLS0gRnJhZ21lbnQgU2hhZGVyIC0tLVxuICAgICAgICAgICAgJHtmcmFnbWVudF9zaGFkZXJfc291cmNlfWApO1xuICAgICAgICBsb2cuZXJyb3IocHJvZ3JhbV9lcnJvcik7XG4gICAgICAgIHRocm93IHByb2dyYW1fZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG59O1xuXG4vLyBDb21waWxlIGEgdmVydGV4IG9yIGZyYWdtZW50IHNoYWRlciBmcm9tIHByb3ZpZGVkIHNvdXJjZVxuU2hhZGVyUHJvZ3JhbS5jcmVhdGVTaGFkZXIgPSBmdW5jdGlvbiAoZ2wsIHNvdXJjZSwgdHlwZSkge1xuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIHZhciBzaGFkZXJfZXJyb3IgPVxuICAgICAgICAgICAgXCJXZWJHTCBzaGFkZXIgZXJyb3I6XFxuXCIgK1xuICAgICAgICAgICAgKHR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyBcIlZFUlRFWFwiIDogXCJGUkFHTUVOVFwiKSArIFwiIFNIQURFUjpcXG5cIiArXG4gICAgICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgIHRocm93IHNoYWRlcl9lcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcbiIsIi8vIEdlbmVyYXRlZCBmcm9tIEdMU0wgZmlsZXMsIGRvbid0IGVkaXQhXG52YXIgc2hhZGVyU291cmNlcyA9IHt9O1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FtYmllbnRMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cImxpZ2h0X2FjY3VtdWxhdG9yXypcXG5cIiArXG5cIlxcblwiICtcblwiKi9cXG5cIiArXG5cIlxcblwiICtcblwic3RydWN0IEFtYmllbnRMaWdodCB7XFxuXCIgK1xuXCIgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBBbWJpZW50TGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIiAgICBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICs9IF9saWdodC5hbWJpZW50O1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvZGlyZWN0aW9uYWxMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjMyBkaXJlY3Rpb247XFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZUxpZ2h0KGluIERpcmVjdGlvbmFsTGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKz0gX2xpZ2h0LmFtYmllbnQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBuRG90VlAgPSBjbGFtcChkb3QoX25vcm1hbCwgLW5vcm1hbGl6ZShfbGlnaHQuZGlyZWN0aW9uKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSArPSBfbGlnaHQuZGlmZnVzZSAqIG5Eb3RWUDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHBmID0gMC4wO1xcblwiICtcblwiICAgICAgICBpZiAobkRvdFZQID4gMC4wKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIHJlZmxlY3RWZWN0b3IgPSByZWZsZWN0KG5vcm1hbGl6ZShfbGlnaHQuZGlyZWN0aW9uKSwgX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBleWVEb3RSID0gbWF4KGRvdChub3JtYWxpemUoX2V5ZVRvUG9pbnQpLCByZWZsZWN0VmVjdG9yKSwgMC4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHBmID0gcG93KGV5ZURvdFIsIG1hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKz0gX2xpZ2h0LnNwZWN1bGFyICogcGY7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9sYXllcl9vcmRlciddID1cblwiLy8gQXBwbHkgbGF5ZXIgb3JkZXJpbmcgdG8gYXZvaWQgei1maWdodGluZ1xcblwiICtcblwidm9pZCBhcHBseUxheWVyT3JkZXIgKGZsb2F0IGxheWVyLCBpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuXCIgK1xuXCIgICAgcG9zaXRpb24ueiAtPSBsYXllciAqIFRBTkdSQU1fTEFZRVJfREVMVEEgKiBwb3NpdGlvbi53O1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbWF0ZXJpYWwnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkRlZmluZXMgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiLy8gTUFURVJJQUxTXFxuXCIgK1xuXCIvL1xcblwiICtcblwic3RydWN0IE1hdGVyaWFsIHtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTlxcblwiICtcblwiICAgICAgICB2ZWM0IGVtaXNzaW9uO1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIGVtaXNzaW9uU2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVFxcblwiICtcblwiICAgICAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBhbWJpZW50U2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICB2ZWM0IGRpZmZ1c2U7XFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBkaWZmdXNlU2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgdmVjNCBzcGVjdWxhcjtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgc2hpbmluZXNzO1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIHNwZWN1bGFyU2NhbGU7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRVxcblwiICtcblwiICAgICAgICB2ZWMzIG5vcm1hbFNjYWxlO1xcblwiICtcblwiICAgICAgICBmbG9hdCBub3JtYWxBbW91bnQ7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBOb3RlOiB1bmlmb3JtIGlzIGNvcGllZCB0byBhIGdsb2JhbCBpbnN0YW5jZSB0byBhbGxvdyBtb2RpZmljYXRpb25cXG5cIiArXG5cInVuaWZvcm0gTWF0ZXJpYWwgdV9tYXRlcmlhbDtcXG5cIiArXG5cIk1hdGVyaWFsIG1hdGVyaWFsID0gdV9tYXRlcmlhbDtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfbm9ybWFsX3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gR2xvYmFsIGxpZ2h0IGFjY3VtdWxhdG9ycyBmb3IgZWFjaCBwcm9wZXJ0eVxcblwiICtcblwidmVjNCBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ID0gdmVjNCgwLjApO1xcblwiICtcblwidmVjNCBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlID0gdmVjNCgwLjApO1xcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICB2ZWM0IGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyID0gdmVjNCgwLjApO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cInZlYzQgZ2V0U3BoZXJlTWFwIChpbiBzYW1wbGVyMkQgX3RleCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsLCBpbiB2ZWMyIF9za2V3KSB7XFxuXCIgK1xuXCIgICAgdmVjMyBleWUgPSBub3JtYWxpemUoX2V5ZVRvUG9pbnQpO1xcblwiICtcblwiICAgIGV5ZS54eSAtPSBfc2tldztcXG5cIiArXG5cIiAgICBleWUgPSBub3JtYWxpemUoZXllKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZlYzMgciA9IHJlZmxlY3QoZXllLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICByLnogKz0gMS4wO1xcblwiICtcblwiICAgIGZsb2F0IG0gPSAyLiAqIGxlbmd0aChyKTtcXG5cIiArXG5cIiAgICB2ZWMyIHV2ID0gci54eSAvIG0gKyAuNTtcXG5cIiArXG5cIiAgICByZXR1cm4gdGV4dHVyZTJEKF90ZXgsIHV2KTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCJ2ZWMzIGdldFRyaVBsYW5hckJsZW5kIChpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIiAgICB2ZWMzIGJsZW5kaW5nID0gYWJzKF9ub3JtYWwpO1xcblwiICtcblwiICAgIGJsZW5kaW5nID0gbm9ybWFsaXplKG1heChibGVuZGluZywgMC4wMDAwMSkpO1xcblwiICtcblwiICAgIGZsb2F0IGIgPSAoYmxlbmRpbmcueCArIGJsZW5kaW5nLnkgKyBibGVuZGluZy56KTtcXG5cIiArXG5cIiAgICByZXR1cm4gYmxlbmRpbmcgLyBiO1xcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCJ2ZWM0IGdldFRyaVBsYW5hciAoaW4gc2FtcGxlcjJEIF90ZXgsIGluIHZlYzMgX3BvcywgaW4gdmVjMyBfbm9ybWFsLCBpbiB2ZWMzIF9zY2FsZSkge1xcblwiICtcblwiICAgIHZlYzMgYmxlbmRpbmcgPSBnZXRUcmlQbGFuYXJCbGVuZChfbm9ybWFsKTtcXG5cIiArXG5cIiAgICB2ZWM0IHhheGlzID0gdGV4dHVyZTJEKF90ZXgsIGZyYWN0KF9wb3MueXogKiBfc2NhbGUueCkpO1xcblwiICtcblwiICAgIHZlYzQgeWF4aXMgPSB0ZXh0dXJlMkQoX3RleCwgZnJhY3QoX3Bvcy54eiAqIF9zY2FsZS55KSk7XFxuXCIgK1xuXCIgICAgdmVjNCB6YXhpcyA9IHRleHR1cmUyRChfdGV4LCBmcmFjdChfcG9zLnh5ICogX3NjYWxlLnopKTtcXG5cIiArXG5cIiAgICByZXR1cm4gIHhheGlzICogYmxlbmRpbmcueCArIHlheGlzICogYmxlbmRpbmcueSArIHpheGlzICogYmxlbmRpbmcuejtcXG5cIiArXG5cIn1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCJ2ZWM0IGdldFBsYW5hciAoaW4gc2FtcGxlcjJEIF90ZXgsIGluIHZlYzMgX3BvcywgaW4gdmVjMiBfc2NhbGUpIHtcXG5cIiArXG5cIiAgICByZXR1cm4gdGV4dHVyZTJEKCBfdGV4LCBmcmFjdChfcG9zLnh5ICogX3NjYWxlLngpICk7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRVxcblwiICtcblwidm9pZCBjYWxjdWxhdGVOb3JtYWwgKGlub3V0IHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiICAgIC8vIEdldCBOT1JNQUxNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgX25vcm1hbCArPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZSwgZnJhY3Qodl90ZXhjb29yZCptYXRlcmlhbC5ub3JtYWxTY2FsZS54eSkpLnJnYioyLjAtMS4wO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgdmVjMyBub3JtYWxUZXggPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLm5vcm1hbFNjYWxlLnh5KS5yZ2IqMi4wLTEuMDtcXG5cIiArXG5cIiAgICBfbm9ybWFsICs9IG5vcm1hbFRleDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgIHZlYzMgbm9ybWFsVGV4ID0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfbm9ybWFsX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5ub3JtYWxTY2FsZSkucmdiKjIuMC0xLjA7XFxuXCIgK1xuXCIgICAgX25vcm1hbCArPSBub3JtYWxUZXg7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBfbm9ybWFsID0gbm9ybWFsaXplKF9ub3JtYWwpO1xcblwiICtcblwifVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTWF0ZXJpYWwgKGluIHZlYzMgX2V5ZVRvUG9pbnQsIGlub3V0IHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiICAgIC8vIGdldCBFTUlTU0lPTiBURVhUVVJFTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZW1pc3Npb24gKj0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZW1pc3Npb24gKj0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLmVtaXNzaW9uU2NhbGUueHkpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5lbWlzc2lvbiAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwuZW1pc3Npb25TY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmVtaXNzaW9uICo9IGdldFNwaGVyZU1hcCh1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmUsIF9leWVUb1BvaW50LCBfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gZ2V0IEFNQklFTlQgVEVYVFVSRU1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRV9VVlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5hbWJpZW50ICo9IHRleHR1cmUyRCh1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5hbWJpZW50ICo9IGdldFBsYW5hcih1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLmFtYmllbnRTY2FsZS54eSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuYW1iaWVudCAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5hbWJpZW50U2NhbGUpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmFtYmllbnQgKj0gZ2V0U3BoZXJlTWFwKHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlLCBfZXllVG9Qb2ludCwgX25vcm1hbCwgdV92YW5pc2hpbmdfcG9pbnQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIGdldCBESUZGVVNFIFRFWFRVUkVNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSAqPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmUsdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSAqPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBtYXRlcmlhbC5kaWZmdXNlU2NhbGUueHkpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmRpZmZ1c2UgKj0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwuZGlmZnVzZVNjYWxlKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5kaWZmdXNlICo9IGdldFNwaGVyZU1hcCh1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwsIHVfdmFuaXNoaW5nX3BvaW50KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBnZXQgU1BFQ1VMQVIgVEVYVFVSRU1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyICo9IHRleHR1cmUyRCh1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmUsdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyICo9IGdldFBsYW5hcih1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBtYXRlcmlhbC5zcGVjdWxhclNjYWxlLnh5KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXIgKj0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyU2NhbGUpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5zcGVjdWxhciAqPSBnZXRTcGhlcmVNYXAodV9tYXRlcmlhbF9zcGVjdWxhcl90ZXh0dXJlLCBfZXllVG9Qb2ludCwgX25vcm1hbCwgdV92YW5pc2hpbmdfcG9pbnQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3BvaW50TGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJzdHJ1Y3QgUG9pbnRMaWdodCB7XFxuXCIgK1xuXCIgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwiICAgIHZlYzQgZGlmZnVzZTtcXG5cIiArXG5cIiAgICB2ZWM0IHNwZWN1bGFyO1xcblwiICtcblwiICAgIHZlYzQgcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgZmxvYXQgaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBvdXRlclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBQb2ludExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb21wdXRlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWMzIFZQID0gKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCkgLyBkaXN0O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTm9ybWFsaXplIHRoZSB2ZWN0b3IgZnJvbSBzdXJmYWNlIHRvIGxpZ2h0IHBvc2l0aW9uXFxuXCIgK1xuXCIgICAgZmxvYXQgbkRvdFZQID0gY2xhbXAoZG90KFZQLCBfbm9ybWFsKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXR0ZW51YXRpb24gZGVmYXVsdHNcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZSA9IF9saWdodC5hdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLShwb3coZCxlKSk7XFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZCA9IG1heCgwLjAsZGlzdC1SaW4pL1JpbisxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC8ocG93KGQsZSkpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDAuMDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgUmluID0gX2xpZ2h0LmlubmVyUmFkaXVzO1xcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKG1heCgwLjAsZGlzdC1SaW4pL1JkaWZmLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBodHRwczovL2ltZG9pbmdpdHdyb25nLndvcmRwcmVzcy5jb20vMjAxMS8wMS8zMS9saWdodC1hdHRlbnVhdGlvbi9cXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC9kLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKGRpc3QvX2xpZ2h0Lm91dGVyUmFkaXVzLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbXB1dGVyIGFjY3VtdWxhdG9yc1xcblwiICtcblwiICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKz0gX2xpZ2h0LmFtYmllbnQgKiBhdHRlbnVhdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSArPSBfbGlnaHQuZGlmZnVzZSAqIG5Eb3RWUCAqIGF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgcGYgPSAwLjA7IC8vIHBvd2VyIGZhY3RvciBmb3Igc2hpbnkgc3BlY3VsYXJzXFxuXCIgK1xuXCIgICAgICAgIGlmIChuRG90VlAgPiAwLjApIHtcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgcmVmbGVjdFZlY3RvciA9IHJlZmxlY3QoLVZQLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGV5ZURvdFIgPSBtYXgoMC4wLCBkb3QoLW5vcm1hbGl6ZShfZXllVG9Qb2ludCksIHJlZmxlY3RWZWN0b3IpKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHBmID0gcG93KGV5ZURvdFIsIG1hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciArPSBfbGlnaHQuc3BlY3VsYXIgKiBwZiAqIGF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2ZyYWdtZW50J10gPVxuXCIvLyBGcmFnbWVudCBzaGFkZXIgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHBhc3Nlc1xcblwiICtcblwiLy8gUmVuZGVycyBpbiBzaWxob3VldHRlIGFjY29yZGluZyB0byBzZWxlY3Rpb24gKHBpY2tpbmcpIGNvbG9yLCBvciBibGFjayBpZiBub25lIGRlZmluZWRcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT05cXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT05cXG5cIiArXG5cIiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLiwgMC4sIDAuLCAxLik7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fZ2xvYmFscyddID1cblwiLy8gVmVydGV4IGF0dHJpYnV0ZSArIHZhcnlpbmcgZm9yIGZlYXR1cmUgc2VsZWN0aW9uXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0ZFQVRVUkVfU0VMRUNUSU9OKSAmJiBkZWZpbmVkKFRBTkdSQU1fVkVSVEVYX1NIQURFUilcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjNCBhX3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl92ZXJ0ZXgnXSA9XG5cIi8vIFNlbGVjdGlvbiBwYXNzLXNwZWNpZmljIHJlbmRlcmluZ1xcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTikgJiYgZGVmaW5lZChUQU5HUkFNX1ZFUlRFWF9TSEFERVIpXFxuXCIgK1xuXCIgICAgaWYgKGFfc2VsZWN0aW9uX2NvbG9yLnJnYiA9PSB2ZWMzKDAuKSkge1xcblwiICtcblwiICAgICAgICAvLyBEaXNjYXJkIGJ5IGZvcmNpbmcgaW52YWxpZCB0cmlhbmdsZSBpZiB3ZVxcJ3JlIGluIHRoZSBmZWF0dXJlXFxuXCIgK1xuXCIgICAgICAgIC8vIHNlbGVjdGlvbiBwYXNzIGJ1dCBoYXZlIG5vIHNlbGVjdGlvbiBpbmZvXFxuXCIgK1xuXCIgICAgICAgIC8vIFRPRE86IGluIHNvbWUgY2FzZXMgd2UgbWF5IGFjdHVhbGx5IHdhbnQgbm9uLXNlbGVjdGFibGUgZmVhdHVyZXMgdG8gb2NjbHVkZSBzZWxlY3RhYmxlIG9uZXM/XFxuXCIgK1xuXCIgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgwLiwgMC4sIDAuLCAxLik7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybjtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIgICAgdl9zZWxlY3Rpb25fY29sb3IgPSBhX3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc3BoZXJpY2FsX2Vudmlyb25tZW50X21hcCddID1cblwiLy8gU3BoZXJpY2FsIGVudmlyb25tZW50IG1hcFxcblwiICtcblwiLy8gQmFzZWQgb246IGh0dHA6Ly93d3cuY2xpY2t0b3JlbGVhc2UuY29tL2Jsb2cvY3JlYXRpbmctc3BoZXJpY2FsLWVudmlyb25tZW50LW1hcHBpbmctc2hhZGVyXFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIHZpZXc6IGxvY2F0aW9uIG9mIGNhbWVyYVxcblwiICtcblwiLy8gcG9zaXRpb246IGxvY2F0aW9uIG9mIGN1cnJlbnQgcG9pbnQgb24gc3VyZmFjZVxcblwiICtcblwiLy8gbm9ybWFsOiBub3JtYWwgb2YgY3VycmVudCBwb2ludCBvbiBzdXJmYWNlXFxuXCIgK1xuXCIvLyBza2V3OiBza2V3aW5nIGZhY3RvciAodXNlZCB0byBjb21wZW5zYXRlIGZvciBhbHRlcmVkIHZhbmlzaGluZyBwb2ludClcXG5cIiArXG5cIi8vIGVudm1hcDogc3BoZXJpY2FsIGVudmlyb25tZW50IG1hcCB0ZXh0dXJlXFxuXCIgK1xuXCJcXG5cIiArXG5cInZlYzQgc3BoZXJpY2FsRW52aXJvbm1lbnRNYXAodmVjMyB2aWV3LCB2ZWMzIHBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMiBza2V3LCBzYW1wbGVyMkQgZW52bWFwKSB7XFxuXCIgK1xuXCIgICAgLy8gTm9ybWFsaXplZCB2ZWN0b3IgZnJvbSBjYW1lcmEgdG8gc3VyZmFjZVxcblwiICtcblwiICAgIHZlYzMgZXllID0gbm9ybWFsaXplKHBvc2l0aW9uLnh5eiAtIHZpZXcueHl6KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNrZXdcXG5cIiArXG5cIiAgICBleWUueHkgLT0gc2tldztcXG5cIiArXG5cIiAgICBleWUgPSBub3JtYWxpemUoZXllKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFJlZmxlY3Rpb24gb2YgZXllIG9mZiBvZiBzdXJmYWNlIG5vcm1hbFxcblwiICtcblwiICAgIHZlYzMgciA9IHJlZmxlY3QoZXllLCBub3JtYWwpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTWFwIHJlZmxlY3RlZCB2ZWN0b3Igb250byB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZVxcblwiICtcblwiICAgIHIueiArPSAxLjtcXG5cIiArXG5cIiAgICBmbG9hdCBtID0gMi4gKiBsZW5ndGgocik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBZGp1c3QgeHkgdG8gYWNjb3VudCBmb3Igc3BoZXJpY2FsIHNoYXBlLCBhbmQgY2VudGVyIGluIG1pZGRsZSBvZiB0ZXh0dXJlXFxuXCIgK1xuXCIgICAgdmVjMiB1diA9IHIueHkgLyBtICsgLjU7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTYW1wbGUgdGhlIGVudmlyb25tZW50IG1hcFxcblwiICtcblwiICAgIHJldHVybiB0ZXh0dXJlMkQoZW52bWFwLCB1dik7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zcG90TGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBpbm5lclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IG91dGVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2ZWMzIGRpcmVjdGlvbjtcXG5cIiArXG5cIiAgICBmbG9hdCBzcG90Q29zQ3V0b2ZmO1xcblwiICtcblwiICAgIGZsb2F0IHNwb3RFeHBvbmVudDtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gU3BvdExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb21wdXRlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWMzIFZQID0gKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCkgLyBkaXN0O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gbm9ybWFsIC4gbGlnaHQgZGlyZWN0aW9uXFxuXCIgK1xuXCIgICAgZmxvYXQgbkRvdFZQID0gY2xhbXAoZG90KF9ub3JtYWwsIFZQKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXR0ZW51YXRpb24gZGVmYXVsdHNcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZSA9IF9saWdodC5hdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLShwb3coZCxlKSk7XFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZCA9IG1heCgwLjAsZGlzdC1SaW4pL1JpbisxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC8ocG93KGQsZSkpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDAuMDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgUmluID0gX2xpZ2h0LmlubmVyUmFkaXVzO1xcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKG1heCgwLjAsZGlzdC1SaW4pL1JkaWZmLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBodHRwczovL2ltZG9pbmdpdHdyb25nLndvcmRwcmVzcy5jb20vMjAxMS8wMS8zMS9saWdodC1hdHRlbnVhdGlvbi9cXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC9kLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKGRpc3QvX2xpZ2h0Lm91dGVyUmFkaXVzLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIHNwb3RsaWdodCBhdHRlbnVhdGlvbiBmYWN0b3JcXG5cIiArXG5cIiAgICBmbG9hdCBzcG90QXR0ZW51YXRpb24gPSAwLjA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTZWUgaWYgcG9pbnQgb24gc3VyZmFjZSBpcyBpbnNpZGUgY29uZSBvZiBpbGx1bWluYXRpb25cXG5cIiArXG5cIiAgICBmbG9hdCBzcG90RG90ID0gY2xhbXAoZG90KC1WUCwgbm9ybWFsaXplKF9saWdodC5kaXJlY3Rpb24pKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgaWYgKHNwb3REb3QgPj0gX2xpZ2h0LnNwb3RDb3NDdXRvZmYpIHtcXG5cIiArXG5cIiAgICAgICAgc3BvdEF0dGVudWF0aW9uID0gcG93KHNwb3REb3QsIF9saWdodC5zcG90RXhwb25lbnQpO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKz0gX2xpZ2h0LmFtYmllbnQgKiBhdHRlbnVhdGlvbiAqIHNwb3RBdHRlbnVhdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSArPSBfbGlnaHQuZGlmZnVzZSAqIG5Eb3RWUCAqIGF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgLy8gUG93ZXIgZmFjdG9yIGZvciBzaGlueSBzcGVjdWxhcnNcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgcGYgPSAwLjA7XFxuXCIgK1xuXCIgICAgICAgIGlmIChuRG90VlAgPiAwLjApIHtcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgcmVmbGVjdFZlY3RvciA9IHJlZmxlY3QoLVZQLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGV5ZURvdFIgPSBtYXgoZG90KC1ub3JtYWxpemUoX2V5ZVRvUG9pbnQpLCByZWZsZWN0VmVjdG9yKSwgMC4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHBmID0gcG93KGV5ZURvdFIsIG1hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKz0gX2xpZ2h0LnNwZWN1bGFyICogcGYgKiBhdHRlbnVhdGlvbiAqIHNwb3RBdHRlbnVhdGlvbjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3dvcmxkX3Bvc2l0aW9uX3dyYXAnXSA9XG5cIi8vIERlZmluZSBhIHdyYXAgdmFsdWUgZm9yIHdvcmxkIGNvb3JkaW5hdGVzIChhbGxvd3MgbW9yZSBwcmVjaXNpb24gYXQgaGlnaGVyIHpvb21zKVxcblwiICtcblwiLy8gZS5nLiBhdCB3cmFwIDEwMDAsIHRoZSB3b3JsZCBzcGFjZSB3aWxsIHdyYXAgZXZlcnkgMTAwMCBtZXRlcnNcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUClcXG5cIiArXG5cIiAgICB2ZWMyIHdvcmxkX3Bvc2l0aW9uX2FuY2hvciA9IHZlYzIoZmxvb3IodV90aWxlX29yaWdpbiAvIFRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUCkgKiBUQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ29udmVydCBiYWNrIHRvIGFic29sdXRlIHdvcmxkIHBvc2l0aW9uIGlmIG5lZWRlZFxcblwiICtcblwiICAgIHZlYzQgYWJzb2x1dGVXb3JsZFBvc2l0aW9uICgpIHtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuIHZlYzQodl93b3JsZF9wb3NpdGlvbi54eSArIHdvcmxkX3Bvc2l0aW9uX2FuY2hvciwgdl93b3JsZF9wb3NpdGlvbi56LCB2X3dvcmxkX3Bvc2l0aW9uLncpO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIiNlbHNlXFxuXCIgK1xuXCIgICAgdmVjNCBhYnNvbHV0ZVdvcmxkUG9zaXRpb24gKCkge1xcblwiICtcblwiICAgICAgICByZXR1cm4gdl93b3JsZF9wb3NpdGlvbjtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvcG9pbnRzL3BvaW50c19mcmFnbWVudCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbztcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV90aW1lO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfbWFwX3Bvc2l0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBBbHBoYSBkaXNjYXJkIHRocmVzaG9sZCAoc3Vic3RpdHV0ZSBmb3IgYWxwaGEgYmxlbmRpbmcpXFxuXCIgK1xuXCIjaWZuZGVmIFRBTkdSQU1fQUxQSEFfRElTQ0FSRFxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX0FMUEhBX0RJU0NBUkQgMC41XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gQWxwaGEgZmFkZSByYW5nZSBmb3IgZWRnZXMgb2YgcG9pbnRzXFxuXCIgK1xuXCIjaWZuZGVmIFRBTkdSQU1fRkFERV9SQU5HRVxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX0ZBREVfUkFOR0UgLjE1XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIiNkZWZpbmUgVEFOR1JBTV9GQURFX1NUQVJUICgxLiAtIFRBTkdSQU1fRkFERV9SQU5HRSlcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgdmVjNCBjb2xvciA9IHZfY29sb3I7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBcHBseSBhIHRleHR1cmVcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yICo9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgIC8vIERyYXcgYSBwb2ludFxcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIC8vIEZhZGUgYWxwaGEgbmVhciBjaXJjbGUgZWRnZVxcblwiICtcblwiICAgICAgICB2ZWMyIHV2ID0gdl90ZXhjb29yZCAqIDIuIC0gMS47XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHBvaW50X2Rpc3QgPSBsZW5ndGgodXYpO1xcblwiICtcblwiICAgICAgICBjb2xvci5hID0gY2xhbXAoMS4gLSAoc21vb3Roc3RlcCgwLiwgVEFOR1JBTV9GQURFX1JBTkdFLCAocG9pbnRfZGlzdCAtIFRBTkdSQU1fRkFERV9TVEFSVCkpIC8gVEFOR1JBTV9GQURFX1JBTkdFKSwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIElmIGJsZW5kaW5nIGlzIG9mZiwgdXNlIGFscGhhIGRpc2NhcmQgYXMgYSBsb3dlci1xdWFsaXR5IHN1YnN0aXR1dGVcXG5cIiArXG5cIiAgICAjaWZuZGVmIFRBTkdSQU1fQkxFTkRfT1ZFUkxBWVxcblwiICtcblwiICAgICAgICBpZiAoY29sb3IuYSA8IFRBTkdSQU1fQUxQSEFfRElTQ0FSRCkge1xcblwiICtcblwiICAgICAgICAgICAgZGlzY2FyZDtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBjb2xvclxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogZmlsdGVyXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvcG9pbnRzL3BvaW50c192ZXJ0ZXgnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3O1xcblwiICtcblwiXFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9zaGFwZTtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMiBhX3RleGNvb3JkO1xcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fT1JERVJfQVRUUklCVVRFXFxuXCIgK1xuXCIgICAgYXR0cmlidXRlIGZsb2F0IGFfbGF5ZXI7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidmVjMiByb3RhdGUyRCh2ZWMyIF9zdCwgZmxvYXQgX2FuZ2xlKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIG1hdDIoY29zKF9hbmdsZSksLXNpbihfYW5nbGUpLFxcblwiICtcblwiICAgICAgICAgICAgICAgIHNpbihfYW5nbGUpLGNvcyhfYW5nbGUpKSAqIF9zdDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluKCkge1xcblwiICtcblwiICAgIC8vIEFkZHMgdmVydGV4IHNoYWRlciBzdXBwb3J0IGZvciBmZWF0dXJlIHNlbGVjdGlvblxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogZmVhdHVyZS1zZWxlY3Rpb24tdmVydGV4XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIiAgICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFwcGx5IHNjYWxpbmcgaW4gc2NyZWVuIHNwYWNlXFxuXCIgK1xuXCIgICAgdmVjNCBzaGFwZSA9IGFfc2hhcGU7XFxuXCIgK1xuXCIgICAgZmxvYXQgenNjYWxlID0gZnJhY3QodV9tYXBfcG9zaXRpb24ueikgKiAoc2hhcGUudyAqIDI1Ni4gLSAxLikgKyAxLjtcXG5cIiArXG5cIiAgICAvLyBmbG9hdCB6c2NhbGUgPSBsb2coZnJhY3QodV9tYXBfcG9zaXRpb24ueikgKyAxLikgLyBsb2coMi4pICogKHNoYXBlLncgLSAxLikgKyAxLjtcXG5cIiArXG5cIiAgICB2ZWMyIHNoYXBlX29mZnNldCA9IHNoYXBlLnh5ICogMjU2LiAqIHpzY2FsZTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFBvc2l0aW9uXFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbiA9IHVfbW9kZWxWaWV3ICogdmVjNChhX3Bvc2l0aW9uLCAxLik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBXb3JsZCBjb29yZGluYXRlcyBmb3IgM2QgcHJvY2VkdXJhbCB0ZXh0dXJlc1xcblwiICtcblwiICAgIHZfd29ybGRfcG9zaXRpb24gPSB1X21vZGVsICogdmVjNChhX3Bvc2l0aW9uLCAxLik7XFxuXCIgK1xuXCIgICAgdl93b3JsZF9wb3NpdGlvbi54eSArPSBzaGFwZV9vZmZzZXQgKiB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKVxcblwiICtcblwiICAgICAgICB2X3dvcmxkX3Bvc2l0aW9uLnh5IC09IHdvcmxkX3Bvc2l0aW9uX2FuY2hvcjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBwb3NpdGlvbiBiZWZvcmUgY2FtZXJhIHByb2plY3Rpb25cXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IHBvc2l0aW9uXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBjYW1lcmFQcm9qZWN0aW9uKHBvc2l0aW9uKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX09SREVSX0FUVFJJQlVURVxcblwiICtcblwiICAgICAgICBhcHBseUxheWVyT3JkZXIoYV9sYXllciwgcG9zaXRpb24pO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgcG9zaXRpb24ueHkgKz0gcm90YXRlMkQoc2hhcGVfb2Zmc2V0LCByYWRpYW5zKHNoYXBlLnogKiAzNjAuKSkgKiAyLiAqIHBvc2l0aW9uLncgLyB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc19mcmFnbWVudCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbztcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV90aW1lO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfbWFwX3Bvc2l0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3Bvc2l0aW9uO1xcblwiICtcblwidmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl93b3JsZF9wb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fVEVYVFVSRV9DT09SRFNcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9saWdodGluZztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBtYXRlcmlhbFxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBsaWdodGluZ1xcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgdmVjNCBjb2xvciA9IHZfY29sb3I7XFxuXCIgK1xuXCIgICAgdmVjMyBub3JtYWwgPSB2X25vcm1hbDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgIGNhbGN1bGF0ZU5vcm1hbChub3JtYWwpO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTW9kaWZ5IG5vcm1hbCBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IG5vcm1hbFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTW9kaWZ5IGNvbG9yIGFuZCBtYXRlcmlhbCBwcm9wZXJ0aWVzIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICNpZiAhZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX0ZSQUdNRU5UKVxcblwiICtcblwiICAgICAgICBjb2xvciA9IGNhbGN1bGF0ZUxpZ2h0aW5nKHZfcG9zaXRpb24ueHl6IC0gdV9leWUsIG5vcm1hbCwgY29sb3IpO1xcblwiICtcblwiICAgICNlbGlmIGRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yID0gdl9saWdodGluZztcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBjb2xvciBhZnRlciBsaWdodGluZyAoZmlsdGVyLWxpa2UgZWZmZWN0cyB0aGF0IGRvblxcJ3QgcmVxdWlyZSBhIGFkZGl0aW9uYWwgcmVuZGVyIHBhc3NlcylcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGZpbHRlclxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvbHlnb25zL3BvbHlnb25zX3ZlcnRleCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV90aW1lO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfbWFwX3Bvc2l0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwiXFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5cIiArXG5cImF0dHJpYnV0ZSBmbG9hdCBhX2xheWVyO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbCBub3JtYWwgYXR0cmlidXRlLCBvdGhlcndpc2UgZGVmYXVsdCB0byB1cFxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTk9STUFMX0FUVFJJQlVURVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcblwiICtcblwiICAgICNkZWZpbmUgVEFOR1JBTV9OT1JNQUwgYV9ub3JtYWxcXG5cIiArXG5cIiNlbHNlXFxuXCIgK1xuXCIgICAgI2RlZmluZSBUQU5HUkFNX05PUk1BTCB2ZWMzKDAuLCAwLiwgMS4pXFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gT3B0aW9uYWwgZHluYW1pYyBsaW5lIGV4dHJ1c2lvblxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fRVhUUlVERV9MSU5FU1xcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMzIGFfZXh0cnVkZTtcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgZmxvYXQgYV9zY2FsZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9wb3NpdGlvbjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIE9wdGlvbmFsIHRleHR1cmUgVVZzXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9URVhUVVJFX0NPT1JEU1xcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWM0IHZfbGlnaHRpbmc7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBjYW1lcmFcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbWF0ZXJpYWxcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogbGlnaHRpbmdcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogZ2xvYmFsXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbigpIHtcXG5cIiArXG5cIiAgICAvLyBBZGRzIHZlcnRleCBzaGFkZXIgc3VwcG9ydCBmb3IgZmVhdHVyZSBzZWxlY3Rpb25cXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGZlYXR1cmUtc2VsZWN0aW9uLXZlcnRleFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gVGV4dHVyZSBVVnNcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9URVhUVVJFX0NPT1JEU1xcblwiICtcblwiICAgICAgICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFBvc2l0aW9uXFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fRVhUUlVERV9MSU5FU1xcblwiICtcblwiICAgICAgICB2ZWMyIGV4dHJ1ZGUgPSBhX2V4dHJ1ZGUueHk7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHdpZHRoID0gYV9leHRydWRlLno7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gS2VlcCBsaW5lIHdpZHRoIGNvbnN0YW50IGluIHNjcmVlbi1zcGFjZVxcblwiICtcblwiICAgICAgICBmbG9hdCB6c2NhbGUgPSB1X3RpbGVfb3JpZ2luLnogLSB1X21hcF9wb3NpdGlvbi56O1xcblwiICtcblwiICAgICAgICB3aWR0aCAqPSBwb3coMi4sIHpzY2FsZSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gU21vb3RobHkgaW50ZXJwb2xhdGUgbGluZSB3aWR0aCBiZXR3ZWVuIHpvb21zXFxuXCIgK1xuXCIgICAgICAgIHdpZHRoID0gbWl4KHdpZHRoLCB3aWR0aCAqIGFfc2NhbGUgKiAyNTYuLCAtenNjYWxlKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNb2RpZnkgbGluZSB3aWR0aCBiZWZvcmUgZXh0cnVzaW9uXFxuXCIgK1xuXCIgICAgICAgICNwcmFnbWEgdGFuZ3JhbTogd2lkdGhcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICBwb3NpdGlvbi54eSArPSBleHRydWRlICogd2lkdGg7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBXb3JsZCBjb29yZGluYXRlcyBmb3IgM2QgcHJvY2VkdXJhbCB0ZXh0dXJlc1xcblwiICtcblwiICAgIHZfd29ybGRfcG9zaXRpb24gPSB1X21vZGVsICogcG9zaXRpb247XFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKVxcblwiICtcblwiICAgICAgICB2X3dvcmxkX3Bvc2l0aW9uLnh5IC09IHdvcmxkX3Bvc2l0aW9uX2FuY2hvcjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFkanVzdCBmb3IgdGlsZSBhbmQgdmlldyBwb3NpdGlvblxcblwiICtcblwiICAgIHBvc2l0aW9uID0gdV9tb2RlbFZpZXcgKiBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBwb3NpdGlvbiBiZWZvcmUgY2FtZXJhIHByb2plY3Rpb25cXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IHBvc2l0aW9uXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTZXR1cCB2YXJ5aW5nc1xcblwiICtcblwiICAgIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIiAgICB2X25vcm1hbCA9IG5vcm1hbGl6ZSh1X25vcm1hbE1hdHJpeCAqIFRBTkdSQU1fTk9STUFMKTtcXG5cIiArXG5cIiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFZlcnRleCBsaWdodGluZ1xcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICAgICB2ZWM0IGNvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBub3JtYWwgPSBUQU5HUkFNX05PUk1BTDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNb2RpZnkgbm9ybWFsIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICAgICAjcHJhZ21hIHRhbmdyYW06IG5vcm1hbFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIE1vZGlmeSBjb2xvciBhbmQgbWF0ZXJpYWwgcHJvcGVydGllcyBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAgICAgI3ByYWdtYSB0YW5ncmFtOiBjb2xvclxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZfbGlnaHRpbmcgPSBjYWxjdWxhdGVMaWdodGluZyhwb3NpdGlvbi54eXosIG5vcm1hbCwgY29sb3IpO1xcblwiICtcblwiICAgICAgICB2X2NvbG9yID0gY29sb3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDYW1lcmFcXG5cIiArXG5cIiAgICBjYW1lcmFQcm9qZWN0aW9uKHBvc2l0aW9uKTtcXG5cIiArXG5cIiAgICBhcHBseUxheWVyT3JkZXIoYV9sYXllciwgcG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWRlclNvdXJjZXM7XG4iLCIvKmdsb2JhbCBUZXh0dXJlICovXG4vLyBUZXh0dXJlIG1hbmFnZW1lbnRcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgc3Vic2NyaWJlTWl4aW4gZnJvbSAnLi4vdXRpbHMvc3Vic2NyaWJlJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vc3R5bGVzL2J1aWxkZXJzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vLyBHTCB0ZXh0dXJlIHdyYXBwZXIgb2JqZWN0IGZvciBrZWVwaW5nIHRyYWNrIG9mIGEgZ2xvYmFsIHNldCBvZiB0ZXh0dXJlcywga2V5ZWQgYnkgYSB1bmlxdWUgdXNlci1kZWZpbmVkIG5hbWVcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsOyAgICAgIC8vIGFuIEltYWdlIG9iamVjdC9lbGVtZW50IHRoYXQgaXMgdGhlIHNvdXJjZSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDsgICAgIC8vIGEgQ2FudmFzIG9iamVjdC9lbGVtZW50IHRoYXQgaXMgdGhlIHNvdXJjZSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7ICAgIC8vIGEgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhpcyB0ZXh0dXJlXG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBhIDEtcGl4ZWwgYmxhY2sgdGV4dHVyZSBzbyB3ZSBjYW4gc2FmZWx5IHJlbmRlciB3aGlsZSB3ZSB3YWl0IGZvciBhbiBpbWFnZSB0byBsb2FkXG4gICAgICAgIC8vIFNlZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMjI0Ny93ZWJnbC13YWl0LWZvci10ZXh0dXJlLXRvLWxvYWRcbiAgICAgICAgdGhpcy5zZXREYXRhKDEsIDEsIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAyNTVdKSwgeyBmaWx0ZXJpbmc6ICduZWFyZXN0JyB9KTtcblxuICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igbm9uLVVSTCBzb3VyY2VzOiBjYW52YXMvdmlkZW8gZWxlbWVudHMsIHJhdyBwaXhlbCBidWZmZXJzXG5cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSBvcHRpb25zLmZpbHRlcmluZztcblxuICAgICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHRleHR1cmUgaWYgcHJlc2VudFxuICAgICAgICBpZiAoVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdKSB7XG4gICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdID0gdGhpcztcblxuICAgICAgICB0aGlzLnNwcml0ZXMgPSBvcHRpb25zLnNwcml0ZXM7XG4gICAgICAgIHRoaXMudGV4Y29vcmRzID0ge307XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSBhIHNpbmdsZSB0ZXh0dXJlIGluc3RhbmNlXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV07XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBiaW5kKHVuaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1bml0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB1bmJpbmQoKSB7XG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICB9XG5cbiAgICAvLyBMb2FkcyBhIHRleHR1cmUgZnJvbSBhIFVSTFxuICAgIGxvYWQodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVGV4dHVyZS5iYXNlX3VybCkge1xuICAgICAgICAgICAgdXJsID0gVXRpbHMuYWRkQmFzZVVSTCh1cmwsIFRleHR1cmUuYmFzZV91cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0dXJlRmlsdGVyaW5nKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlU3ByaXRlcygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsOyAvLyBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBvdGhlciB0eXBlc1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gdXJsO1xuICAgICAgICAgICAgLy8gVE9ETzogZXJyb3IvcHJvbWlzZSByZWplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmc7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0ZXh0dXJlIHRvIGEgcmF3IGltYWdlIGJ1ZmZlclxuICAgIHNldERhdGEod2lkdGgsIGhlaWdodCwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IG51bGw7IC8vIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIG90aGVyIHR5cGVzXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcblxuICAgICAgICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlRmlsdGVyaW5nKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIFNldHMgdGhlIHRleHR1cmUgdG8gdHJhY2sgYSBjYW52YXMgZWxlbWVudFxuICAgIHNldENhbnZhcyhjYW52YXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMudXBkYXRlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldFRleHR1cmVGaWx0ZXJpbmcob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IG51bGw7IC8vIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIG90aGVyIHR5cGVzXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVXBsb2FkcyBjdXJyZW50IGltYWdlIG9yIGJ1ZmZlciB0byB0aGUgR1BVIChjYW4gYmUgdXNlZCB0byB1cGRhdGUgYW5pbWF0ZWQgdGV4dHVyZXMgb24gdGhlIGZseSlcbiAgICB1cGRhdGUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCAob3B0aW9ucy5VTlBBQ0tfRkxJUF9ZX1dFQkdMID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSkpO1xuICAgICAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBvcHRpb25zLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCB8fCBmYWxzZSk7XG5cbiAgICAgICAgLy8gSW1hZ2UgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5pbWFnZSAmJiB0aGlzLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5pbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCB0aGlzLmltYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW52YXMgZWxlbWVudFxuICAgICAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCB0aGlzLmNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmF3IGltYWdlIGJ1ZmZlclxuICAgICAgICBlbHNlIGlmICh0aGlzLndpZHRoICYmIHRoaXMuaGVpZ2h0KSB7IC8vIE5PVEU6IHRoaXMuZGF0YSBjYW4gYmUgbnVsbCwgdG8gemVybyBvdXQgdGV4dHVyZVxuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBUZXh0dXJlLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZXMgYXBwcm9wcmlhdGUgZmlsdGVyaW5nIG1vZGVcbiAgICBzZXRUZXh0dXJlRmlsdGVyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyaW5nID0gb3B0aW9ucy5maWx0ZXJpbmcgfHwgdGhpcy5maWx0ZXJpbmcgfHwgJ2xpbmVhcic7IC8vIGRlZmF1bHQgdG8gbWlwbWFwcyBmb3IgcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuXG4gICAgICAgIC8vIEZvciBwb3dlci1vZi0yIHRleHR1cmVzLCB0aGUgZm9sbG93aW5nIHByZXNldHMgYXJlIGF2YWlsYWJsZTpcbiAgICAgICAgLy8gbWlwbWFwOiBsaW5lYXIgYmxlbmQgZnJvbSBuZWFyZXN0IG1pcFxuICAgICAgICAvLyBsaW5lYXI6IGxpbmVhciBibGVuZCBmcm9tIG9yaWdpbmFsIGltYWdlIChubyBtaXBzKVxuICAgICAgICAvLyBuZWFyZXN0OiBuZWFyZXN0IHBpeGVsIGZyb20gb3JpZ2luYWwgaW1hZ2UgKG5vIG1pcHMsICdibG9ja3knIGxvb2spXG4gICAgICAgIGlmIChVdGlscy5pc1Bvd2VyT2YyKHRoaXMud2lkdGgpICYmIFV0aWxzLmlzUG93ZXJPZjIodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLnBvd2VyX29mXzIgPSB0cnVlO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgb3B0aW9ucy5URVhUVVJFX1dSQVBfUyB8fCAob3B0aW9ucy5yZXBlYXQgJiYgZ2wuUkVQRUFUKSB8fCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgICAgIC8vIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1MgfHwgZ2wuUkVQRUFUKTtcbiAgICAgICAgICAgIC8vIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgZ2wuUkVQRUFUKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbWlwbWFwJykge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBNSVBNQVAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdtaXBtYXAnO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7IC8vIFRPRE86IHVzZSB0cmlsaW5lYXIgZmlsdGVyaW5nIGJ5IGRlZnVhbHQgaW5zdGVhZD9cbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBMSU5FQVInKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5maWx0ZXJpbmcgPT09ICduZWFyZXN0Jykge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBORUFSRVNUJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbmVhcmVzdCc7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIGhhcyBzdHJpY3QgcmVxdWlyZW1lbnRzIG9uIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzOlxuICAgICAgICAgICAgLy8gTm8gbWlwbWFwcyBhbmQgbXVzdCBjbGFtcCB0byBlZGdlXG4gICAgICAgICAgICB0aGlzLnBvd2VyX29mXzIgPSBmYWxzZTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIE5FQVJFU1QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICduZWFyZXN0JztcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIGRlZmF1bHQgdG8gbGluZWFyIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBMSU5FQVInKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBQcmUtY2FsYyBzcHJpdGUgcmVnaW9ucyBmb3IgYSB0ZXh0dXJlIHNwcml0ZSBpbiBVViBbMCwgMV0gc3BhY2VcbiAgICBjYWxjdWxhdGVTcHJpdGVzKCkge1xuICAgICAgICBpZiAodGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbc107XG5cbiAgICAgICAgICAgICAgICAvLyBNYXAgWzAsIDBdIHRvIFsxLCAxXSBjb29yZHMgdG8gdGhlIGFwcHJvcHJpYXRlIHNwcml0ZSBzdWItYXJlYSBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIHRoaXMudGV4Y29vcmRzW3NdID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzBdLCBzcHJpdGVbMV1dLFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzJdLCBzcHJpdGVbM11dLFxuICAgICAgICAgICAgICAgICAgICBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbi8vIFN0YXRpYy9jbGFzcyBtZXRob2RzIGFuZCBzdGF0ZVxuXG4vLyBEZXN0cm95IGFsbCB0ZXh0dXJlIGluc3RhbmNlcyBmb3IgYSBnaXZlbiBHTCBjb250ZXh0XG5UZXh0dXJlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSBPYmplY3Qua2V5cyhUZXh0dXJlLnRleHR1cmVzKTtcbiAgICBmb3IgKHZhciB0IG9mIHRleHR1cmVzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcbiAgICAgICAgaWYgKHRleHR1cmUuZ2wgPT09IGdsKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYGRlc3Ryb3lpbmcgVGV4dHVyZSAke3RleHR1cmUubmFtZX1gKTtcbiAgICAgICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gR2V0IHNwcml0ZSBzdWItYXJlYSB0byB1c2UgZm9yIHRleHR1cmUgY29vcmRpbmF0ZXMgKGRlZmF1bHQgaXMgWzAsIDFdKVxuVGV4dHVyZS5nZXRTcHJpdGVUZXhjb29yZHMgPSBmdW5jdGlvbiAodGV4bmFtZSwgc3ByaXRlKSB7XG4gICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RleG5hbWVdO1xuICAgIHJldHVybiB0ZXh0dXJlICYmIHRleHR1cmUudGV4Y29vcmRzW3Nwcml0ZV07XG59O1xuXG4vLyBDcmVhdGUgYSBzZXQgb2YgdGV4dHVyZXMga2V5ZWQgaW4gYW4gb2JqZWN0XG4vLyBPcHRpb25hbGx5IGxvYWQgZWFjaCBpZiBpdCBoYXMgYSBVUkwgc3BlY2lmaWVkXG5UZXh0dXJlLmNyZWF0ZUZyb21PYmplY3QgPSBmdW5jdGlvbiAoZ2wsIHRleHR1cmVzKSB7XG4gICAgbGV0IGxvYWRpbmcgPSBbXTtcbiAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgZm9yIChsZXQgdGV4bmFtZSBpbiB0ZXh0dXJlcykge1xuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHRleHR1cmVzW3RleG5hbWVdO1xuICAgICAgICAgICAgaWYgKCFUZXh0dXJlLnRleHR1cmVzW3RleG5hbWVdKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCwgdGV4bmFtZSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnVybCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnB1c2godGV4dHVyZS5sb2FkKGNvbmZpZy51cmwsIGNvbmZpZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZyk7XG59O1xuXG4vLyBHZXQgbWV0YWRhdGEgZm9yIGEgdGV4dHVyZSBieSBuYW1lXG4vLyBSZXR1cm5zIHZpYSBwcm9taXNlLCBpbiBjYXNlIHRleHR1cmUgaXMgc3RpbGwgbG9hZGluZ1xuLy8gQ2FuIGJlIGNhbGxlZCBvbiBtYWluIHRocmVhZCBmcm9tIHdvcmtlciwgdG8gc3luYyB0ZXh0dXJlIGluZm8gdG8gd29ya2VyXG5UZXh0dXJlLmdldEluZm8gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIEdldCBpbmZvIGZvciBhbGwgdGV4dHVyZXMgYnkgZGVmYXVsdFxuICAgIGlmICghbmFtZSkge1xuICAgICAgICBuYW1lID0gT2JqZWN0LmtleXMoVGV4dHVyZS50ZXh0dXJlcyk7XG4gICAgfVxuXG4gICAgLy8gR2V0IG11bHRpcGxlIHRleHR1cmVzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG5hbWUubWFwKG4gPT4gVGV4dHVyZS5nZXRJbmZvKG4pKSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNpbmdsZSB0ZXh0dXJlXG4gICAgdmFyIHRleCA9IFRleHR1cmUudGV4dHVyZXNbbmFtZV07XG4gICAgaWYgKHRleCkge1xuICAgICAgICAvLyBXYWl0IGZvciB0aGlzIHRleHR1cmUgdG8gZmluaXNoIGxvYWRpbmcsIG9yIHJldHVybiBpbW1lZGlhdGVseVxuICAgICAgICB2YXIgbG9hZGluZyA9IHRleC5sb2FkaW5nIHx8IFByb21pc2UucmVzb2x2ZSh0ZXgpO1xuICAgICAgICByZXR1cm4gbG9hZGluZy50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhIHN1YnNldCBvZiB0ZXh0dXJlIGluZm9cbiAgICAgICAgICAgIC8vIChjb21wYXRpYmxlIHcvc3RydWN0dXJlZCBjbG9uaW5nLCBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhIHdvcmtlcilcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGV4Lm5hbWUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRleC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgc3ByaXRlczogdGV4LnNwcml0ZXMsXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRzOiB0ZXgudGV4Y29vcmRzLFxuICAgICAgICAgICAgICAgIGZpbHRlcmluZzogdGV4LmZpbHRlcmluZyxcbiAgICAgICAgICAgICAgICBwb3dlcl9vZl8yOiB0ZXgucG93ZXJfb2ZfMixcbiAgICAgICAgICAgICAgICB2YWxpZDogdGV4LnZhbGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHRleHR1cmUgZm91bmRcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG59O1xuXG4vLyBTeW5jIHRleHR1cmUgaW5mbyB0byB3b3JrZXJcbi8vIENhbGxlZCBmcm9tIHdvcmtlciwgZ2V0cyBpbmZvIG9uIG9uZSBvciBtb3JlIHRleHR1cmVzIGluZm8gZnJvbSBtYWluIHRocmVhZCB2aWEgcmVtb3RlIGNhbGwsIHRoZW4gc3RvcmVzIGl0XG4vLyBsb2NhbGx5IGluIHdvcmtlci4gJ3RleHR1cmVzJyBjYW4gYmUgYW4gYXJyYXkgb2YgdGV4dHVyZSBuYW1lcyB0byBzeW5jLCBvciBpZiBudWxsLCBhbGwgdGV4dHVyZXMgYXJlIHN5bmNlZC5cblRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIgPSBmdW5jdGlvbiAobmFtZXMpIHtcbiAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKCdUZXh0dXJlJywgJ2dldEluZm8nLCBuYW1lcykuXG4gICAgICAgIHRoZW4odGV4dHVyZXMgPT4ge1xuICAgICAgICAgICAgZm9yICh2YXIgdGV4IG9mIHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgVGV4dHVyZS50ZXh0dXJlc1t0ZXgubmFtZV0gPSB0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS50ZXh0dXJlcztcbiAgICAgICAgfSk7XG59O1xuXG4vLyBHbG9iYWwgc2V0IG9mIHRleHR1cmVzLCBieSBuYW1lXG5UZXh0dXJlLnRleHR1cmVzID0ge307XG5cblRleHR1cmUuYmFzZV91cmwgPSBudWxsOyAvLyBvcHRpb25hbCBiYXNlIFVSTCB0byBhZGQgdG8gdGV4dHVyZXNcblxuc3Vic2NyaWJlTWl4aW4oVGV4dHVyZSk7XG4iLCIvLyBDcmVhdGVzIGEgVmVydGV4IEFycmF5IE9iamVjdCBpZiB0aGUgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayBvbiBzdGFuZGFyZCBhdHRyaWJ1dGUgY2FsbHNcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbnZhciBWZXJ0ZXhBcnJheU9iamVjdDtcbmV4cG9ydCBkZWZhdWx0IFZlcnRleEFycmF5T2JqZWN0ID0ge307XG5cblZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkID0gZmFsc2U7IC8vIHNldCB0byB0cnVlIHRvIGRpc2FibGUgVkFPcyBldmVuIGlmIGV4dGVuc2lvbiBpcyBhdmFpbGFibGVcblZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IG51bGw7IC8vIGN1cnJlbnRseSBib3VuZCBWQU9cblxuVmVydGV4QXJyYXlPYmplY3QuaW5pdCA9IGZ1bmN0aW9uIChnbCkge1xuICAgIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5leHQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoVmVydGV4QXJyYXlPYmplY3QuZGlzYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmV4dCA9IGdsLmdldEV4dGVuc2lvbihcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFZlcnRleEFycmF5T2JqZWN0LmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2cuaW5mbygnVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVmVydGV4QXJyYXlPYmplY3QuZGlzYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKCdWZXJ0ZXggQXJyYXkgT2JqZWN0IGV4dGVuc2lvbiBOT1QgYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cud2FybignVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gZm9yY2UgZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChzZXR1cCwgdGVhcmRvd24pIHtcbiAgICBsZXQgdmFvID0ge307XG4gICAgdmFvLnNldHVwID0gc2V0dXA7XG4gICAgdmFvLnRlYXJkb3duID0gdGVhcmRvd247XG5cbiAgICBsZXQgZXh0ID0gVmVydGV4QXJyYXlPYmplY3QuZXh0O1xuICAgIGlmIChleHQgIT0gbnVsbCkge1xuICAgICAgICB2YW8uX3ZhbyA9IGV4dC5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHZhby5fdmFvKTtcbiAgICAgICAgdmFvLnNldHVwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YW8uc2V0dXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFvO1xufTtcblxuVmVydGV4QXJyYXlPYmplY3QuYmluZCA9IGZ1bmN0aW9uICh2YW8pIHtcbiAgICBsZXQgZXh0ID0gVmVydGV4QXJyYXlPYmplY3QuZXh0O1xuICAgIGlmICh2YW8gIT0gbnVsbCkge1xuICAgICAgICBpZiAoZXh0ICE9IG51bGwgJiYgdmFvLl92YW8gIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8uX3Zhbyk7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gPSB2YW87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YW8uc2V0dXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyAhPSBudWxsICYmIHR5cGVvZiBWZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8udGVhcmRvd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3Zhby50ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IG51bGw7XG4gICAgfVxufTtcbiIsIi8qIGdsb2JhbCBWQk9NZXNoICovXG4vLyBNYW5hZ2UgcmVuZGVyaW5nIGZvciBwcmltaXRpdmVzXG5pbXBvcnQgR0xTTCBmcm9tICcuL2dsc2wnO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL3RleHR1cmUnO1xuaW1wb3J0IFZlcnRleEFycmF5T2JqZWN0IGZyb20gJy4vdmFvJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vLyBBIHNpbmdsZSBtZXNoL1ZCTywgZGVzY3JpYmVkIGJ5IGEgdmVydGV4IGxheW91dCwgdGhhdCBjYW4gYmUgZHJhd24gd2l0aCBvbmUgb3IgbW9yZSBwcm9ncmFtc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVkJPTWVzaCAge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfbGF5b3V0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfZGF0YSA9IHZlcnRleF9kYXRhOyAvLyB0eXBlZCBhcnJheVxuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSB2ZXJ0ZXhfbGF5b3V0O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuZHJhd19tb2RlID0gb3B0aW9ucy5kcmF3X21vZGUgfHwgdGhpcy5nbC5UUklBTkdMRVM7XG4gICAgICAgIHRoaXMuZGF0YV91c2FnZSA9IG9wdGlvbnMuZGF0YV91c2FnZSB8fCB0aGlzLmdsLlNUQVRJQ19EUkFXO1xuICAgICAgICB0aGlzLnZlcnRpY2VzX3Blcl9nZW9tZXRyeSA9IDM7IC8vIFRPRE86IHN1cHBvcnQgbGluZXMsIHN0cmlwLCBmYW4sIGV0Yy5cbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXM7XG4gICAgICAgIHRoaXMucmV0YWluID0gb3B0aW9ucy5yZXRhaW4gfHwgZmFsc2U7IC8vIHdoZXRoZXIgdG8gcmV0YWluIG1lc2ggZGF0YSBpbiBDUFUgYWZ0ZXIgdXBsb2FkaW5nIHRvIEdQVVxuXG4gICAgICAgIHRoaXMudmVydGV4X2NvdW50ID0gdGhpcy52ZXJ0ZXhfZGF0YS5ieXRlTGVuZ3RoIC8gdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZTtcbiAgICAgICAgdGhpcy5nZW9tZXRyeV9jb3VudCA9IHRoaXMudmVydGV4X2NvdW50IC8gdGhpcy52ZXJ0aWNlc19wZXJfZ2VvbWV0cnk7XG4gICAgICAgIHRoaXMudmFvcyA9IG5ldyBNYXAoKTsgLy8gbWFwIG9mIFZlcnRleEFycmF5T2JqZWN0cywga2V5ZWQgYnkgcHJvZ3JhbVxuXG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4X2RhdGEsIHRoaXMuZGF0YV91c2FnZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnJldGFpbikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudmVydGV4X2RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyLCBieSBkZWZhdWx0IHdpdGggY3VycmVudGx5IGJvdW5kIHByb2dyYW0sIG9yIG90aGVyd2lzZSB3aXRoIG9wdGlvbmFsbHkgcHJvdmlkZWQgb25lXG4gICAgcmVuZGVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fcmVuZGVyX3NldHVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJfc2V0dXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9ncmFtID0gb3B0aW9ucy5wcm9ncmFtIHx8IFNoYWRlclByb2dyYW0uY3VycmVudDtcbiAgICAgICAgcHJvZ3JhbS51c2UoKTtcblxuICAgICAgICBpZiAodGhpcy51bmlmb3Jtcykge1xuICAgICAgICAgICAgcHJvZ3JhbS5zYXZlVW5pZm9ybXModGhpcy51bmlmb3Jtcyk7XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1zKHRoaXMudW5pZm9ybXMsIGZhbHNlKTsgLy8gZG9uJ3QgcmVzZXQgdGV4dHVyZSB1bml0XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJpbmQocHJvZ3JhbSk7XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBlbGVtZW50IGFycmF5IG1vZGVcbiAgICAgICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZHJhd19tb2RlLCAwLCB0aGlzLnZlcnRleF9jb3VudCk7XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJpbmQobnVsbCk7XG5cbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHByb2dyYW0ucmVzdG9yZVVuaWZvcm1zKHRoaXMudW5pZm9ybXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQmluZCBidWZmZXJzIGFuZCB2ZXJ0ZXggYXR0cmlidXRlcyB0byBwcmVwYXJlIGZvciByZW5kZXJpbmdcbiAgICBiaW5kKHByb2dyYW0pIHtcbiAgICAgICAgLy8gQmluZCBWQU8gZm9yIHRoaXMgcHJvZ2FtLCBvciBjcmVhdGUgb25lXG4gICAgICAgIGxldCB2YW8gPSB0aGlzLnZhb3MuZ2V0KHByb2dyYW0pO1xuICAgICAgICBpZiAodmFvKSB7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5iaW5kKHZhbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhb3Muc2V0KHByb2dyYW0sIFZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0LmVuYWJsZSh0aGlzLmdsLCBwcm9ncmFtKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcblxuICAgICAgICBsb2cudHJhY2UoJ1ZCT01lc2guZGVzdHJveTogZGVsZXRlIGJ1ZmZlcicgKyAodGhpcy52ZXJ0ZXhfZGF0YSA/IGAgb2Ygc2l6ZSAke3RoaXMudmVydGV4X2RhdGEuYnl0ZUxlbmd0aH1gIDogJycpKTtcblxuICAgICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHRoaXMudmVydGV4X2RhdGE7XG5cbiAgICAgICAgLy8gRnJlZSB0ZXh0dXJlIHVuaWZvcm1zIHRoYXQgYXJlIG93bmVkIGJ5IHRoaXMgbWVzaFxuICAgICAgICBmb3IgKGxldCB7dHlwZSwgdmFsdWV9IG9mIEdMU0wucGFyc2VVbmlmb3Jtcyh0aGlzLnVuaWZvcm1zKSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzYW1wbGVyMkQnICYmIFRleHR1cmUudGV4dHVyZXNbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgVGV4dHVyZS50ZXh0dXJlc1t2YWx1ZV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG4iLCIvKiBnbG9iYWwgVmVydGV4RGF0YSAqL1xuXG5pbXBvcnQgZ2wgZnJvbSAnLi9jb25zdGFudHMnOyAvLyB3ZWIgd29ya2VycyBkb24ndCBoYXZlIGFjY2VzcyB0byBHTCBjb250ZXh0LCBzbyBpbXBvcnQgYWxsIEdMIGNvbnN0YW50c1xuaW1wb3J0IHtsb2d9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcblxuLy8gTWFwcyBHTCB0eXBlcyB0byBKUyBhcnJheSB0eXBlc1xubGV0IGFycmF5X3R5cGVzID0ge1xuICAgIFtnbC5GTE9BVF06IEZsb2F0MzJBcnJheSxcbiAgICBbZ2wuQllURV06IEludDhBcnJheSxcbiAgICBbZ2wuVU5TSUdORURfQllURV06IFVpbnQ4QXJyYXksXG4gICAgW2dsLklOVF06IEludDMyQXJyYXksXG4gICAgW2dsLlVOU0lHTkVEX0lOVF06IFVpbnQzMkFycmF5LFxuICAgIFtnbC5TSE9SVF06IEludDE2QXJyYXksXG4gICAgW2dsLlVOU0lHTkVEX1NIT1JUXTogVWludDE2QXJyYXlcbn07XG5cbi8vIEFuIGludGVybWVkaWFyeSBvYmplY3QgdGhhdCBob2xkcyB2ZXJ0ZXggZGF0YSBpbiB0eXBlZCBhcnJheXMsIGFjY29yZGluZyB0byBhIGdpdmVuIHZlcnRleCBsYXlvdXRcbi8vIFVzZWQgdG8gY29uc3RydWN0IGEgbWVzaC9WQk8gZm9yIHJlbmRlcmluZ1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydGV4RGF0YSB7XG5cbiAgICBjb25zdHJ1Y3RvciAodmVydGV4X2xheW91dCwgeyBwcmVhbGxvYyB9ID0ge30pIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gdmVydGV4X2xheW91dDtcblxuICAgICAgICBpZiAoVmVydGV4RGF0YS5hcnJheV9wb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gVmVydGV4RGF0YS5hcnJheV9wb29sLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfbGVuZ3RoID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3NpemUgPSBNYXRoLmZsb29yKHRoaXMuYnVmZmVyX2xlbmd0aCAvIHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUpO1xuICAgICAgICAgICAgbG9nKCd0cmFjZScsIGBWZXJ0ZXhEYXRhOiByZXVzZWQgYnVmZmVyIG9mIGJ5dGVzICR7dGhpcy5idWZmZXJfbGVuZ3RofSwgJHt0aGlzLmJ1ZmZlcl9zaXplfSB2ZXJ0aWNlc2ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfc2l6ZSA9IHByZWFsbG9jIHx8IDUwMDsgLy8gIyBvZiB2ZXJ0aWNlcyB0byBhbGxvY2F0ZVxuICAgICAgICAgICAgdGhpcy5idWZmZXJfbGVuZ3RoID0gdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZSAqIHRoaXMuYnVmZmVyX3NpemU7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyX2xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJfb2Zmc2V0ID0gMDsgICAgICAgICAgICAgLy8gYnl0ZSBvZmZzZXQgaW50byBjdXJyZW50bHkgYWxsb2NhdGVkIGJ1ZmZlclxuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb21wb25lbnQgb2YgdGhpcy52ZXJ0ZXhfbGF5b3V0LmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKFsuLi5jb21wb25lbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVhbGxvY19jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc2V0QnVmZmVyVmlld3MoKTtcbiAgICB9XG5cbiAgICAvLyAoUmUtKWFsbG9jYXRlIHR5cGVkIHZpZXdzIGludG8gdGhlIG1haW4gYnVmZmVyIC0gb25seSBjcmVhdGUgdGhlIHR5cGVzIHdlIG5lZWQgZm9yIHRoaXMgbGF5b3V0XG4gICAgc2V0QnVmZmVyVmlld3MgKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcl92aWV3cyA9IHt9O1xuICAgICAgICB0aGlzLmJ1ZmZlcl92aWV3c1tnbC5VTlNJR05FRF9CWVRFXSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBmb3IgKHZhciBhdHRyaWIgb2YgdGhpcy52ZXJ0ZXhfbGF5b3V0LmF0dHJpYnMpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdmlldyBmb3IgdGhpcyB0eXBlP1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyX3ZpZXdzW2F0dHJpYi50eXBlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5X3R5cGUgPSBhcnJheV90eXBlc1thdHRyaWIudHlwZV07XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJfdmlld3NbYXR0cmliLnR5cGVdID0gbmV3IGFycmF5X3R5cGUodGhpcy5idWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnQgYnVmZmVyIHBvaW50ZXJzXG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFsxXSA9IHRoaXMuYnVmZmVyX3ZpZXdzW2NvbXBvbmVudFswXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGxvY2F0ZWQgYnVmZmVyIHNpemUsIGV4cGFuZC9yZWFsbG9jIGJ1ZmZlciBpZiBuZWVkZWRcbiAgICBjaGVja0J1ZmZlclNpemUgKCkge1xuICAgICAgICBpZiAoKHRoaXMuYnVmZmVyX29mZnNldCArIHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUpID4gdGhpcy5idWZmZXJfbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9zaXplID0gTWF0aC5mbG9vcih0aGlzLmJ1ZmZlcl9zaXplICogMS41KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3NpemUgLT0gdGhpcy5idWZmZXJfc2l6ZSAlIDQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9sZW5ndGggPSB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlICogdGhpcy5idWZmZXJfc2l6ZTtcbiAgICAgICAgICAgIHZhciBuZXdfdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyX2xlbmd0aCk7XG4gICAgICAgICAgICBuZXdfdmlldy5zZXQodGhpcy5idWZmZXIpOyAvLyBjb3B5IGV4aXN0aW5nIGRhdGEgdG8gbmV3IGJ1ZmZlclxuICAgICAgICAgICAgVmVydGV4RGF0YS5hcnJheV9wb29sLnB1c2godGhpcy5idWZmZXIpOyAvLyBzYXZlIHByZXZpb3VzIGJ1ZmZlciBmb3IgdXNlIGJ5IG5leHQgdGlsZVxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdfdmlldztcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyVmlld3MoKTtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvY19jb3VudCsrO1xuICAgICAgICAgICAgLy8gbG9nLmluZm8oYFZlcnRleERhdGE6IGV4cGFuZGVkIHZlcnRleCBibG9jayB0byAke3RoaXMuYnVmZmVyX3NpemV9IHZlcnRpY2VzYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgYSB2ZXJ0ZXgsIGNvcGllZCBmcm9tIGEgcGxhaW4gSlMgYXJyYXkgb2YgZWxlbWVudHMgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxuICAgIC8vIE5vdGU6IHVzZXMgcHJlLWNhbGN1bGF0ZWQgaW5mbyBhYm91dCBlYWNoIGF0dHJpYnV0ZSwgaW5jbHVkaW5nIHBvaW50ZXIgdG8gYXBwcm9wcmlhdGUgdHlwZWQgYXJyYXlcbiAgICAvLyB2aWV3IGFuZCBvZmZzZXQgaW50byBpdC4gVGhpcyB3YXMgdGhlIGZhc3Rlc3QgbWV0aG9kIHByb2ZpbGVkIHNvIGZhciBmb3IgZmlsbGluZyBhIG1peGVkLXR5cGVcbiAgICAvLyB2ZXJ0ZXggbGF5b3V0ICh0aG91Z2ggc3RpbGwgc2xvd2VyIHRoYW4gdGhlIHByZXZpb3VzIG1ldGhvZCB0aGF0IG9ubHkgc3VwcG9ydGVkIEZsb2F0MzJBcnJheSBhdHRyaWJ1dGVzKS5cbiAgICBhZGRWZXJ0ZXggKHZlcnRleCkge1xuICAgICAgICB0aGlzLmNoZWNrQnVmZmVyU2l6ZSgpO1xuICAgICAgICB2YXIgaT0wO1xuXG4gICAgICAgIHZhciBjbGVuID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgYz0wOyBjIDwgY2xlbjsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2NdO1xuICAgICAgICAgICAgY29tcG9uZW50WzFdWyh0aGlzLmJ1ZmZlcl9vZmZzZXQgPj4gY29tcG9uZW50WzJdKSArIGNvbXBvbmVudFszXV0gPSB2ZXJ0ZXhbaSsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVmZmVyX29mZnNldCArPSB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlO1xuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCsrO1xuICAgIH1cblxuICAgIC8vIEZpbmFsaXplIHZlcnRleCBidWZmZXIgZm9yIHVzZSBpbiBjb25zdHJ1Y3RpbmcgYSBtZXNoXG4gICAgZW5kICgpIHtcbiAgICAgICAgLy8gQ2xpcCB0aGUgYnVmZmVyIHRvIHNpemUgdXNlZCBmb3IgdGhpcyBWQk9cbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLmJ1ZmZlcl9vZmZzZXQpO1xuICAgICAgICBsb2coJ3RyYWNlJywgYFZlcnRleERhdGE6ICR7dGhpcy5idWZmZXJfc2l6ZX0gdmVydGljZXMgdG90YWwsIHJlYWxsb2MgY291bnQgJHt0aGlzLnJlYWxsb2NfY291bnR9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufVxuXG5WZXJ0ZXhEYXRhLmFycmF5X3Bvb2wgPSBbXTsgLy8gcG9vbCBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIChwcmV2aW91c2x5IHVzZWQpIGJ1ZmZlcnMgKHVpbnQ4KVxuIiwiLyogZ2xvYmFsIFZlcnRleExheW91dCAqL1xuXG5pbXBvcnQgZ2wgZnJvbSAnLi9jb25zdGFudHMnOyAvLyB3ZWIgd29ya2VycyBkb24ndCBoYXZlIGFjY2VzcyB0byBHTCBjb250ZXh0LCBzbyBpbXBvcnQgYWxsIEdMIGNvbnN0YW50c1xuaW1wb3J0IFZlcnRleERhdGEgZnJvbSAnLi92ZXJ0ZXhfZGF0YSc7XG5cbi8vIERlc2NyaWJlcyBhIHZlcnRleCBsYXlvdXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIG1hbnkgZGlmZmVyZW50IEdMIHByb2dyYW1zLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydGV4TGF5b3V0IHtcbiAgICAvLyBBdHRyaWJzIGFyZSBhbiBhcnJheSwgaW4gbGF5b3V0IG9yZGVyLCBvZjogbmFtZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZFxuICAgIC8vIGV4OiB7IG5hbWU6ICdwb3NpdGlvbicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XG4gICAgY29uc3RydWN0b3IgKGF0dHJpYnMpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJzID0gYXR0cmliczsgLy8gZGljdGlvbmFyeSBvZiBhdHRyaWJ1dGVzLCBzcGVjaWZpZWQgYXMgc3RhbmRhcmQgR0wgYXR0cmliIG9wdGlvbnNcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107ICAgLy8gbGlzdCBvZiB0eXBlIGFuZCBvZmZzZXQgaW5mbyBhYm91dCBlYWNoIGF0dHJpYnV0ZSBjb21wb25lbnRcbiAgICAgICAgdGhpcy5pbmRleCA9IHt9OyAgICAgICAgLy8gbGluZWFyIGJ1ZmZlciBpbmRleCBvZiBlYWNoIGF0dHJpYnV0ZSBjb21wb25lbnQsIGUuZy4gdGhpcy5pbmRleC5wb3NpdGlvbi54XG5cbiAgICAgICAgLy8gQ2FsYyB2ZXJ0ZXggc3RyaWRlXG4gICAgICAgIHRoaXMuc3RyaWRlID0gMDtcblxuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBhdHRyaWIgb2YgdGhpcy5hdHRyaWJzKSB7XG4gICAgICAgICAgICBhdHRyaWIub2Zmc2V0ID0gdGhpcy5zdHJpZGU7XG4gICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplID0gYXR0cmliLnNpemU7XG4gICAgICAgICAgICB2YXIgc2hpZnQgPSAwO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGF0dHJpYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5GTE9BVDpcbiAgICAgICAgICAgICAgICBjYXNlIGdsLklOVDpcbiAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX0lOVDpcbiAgICAgICAgICAgICAgICAgICAgYXR0cmliLmJ5dGVfc2l6ZSAqPSA0O1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZ2wuU0hPUlQ6XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5VTlNJR05FRF9TSE9SVDpcbiAgICAgICAgICAgICAgICAgICAgYXR0cmliLmJ5dGVfc2l6ZSAqPSAyO1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3JjZSA0LWJ5dGUgYWxpZ25tZW50IG9uIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlICs9IGF0dHJpYi5ieXRlX3NpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJpZGUgJiAzKSB7IC8vIHBhZCB0byBtdWx0aXBsZSBvZiA0IGJ5dGVzXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpZGUgKz0gNCAtICh0aGlzLnN0cmlkZSAmIDMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgaW5mbyB0byBsaXN0IG9mIGF0dHJpYnV0ZSBjb21wb25lbnRzXG4gICAgICAgICAgICAvLyBVc2VkIHRvIGJ1aWxkIHRoZSB2ZXJ0ZXggZGF0YSwgcHJvdmlkZXMgcG9pbnRlcnMgYW5kIG9mZnNldHMgaW50byBlYWNoIHR5cGVkIGFycmF5IHZpZXdcbiAgICAgICAgICAgIC8vIEVhY2ggY29tcG9uZW50IGlzIGFuIGFycmF5IG9mOlxuICAgICAgICAgICAgLy8gW0dMIGF0dHJpYiB0eXBlLCBwb2ludGVyIHRvIHR5cGVkIGFycmF5IHZpZXcsIGJpdHMgdG8gc2hpZnQgcmlnaHQgdG8gZGV0ZXJtaW5lIGJ1ZmZlciBvZmZzZXQsIGFkZGl0aW9uYWwgYnVmZmVyIG9mZnNldCBmb3IgdGhlIGNvbXBvbmVudF1cbiAgICAgICAgICAgIHZhciBvZmZzZXRfdHlwZWQgPSBhdHRyaWIub2Zmc2V0ID4+IHNoaWZ0O1xuICAgICAgICAgICAgaWYgKGF0dHJpYi5zaXplID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGE9MDsgYSA8IGF0dHJpYi5zaXplOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goW2F0dHJpYi50eXBlLCBudWxsLCBzaGlmdCwgb2Zmc2V0X3R5cGVkKytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChbYXR0cmliLnR5cGUsIG51bGwsIHNoaWZ0LCBvZmZzZXRfdHlwZWRdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvdmlkZSBhbiBpbmRleCBpbnRvIHRoZSB2ZXJ0ZXggZGF0YSBidWZmZXIgZm9yIGVhY2ggYXR0cmlidXRlIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5pbmRleFthdHRyaWIubmFtZV0gPSBjb3VudDtcbiAgICAgICAgICAgIGNvdW50ICs9IGF0dHJpYi5zaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgYSB2ZXJ0ZXggbGF5b3V0IGZvciBhIHNwZWNpZmljIEdMIHByb2dyYW1cbiAgICAvLyBBc3N1bWVzIHRoYXQgdGhlIGRlc2lyZWQgdmVydGV4IGJ1ZmZlciAoVkJPKSBpcyBhbHJlYWR5IGJvdW5kXG4gICAgLy8gSWYgYSBnaXZlbiBwcm9ncmFtIGRvZXNuJ3QgaW5jbHVkZSBhbGwgYXR0cmlidXRlcywgaXQgY2FuIHN0aWxsIHVzZSB0aGUgdmVydGV4IGxheW91dFxuICAgIC8vIHRvIHJlYWQgdGhvc2UgYXR0cmlicyB0aGF0IGl0IGRvZXMgcmVjb2duaXplLCB1c2luZyB0aGUgYXR0cmliIG9mZnNldHMgdG8gc2tpcCBvdGhlcnMuXG4gICAgZW5hYmxlIChnbCwgcHJvZ3JhbSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWIsIGxvY2F0aW9uO1xuXG4gICAgICAgIC8vIEVuYWJsZSBhbGwgYXR0cmlidXRlcyBmb3IgdGhpcyBsYXlvdXRcbiAgICAgICAgZm9yICh2YXIgYT0wOyBhIDwgdGhpcy5hdHRyaWJzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICBhdHRyaWIgPSB0aGlzLmF0dHJpYnNbYV07XG4gICAgICAgICAgICBsb2NhdGlvbiA9IHByb2dyYW0uYXR0cmlidXRlKGF0dHJpYi5uYW1lKS5sb2NhdGlvbjtcblxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyaWIuc2l6ZSwgYXR0cmliLnR5cGUsIGF0dHJpYi5ub3JtYWxpemVkLCB0aGlzLnN0cmlkZSwgYXR0cmliLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlic1tsb2NhdGlvbl0gPSBwcm9ncmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZSBhbnkgcHJldmlvdXNseSBib3VuZCBhdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGZvciB0aGlzIGxheW91dFxuICAgICAgICBmb3IgKGxvY2F0aW9uIGluIFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZShnbCwgbG9jYXRpb24sIHByb2dyYW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSBhbiBhdHRyaWJ1dGUgaWYgaXQgd2FzIG5vdCBlbmFibGVkIGZvciB0aGUgc3BlY2lmaWVkIHByb2dyYW1cbiAgICAvLyBOT1RFOiB0aGlzIHdhcyBtb3ZlZCBvdXQgb2YgdGhlIGlubmVyIGxvb3AgaW4gZW5hYmxlKCkgdG8gYXNzaXN0IHcvVk0gb3B0aW1pemF0aW9uXG4gICAgZGlzYWJsZVVudXNlZEF0dHJpYnV0ZSAoZ2wsIGxvY2F0aW9uLCBwcm9ncmFtKSB7XG4gICAgICAgIGlmIChWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSAhPT0gcHJvZ3JhbSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGRlbGV0ZSBWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZVZlcnRleERhdGEgKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlcnRleERhdGEodGhpcyk7XG4gICAgfVxuXG59XG5cbi8vIFRyYWNrIGN1cnJlbnRseSBlbmFibGVkIGF0dHJpYnMsIGJ5IHRoZSBwcm9ncmFtIHRoZXkgYXJlIGJvdW5kIHRvXG4vLyBTdGF0aWMgY2xhc3MgcHJvcGVydHkgdG8gcmVmbGVjdCBnbG9iYWwgR0wgc3RhdGVcblZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnMgPSB7fTtcbiIsImltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTY2VuZSBmcm9tICcuL3NjZW5lJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEV4cG9ydHMgbXVzdCBhcHBlYXIgb3V0c2lkZSBhIGZ1bmN0aW9uLCBidXQgd2lsbCBvbmx5IGJlIGRlZmluZWQgaW4gbWFpbiB0aHJlYWQgKGJlbG93KVxuZXhwb3J0IHZhciBMZWFmbGV0TGF5ZXI7XG5leHBvcnQgZnVuY3Rpb24gbGVhZmxldExheWVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExlYWZsZXRMYXllcihvcHRpb25zKTtcbn1cblxuLy8gTGVhZmxldCBsYXllciBmdW5jdGlvbmFsaXR5IGlzIG9ubHkgZGVmaW5lZCBpbiBtYWluIHRocmVhZFxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHdlIGFyZSBleHRlbmRpbmcgdGhlIGxlYWZsZXQgMC43LnggVGlsZUxheWVyIGNsYXNzLCBvciB0aGUgbmV3ZXJcbiAgICAvLyBsZWFmbGV0IDEueCBHcmlkTGF5ZXIgY2xhc3MuXG4gICAgbGV0IGxheWVyQmFzZUNsYXNzID0gTC5HcmlkTGF5ZXIgPyBMLkdyaWRMYXllciA6IEwuVGlsZUxheWVyO1xuICAgIGxldCBsZWFmbGV0VmVyc2lvbiA9IGxheWVyQmFzZUNsYXNzID09PSBMLkdyaWRMYXllciA/ICcxLngnIDogJzAuNy54JztcbiAgICBsZXQgbGF5ZXJDbGFzc0NvbmZpZyA9IHt9O1xuXG4gICAgLy8gSWYgZXh0ZW5kaW5nIGxlYWZsZXQgMC43LnggVGlsZUxheWVyLCBtYWtlIGFkZC9yZW1vdmUgdGlsZSBubyBvcHNcbiAgICBpZiAobGF5ZXJCYXNlQ2xhc3MgPT09IEwuVGlsZUxheWVyKSB7XG4gICAgICAgIGxheWVyQ2xhc3NDb25maWcuX2FkZFRpbGUgPSBmdW5jdGlvbigpe307XG4gICAgICAgIGxheWVyQ2xhc3NDb25maWcuX3JlbW92ZVRpbGUgPSBmdW5jdGlvbigpe307XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIGN1c3RvbSBsYXllciBtZXRob2RzXG4gICAgT2JqZWN0LmFzc2lnbihsYXllckNsYXNzQ29uZmlnLCB7XG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgICAgICBvcHRpb25zLnNob3dEZWJ1ZyA9ICghb3B0aW9ucy5zaG93RGVidWcgPyBmYWxzZSA6IHRydWUpO1xuXG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNjZW5lKCk7XG4gICAgICAgICAgICB0aGlzLmhvb2tzID0ge307XG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGxlYWZsZXQgem9vbSBhbmltYXRpb25zIG9mZlxuICAgICAgICAgICAgdGhpcy5fem9vbUFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU2NlbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBTY2VuZS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjZW5lLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtV29ya2VyczogdGhpcy5vcHRpb25zLm51bVdvcmtlcnMsXG4gICAgICAgICAgICAgICAgICAgIHByZVVwZGF0ZTogdGhpcy5vcHRpb25zLnByZVVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zdFVwZGF0ZTogdGhpcy5vcHRpb25zLnBvc3RVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNab29tOiAoTGVhZmxldExheWVyLmxlYWZsZXRWZXJzaW9uID09PSAnMS54JyksXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hEZW5zaXR5RGlzcGxheTogdGhpcy5vcHRpb25zLmhpZ2hEZW5zaXR5RGlzcGxheSxcbiAgICAgICAgICAgICAgICAgICAgbG9nTGV2ZWw6IHRoaXMub3B0aW9ucy5sb2dMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWR2YW5jZWQgb3B0aW9uLCBhcHAgd2lsbCBoYXZlIHRvIG1hbnVhbGx5IGNhbGxlZCBzY2VuZS51cGRhdGUoKSBwZXIgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVJlbmRlckxvb3A6IHRoaXMub3B0aW9ucy5kaXNhYmxlUmVuZGVyTG9vcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWR2YW5jZWQgb3B0aW9uLCB3aWxsIHJlcXVpcmUgbGlicmFyeSB0byBiZSBzZXJ2ZWQgYXMgc2FtZSBob3N0IGFzIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dDcm9zc0RvbWFpbldvcmtlcnM6IHRoaXMub3B0aW9ucy5hbGxvd0Nyb3NzRG9tYWluV29ya2Vyc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZpbmlzaCBpbml0aWFsaXppbmcgc2NlbmUgYW5kIHNldHVwIGV2ZW50cyB3aGVuIGxheWVyIGlzIGFkZGVkIHRvIG1hcFxuICAgICAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTY2VuZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXllckJhc2VDbGFzcy5wcm90b3R5cGUub25BZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5ob29rcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBtYXAuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucmVzaXplTWFwKHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWFwLm9uKCdyZXNpemUnLCB0aGlzLmhvb2tzLnJlc2l6ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuaG9va3MubW92ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgdmlldy56b29tID0gbWFwLmdldFpvb20oKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0Vmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmltbWVkaWF0ZVJlZHJhdygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYXAub24oJ21vdmUnLCB0aGlzLmhvb2tzLm1vdmUpO1xuXG4gICAgICAgICAgICB0aGlzLmhvb2tzLnpvb21zdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5zdGFydFpvb20oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWFwLm9uKCd6b29tc3RhcnQnLCB0aGlzLmhvb2tzLnpvb21zdGFydCk7XG5cbiAgICAgICAgICAgIHRoaXMuaG9va3MuZHJhZ3N0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWFwLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhvb2tzLmRyYWdzdGFydCk7XG5cbiAgICAgICAgICAgIHRoaXMuaG9va3MuZHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYXAub24oJ2RyYWdlbmQnLCB0aGlzLmhvb2tzLmRyYWdlbmQpO1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBsZWFmbGV0IHpvb20gYW5pbWF0aW9ucyBvZmZcbiAgICAgICAgICAgIG1hcC5fem9vbUFuaW1hdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIE1vZGlmeSBkZWZhdWx0IGxlYWZsZXQgc2Nyb2xsIHdoZWVsIGJlaGF2aW9yXG4gICAgICAgICAgICB0aGlzLm1vZGlmeVNjcm9sbFdoZWVsQmVoYXZpb3IobWFwKTtcblxuICAgICAgICAgICAgLy8gQ2FudmFzIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZCBhZnRlciBtYXAgY29udGFpbmVyIChsZWFmbGV0IHRyYW5zZm9ybXMgc2hvdWxkbid0IGJlIGFwcGxpZWQgdG8gdGhlIEdMIGNhbnZhcylcbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzPyByaWdodCBub3cgR0wgbWFwIG9ubHkgcmVuZGVycyBjb3JyZWN0bHkgYXMgdGhlIGJvdHRvbSBsYXllclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5jb250YWluZXIgPSBtYXAuZ2V0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWwgdmlld1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgICB2aWV3Lnpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5zZXRWaWV3KHZpZXcpO1xuXG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGFuZ3JhbSBldmVudHNcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBtb3ZlOiB0aGlzLm9uVGFuZ3JhbVZpZXdVcGRhdGUuYmluZCh0aGlzKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVzZSBsZWFmbGV0J3MgZXhpc3RpbmcgZXZlbnQgc3lzdGVtIGFzIHRoZSBjYWxsYmFjayBtZWNoYW5pc21cbiAgICAgICAgICAgIHRoaXMuc2NlbmUuaW5pdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnU2NlbmUuaW5pdCgpIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnaW5pdCcpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU2NlbmUuaW5pdCgpIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGxheWVyQmFzZUNsYXNzLnByb3RvdHlwZS5vblJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBtYXAub2ZmKCdyZXNpemUnLCB0aGlzLmhvb2tzLnJlc2l6ZSk7XG4gICAgICAgICAgICBtYXAub2ZmKCdtb3ZlJywgdGhpcy5ob29rcy5tb3ZlKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21zdGFydCcsIHRoaXMuaG9va3Muem9vbXN0YXJ0KTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuaG9va3MuZHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ2RyYWdlbmQnLCB0aGlzLmhvb2tzLmRyYWdlbmQpO1xuICAgICAgICAgICAgdGhpcy5ob29rcyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjb29yZHMueCArICcvJyArIGNvb3Jkcy55ICsgJy8nICsgY29vcmRzLno7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLXRpbGUta2V5Jywga2V5KTtcbiAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcyNTZweCc7XG4gICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzI1NnB4JztcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93RGVidWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVidWdfb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkudGV4dENvbnRlbnQgPSBrZXk7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnRvcCA9IDA7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5mb250U2l6ZSA9ICcxNnB4JztcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnRleHRPdXRsaW5lID0gJzFweCAjMDAwMDAwJztcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnBhZGRpbmcgPSAnOHB4JztcblxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChkZWJ1Z19vdmVybGF5KTtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJDb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlcldpZHRoID0gJzFweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTW9kaWZ5IGxlYWZsZXQncyBkZWZhdWx0IHNjcm9sbCB3aGVlbCBiZWhhdmlvciB0byBoYXZlIGEgbXVjaCBtb3JlIHNlbnNpdHZlL2NvbnRpbnVvdXMgem9vbVxuICAgICAgICAvLyBOb3RlOiB0aGlzIHNob3VsZCBiZSBkZXByZWNhdGVkIG9uY2UgbGVhZmxldCBjb250aW51b3VzIHpvb20gaXMgbW9yZSB3aWRlbHkgdXNlZCBhbmQgdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJlc3VtYWJseSBpbXByb3ZlZFxuICAgICAgICBtb2RpZnlTY3JvbGxXaGVlbEJlaGF2aW9yOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZS5jb250aW51b3VzX3pvb20gJiYgbWFwLnNjcm9sbFdoZWVsWm9vbSAmJiB0aGlzLm9wdGlvbnMubW9kaWZ5U2Nyb2xsV2hlZWwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNjcm9sbFdoZWVsWm9vbS5fcGVyZm9ybVpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHRoaXMuX2RlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgem9vbSA9IG1hcC5nZXRab29tKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFwLnN0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIHRoZSBvbmx5IHJlYWwgbW9kaWZpY2F0aW9uIHRvIGRlZmF1bHQgbGVhZmxldCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBkZWx0YSAvPSA0MDtcblxuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IE1hdGgubWF4KE1hdGgubWluKGRlbHRhLCA0KSwgLTQpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyBkZWx0YSkgLSB6b29tO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uVGFuZ3JhbVZpZXdVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXRWaWV3KFt0aGlzLnNjZW5lLmNlbnRlci5sYXQsIHRoaXMuc2NlbmUuY2VudGVyLmxuZ10sIHRoaXMuc2NlbmUuem9vbSwgeyBhbmltYXRlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY2VuZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NlbmUudXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBsYXllciBjbGFzc1xuICAgIExlYWZsZXRMYXllciA9IGxheWVyQmFzZUNsYXNzLmV4dGVuZChsYXllckNsYXNzQ29uZmlnKTtcblxuICAgIC8vIFBvbHlmaWxsIHNvbWUgMS4wIG1ldGhvZHNcbiAgICBpZiAodHlwZW9mIExlYWZsZXRMYXllci5yZW1vdmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgTGVhZmxldExheWVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3JlbW92ZScpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIExlYWZsZXRMYXllci5sYXllckJhc2VDbGFzcyA9IGxheWVyQmFzZUNsYXNzO1xuICAgIExlYWZsZXRMYXllci5sZWFmbGV0VmVyc2lvbiA9IGxlYWZsZXRWZXJzaW9uO1xuXG59XG4iLCIvKmdsb2JhbCBMaWdodCAqL1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcblxuLy8gQWJzdHJhY3QgbGlnaHRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yIChzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5hbWJpZW50ID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5hbWJpZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gR0xTTC5leHBhbmRWZWM0KGNvbmZpZy5hbWJpZW50IHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuYW1iaWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmRpZmZ1c2UgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmRpZmZ1c2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBHTFNMLmV4cGFuZFZlYzQoY29uZmlnLmRpZmZ1c2UgIT0gbnVsbCA/IGNvbmZpZy5kaWZmdXNlIDogMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5kaWZmdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuc3BlY3VsYXIgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNwZWN1bGFyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5zcGVjdWxhciA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuc3BlY3VsYXIgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuc3BlY3VsYXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbGlnaHQgYnkgdHlwZSBuYW1lLCBmYWN0b3J5LXN0eWxlXG4gICAgLy8gJ2NvbmZpZycgbXVzdCBpbmNsdWRlICduYW1lJyBhbmQgJ3R5cGUnLCBhbG9uZyB3aXRoIGFueSBvdGhlciB0eXBlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICBzdGF0aWMgY3JlYXRlIChzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChMaWdodC50eXBlc1tjb25maWcudHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlnaHQudHlwZXNbY29uZmlnLnR5cGVdKHNjZW5lLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGxpZ2h0IGZvciBhIHN0eWxlOiBmcmFnbWVudCBsaWdodGluZywgdmVydGV4IGxpZ2h0aW5nLCBvciBub25lXG4gICAgc3RhdGljIHNldE1vZGUgKG1vZGUsIHN0eWxlKSB7XG4gICAgICAgIG1vZGUgPSBMaWdodC5lbmFibGVkICYmICgobW9kZSAhPSBudWxsKSA/IG1vZGUgOiAnZnJhZ21lbnQnKTsgLy8gZGVmYXVsdCB0byBmcmFnbWVudCBsaWdodGluZ1xuICAgICAgICBzdHlsZS5kZWZpbmVzWydUQU5HUkFNX0xJR0hUSU5HX0ZSQUdNRU5UJ10gPSAobW9kZSA9PT0gJ2ZyYWdtZW50Jyk7XG4gICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTElHSFRJTkdfVkVSVEVYJ10gPSAobW9kZSA9PT0gJ3ZlcnRleCcpO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBhbGwgcHJvdmlkZWQgbGlnaHQgZGVmaW5pdGlvbnMsIGFuZCBjYWxjdWxhdGUgY3VtdWxhdGl2ZSBsaWdodCBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QgKGxpZ2h0cykge1xuICAgICAgICAvLyBDbGVhciBwcmV2aW91cyBpbmplY3Rpb25zXG4gICAgICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soTGlnaHQuYmxvY2spO1xuXG4gICAgICAgIC8vIElmIGxpZ2h0aW5nIGlzIGdsb2JhbGx5IGRpc2FibGVkLCBub3RoaW5nIGlzIGluamVjdGVkIChtb3N0bHkgZm9yIGRlYnVnZ2luZyBvciBsaXZlIGVkaXRpbmcpXG4gICAgICAgIGlmICghTGlnaHQuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGNvZGUgdG8gY2FsY3VsYXRlIGVhY2ggbGlnaHQgaW5zdGFuY2VcbiAgICAgICAgbGV0IGNhbGN1bGF0ZUxpZ2h0cyA9IFwiXCI7XG4gICAgICAgIGlmIChsaWdodHMgJiYgT2JqZWN0LmtleXMobGlnaHRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDb2xsZWN0IHVuaXF1ZXMgdHlwZXMgb2YgbGlnaHRzXG4gICAgICAgICAgICBsZXQgdHlwZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpZ2h0X25hbWUgaW4gbGlnaHRzKSB7XG4gICAgICAgICAgICAgICAgdHlwZXNbbGlnaHRzW2xpZ2h0X25hbWVdLnR5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5qZWN0IGVhY2ggdHlwZSBvZiBsaWdodFxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgICAgIExpZ2h0LnR5cGVzW3R5cGVdLmluamVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmplY3QgcGVyLWluc3RhbmNlIGJsb2NrcyBhbmQgY29uc3RydWN0IHRoZSBsaXN0IG9mIGZ1bmN0aW9ucyB0byBjYWxjdWxhdGUgZWFjaCBsaWdodFxuICAgICAgICAgICAgZm9yIChsZXQgbGlnaHRfbmFtZSBpbiBsaWdodHMpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZpbmUgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBsaWdodHNbbGlnaHRfbmFtZV0uaW5qZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNhbGN1bGF0aW9uIGZ1bmN0aW9uIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlTGlnaHRzICs9IGBjYWxjdWxhdGVMaWdodCgke2xpZ2h0X25hbWV9LCBfZXllVG9Qb2ludCwgX25vcm1hbCk7XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGxpZ2h0IGlzIGRlZmluZWQsIHVzZSAxMDAlIG9tbmlkaXJlY3Rpb25hbCBkaWZmdXNlIGxpZ2h0XG4gICAgICAgICAgICBjYWxjdWxhdGVMaWdodHMgPSBgXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxuICAgICAgICAgICAgICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlID0gdmVjNCgxLik7XG4gICAgICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICBgO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2x1ZSB0b2dldGhlciB0aGUgZmluYWwgbGlnaHRpbmcgZnVuY3Rpb24gdGhhdCBzdW1zIGFsbCB0aGUgbGlnaHRzXG4gICAgICAgIGxldCBjYWxjdWxhdGVGdW5jdGlvbiA9IGBcbiAgICAgICAgICAgIHZlYzQgY2FsY3VsYXRlTGlnaHRpbmcoaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsLCBpbiB2ZWM0IF9jb2xvcikge1xuXG4gICAgICAgICAgICAgICAgLy8gRG8gaW5pdGlhbCBtYXRlcmlhbCBjYWxjdWxhdGlvbnMgb3ZlciBub3JtYWwsIGVtaXNzaW9uLCBhbWJpZW50LCBkaWZmdXNlIGFuZCBzcGVjdWxhciB2YWx1ZXNcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVNYXRlcmlhbChfZXllVG9Qb2ludCxfbm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIC8vIFVuIHJvbGwgdGhlIGxvb3Agb2YgaW5kaXZpZHVhbCBsaWd0aHMgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgJHtjYWxjdWxhdGVMaWdodHN9XG5cbiAgICAgICAgICAgICAgICAvLyAgRmluYWwgbGlnaHQgaW50ZW5zaXR5IGNhbGN1bGF0aW9uXG4gICAgICAgICAgICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcblxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbWF0ZXJpYWwuZW1pc3Npb247XG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yICs9IGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKiBfY29sb3IgKiBtYXRlcmlhbC5hbWJpZW50O1xuICAgICAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yICs9IGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKiBfY29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlO1xuICAgICAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSAqIF9jb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2U7XG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxuICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciAqIG1hdGVyaWFsLnNwZWN1bGFyO1xuICAgICAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgZmluYWwgY29sb3JcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNsYW1wKGNvbG9yLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICB9YDtcblxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBjYWxjdWxhdGVGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgLy8gQ29tbW9uIGluc3RhbmNlIGRlZmluaXRpb25cbiAgICBpbmplY3QgKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSAgYFxuICAgICAgICAgICAgdW5pZm9ybSAke3RoaXMuc3RydWN0X25hbWV9IHVfJHt0aGlzLm5hbWV9O1xuICAgICAgICAgICAgJHt0aGlzLnN0cnVjdF9uYW1lfSAke3RoaXMubmFtZX0gPSB1XyR7dGhpcy5uYW1lfTtcXG5gO1xuXG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbWV0aG9kIGNhbGxlZCBvbmNlIHBlciBmcmFtZVxuICAgIHVwZGF0ZSAoKSB7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGZyYW1lIHBlciBwcm9ncmFtIChlLmcuIGZvciBtYWluIHJlbmRlciBwYXNzLCB0aGVuIGZvciBlYWNoIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiwgZXRjLilcbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIC8vICBUaHJlZSBjb21tb24gbGlnaHQgcHJvcGVydGllc1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uYW1iaWVudGAsIHRoaXMuYW1iaWVudCk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1XyR7dGhpcy5uYW1lfS5kaWZmdXNlYCwgdGhpcy5kaWZmdXNlKTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LnNwZWN1bGFyYCwgdGhpcy5zcGVjdWxhcik7XG4gICAgfVxuXG59XG5cbkxpZ2h0LnR5cGVzID0ge307IC8vIHJlZmVyZW5jZXMgdG8gc3ViY2xhc3NlcyBieSBzaG9ydCBuYW1lXG5MaWdodC5ibG9jayA9ICdsaWdodGluZyc7IC8vIHNoYWRlciBibG9jayBuYW1lXG5MaWdodC5lbmFibGVkID0gdHJ1ZTsgLy8gbGlnaHRpbmcgY2FuIGJlIGdsb2JhbGx5IGVuYWJsZWQvZGlzYWJsZWRcblxuXG4vLyBMaWdodCBzdWJjbGFzc2VzXG5jbGFzcyBBbWJpZW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHNjZW5lLCBjb25maWcpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYW1iaWVudCc7XG4gICAgICAgIHRoaXMuc3RydWN0X25hbWUgPSAnQW1iaWVudExpZ2h0JztcbiAgICB9XG5cbiAgICAvLyBJbmplY3Qgc3RydWN0IGFuZCBjYWxjdWxhdGUgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0KCkge1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FtYmllbnRMaWdodCddKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1XyR7dGhpcy5uYW1lfS5hbWJpZW50YCwgdGhpcy5hbWJpZW50KTtcbiAgICB9XG5cbn1cbkxpZ2h0LnR5cGVzWydhbWJpZW50J10gPSBBbWJpZW50TGlnaHQ7XG5cbmNsYXNzIERpcmVjdGlvbmFsTGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHNjZW5lLCBjb25maWcpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGlyZWN0aW9uYWwnO1xuICAgICAgICB0aGlzLnN0cnVjdF9uYW1lID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gKGNvbmZpZy5kaXJlY3Rpb24gfHwgWzAuMiwgMC43LCAtMC41XSkubWFwKHBhcnNlRmxvYXQpOyAvLyBbeCwgeSwgel1cbiAgICB9XG5cbiAgICAvLyBJbmplY3Qgc3RydWN0IGFuZCBjYWxjdWxhdGUgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0KCkge1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2RpcmVjdGlvbmFsTGlnaHQnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBzdXBlci5zZXR1cFByb2dyYW0oX3Byb2dyYW0pO1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCBgdV8ke3RoaXMubmFtZX0uZGlyZWN0aW9uYCwgdGhpcy5kaXJlY3Rpb24pO1xuICAgIH1cblxufVxuTGlnaHQudHlwZXNbJ2RpcmVjdGlvbmFsJ10gPSBEaXJlY3Rpb25hbExpZ2h0O1xuXG5cbmNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BvaW50JztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdQb2ludExpZ2h0JztcblxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uIHx8IFswLCAwLCAwXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9leWUgPSBbXTsgLy8gcG9zaXRpb24gaW4gZXllc3BhY2VcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBjb25maWcub3JpZ2luIHx8ICd3b3JsZCc7XG4gICAgICAgIHRoaXMuYXR0ZW51YXRpb24gPSAhaXNOYU4ocGFyc2VGbG9hdChjb25maWcuYXR0ZW51YXRpb24pKSA/IHBhcnNlRmxvYXQoY29uZmlnLmF0dGVudWF0aW9uKSA6IDA7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5yYWRpdXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5yYWRpdXMpICYmIGNvbmZpZy5yYWRpdXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBjb25maWcucmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBbbnVsbCwgY29uZmlnLnJhZGl1c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmplY3Qgc3RydWN0IGFuZCBjYWxjdWxhdGUgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0ICgpIHtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhMaWdodC5ibG9jaywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9wb2ludExpZ2h0J10pO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBpc250YW5jZS1zcGVjaWZpYyBzZXR0aW5nc1xuICAgIGluamVjdCgpIHtcbiAgICAgICAgc3VwZXIuaW5qZWN0KCk7XG5cbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlQnXSA9ICh0aGlzLmF0dGVudWF0aW9uICE9PSAwKTtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTJ10gPSAodGhpcy5yYWRpdXMgIT0gbnVsbCAmJiB0aGlzLnJhZGl1c1swXSAhPSBudWxsKTtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTJ10gPSAodGhpcy5yYWRpdXMgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgdXBkYXRlICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFeWVQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIHVwZGF0ZUV5ZVBvc2l0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luID09PSAnd29ybGQnKSB7XG4gICAgICAgICAgICAvLyBGb3Igd29ybGQgb3JpZ2luLCBmb3JtYXQgaXM6IFtsb25naXR1ZGUsIGxhdGl0dWRlLCBtZXRlcnMgKGRlZmF1bHQpIG9yIHBpeGVscyB3L3B4IHVuaXRzXVxuXG4gICAgICAgICAgICAvLyBNb3ZlIGxpZ2h0J3Mgd29ybGQgcG9zaXRpb24gaW50byBjYW1lcmEgc3BhY2VcbiAgICAgICAgICAgIGxldCBbeCwgeV0gPSBHZW8ubGF0TG5nVG9NZXRlcnModGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVswXSA9IHggLSB0aGlzLnNjZW5lLmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMF07XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsxXSA9IHkgLSB0aGlzLnNjZW5lLmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMV07XG5cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzJdID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucG9zaXRpb25bMl0sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMl0gPSB0aGlzLnBvc2l0aW9uX2V5ZVsyXSAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1syXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdncm91bmQnIHx8IHRoaXMub3JpZ2luID09PSAnY2FtZXJhJykge1xuICAgICAgICAgICAgLy8gRm9yIGNhbWVyYSBvciBncm91bmQgb3JpZ2luLCBmb3JtYXQgaXM6IFt4LCB5LCB6XSBpbiBtZXRlcnMgKGRlZmF1bHQpIG9yIHBpeGVscyB3L3B4IHVuaXRzXG5cbiAgICAgICAgICAgIC8vIExpZ2h0IGlzIGluIGNhbWVyYSBzcGFjZSBieSBkZWZhdWx0XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZSA9IFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh0aGlzLnBvc2l0aW9uLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luID09PSAnZ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIC8vIExlYXZlIGxpZ2h0J3MgeHkgaW4gY2FtZXJhIHNwYWNlLCBidXQgeiBuZWVkcyB0byBiZSBtb3ZlZCByZWxhdGl2ZSB0byBncm91bmQgcGxhbmVcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsyXSA9IHRoaXMucG9zaXRpb25fZXllWzJdIC0gdGhpcy5zY2VuZS5jYW1lcmEucG9zaXRpb25fbWV0ZXJzWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBzdXBlci5zZXR1cFByb2dyYW0oX3Byb2dyYW0pO1xuXG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmJywgYHVfJHt0aGlzLm5hbWV9LnBvc2l0aW9uYCxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzBdLCB0aGlzLnBvc2l0aW9uX2V5ZVsxXSwgdGhpcy5wb3NpdGlvbl9leWVbMl0sIDEpO1xuXG4gICAgICAgIGlmKFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UJ10pIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LmF0dGVudWF0aW9uRXhwb25lbnRgLCB0aGlzLmF0dGVudWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVUyddKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5pbm5lclJhZGl1c2AsXG4gICAgICAgICAgICAgICAgU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucmFkaXVzWzBdLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVMnXSkge1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0ub3V0ZXJSYWRpdXNgLFxuICAgICAgICAgICAgICAgIFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh0aGlzLnJhZGl1c1sxXSwgeyB6b29tOiB0aGlzLnNjZW5lLnpvb20gfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuTGlnaHQudHlwZXNbJ3BvaW50J10gPSBQb2ludExpZ2h0O1xuXG5cbmNsYXNzIFNwb3RMaWdodCBleHRlbmRzIFBvaW50TGlnaHQge1xuXG4gICAgY29uc3RydWN0b3IgKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzcG90bGlnaHQnO1xuICAgICAgICB0aGlzLnN0cnVjdF9uYW1lID0gJ1Nwb3RMaWdodCc7XG5cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAoY29uZmlnLmRpcmVjdGlvbiB8fCBbMCwgMCwgLTFdKS5tYXAocGFyc2VGbG9hdCk7IC8vIFt4LCB5LCB6XVxuICAgICAgICB0aGlzLmV4cG9uZW50ID0gY29uZmlnLmV4cG9uZW50ID8gcGFyc2VGbG9hdChjb25maWcuZXhwb25lbnQpIDogMC4yO1xuICAgICAgICB0aGlzLmFuZ2xlID0gY29uZmlnLmFuZ2xlID8gcGFyc2VGbG9hdChjb25maWcuYW5nbGUpIDogMjA7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IHN0cnVjdCBhbmQgY2FsY3VsYXRlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGluamVjdCAoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc3BvdExpZ2h0J10pO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBQcm9ncmFtKF9wcm9ncmFtKTtcblxuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCBgdV8ke3RoaXMubmFtZX0uZGlyZWN0aW9uYCwgdGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5zcG90Q29zQ3V0b2ZmYCwgTWF0aC5jb3ModGhpcy5hbmdsZSAqIDMuMTQxNTkgLyAxODApKTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uc3BvdEV4cG9uZW50YCwgdGhpcy5leHBvbmVudCk7XG4gICAgfVxuXG59XG5MaWdodC50eXBlc1snc3BvdGxpZ2h0J10gPSBTcG90TGlnaHQ7XG4iLCIvKmdsb2JhbCBNYXRlcmlhbCAqL1xuaW1wb3J0IHNoYWRlclNvdXJjZXMgZnJvbSAnLi9nbC9zaGFkZXJfc291cmNlcyc7IC8vIGJ1aWx0LWluIHNoYWRlcnNcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2wvZ2xzbCc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRlcmlhbCB7XG4gICAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuXG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFsbCBoYXZlIHRoZSBzYW1lIGRlZmF1bHRzLCBzbyB0aGV5IGNhbiBiZSBzZXQgaW4gYnVsa1xuICAgICAgICBmb3IgKGxldCBwcm9wIG9mIFsnZW1pc3Npb24nLCAnYW1iaWVudCcsICdkaWZmdXNlJywgJ3NwZWN1bGFyJ10pIHtcbiAgICAgICAgICAgIGlmIChjb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWdbcHJvcF0udGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTogY29uZmlnW3Byb3BdLnRleHR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjb25maWdbcHJvcF0ubWFwcGluZyB8fCAnc3BoZXJlbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBHTFNMLmV4cGFuZFZlYzMoY29uZmlnW3Byb3BdLnNjYWxlICE9IG51bGwgPyBjb25maWdbcHJvcF0uc2NhbGUgOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogR0xTTC5leHBhbmRWZWM0KGNvbmZpZ1twcm9wXS5hbW91bnQgIT0gbnVsbCA/IGNvbmZpZ1twcm9wXS5hbW91bnQgOiAxKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnW3Byb3BdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BdID0geyBhbW91bnQ6IEdMU0wuZXhwYW5kVmVjNChjb25maWdbcHJvcF0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25maWdbcHJvcF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSB7IGFtb3VudDogU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWdbcHJvcF0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BdID0gY29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJhIHNwZWN1bGFyIHByb3BzXG4gICAgICAgIGlmICh0aGlzLnNwZWN1bGFyKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyLnNoaW5pbmVzcyA9IGNvbmZpZy5zaGluaW5lc3MgPyBwYXJzZUZsb2F0KGNvbmZpZy5zaGluaW5lc3MpIDogMC4yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ybWFsIG1hcHBpbmdcbiAgICAgICAgaWYgKGNvbmZpZy5ub3JtYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwgPSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZTogY29uZmlnLm5vcm1hbC50ZXh0dXJlLFxuICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNvbmZpZy5ub3JtYWwubWFwcGluZyB8fCAndHJpcGxhbmFyJyxcbiAgICAgICAgICAgICAgICBzY2FsZTogR0xTTC5leHBhbmRWZWMzKGNvbmZpZy5ub3JtYWwuc2NhbGUgIT0gbnVsbCA/IGNvbmZpZy5ub3JtYWwuc2NhbGUgOiAxKSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGNvbmZpZy5ub3JtYWwuYW1vdW50ICE9IG51bGwgPyBjb25maWcubm9ybWFsLmFtb3VudCA6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgYSBtYXRlcmlhbCBjb25maWcgYmxvY2sgaGFzIHN1ZmZpY2llbnQgcHJvcGVydGllcyB0byBjcmVhdGUgYSBtYXRlcmlhbFxuICAgIHN0YXRpYyBpc1ZhbGlkIChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmVtaXNzaW9uID09IG51bGwgJiZcbiAgICAgICAgICAgIGNvbmZpZy5hbWJpZW50ID09IG51bGwgJiZcbiAgICAgICAgICAgIGNvbmZpZy5kaWZmdXNlID09IG51bGwgJiZcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjdWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbmplY3QgKHN0eWxlKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIHByb3BlcnR5LCBzZXRzIGRlZmluZXMgdG8gY29uZmlndXJlIHRleHR1cmUgbWFwcGluZywgd2l0aCBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0UsIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFLCBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9TUEhFUkVNQVBcbiAgICAgICAgLy8gQWxzbyBzZXRzIGZsYWdzIHRvIGtlZXAgdHJhY2sgb2YgZWFjaCB1bmlxdWUgbWFwcGluZyB0eXBlIGJlaW5nIHVzZWQsIGUuZy46XG4gICAgICAgIC8vICAgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxuICAgICAgICAvLyBFbmFibGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgaWYgbmVlZGVkIGFuZCBub3QgYWxyZWFkeSBvblxuICAgICAgICBmb3IgKGxldCBwcm9wIG9mIFsnZW1pc3Npb24nLCAnYW1iaWVudCcsICdkaWZmdXNlJywgJ3NwZWN1bGFyJ10pIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBgVEFOR1JBTV9NQVRFUklBTF8ke3Byb3AudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgICAgbGV0IHRleGRlZiA9IGRlZiArICdfVEVYVFVSRSc7XG4gICAgICAgICAgICBzdHlsZS5kZWZpbmVzW2RlZl0gPSAodGhpc1twcm9wXSAhPSBudWxsKTtcbiAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdICYmIHRoaXNbcHJvcF0udGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbdGV4ZGVmXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1t0ZXhkZWYgKyAnXycgKyB0aGlzW3Byb3BdLm1hcHBpbmcudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbYFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV8ke3RoaXNbcHJvcF0ubWFwcGluZy50b1VwcGVyQ2FzZSgpfWBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXhjb29yZHMgPSBzdHlsZS50ZXhjb29yZHMgfHwgKHRoaXNbcHJvcF0ubWFwcGluZyA9PT0gJ3V2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWwgbWFwcGluZ1xuICAgICAgICAvLyBBcyBhbm92ZSwgc2V0cyBmbGFncyB0byBrZWVwIHRyYWNrIG9mIGVhY2ggdW5pcXVlIG1hcHBpbmcgdHlwZSBiZWluZyB1c2VkLCBlLmcuOlxuICAgICAgICAvLyAgIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9TUEhFUkVNQVBcbiAgICAgICAgaWYgKHRoaXMubm9ybWFsICYmIHRoaXMubm9ybWFsLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkUnXSA9IHRydWU7XG4gICAgICAgICAgICBzdHlsZS5kZWZpbmVzWydUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXycgKyB0aGlzLm5vcm1hbC5tYXBwaW5nLnRvVXBwZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbYFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV8ke3RoaXMubm9ybWFsLm1hcHBpbmcudG9VcHBlckNhc2UoKX1gXSA9IHRydWU7XG4gICAgICAgICAgICBzdHlsZS50ZXhjb29yZHMgPSBzdHlsZS50ZXhjb29yZHMgfHwgKHRoaXMubm9ybWFsLm1hcHBpbmcgPT09ICd1dicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUucmVwbGFjZVNoYWRlckJsb2NrKE1hdGVyaWFsLmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL21hdGVyaWFsJ10pO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggcHJvcGVydHksIHNldHMgdW5pZm9ybXMgaW4gdGhlIHBhdHRlcm46XG4gICAgICAgIC8vIHVfbWF0ZXJpYWwuZGlmZnVzZSwgdV9tYXRlcmlhbC5kaWZmdXNlU2NhbGUgdV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmVcbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBbJ2VtaXNzaW9uJywgJ2FtYmllbnQnLCAnZGlmZnVzZScsICdzcGVjdWxhciddKSB7XG4gICAgICAgICAgICBpZiAodGhpc1twcm9wXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Byb2dyYW0uc2V0VGV4dHVyZVVuaWZvcm0oYHVfbWF0ZXJpYWxfJHtwcm9wfV90ZXh0dXJlYCwgdGhpc1twcm9wXS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnM2Z2JywgYHVfbWF0ZXJpYWwuJHtwcm9wfVNjYWxlYCwgdGhpc1twcm9wXS5zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1X21hdGVyaWFsLiR7cHJvcH1gLCB0aGlzW3Byb3BdLmFtb3VudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW3Byb3BdLmFtb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV9tYXRlcmlhbC4ke3Byb3B9YCwgdGhpc1twcm9wXS5hbW91bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dHJhIHNwZWN1bGFyIHByb3BzXG4gICAgICAgIGlmICh0aGlzLnNwZWN1bGFyKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21hdGVyaWFsLnNoaW5pbmVzcycsIHRoaXMuc3BlY3VsYXIuc2hpbmluZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcm1hbCBtYXBwaW5nXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbCAmJiB0aGlzLm5vcm1hbC50ZXh0dXJlKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS5zZXRUZXh0dXJlVW5pZm9ybSgndV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZScsIHRoaXMubm9ybWFsLnRleHR1cmUpO1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnM2Z2JywgJ3VfbWF0ZXJpYWwubm9ybWFsU2NhbGUnLCB0aGlzLm5vcm1hbC5zY2FsZSk7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21hdGVyaWFsLm5vcm1hbEFtb3VudCcsIHRoaXMubm9ybWFsLmFtb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk1hdGVyaWFsLmJsb2NrID0gJ21hdGVyaWFsJztcbiIsIi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXG5cbi8vIE1vZHVsZXMgYW5kIGRlcGVuZGVuY2llcyB0byBleHBvc2UgaW4gdGhlIHB1YmxpYyBUYW5ncmFtIG1vZHVsZVxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuXG4vLyBUaGUgbGVhZmxldCBsYXllciBwbHVnaW4gaXMgY3VycmVudGx5IHRoZSBwcmltYXJ5IHB1YmxpYyBBUElcbmltcG9ydCB7TGVhZmxldExheWVyLCBsZWFmbGV0TGF5ZXJ9IGZyb20gJy4vbGVhZmxldF9sYXllcic7XG5cbi8vIFRoZSBzY2VuZSB3b3JrZXIgaXMgb25seSBhY3RpdmF0ZWQgd2hlbiBhIHdvcmtlciB0aHJlYWQgaXMgaW5zdGFudGlhdGVkLCBidXQgbXVzdCBhbHdheXMgYmUgbG9hZGVkXG5pbXBvcnQge1NjZW5lV29ya2VyfSBmcm9tICcuLi9zcmMvc2NlbmVfd29ya2VyJztcblxuLy8gQWRkaXRpb25hbCBtb2R1bGVzIGFyZSBleHBvc2VkIGZvciBkZWJ1Z2dpbmdcbmltcG9ydCB2ZXJzaW9uIGZyb20gJy4vdXRpbHMvdmVyc2lvbic7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9kYXRhX3NvdXJjZSc7XG5pbXBvcnQgVGlsZU1hbmFnZXIgZnJvbSAnLi90aWxlX21hbmFnZXInO1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xuaW1wb3J0IFZlcnRleERhdGEgZnJvbSAnLi9nbC92ZXJ0ZXhfZGF0YSc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuaW1wb3J0IE1hdGVyaWFsIGZyb20gJy4vbWF0ZXJpYWwnO1xuaW1wb3J0IExpZ2h0IGZyb20gJy4vbGlnaHQnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IHtydWxlQ2FjaGV9IGZyb20gJy4vc3R5bGVzL3J1bGUnO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcbmltcG9ydCBGZWF0dXJlU2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJztcblxuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XG5cbi8vIERlZmF1bHQgdG8gNjQtYml0IGJlY2F1c2Ugd2UgbmVlZCB0aGUgZXh0cmEgcHJlY2lzaW9uIHdoZW4gbXVsdGlwbHlpbmcgbWF0cmljZXMgdy9tZXJjYXRvciBwcm9qZWN0ZWQgdmFsdWVzXG5nbE1hdHJpeC5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoRmxvYXQ2NEFycmF5KTtcblxuLy8gTWFrZSBzb21lIG1vZHVsZXMgYWNjZXNzaWJsZSBmb3IgZGVidWdnaW5nXG52YXIgZGVidWcgPSB7XG4gICAgbG9nLFxuICAgIFV0aWxzLFxuICAgIEdlbyxcbiAgICBEYXRhU291cmNlLFxuICAgIFRpbGVNYW5hZ2VyLFxuICAgIEdMU0wsXG4gICAgU2hhZGVyUHJvZ3JhbSxcbiAgICBWZXJ0ZXhEYXRhLFxuICAgIFRleHR1cmUsXG4gICAgTWF0ZXJpYWwsXG4gICAgTGlnaHQsXG4gICAgU2NlbmVXb3JrZXIsXG4gICAgV29ya2VyQnJva2VyLFxuICAgIHJ1bGVDYWNoZSxcbiAgICBTdHlsZU1hbmFnZXIsXG4gICAgU3R5bGVQYXJzZXIsXG4gICAgRmVhdHVyZVNlbGVjdGlvblxufTtcblxuLy8gV2luZG93IGNhbiBvbmx5IGJlIHNldCBpbiBtYWluIHRocmVhZFxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgIC8vIE1haW4gdGhyZWFkIG9iamVjdHMgdGhhdCBjYW4gYmUgY2FsbGVkIGZyb20gd29ya2Vyc1xuICAgIFdvcmtlckJyb2tlci5hZGRUYXJnZXQoJ1RleHR1cmUnLCBUZXh0dXJlKTtcblxuICAgIHdpbmRvdy5UYW5ncmFtID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIExlYWZsZXRMYXllcixcbiAgICAgICAgbGVhZmxldExheWVyLFxuICAgICAgICBkZWJ1ZyxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbi5zdHJpbmdcbiAgICB9O1xuXG59XG5cbmlmIChVdGlscy5pc1dvcmtlclRocmVhZCkge1xuICAgIHNlbGYuVGFuZ3JhbSA9IHtcbiAgICAgICAgZGVidWcsXG4gICAgICAgIHZlcnNpb246IHZlcnNpb24uc3RyaW5nXG4gICAgfTtcbn1cblxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgIFV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZVBvbHlmaWxsKCk7XG59XG5cbi8vIFNldHVwIGxvZ2dpbmcgdG8gcHJlZml4IHdpdGggVGFuZ3JhbSB2ZXJzaW9uXG52YXIgb3JpZ2luYWxGYWN0b3J5ID0gbG9nLm1ldGhvZEZhY3Rvcnk7XG5sb2cubWV0aG9kRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBsb2dMZXZlbCkge1xuICAgIHZhciByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgbG9nTGV2ZWwpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4ubWVzc2FnZSkge1xuICAgICAgICByYXdNZXRob2QoYFRhbmdyYW0gJHt2ZXJzaW9uLnN0cmluZ306IGAsIC4uLm1lc3NhZ2UpO1xuICAgIH07XG59O1xuIiwiLypnbG9iYWwgU2NlbmUgKi9cbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IHN1YnNjcmliZU1peGluIGZyb20gJy4vdXRpbHMvc3Vic2NyaWJlJztcbmltcG9ydCBDb250ZXh0IGZyb20gJy4vZ2wvY29udGV4dCc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuaW1wb3J0IFZlcnRleEFycmF5T2JqZWN0IGZyb20gJy4vZ2wvdmFvJztcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vY2FtZXJhJztcbmltcG9ydCBMaWdodCBmcm9tICcuL2xpZ2h0JztcbmltcG9ydCBUaWxlTWFuYWdlciBmcm9tICcuL3RpbGVfbWFuYWdlcic7XG5pbXBvcnQgRGF0YVNvdXJjZSBmcm9tICcuL2RhdGFfc291cmNlJztcbmltcG9ydCBGZWF0dXJlU2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJztcblxuaW1wb3J0IHtQb2x5Z29uc30gZnJvbSAnLi9zdHlsZXMvcG9seWdvbnMvcG9seWdvbnMnO1xuaW1wb3J0IHtMaW5lc30gZnJvbSAnLi9zdHlsZXMvbGluZXMvbGluZXMnO1xuaW1wb3J0IHtQb2ludHN9IGZyb20gJy4vc3R5bGVzL3BvaW50cy9wb2ludHMnO1xuaW1wb3J0IHtUZXh0U3R5bGV9IGZyb20gJy4vc3R5bGVzL3RleHQvdGV4dCc7XG5cbi8vIEFkZCBidWlsdC1pbiByZW5kZXJpbmcgc3R5bGVzXG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIoUG9seWdvbnMpO1xuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKExpbmVzKTtcblN0eWxlTWFuYWdlci5yZWdpc3RlcihQb2ludHMpO1xuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKFRleHRTdHlsZSk7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XG5sZXQgbWF0NCA9IGdsTWF0cml4Lm1hdDQ7XG5sZXQgbWF0MyA9IGdsTWF0cml4Lm1hdDM7XG5sZXQgdmVjMyA9IGdsTWF0cml4LnZlYzM7XG5cbi8vIExvYWQgc2NlbmUgZGVmaW5pdGlvbjogcGFzcyBhbiBvYmplY3QgZGlyZWN0bHksIG9yIGEgVVJMIGFzIHN0cmluZyB0byBsb2FkIHJlbW90ZWx5XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBzdWJzY3JpYmVNaXhpbih0aGlzKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyID0gVGlsZU1hbmFnZXI7XG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLmluaXQodGhpcyk7XG4gICAgICAgIHRoaXMubnVtX3dvcmtlcnMgPSBvcHRpb25zLm51bVdvcmtlcnMgfHwgMjtcbiAgICAgICAgdGhpcy5jb250aW51b3VzX3pvb20gPSAodHlwZW9mIG9wdGlvbnMuY29udGludW91c1pvb20gPT09ICdib29sZWFuJykgPyBvcHRpb25zLmNvbnRpbnVvdXNab29tIDogdHJ1ZTtcbiAgICAgICAgdGhpcy50aWxlX3NpbXBsaWZpY2F0aW9uX2xldmVsID0gMDsgLy8gbGV2ZWwtb2YtZGV0YWlsIGRvd25zYW1wbGluZyB0byBhcHBseSB0byB0aWxlIGxvYWRpbmdcbiAgICAgICAgdGhpcy5hbGxvd19jcm9zc19kb21haW5fd29ya2VycyA9IChvcHRpb25zLmFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICAgIHRoaXMud29ya2VyX3VybCA9IG9wdGlvbnMud29ya2VyVXJsO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlVmVydGV4QXJyYXlPYmplY3RzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBVdGlscy51c2VfaGlnaF9kZW5zaXR5X2Rpc3BsYXkgPSBvcHRpb25zLmhpZ2hEZW5zaXR5RGlzcGxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5oaWdoRGVuc2l0eURpc3BsYXkgOiB0cnVlO1xuICAgICAgICBVdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZ19zb3VyY2UgPSBjb25maWdfc291cmNlO1xuICAgICAgICB0aGlzLmNvbmZpZ19zZXJpYWxpemVkID0gbnVsbDtcblxuICAgICAgICB0aGlzLnN0eWxlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0eWxlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYWNrcyBjdXJyZW50IHNjZW5lIGJ1aWxkaW5nIHN0YXRlICh0aWxlcyBiZWluZyBidWlsdCwgZXRjLilcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBhIHJlZHJhd1xuICAgICAgICB0aGlzLmFuaW1hdGVkID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IHJlZHJhdyBldmVyeSBmcmFtZVxuICAgICAgICB0aGlzLnByZVVwZGF0ZSA9IG9wdGlvbnMucHJlVXBkYXRlOyAgICAgICAgICAgICAvLyBvcHRpb25hbCBwcmUtcmVuZGVyIGxvb3AgaG9va1xuICAgICAgICB0aGlzLnBvc3RVcGRhdGUgPSBvcHRpb25zLnBvc3RVcGRhdGU7ICAgICAgICAgICAvLyBvcHRpb25hbCBwb3N0LXJlbmRlciBsb29wIGhvb2tcbiAgICAgICAgdGhpcy5yZW5kZXJfbG9vcCA9ICFvcHRpb25zLmRpc2FibGVSZW5kZXJMb29wOyAgLy8gZGlzYWJsZSByZW5kZXIgbG9vcCAtIGFwcCB3aWxsIGhhdmUgdG8gbWFudWFsbHkgY2FsbCBTY2VuZS5yZW5kZXIoKSBwZXIgZnJhbWVcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lKCk7XG5cbiAgICAgICAgdGhpcy56b29tID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tID0gMTtcbiAgICAgICAgdGhpcy5wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5jYW1lcmEgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cbiAgICAgICAgLy8gTW9kZWwtdmlldyBtYXRyaWNlc1xuICAgICAgICAvLyA2NC1iaXQgdmVyc2lvbnMgYXJlIGZvciBDUFUgY2FsY3VhdGlvbnNcbiAgICAgICAgLy8gMzItYml0IHZlcnNpb25zIGFyZSBkb3duc2FtcGxlZCBhbmQgc2VudCB0byBHUFVcbiAgICAgICAgdGhpcy5tb2RlbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLm1vZGVsTWF0cml4MzIgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXggPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICB0aGlzLm5vcm1hbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoOSk7XG4gICAgICAgIHRoaXMubm9ybWFsTWF0cml4MzIgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0dXJlX2xpc3RlbmVyID0gbnVsbDtcblxuICAgICAgICAvLyBEZWJ1ZyBjb25maWdcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IHtcbiAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeV9idWlsZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRpbmcgPSAwO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb24gPSAwOyAvLyBhbiBpZCB0aGF0IGlzIGluY3JlbWVudGVkIGVhY2ggdGltZSB0aGUgc2NlbmUgY29uZmlnIGlzIGludmFsaWRhdGVkXG5cbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IG9wdGlvbnMubG9nTGV2ZWwgfHwgJ3dhcm4nO1xuICAgICAgICBsb2cuc2V0TGV2ZWwodGhpcy5sb2dMZXZlbCk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gTG9hZCBzY2VuZSBkZWZpbml0aW9uIChzb3VyY2VzLCBzdHlsZXMsIGV0Yy4pLCB0aGVuIGNyZWF0ZSBzdHlsZXMgJiB3b3JrZXJzXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5pbml0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5sb2FkU2NlbmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVdvcmtlcnMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgRmVhdHVyZVNlbGVjdGlvbih0aGlzLmdsLCB0aGlzLndvcmtlcnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZV9saXN0ZW5lciA9IHsgdXBkYXRlOiAoKSA9PiB0aGlzLmRpcnR5ID0gdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICBUZXh0dXJlLnN1YnNjcmliZSh0aGlzLnRleHR1cmVfbGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWRzIHJlbmRlcmluZyBzdHlsZXMgZnJvbSBjb25maWcsIHNldHMgR0wgY29udGV4dCBhbmQgY29tcGlsZXMgcHJvZ3JhbXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb25maWcoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9sb29wICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cFJlbmRlckxvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlckxvb3AgPSAoKSA9PiB7fTsgLy8gc2V0IHRvIG5vLW9wIGJlY2F1c2UgYSBudWxsIGNhbiBjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gdGhyb3dcblxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQWxsKCk7IC8vIGNsZWFyIGFsbCBldmVudCBsaXN0ZW5lcnNcblxuICAgICAgICBUZXh0dXJlLnVuc3Vic2NyaWJlKHRoaXMudGV4dHVyZV9saXN0ZW5lcik7XG4gICAgICAgIHRoaXMudGV4dHVyZV9saXN0ZW5lciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZibyk7XG4gICAgICAgICAgICB0aGlzLmZibyA9IG51bGw7XG5cbiAgICAgICAgICAgIFRleHR1cmUuZGVzdHJveSh0aGlzLmdsKTtcbiAgICAgICAgICAgIFN0eWxlTWFuYWdlci5kZXN0cm95KHRoaXMuZ2wpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvdXJjZXMgPSB7fTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLndvcmtlcnMpKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aWxlX21hbmFnZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuXG4gICAgICAgIC8vIEZvcmNlIHRhbmdyYW0gY2FudmFzIHVuZGVybmVhdGggYWxsIGxlYWZsZXQgbGF5ZXJzLCBhbmQgc2V0IGJhY2tncm91bmQgdG8gdHJhbnNwYXJlbnRcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IHRyYW5zcGFyZW50Oyc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IENvbnRleHQuZ2V0Q29udGV4dCh0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgIGFscGhhOiBmYWxzZSAvKnByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UqLyxcbiAgICAgICAgICAgICAgICBkZXZpY2VfcGl4ZWxfcmF0aW86IFV0aWxzLmRldmljZV9waXhlbF9yYXRpb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ291bGRuJ3QgY3JlYXRlIFdlYkdMIGNvbnRleHQuIFwiICtcbiAgICAgICAgICAgICAgICBcIllvdXIgYnJvd3NlciBtYXkgbm90IHN1cHBvcnQgV2ViR0wsIG9yIGl0J3MgdHVybmVkIG9mZj8gXCIgK1xuICAgICAgICAgICAgICAgIFwiVmlzaXQgaHR0cDovL3dlYmdscmVwb3J0LmNvbS8gZm9yIG1vcmUgaW5mby5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzaXplTWFwKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLCB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xuICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5pbml0KHRoaXMuZ2wpO1xuICAgIH1cblxuICAgIGNyZWF0ZU9iamVjdFVSTCgpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cuVVJMICYmIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKSB8fCAod2luZG93LndlYmtpdFVSTCAmJiB3aW5kb3cud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTCk7XG4gICAgfVxuXG4gICAgbG9hZFdvcmtlclVybChzY2VuZSkge1xuICAgICAgICB2YXIgd29ya2VyX3VybCA9IHNjZW5lLndvcmtlcl91cmwgfHwgVXRpbHMuZmluZEN1cnJlbnRVUkwoJ3RhbmdyYW0uZGVidWcuanMnLCAndGFuZ3JhbS5taW4uanMnKSxcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFVSTCA9IHNjZW5lLmNyZWF0ZU9iamVjdFVSTCgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXdvcmtlcl91cmwpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ2FuJ3QgbG9hZCB3b3JrZXIgYmVjYXVzZSBjb3VsZG4ndCBmaW5kIGJhc2UgVVJMIHRoYXQgbGlicmFyeSB3YXMgbG9hZGVkIGZyb21cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNyZWF0ZU9iamVjdFVSTCAmJiBzY2VuZS5hbGxvd19jcm9zc19kb21haW5fd29ya2Vycykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYGltcG9ydFNjcmlwdHMoJyR7d29ya2VyX3VybH0nKTtgO1xuICAgICAgICAgICAgICAgIHZhciB3b3JrZXJfbG9jYWxfdXJsID0gY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUod29ya2VyX2xvY2FsX3VybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUod29ya2VyX3VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdlYiB3b3JrZXJzIGhhbmRsZSBoZWF2eSBkdXR5IHRpbGUgY29uc3RydWN0aW9uOiBuZXR3b3JraW5nLCBnZW9tZXRyeSBwcm9jZXNzaW5nLCBldGMuXG4gICAgY3JlYXRlV29ya2VycygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZFdvcmtlclVybCh0aGlzKS50aGVuKCh3b3JrZXJfdXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlV29ya2Vycyh3b3JrZXJfdXJsKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSW5zdGFudGlhdGUgd29ya2VycyBmcm9tIFVSTCwgaW5pdCBldmVudCBoYW5kbGVyc1xuICAgIG1ha2VXb3JrZXJzKHVybCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcblxuICAgICAgICB0aGlzLndvcmtlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaWQ9MDsgaWQgPCB0aGlzLm51bV93b3JrZXJzOyBpZCsrKSB7XG4gICAgICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJzW2lkXSA9IHdvcmtlcjtcblxuICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLndvcmtlckxvZ01lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyKHdvcmtlcik7XG5cbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmUubWFrZVdvcmtlcnM6IGluaXRpYWxpemluZyB3b3JrZXIgJHtpZH1gKTtcbiAgICAgICAgICAgIGxldCBfaWQgPSBpZDtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ2luaXQnLCBpZCwgdGhpcy5udW1fd29ya2VycywgVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvKS50aGVuKFxuICAgICAgICAgICAgICAgIChpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoYFNjZW5lLm1ha2VXb3JrZXJzOiBpbml0aWFsaXplZCB3b3JrZXIgJHtpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU2NlbmUubWFrZVdvcmtlcnM6IGZhaWxlZCB0byBpbml0aWFsaXplIHdvcmtlciAke19pZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZXh0X3dvcmtlciA9IDA7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZSk7XG4gICAgfVxuXG4gICAgLy8gUm91bmQgcm9iaW4gc2VsZWN0aW9uIG9mIG5leHQgd29ya2VyXG4gICAgbmV4dFdvcmtlcigpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHRoaXMud29ya2Vyc1t0aGlzLm5leHRfd29ya2VyXTtcbiAgICAgICAgdGhpcy5uZXh0X3dvcmtlciA9ICh0aGlzLm5leHRfd29ya2VyICsgMSkgJSB0aGlzLndvcmtlcnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBTZXQgdGhlIG1hcCB2aWV3LCBjYW4gYmUgcGFzc2VkIGFuIG9iamVjdCB3aXRoIGxhdC9sbmcgYW5kL29yIHpvb21cbiAgICAqL1xuICAgIHNldFZpZXcoeyBsbmcsIGxhdCwgem9vbSB9ID0ge30pIHtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBTZXQgY2VudGVyXG4gICAgICAgIGlmICh0eXBlb2YgbG5nID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNlbnRlciB8fCBsbmcgIT09IHRoaXMuY2VudGVyLmxuZyB8fCBsYXQgIT09IHRoaXMuY2VudGVyLmxhdCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyID0geyBsbmc6IEdlby53cmFwTG5nKGxuZyksIGxhdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHpvb21cbiAgICAgICAgaWYgKHR5cGVvZiB6b29tID09PSAnbnVtYmVyJyAmJiB6b29tICE9PSB0aGlzLnpvb20pIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRab29tKHpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgc3RhcnRab29tKCkge1xuICAgICAgICB0aGlzLmxhc3Rfem9vbSA9IHRoaXMuem9vbTtcbiAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaG9vc2UgdGhlIGJhc2Ugem9vbSBsZXZlbCB0byB1c2UgZm9yIGEgZ2l2ZW4gZnJhY3Rpb25hbCB6b29tXG4gICAgYmFzZVpvb20oem9vbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih6b29tKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYSBnaXZlbiB2aWV3IHpvb20sIHdoYXQgdGlsZSB6b29tIHNob3VsZCBiZSBsb2FkZWQ/XG4gICAgdGlsZVpvb20odmlld196b29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2Vab29tKHZpZXdfem9vbSkgLSB0aGlzLnRpbGVfc2ltcGxpZmljYXRpb25fbGV2ZWw7XG4gICAgfVxuXG4gICAgLy8gRm9yIGEgZ2l2ZW4gdGlsZSB6b29tLCB3aGF0IHN0eWxlIHpvb20gc2hvdWxkIGJlIHVzZWQ/XG4gICAgc3R5bGVab29tKHRpbGVfem9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlWm9vbSh0aWxlX3pvb20pICsgdGhpcy50aWxlX3NpbXBsaWZpY2F0aW9uX2xldmVsO1xuICAgIH1cblxuICAgIHNldFpvb20oem9vbSkge1xuICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRpbGVfem9vbSA9IHRoaXMudGlsZVpvb20oem9vbSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRpbnVvdXNfem9vbSkge1xuICAgICAgICAgICAgem9vbSA9IHRpbGVfem9vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aWxlX3pvb20gIT09IHRoaXMudGlsZVpvb20odGhpcy5sYXN0X3pvb20pKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGlsZXMgb3V0c2lkZSBjdXJyZW50IHpvb20gdGhhdCBhcmUgc3RpbGwgbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy50aWxlX21hbmFnZXIucmVtb3ZlVGlsZXModGlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbGUubG9hZGluZyAmJiB0aGlzLnRpbGVab29tKHRpbGUuY29vcmRzLnopICE9PSB0aWxlX3pvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLnRyYWNlKGByZW1vdmVkICR7dGlsZS5rZXl9ICh3YXMgbG9hZGluZywgYnV0IG91dHNpZGUgY3VycmVudCB6b29tKWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdF96b29tID0gdGhpcy56b29tO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnRpbGVfem9vbSA9IHRpbGVfem9vbTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHZpZXdSZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3NzX3NpemUgPT0gbnVsbCB8fCB0aGlzLmNlbnRlciA9PSBudWxsIHx8IHRoaXMuem9vbSA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHRoaXMuc291cmNlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB2aWV3cG9ydCBib3VuZHMgYmFzZWQgb24gY3VycmVudCBjZW50ZXIgYW5kIHpvb21cbiAgICB1cGRhdGVCb3VuZHMoKSB7XG4gICAgICAgIC8vIFRPRE86IGJldHRlciBjb25jZXB0IG9mIFwicmVhZGluZXNzXCIgc3RhdGU/XG4gICAgICAgIGlmICghdGhpcy52aWV3UmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXRlcnNfcGVyX3BpeGVsID0gR2VvLm1ldGVyc1BlclBpeGVsKHRoaXMuem9vbSk7XG5cbiAgICAgICAgLy8gU2l6ZSBvZiB0aGUgaGFsZi12aWV3cG9ydCBpbiBtZXRlcnMgYXQgY3VycmVudCB6b29tXG4gICAgICAgIHRoaXMudmlld3BvcnRfbWV0ZXJzID0ge1xuICAgICAgICAgICAgeDogdGhpcy5jc3Nfc2l6ZS53aWR0aCAqIHRoaXMubWV0ZXJzX3Blcl9waXhlbCxcbiAgICAgICAgICAgIHk6IHRoaXMuY3NzX3NpemUuaGVpZ2h0ICogdGhpcy5tZXRlcnNfcGVyX3BpeGVsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2VudGVyIG9mIHZpZXdwb3J0IGluIG1ldGVycywgYW5kIHRpbGVcbiAgICAgICAgbGV0IFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyhbdGhpcy5jZW50ZXIubG5nLCB0aGlzLmNlbnRlci5sYXRdKTtcbiAgICAgICAgdGhpcy5jZW50ZXJfbWV0ZXJzID0geyB4LCB5IH07XG5cbiAgICAgICAgbGV0IHogPSB0aGlzLnRpbGVab29tKHRoaXMuem9vbSk7XG4gICAgICAgIHRoaXMuY2VudGVyX3RpbGUgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5jZW50ZXJfbWV0ZXJzLngsIHRoaXMuY2VudGVyX21ldGVycy55XSwgeik7XG5cbiAgICAgICAgdGhpcy5ib3VuZHNfbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3c6IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmNlbnRlcl9tZXRlcnMueCAtIHRoaXMudmlld3BvcnRfbWV0ZXJzLnggLyAyLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuY2VudGVyX21ldGVycy55IC0gdGhpcy52aWV3cG9ydF9tZXRlcnMueSAvIDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZToge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyX21ldGVycy54ICsgdGhpcy52aWV3cG9ydF9tZXRlcnMueCAvIDIsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5jZW50ZXJfbWV0ZXJzLnkgKyB0aGlzLnZpZXdwb3J0X21ldGVycy55IC8gMlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnVwZGF0ZVRpbGVzRm9yVmlldygpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignbW92ZScpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmaW5kVmlzaWJsZVRpbGVDb29yZGluYXRlcyh7IGJ1ZmZlciB9ID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kc19tZXRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB6ID0gdGhpcy50aWxlWm9vbSh0aGlzLnpvb20pO1xuICAgICAgICBsZXQgc3cgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5ib3VuZHNfbWV0ZXJzLnN3LngsIHRoaXMuYm91bmRzX21ldGVycy5zdy55XSwgeik7XG4gICAgICAgIGxldCBuZSA9IEdlby50aWxlRm9yTWV0ZXJzKFt0aGlzLmJvdW5kc19tZXRlcnMubmUueCwgdGhpcy5ib3VuZHNfbWV0ZXJzLm5lLnldLCB6KTtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyIHx8IDA7XG5cbiAgICAgICAgbGV0IGNvb3JkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB4ID0gc3cueCAtIGJ1ZmZlcjsgeCA8PSBuZS54ICsgYnVmZmVyOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSBuZS55IC0gYnVmZmVyOyB5IDw9IHN3LnkgKyBidWZmZXI7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKHsgeCwgeSwgeiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aWxlcyB0b28gZmFyIG91dHNpZGUgb2Ygdmlld1xuICAgIHBydW5lVGlsZUNvb3JkaW5hdGVzRm9yVmlldyhib3JkZXJfYnVmZmVyID0gMikge1xuICAgICAgICBpZiAoIXRoaXMudmlld1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aWxlcyB0aGF0IGFyZSBhIHNwZWNpZmllZCAjIG9mIHRpbGVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGJvcmRlclxuICAgICAgICBsZXQgYm9yZGVyX3RpbGVzID0gW1xuICAgICAgICAgICAgTWF0aC5jZWlsKChNYXRoLmZsb29yKHRoaXMuY3NzX3NpemUud2lkdGggLyBHZW8udGlsZV9zaXplKSArIDIpIC8gMiksXG4gICAgICAgICAgICBNYXRoLmNlaWwoKE1hdGguZmxvb3IodGhpcy5jc3Nfc2l6ZS5oZWlnaHQgLyBHZW8udGlsZV9zaXplKSArIDIpIC8gMilcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IHN0eWxlX3pvb20gPSB0aGlzLnRpbGVab29tKHRoaXMuem9vbSk7XG5cbiAgICAgICAgdGhpcy50aWxlX21hbmFnZXIucmVtb3ZlVGlsZXModGlsZSA9PiB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdmlzaWJsZSB0aWxlc1xuICAgICAgICAgICAgaWYgKHRpbGUudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzY2FyZCBpZiB0b28gZmFyIGZyb20gY3VycmVudCB6b29tXG4gICAgICAgICAgICBsZXQgemRpZmYgPSB0aWxlLmNvb3Jkcy56IC0gc3R5bGVfem9vbTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh6ZGlmZikgPiB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aWxlcyBhdCBkaWZmZXJlbnQgem9vbXNcbiAgICAgICAgICAgIGxldCB6dHJhbnMgPSBNYXRoLnBvdygyLCB6ZGlmZik7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGguZmxvb3IodGlsZS5jb29yZHMueCAvIHp0cmFucyksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5mbG9vcih0aWxlLmNvb3Jkcy55IC8genRyYW5zKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRGlzY2FyZCB0aWxlcyBvdXRzaWRlIGFuIGFyZWEgc3Vycm91bmRpbmcgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29vcmRzLnggLSB0aGlzLmNlbnRlcl90aWxlLngpIC0gYm9yZGVyX3RpbGVzWzBdID4gYm9yZGVyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgU2NlbmU6IHJlbW92ZSB0aWxlICR7dGlsZS5rZXl9IChhcyAke2Nvb3Jkcy54fS8ke2Nvb3Jkcy55fS8ke3N0eWxlX3pvb219KSBmb3IgYmVpbmcgdG9vIGZhciBvdXQgb2YgdmlzaWJsZSBhcmVhICoqKmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoY29vcmRzLnkgLSB0aGlzLmNlbnRlcl90aWxlLnkpIC0gYm9yZGVyX3RpbGVzWzFdID4gYm9yZGVyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgU2NlbmU6IHJlbW92ZSB0aWxlICR7dGlsZS5rZXl9IChhcyAke2Nvb3Jkcy54fS8ke2Nvb3Jkcy55fS8ke3N0eWxlX3pvb219KSBmb3IgYmVpbmcgdG9vIGZhciBvdXQgb2YgdmlzaWJsZSBhcmVhICoqKmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNpemVNYXAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNzc19zaXplID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICAgIHRoaXMuZGV2aWNlX3NpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh0aGlzLmNzc19zaXplLndpZHRoICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmNzc19zaXplLmhlaWdodCAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbylcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52aWV3X2FzcGVjdCA9IHRoaXMuY3NzX3NpemUud2lkdGggLyB0aGlzLmNzc19zaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5jc3Nfc2l6ZS53aWR0aCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLmNzc19zaXplLmhlaWdodCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuZGV2aWNlX3NpemUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmRldmljZV9zaXplLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVxdWVzdCBzY2VuZSBiZSByZWRyYXduIGF0IG5leHQgYW5pbWF0aW9uIGxvb3BcbiAgICByZXF1ZXN0UmVkcmF3KCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBSZWRyYXcgc2NlbmUgaW1tZWRpYXRlbHkgLSBkb24ndCB3YWl0IGZvciBhbmltYXRpb24gbG9vcFxuICAgIC8vIFVzZSBzcGFyaW5nbHksIGJ1dCBmb3IgY2FzZXMgd2hlcmUgeW91IG5lZWQgdGhlIGNsb3Nlc3QgcG9zc2libGUgc3luYyB3aXRoIG90aGVyIFVJIGVsZW1lbnRzLFxuICAgIC8vIHN1Y2ggYXMgb3RoZXIsIG5vbi1XZWJHTCBtYXAgbGF5ZXJzIChlLmcuIExlYWZsZXQgcmFzdGVyIGxheWVycywgbWFya2VycywgZXRjLilcbiAgICBpbW1lZGlhdGVSZWRyYXcoKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHRoZSByZW5kZXIgbG9vcFxuICAgIHNldHVwUmVuZGVyTG9vcCh7IHByZV9yZW5kZXIsIHBvc3RfcmVuZGVyIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnJlbmRlckxvb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgc2NlbmVcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHRoZSBuZXh0IGZyYW1lXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyTG9vcCk7XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLnJlbmRlckxvb3AoKTsgfSwgMCk7IC8vIGRlbGF5IHN0YXJ0IGJ5IG9uZSB0aWNrXG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5sb2FkUXVldWVkQ29vcmRpbmF0ZXMoKTtcblxuICAgICAgICAvLyBSZW5kZXIgb24gZGVtYW5kXG4gICAgICAgIHZhciB3aWxsX3JlbmRlciA9ICEoXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHRoaXMudXBkYXRpbmcgPiAwIHx8XG4gICAgICAgICAgICB0aGlzLnZpZXdSZWFkeSgpID09PSBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFByZS1yZW5kZXIgbG9vcCBob29rXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlVXBkYXRlKHdpbGxfcmVuZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhaWwgaWYgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgICAgaWYgKCF3aWxsX3JlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTsgLy8gc3ViY2xhc3NlcyBjYW4gc2V0IHRoaXMgYmFjayB0byB0cnVlIHdoZW4gYW5pbWF0aW9uIGlzIG5lZWRlZFxuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgc2NlbmVcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICAvLyBQb3N0LXJlbmRlciBsb29wIGhvb2tcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBvc3RVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucG9zdFVwZGF0ZSh3aWxsX3JlbmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWRyYXcgZXZlcnkgZnJhbWUgaWYgYW5pbWF0aW5nXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnJhbWUrKztcbiAgICAgICAgbG9nLnRyYWNlKCdTY2VuZS5yZW5kZXIoKScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgLy8gTWFwIHRyYW5zZm9ybXNcbiAgICAgICAgaWYgKCF0aGlzLmNlbnRlcl9tZXRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMsIGNhbWVyYSwgbGlnaHRzXG4gICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZSgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLmZvckVhY2goaSA9PiB0aGlzLnN0eWxlc1tpXS51cGRhdGUoKSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMubGlnaHRzKS5mb3JFYWNoKGkgPT4gdGhpcy5saWdodHNbaV0udXBkYXRlKCkpO1xuXG4gICAgICAgIC8vIFJlbmRlcmFibGUgdGlsZSBsaXN0XG4gICAgICAgIHRoaXMucmVuZGVyYWJsZV90aWxlcyA9IHRoaXMudGlsZV9tYW5hZ2VyLmdldFJlbmRlcmFibGVUaWxlcygpO1xuICAgICAgICB0aGlzLnJlbmRlcmFibGVfdGlsZXNfY291bnQgPSB0aGlzLnJlbmRlcmFibGVfdGlsZXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIFJlbmRlciBtYWluIHBhc3NcbiAgICAgICAgdGhpcy5yZW5kZXJfY291bnQgPSB0aGlzLnJlbmRlclBhc3MoKTtcblxuICAgICAgICAvLyBSZW5kZXIgc2VsZWN0aW9uIHBhc3MgKGlmIG5lZWRlZClcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnBlbmRpbmdSZXF1ZXN0cygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5iaW5kKCk7ICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIEZCT1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJQYXNzKFxuICAgICAgICAgICAgICAgICdzZWxlY3Rpb25fcHJvZ3JhbScsICAgICAgICAgICAgICAgIC8vIHJlbmRlciB3L2FsdGVybmF0ZSBwcm9ncmFtXG4gICAgICAgICAgICAgICAgeyBhbGxvd19hbHBoYV9ibGVuZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZWFkKCk7ICAgICAgICAgICAgICAgICAgLy8gcmVhZCByZXN1bHRzIGZyb20gc2VsZWN0aW9uIGJ1ZmZlclxuXG4gICAgICAgICAgICAvLyBSZXNldCB0byBzY3JlZW4gYnVmZmVyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZW5kZXJfY291bnQgIT09IHRoaXMubGFzdF9yZW5kZXJfY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RmVhdHVyZVNlbGVjdGlvbk1hcFNpemUoKS50aGVuKHNpemUgPT4ge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKGBTY2VuZTogcmVuZGVyZWQgJHt0aGlzLnJlbmRlcl9jb3VudH0gcHJpbWl0aXZlcyAoJHtzaXplfSBmZWF0dXJlcyBpbiBzZWxlY3Rpb24gbWFwKWApO1xuICAgICAgICAgICAgfSwgKCkgPT4ge30pOyAvLyBubyBvcCB3aGVuIHByb21pc2UgcmVqZWN0cyAob25seSBwcmludCBsYXN0IHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdF9yZW5kZXJfY291bnQgPSB0aGlzLnJlbmRlcl9jb3VudDtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgYWxsIGFjdGl2ZSBzdHlsZXMsIGdyb3VwZWQgYnkgYmxlbmQvZGVwdGggdHlwZSAob3BhcXVlLCBvdmVybGF5LCBldGMuKSBhbmQgYnkgcHJvZ3JhbSAoc3R5bGUpXG4gICAgLy8gQ2FsbGVkIGJvdGggZm9yIG1haW4gcmVuZGVyIHBhc3MsIGFuZCBmb3Igc2Vjb25kYXJ5IHBhc3NlcyBsaWtlIHNlbGVjdGlvbiBidWZmZXJcbiAgICByZW5kZXJQYXNzKHByb2dyYW1fa2V5ID0gJ3Byb2dyYW0nLCB7IGFsbG93X2FscGhhX2JsZW5kIH0gPSB7fSkge1xuICAgICAgICBsZXQgc3R5bGVzO1xuICAgICAgICBsZXQgY291bnQgPSAwOyAvLyBob3cgbWFueSBwcmltaXRpdmVzIHdlcmUgcmVuZGVyZWRcblxuICAgICAgICAvLyBvcHRpb25hbGx5IGZvcmNlIGFscGhhIG9mZiAoZS5nLiBmb3Igc2VsZWN0aW9uIHBhc3MpXG4gICAgICAgIGFsbG93X2FscGhhX2JsZW5kID0gKGFsbG93X2FscGhhX2JsZW5kID09IG51bGwpID8gdHJ1ZSA6IGFsbG93X2FscGhhX2JsZW5kO1xuXG4gICAgICAgIHRoaXMuY2xlYXJGcmFtZSh7IGNsZWFyX2NvbG9yOiB0cnVlLCBjbGVhcl9kZXB0aDogdHJ1ZSB9KTtcblxuICAgICAgICAvLyBPcGFxdWUgc3R5bGVzOiBkZXB0aCB0ZXN0IG9uLCBkZXB0aCB3cml0ZSBvbiwgYmxlbmRpbmcgb2ZmXG4gICAgICAgIHN0eWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcykuZmlsdGVyKHMgPT4gdGhpcy5zdHlsZXNbc10uYmxlbmQgPT09ICdvcGFxdWUnKTtcbiAgICAgICAgdGhpcy5zZXRSZW5kZXJTdGF0ZSh7IGRlcHRoX3Rlc3Q6IHRydWUsIGRlcHRoX3dyaXRlOiB0cnVlLCBhbHBoYV9ibGVuZDogZmFsc2UgfSk7XG4gICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xuXG4gICAgICAgIC8vIFRyYW5zcGFyZW50IHN0eWxlczogZGVwdGggdGVzdCBvZmYsIGRlcHRoIHdyaXRlIG9uLCBjdXN0b20gYmxlbmRpbmdcbiAgICAgICAgc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiB0aGlzLnN0eWxlc1tzXS5ibGVuZCA9PT0gJ2FkZCcpO1xuICAgICAgICB0aGlzLnNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IGZhbHNlLCBhbHBoYV9ibGVuZDogKGFsbG93X2FscGhhX2JsZW5kICYmICdhZGQnKSB9KTtcbiAgICAgICAgY291bnQgKz0gdGhpcy5yZW5kZXJTdHlsZXMoc3R5bGVzLCBwcm9ncmFtX2tleSk7XG5cbiAgICAgICAgc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiB0aGlzLnN0eWxlc1tzXS5ibGVuZCA9PT0gJ211bHRpcGx5Jyk7XG4gICAgICAgIHRoaXMuc2V0UmVuZGVyU3RhdGUoeyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF93cml0ZTogZmFsc2UsIGFscGhhX2JsZW5kOiAoYWxsb3dfYWxwaGFfYmxlbmQgJiYgJ211bHRpcGx5JykgfSk7XG4gICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xuXG4gICAgICAgIC8vIE92ZXJsYXkgc3R5bGVzOiBkZXB0aCB0ZXN0IG9mZiwgZGVwdGggd3JpdGUgb2ZmLCBibGVuZGluZyBvblxuICAgICAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0eWxlcykuZmlsdGVyKHMgPT4gdGhpcy5zdHlsZXNbc10uYmxlbmQgPT09ICdvdmVybGF5Jyk7XG4gICAgICAgIHRoaXMuc2V0UmVuZGVyU3RhdGUoeyBkZXB0aF90ZXN0OiBmYWxzZSwgZGVwdGhfd3JpdGU6IGZhbHNlLCBhbHBoYV9ibGVuZDogYWxsb3dfYWxwaGFfYmxlbmQgfSk7XG4gICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cbiAgICByZW5kZXJTdHlsZXMoc3R5bGVzLCBwcm9ncmFtX2tleSkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBzdHlsZSBvZiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGxldCBwcm9ncmFtID0gdGhpcy5zdHlsZXNbc3R5bGVdW3Byb2dyYW1fa2V5XTtcbiAgICAgICAgICAgIGlmICghcHJvZ3JhbSB8fCAhcHJvZ3JhbS5jb21waWxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gdGhpcy5yZW5kZXJTdHlsZShzdHlsZSwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIHJlbmRlclN0eWxlKHN0eWxlLCBwcm9ncmFtKSB7XG4gICAgICAgIHZhciBmaXJzdF9mb3Jfc3R5bGUgPSB0cnVlO1xuICAgICAgICB2YXIgcmVuZGVyX2NvdW50ID0gMDtcblxuICAgICAgICAvLyBSZW5kZXIgdGlsZSBHTCBnZW9tZXRyaWVzXG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5yZW5kZXJhYmxlX3RpbGVzKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMucmVuZGVyYWJsZV90aWxlc1t0XTtcblxuICAgICAgICAgICAgaWYgKHRpbGUubWVzaGVzW3N0eWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0dXAgc3R5bGUgaWYgZW5jb3VudGVyaW5nIGZvciBmaXJzdCB0aW1lIHRoaXMgZnJhbWVcbiAgICAgICAgICAgICAgICAvLyAobGF6eSBpbml0LCBub3QgYWxsIHN0eWxlcyB3aWxsIGJlIHVzZWQgaW4gYWxsIHNjcmVlbiB2aWV3czsgc29tZSBzdHlsZXMgbWlnaHQgYmUgZGVmaW5lZCBidXQgbmV2ZXIgdXNlZClcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RfZm9yX3N0eWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2Zvcl9zdHlsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0udXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW3N0eWxlXS5zZXR1cCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvbid0IHNldCB1bmlmb3JtcyB3aGVuIHRoZXkgaGF2ZW4ndCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmYnLCAndV9yZXNvbHV0aW9uJywgdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aCwgdGhpcy5kZXZpY2Vfc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfdGltZScsICgoK25ldyBEYXRlKCkpIC0gdGhpcy5zdGFydF90aW1lKSAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfbWFwX3Bvc2l0aW9uJywgdGhpcy5jZW50ZXJfbWV0ZXJzLngsIHRoaXMuY2VudGVyX21ldGVycy55LCB0aGlzLnpvb20pO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yKHRoaXMuem9vbSkgKyAoTWF0aC5sb2coKHRoaXMuem9vbSAlIDEpICsgMSkgLyBNYXRoLkxOMiAvLyBzY2FsZSBmcmFjdGlvbmFsIHpvb20gYnkgbG9nXG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnMWYnLCAndV9tZXRlcnNfcGVyX3BpeGVsJywgdGhpcy5tZXRlcnNfcGVyX3BpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X2RldmljZV9waXhlbF9yYXRpbycsIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0dXBQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMubGlnaHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0c1tpXS5zZXR1cFByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjYWxjIHRoZXNlIG9uY2UgcGVyIHRpbGUgKGN1cnJlbnRseSBiZWluZyBuZWVkbGVzc2x5IHJlLWNhbGN1bGF0ZWQgcGVyLXRpbGUtcGVyLXN0eWxlKVxuXG4gICAgICAgICAgICAgICAgLy8gVGlsZSBvcmlnaW5cbiAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfdGlsZV9vcmlnaW4nLCB0aWxlLm1pbi54LCB0aWxlLm1pbi55LCB0aWxlLnN0eWxlX3pvb20pO1xuXG4gICAgICAgICAgICAgICAgLy8gTW9kZWwgbWF0cml4IC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB3b3JsZCBzcGFjZSAobWV0ZXJzLCBhYnNvbHV0ZSBtZXJjYXRvciBwb3NpdGlvbilcbiAgICAgICAgICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMubW9kZWxNYXRyaXgsIHRoaXMubW9kZWxNYXRyaXgsIHZlYzMuZnJvbVZhbHVlcyh0aWxlLm1pbi54LCB0aWxlLm1pbi55LCAwKSk7XG4gICAgICAgICAgICAgICAgbWF0NC5zY2FsZSh0aGlzLm1vZGVsTWF0cml4LCB0aGlzLm1vZGVsTWF0cml4LCB2ZWMzLmZyb21WYWx1ZXModGlsZS5zcGFuLnggLyBHZW8udGlsZV9zY2FsZSwgLTEgKiB0aWxlLnNwYW4ueSAvIEdlby50aWxlX3NjYWxlLCAxKSk7IC8vIHNjYWxlIHRpbGUgbG9jYWwgY29vcmRzIHRvIG1ldGVyc1xuICAgICAgICAgICAgICAgIG1hdDQuY29weSh0aGlzLm1vZGVsTWF0cml4MzIsIHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfbW9kZWwnLCBmYWxzZSwgdGhpcy5tb2RlbE1hdHJpeDMyKTtcblxuICAgICAgICAgICAgICAgIC8vIE1vZGVsIHZpZXcgbWF0cml4IC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB2aWV3IHNwYWNlIChtZXRlcnMsIHJlbGF0aXZlIHRvIGNhbWVyYSlcbiAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KHRoaXMubW9kZWxWaWV3TWF0cml4MzIsIHRoaXMuY2FtZXJhLnZpZXdNYXRyaXgsIHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfbW9kZWxWaWV3JywgZmFsc2UsIHRoaXMubW9kZWxWaWV3TWF0cml4MzIpO1xuXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIG1hdHJpeCAtIHRyYW5zZm9ybXMgc3VyZmFjZSBub3JtYWxzIGludG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgICAgIG1hdDMubm9ybWFsRnJvbU1hdDQodGhpcy5ub3JtYWxNYXRyaXgzMiwgdGhpcy5tb2RlbFZpZXdNYXRyaXgzMik7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXgzZnYnLCAndV9ub3JtYWxNYXRyaXgnLCBmYWxzZSwgdGhpcy5ub3JtYWxNYXRyaXgzMik7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGlsZVxuICAgICAgICAgICAgICAgIHRpbGUubWVzaGVzW3N0eWxlXS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICByZW5kZXJfY291bnQgKz0gdGlsZS5tZXNoZXNbc3R5bGVdLmdlb21ldHJ5X2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcl9jb3VudDtcbiAgICB9XG5cbiAgICBjbGVhckZyYW1lKHsgY2xlYXJfY29sb3IsIGNsZWFyX2RlcHRoIH0gPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgIGNsZWFyX2NvbG9yID0gKGNsZWFyX2NvbG9yID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7IC8vIGRlZmF1bHQgdHJ1ZVxuICAgICAgICBjbGVhcl9kZXB0aCA9IChjbGVhcl9kZXB0aCA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRydWVcblxuICAgICAgICAvLyBSZXNldCBmcmFtZSBzdGF0ZVxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIGlmIChjbGVhcl9jb2xvcikge1xuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvciguLi50aGlzLmJhY2tncm91bmQuY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsZWFyX2RlcHRoKSB7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7IC8vIGFsd2F5cyBjbGVhciBkZXB0aCBpZiByZXF1ZXN0ZWQsIGV2ZW4gaWYgZGVwdGggd3JpdGUgd2lsbCBiZSB0dXJuZWQgb2ZmXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYXJfY29sb3IgfHwgY2xlYXJfZGVwdGgpIHtcbiAgICAgICAgICAgIGxldCBtYXNrID0gKGNsZWFyX2NvbG9yICYmIGdsLkNPTE9SX0JVRkZFUl9CSVQpIHwgKGNsZWFyX2RlcHRoICYmIGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuY2xlYXIobWFzayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSZW5kZXJTdGF0ZSh7IGRlcHRoX3Rlc3QsIGRlcHRoX3dyaXRlLCBjdWxsX2ZhY2UsIGFscGhhX2JsZW5kIH0gPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgIC8vIFRPRE86IHdoZW4gd2UgYWJzdHJhY3Qgb3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHJlbmRlciBwYXNzZXMsIHRoZXNlIGNhbiBiZSBwZXItcGFzcyBjb25maWcgb3B0aW9uc1xuICAgICAgICBkZXB0aF90ZXN0ID0gKGRlcHRoX3Rlc3QgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgICAgICAgICAvLyBkZWZhdWx0IHRydWVcbiAgICAgICAgZGVwdGhfd3JpdGUgPSAoZGVwdGhfd3JpdGUgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgICAgICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgICAgIGN1bGxfZmFjZSA9IChjdWxsX2ZhY2UgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgICAgICAgICAgIC8vIGRlZmF1bHQgdHJ1ZVxuICAgICAgICBhbHBoYV9ibGVuZCA9IChhbHBoYV9ibGVuZCAhPSBudWxsKSA/IGFscGhhX2JsZW5kIDogZmFsc2U7ICAvLyBkZWZhdWx0IGZhbHNlXG5cbiAgICAgICAgLy8gUmVzZXQgZnJhbWUgc3RhdGVcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcblxuICAgICAgICBpZiAoZGVwdGhfdGVzdCkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wuZGVwdGhNYXNrKGRlcHRoX3dyaXRlKTtcblxuICAgICAgICBpZiAoY3VsbF9mYWNlKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFscGhhX2JsZW5kKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAgICAgICAvLyBUcmFkaXRpb25hbCBibGVuZGluZ1xuICAgICAgICAgICAgaWYgKGFscGhhX2JsZW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZ1xuICAgICAgICAgICAgZWxzZSBpZiAoYWxwaGFfYmxlbmQgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE11bHRpcGxpY2F0aXZlIGJsZW5kaW5nXG4gICAgICAgICAgICBlbHNlIGlmIChhbHBoYV9ibGVuZCA9PT0gJ211bHRpcGx5Jykge1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5aRVJPLCBnbC5TUkNfQ09MT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IGZlYXR1cmUgc2VsZWN0aW9uIGF0IGdpdmVuIHBpeGVsLiBSdW5zIGFzeW5jIGFuZCByZXR1cm5zIHJlc3VsdHMgdmlhIGEgcHJvbWlzZS5cbiAgICBnZXRGZWF0dXJlQXQocGl4ZWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiU2NlbmUuZ2V0RmVhdHVyZUF0KCkgY2FsbGVkIGJlZm9yZSBzY2VuZSB3YXMgaW5pdGlhbGl6ZWRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9pbnQgc2NhbGVkIHRvIFswLi4xXSByYW5nZVxuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBwaXhlbC54ICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvIC8gdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHk6IHBpeGVsLnkgKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gLyB0aGlzLmRldmljZV9zaXplLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlOyAvLyBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgc2NlbmUgcmUtcmVuZGVycyBmb3IgdGhlc2UgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXRGZWF0dXJlQXQocG9pbnQpO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgZ2VvbWV0cnksIHdpdGhvdXQgcmUtcGFyc2luZyB0aGUgY29uZmlnIG9yIHJlLWNvbXBpbGluZyBzdHlsZXNcbiAgICAvLyBUT0RPOiBkZXRlY3Qgd2hpY2ggZWxlbWVudHMgbmVlZCB0byBiZSByZWZyZXNoZWQvcmVidWlsdCAoc3R5bGVzaGVldCBjaGFuZ2VzLCBldGMuKVxuICAgIHJlYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGRHZW9tZXRyeSgpO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgYWxsIHRpbGVzXG4gICAgcmVidWlsZEdlb21ldHJ5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU2tpcCByZWJ1aWxkIGlmIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gUXVldWUgdXAgdG8gb25lIHJlYnVpbGQgY2FsbCBhdCBhIHRpbWUsIG9ubHkgc2F2ZSBsYXN0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWlsZGluZy5xdWV1ZWQgJiYgdGhpcy5idWlsZGluZy5xdWV1ZWQucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBwcmV2aW91cyByZXF1ZXN0IHRoYXQgaXQgZGlkIG5vdCBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1NjZW5lLnJlYnVpbGRHZW9tZXRyeTogcmVxdWVzdCBzdXBlcmNlZGVkIGJ5IGEgbmV3ZXIgY2FsbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkaW5nLnF1ZXVlZC5yZXNvbHZlKGZhbHNlKTsgLy8gZmFsc2UgZmxhZyBpbmRpY2F0ZXMgcmVidWlsZCByZXF1ZXN0IHdhcyBzdXBlcmNlZGVkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBxdWV1ZWQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucXVldWVkID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFNjZW5lLnJlYnVpbGRHZW9tZXRyeSgpOiBxdWV1aW5nIHJlcXVlc3RgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyYWNrIHRpbGUgYnVpbGQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuXG4gICAgICAgICAgICAvLyBQcm9maWxpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnLnByb2ZpbGUuZ2VvbWV0cnlfYnVpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9maWxlKCdyZWJ1aWxkR2VvbWV0cnknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoaW4gY2FzZSBKUyBvYmplY3RzIHdlcmUgbWFuaXB1bGF0ZWQgZGlyZWN0bHkpXG4gICAgICAgICAgICB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpO1xuICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLmNvbXBpbGUodGhpcy51cGRhdGVBY3RpdmVTdHlsZXMoKSk7IC8vIG9ubHkgcmVjb21waWxlIG5ld2x5IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgICAgIHRoaXMucmVzZXRGZWF0dXJlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VGltZSgpO1xuXG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHZpc2libGUgdGlsZXMsIHNvcnRlZCBmcm9tIGNlbnRlclxuICAgICAgICAgICAgbGV0IGJ1aWxkID0gW107XG4gICAgICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5mb3JFYWNoVGlsZSgodGlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGQucHVzaCh0aWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnJlbW92ZVRpbGUodGlsZS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50aWxlX21hbmFnZXIuYnVpbGRUaWxlcyhidWlsZCk7XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUHJvZmlsaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zy5wcm9maWxlLmdlb21ldHJ5X2J1aWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZmlsZUVuZCgncmVidWlsZEdlb21ldHJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRpbGUgbWFuYWdlciBmaW5pc2hlZCBidWlsZGluZyB0aWxlc1xuICAgIHRpbGVNYW5hZ2VyQnVpbGREb25lKCkge1xuICAgICAgICBpZiAodGhpcy5idWlsZGluZykge1xuICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lOiBidWlsZCBnZW9tZXRyeSBmaW5pc2hlZGApO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcucmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQW5vdGhlciByZWJ1aWxkIHF1ZXVlZD9cbiAgICAgICAgICAgIHZhciBxdWV1ZWQgPSB0aGlzLmJ1aWxkaW5nLnF1ZXVlZDtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmU6IHN0YXJ0aW5nIHF1ZXVlZCByZWJ1aWxkR2VvbWV0cnkoKSByZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKS50aGVuKHF1ZXVlZC5yZXNvbHZlLCBxdWV1ZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgIExvYWQgKG9yIHJlbG9hZCkgdGhlIHNjZW5lIGNvbmZpZ1xuICAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICBsb2FkU2NlbmUoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnX3BhdGggPSAodHlwZW9mIHRoaXMuY29uZmlnX3NvdXJjZSA9PT0gJ3N0cmluZycpICYmIFV0aWxzLnBhdGhGb3JVUkwodGhpcy5jb25maWdfc291cmNlKTtcbiAgICAgICAgVGV4dHVyZS5iYXNlX3VybCA9IHRoaXMuY29uZmlnX3BhdGg7XG5cbiAgICAgICAgcmV0dXJuIFV0aWxzLmxvYWRSZXNvdXJjZSh0aGlzLmNvbmZpZ19zb3VyY2UpLnRoZW4oKGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVQcm9jZXNzQ29uZmlnKCkudGhlbigoKSA9PiB7IHRoaXMudHJpZ2dlcignbG9hZFNjZW5lJywgdGhpcy5jb25maWcpOyB9KTtcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGxvYWRpbmcgc2NlbmUgZmlsZSAnJHt0aGlzLmNvbmZpZ19zb3VyY2V9JzogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlbG9hZCBzY2VuZSBjb25maWcgYW5kIHJlYnVpbGQgdGlsZXNcbiAgICAvLyBPcHRpb25hbGx5IHNwZWNpZnkgbmV3IHNjZW5lIGZpbGUgVVJMXG4gICAgcmVsb2FkKGNvbmZpZ19zb3VyY2UgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aWxlcyBiZWZvcmUgcmVidWlsZGluZ1xuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5yZW1vdmVUaWxlcyh0aWxlID0+ICF0aWxlLnZpc2libGUpO1xuXG4gICAgICAgIHRoaXMudXBkYXRpbmcrKztcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jb25maWdfc291cmNlID0gY29uZmlnX3NvdXJjZSB8fCB0aGlzLmNvbmZpZ19zb3VyY2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNjZW5lKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbmZpZygpO1xuICAgICAgICAgICAgdGhpcy5zeW5jQ29uZmlnVG9Xb3JrZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGRHZW9tZXRyeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRpbmctLTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGluZy0tO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvYWREYXRhU291cmNlcygpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmNvbmZpZy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gdGhpcy5jb25maWcuc291cmNlc1tuYW1lXTtcbiAgICAgICAgICAgIHNvdXJjZS51cmwgPSBVdGlscy5hZGRCYXNlVVJMKHNvdXJjZS51cmwpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzW25hbWVdID0gRGF0YVNvdXJjZS5jcmVhdGUoT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLCB7bmFtZX0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBzb21lIHNldHRpbmdzIHRoYXQgbWF5IG5vdCBoYXZlIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlIHNjZW5lIGRlZmluaXRpb25cbiAgICBwcmVQcm9jZXNzQ29uZmlnKCkge1xuICAgICAgICAvLyBBc3NpZ24gaWRzIHRvIGRhdGEgc291cmNlc1xuICAgICAgICBsZXQgc291cmNlX2lkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIHRoaXMuY29uZmlnLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNvdXJjZXNbc291cmNlXS5pZCA9IHNvdXJjZV9pZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgb25seSBvbmUgY2FtZXJhIHNwZWNpZmllZCwgc2V0IGl0IGFzIGRlZmF1bHRcbiAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhcyA9IHRoaXMuY29uZmlnLmNhbWVyYXMgfHwge307XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmEpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYXMuZGVmYXVsdCA9IHRoaXMuY29uZmlnLmNhbWVyYTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FtZXJhX25hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb25maWcuY2FtZXJhcyk7XG4gICAgICAgIGlmIChjYW1lcmFfbmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFzLmRlZmF1bHQgPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2FjdGl2ZV9jYW1lcmEpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGNhbWVyYSBzZXQgYXMgYWN0aXZlLCB1c2UgZmlyc3Qgb25lXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFzW2NhbWVyYV9uYW1lc1swXV0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLmxpZ2h0cyA9IHRoaXMuY29uZmlnLmxpZ2h0cyB8fCB7fTsgLy8gZW5zdXJlIGxpZ2h0cyBvYmplY3RcbiAgICAgICAgdGhpcy5jb25maWcuc3R5bGVzID0gdGhpcy5jb25maWcuc3R5bGVzIHx8IHt9OyAvLyBlbnN1cmUgc3R5bGVzIG9iamVjdFxuXG4gICAgICAgIHJldHVybiBTdHlsZU1hbmFnZXIucHJlbG9hZCh0aGlzLmNvbmZpZy5zdHlsZXMsIHRoaXMuY29uZmlnX3BhdGgpO1xuICAgIH1cblxuICAgIC8vIExvYWQgYWxsIHRleHR1cmVzIGluIHRoZSBzY2VuZSBkZWZpbml0aW9uXG4gICAgbG9hZFRleHR1cmVzKCkge1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZVRleHR1cmVzKCk7XG4gICAgICAgIHJldHVybiBUZXh0dXJlLmNyZWF0ZUZyb21PYmplY3QodGhpcy5nbCwgdGhpcy5jb25maWcudGV4dHVyZXMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzaW5nbGUgb3IgbXVsdGktdGV4dHVyZSBzeW50YXgsIGZvciBzdHlsZXNoZWV0IGNvbnZlbmllbmNlXG4gICAgbm9ybWFsaXplVGV4dHVyZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuc3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBbc3R5bGVfbmFtZSwgc3R5bGVdIG9mIFV0aWxzLmVudHJpZXModGhpcy5jb25maWcuc3R5bGVzKSkge1xuICAgICAgICAgICAgLy8gSWYgc3R5bGUgaGFzIGEgc2luZ2xlICd0ZXh0dXJlJyBvYmplY3QsIG1vdmUgaXQgdG8gdGhlIGdsb2JhbCBzY2VuZSB0ZXh0dXJlIHNldFxuICAgICAgICAgICAgLy8gYW5kIGdpdmUgaXQgYSBkZWZhdWx0IG5hbWVcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0dXJlICYmIHR5cGVvZiBzdHlsZS50ZXh0dXJlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlX25hbWUgPSAnX18nICsgc3R5bGVfbmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy50ZXh0dXJlcyA9IHRoaXMuY29uZmlnLnRleHR1cmVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnRleHR1cmVzW3RleHR1cmVfbmFtZV0gPSBzdHlsZS50ZXh0dXJlO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRleHR1cmUgPSB0ZXh0dXJlX25hbWU7IC8vIHBvaW50IHN0bHllIHRvIGxvY2F0aW9uIG9mIHRleHR1cmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGxlZCAoY3VycmVudGx5IG1hbnVhbGx5KSBhZnRlciBzdHlsZXMgYXJlIHVwZGF0ZWQgaW4gc3R5bGVzaGVldFxuICAgIHVwZGF0ZVN0eWxlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkICYmICF0aGlzLmluaXRpYWxpemluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2VuZS51cGRhdGVTdHlsZXMoKSBjYWxsZWQgYmVmb3JlIHNjZW5lIHdhcyBpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKFJlKWJ1aWxkIHN0eWxlcyBmcm9tIGNvbmZpZ1xuICAgICAgICBTdHlsZU1hbmFnZXIuaW5pdCgpO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFN0eWxlTWFuYWdlci5idWlsZCh0aGlzLmNvbmZpZy5zdHlsZXMsIHRoaXMpO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsbHkgc2V0IEdMIGNvbnRleHQgKHVzZWQgd2hlbiBpbml0aWFsaXppbmcgb3IgcmUtaW5pdGlhbGl6aW5nIEdMIHJlc291cmNlcylcbiAgICAgICAgZm9yICh2YXIgc3R5bGUgb2YgVXRpbHMudmFsdWVzKHRoaXMuc3R5bGVzKSkge1xuICAgICAgICAgICAgc3R5bGUuc2V0R0wodGhpcy5nbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kICYgY29tcGlsZSBhY3RpdmUgc3R5bGVzXG4gICAgICAgIHRoaXMudXBkYXRlQWN0aXZlU3R5bGVzKCk7XG4gICAgICAgIFN0eWxlTWFuYWdlci5jb21waWxlKE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcykpO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHVwZGF0ZUFjdGl2ZVN0eWxlcygpIHtcbiAgICAgICAgLy8gTWFrZSBhIHNldCBvZiBjdXJyZW50bHkgYWN0aXZlIHN0eWxlcyAodXNlZCBpbiBhIGRyYXcgcnVsZSlcbiAgICAgICAgLy8gTm90ZTogZG9lc24ndCBhY3R1YWxseSBjaGVjayBpZiBhbnkgZ2VvbWV0cnkgbWF0Y2hlcyB0aGUgcnVsZSwganVzdCB0aGF0IHRoZSBzdHlsZSBpcyBwb3RlbnRpYWxseSByZW5kZXJhYmxlXG4gICAgICAgIGxldCBwcmV2X3N0eWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcyB8fCB7fSk7XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0eWxlcyA9IHt9O1xuICAgICAgICB2YXIgYW5pbWF0ZWQgPSBmYWxzZTsgLy8gaXMgYW55IGFjdGl2ZSBzdHlsZSBhbmltYXRlZD9cbiAgICAgICAgZm9yICh2YXIgcnVsZSBvZiBVdGlscy5yZWN1cnNlVmFsdWVzKHRoaXMuY29uZmlnLmxheWVycykpIHtcbiAgICAgICAgICAgIGlmIChydWxlLmRyYXcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbbmFtZSwgZ3JvdXBdIG9mIFV0aWxzLmVudHJpZXMocnVsZS5kcmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXJuIG9uIG5vbi1vYmplY3QgZHJhdyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnb2JqZWN0JyAmJiBncm91cC52aXNpYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlX25hbWUgPSBncm91cC5zdHlsZSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlcyA9IFtzdHlsZV9uYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYWRkaXRpb25hbCBvdXRsaW5lIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAub3V0bGluZSAmJiBncm91cC5vdXRsaW5lLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goZ3JvdXAub3V0bGluZS5zdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHN0eWxlcy5maWx0ZXIoeCA9PiB0aGlzLnN0eWxlc1t4XSkuZm9yRWFjaChzdHlsZV9uYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnN0eWxlc1tzdHlsZV9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVfc3R5bGVzW3N0eWxlX25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBleHBsaWNpdGx5IHNldCBzY2VuZSBhbmltYXRpb24gZmxhZyBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdHVybiBvbiBhbmltYXRpb25cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGFueSBhbmltYXRlZCBzdHlsZXNcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IHRoaXMuY29uZmlnLnNjZW5lLmFuaW1hdGVkICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5zY2VuZS5hbmltYXRlZCA6IGFuaW1hdGVkO1xuXG4gICAgICAgIC8vIENvbXBpbGUgbmV3bHkgYWN0aXZlIHN0eWxlc1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiBwcmV2X3N0eWxlcy5pbmRleE9mKHMpID09PSAtMSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNhbWVyYVxuICAgIGNyZWF0ZUNhbWVyYSgpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBDYW1lcmEuY3JlYXRlKHRoaXMuX2FjdGl2ZV9jYW1lcmEsIHRoaXMsIHRoaXMuY29uZmlnLmNhbWVyYXNbdGhpcy5fYWN0aXZlX2NhbWVyYV0pO1xuXG4gICAgICAgIC8vIFRPRE86IHJlcGxhY2UgdGhpcyBhbmQgbW92ZSBhbGwgcG9zaXRpb24gaW5mbyB0byBjYW1lcmFcbiAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlU2NlbmUoKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWN0aXZlIGNhbWVyYSAtIGZvciBwdWJsaWMgQVBJXG4gICAgZ2V0QWN0aXZlQ2FtZXJhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlX2NhbWVyYTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYWN0aXZlIGNhbWVyYSBhbmQgcmVjb21waWxlIC0gZm9yIHB1YmxpYyBBUElcbiAgICBzZXRBY3RpdmVDYW1lcmEobmFtZSkge1xuICAgICAgICB0aGlzLl9hY3RpdmVfY2FtZXJhID0gbmFtZTtcbiAgICAgICAgdGhpcy51cGRhdGVDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZV9jYW1lcmE7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWwgbWFuYWdlbWVudCBvZiBhY3RpdmUgY2FtZXJhXG4gICAgZ2V0IF9hY3RpdmVfY2FtZXJhKCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuY29uZmlnLmNhbWVyYXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IF9hY3RpdmVfY2FtZXJhKG5hbWUpIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9hY3RpdmVfY2FtZXJhO1xuXG4gICAgICAgIC8vIFNldCBuZXcgYWN0aXZlIGNhbWVyYVxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2FtZXJhc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhc1tuYW1lXS5hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBDbGVhciBwcmV2aW91c2x5IGFjdGl2ZSBjYW1lcmFcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT09IG5hbWUgJiYgdGhpcy5jb25maWcuY2FtZXJhc1twcmV2XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmZpZy5jYW1lcmFzW3ByZXZdLmFjdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBsaWdodGluZ1xuICAgIGNyZWF0ZUxpZ2h0cygpIHtcbiAgICAgICAgdGhpcy5saWdodHMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmNvbmZpZy5saWdodHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpZ2h0c1tpXS5uYW1lID0gaTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpZ2h0c1tpXS52aXNpYmxlID0gKHRoaXMuY29uZmlnLmxpZ2h0c1tpXS52aXNpYmxlID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcubGlnaHRzW2ldLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0c1tpXSA9IExpZ2h0LmNyZWF0ZSh0aGlzLCB0aGlzLmNvbmZpZy5saWdodHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExpZ2h0LmluamVjdCh0aGlzLmxpZ2h0cyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGJhY2tncm91bmQgY29sb3JcbiAgICBzZXRCYWNrZ3JvdW5kKCkge1xuICAgICAgICBsZXQgYmcgPSB0aGlzLmNvbmZpZy5zY2VuZS5iYWNrZ3JvdW5kO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSB7fTtcbiAgICAgICAgaWYgKGJnICYmIGJnLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuY29sb3IgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGJnLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZC5jb2xvcikge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmNvbG9yID0gWzAsIDAsIDAsIDFdOyAvLyBkZWZhdWx0IGJhY2tncm91bmQgdG8gYmxhY2tcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzY2VuZSBjb25maWcsIGFuZCBvcHRpb25hbGx5IHJlYnVpbGQgZ2VvbWV0cnlcbiAgICB1cGRhdGVDb25maWcoeyByZWJ1aWxkIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRpb24rKztcbiAgICAgICAgdGhpcy51cGRhdGluZysrO1xuICAgICAgICB0aGlzLmNvbmZpZy5zY2VuZSA9IHRoaXMuY29uZmlnLnNjZW5lIHx8IHt9O1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbWVyYSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUxpZ2h0cygpO1xuICAgICAgICB0aGlzLmxvYWREYXRhU291cmNlcygpO1xuICAgICAgICB0aGlzLmxvYWRUZXh0dXJlcygpO1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgICAgICAvLyBUT0RPOiBkZXRlY3QgY2hhbmdlcyB0byBzdHlsZXM/IGFscmVhZHkgKGN1cnJlbnRseSkgbmVlZCB0byByZWNvbXBpbGUgYW55d2F5IHdoZW4gY2FtZXJhIG9yIGxpZ2h0cyBjaGFuZ2VcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZXMoKTtcbiAgICAgICAgdGhpcy5zeW5jQ29uZmlnVG9Xb3JrZXIoKTtcbiAgICAgICAgaWYgKHJlYnVpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGRHZW9tZXRyeSgpLnRoZW4oKCkgPT4gdGhpcy51cGRhdGluZy0tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRpbmctLTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNlcmlhbGl6ZSBjb25maWcgYW5kIHNlbmQgdG8gd29ya2VyXG4gICAgc3luY0NvbmZpZ1RvV29ya2VyKCkge1xuICAgICAgICAvLyBUZWxsIHdvcmtlcnMgd2UncmUgYWJvdXQgdG8gcmVidWlsZCAoc28gdGhleSBjYW4gdXBkYXRlIHN0eWxlcywgZXRjLilcbiAgICAgICAgdGhpcy5jb25maWdfc2VyaWFsaXplZCA9IFV0aWxzLnNlcmlhbGl6ZVdpdGhGdW5jdGlvbnModGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCh3b3JrZXIgPT4ge1xuICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3VwZGF0ZUNvbmZpZycsIHtcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnX3NlcmlhbGl6ZWQsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbjogdGhpcy5nZW5lcmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzZXRGZWF0dXJlU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCh3b3JrZXIgPT4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3Jlc2V0RmVhdHVyZVNlbGVjdGlvbicpKTtcbiAgICB9XG5cbiAgICAvLyBHZXRzIHRoZSBjdXJyZW50IGZlYXR1cmUgc2VsZWN0aW9uIG1hcCBzaXplIGFjcm9zcyBhbGwgd29ya2Vycy4gUmV0dXJucyBhIHByb21pc2UuXG4gICAgZ2V0RmVhdHVyZVNlbGVjdGlvbk1hcFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoaW5nX3NlbGVjdGlvbl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmV0Y2hpbmdfc2VsZWN0aW9uX21hcCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgIC5hbGwodGhpcy53b3JrZXJzLm1hcCh3b3JrZXIgPT4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ2dldEZlYXR1cmVTZWxlY3Rpb25NYXBTaXplJykpKVxuICAgICAgICAgICAgLnRoZW4oc2l6ZXMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hpbmdfc2VsZWN0aW9uX21hcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGludGVybmFsIGNsb2NrLCBtb3N0bHkgdXNlZnVsIGZvciBjb25zaXN0ZW50IGV4cGVyaWVuY2Ugd2hlbiBjaGFuZ2luZyBzdHlsZXMvZGVidWdnaW5nXG4gICAgcmVzZXRUaW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0X3RpbWUgPSArbmV3IERhdGUoKTtcbiAgICB9XG5cblxuICAgIC8vIFN0YXRzL2RlYnVnL3Byb2ZpbGluZyBtZXRob2RzXG5cbiAgICAvLyBTdW0gb2YgYSBkZWJ1ZyBwcm9wZXJ0eSBhY3Jvc3MgdGlsZXNcbiAgICBnZXREZWJ1Z1N1bShwcm9wLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMudGlsZXNbdF0uZGVidWdbcHJvcF0gIT0gbnVsbCAmJiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJyB8fCBmaWx0ZXIodGhpcy50aWxlc1t0XSkgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHRoaXMudGlsZXNbdF0uZGVidWdbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICAvLyBBdmVyYWdlIG9mIGEgZGVidWcgcHJvcGVydHkgYWNyb3NzIHRpbGVzXG4gICAgZ2V0RGVidWdBdmVyYWdlKHByb3AsIGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREZWJ1Z1N1bShwcm9wLCBmaWx0ZXIpIC8gT2JqZWN0LmtleXModGhpcy50aWxlcykubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIExvZyBtZXNzYWdlcyBwYXNzIHRocm91Z2ggZnJvbSB3ZWIgd29ya2Vyc1xuICAgIHdvcmtlckxvZ01lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB7IHdvcmtlcl9pZCwgbGV2ZWwsIG1zZyB9ID0gZXZlbnQuZGF0YTtcblxuICAgICAgICBpZiAobG9nW2xldmVsXSkge1xuICAgICAgICAgICAgbG9nW2xldmVsXShgd29ya2VyICR7d29ya2VyX2lkfTpgLCAgLi4ubXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihgU2NlbmUud29ya2VyTG9nTWVzc2FnZTogdW5yZWNvZ25pemVkIGxvZyBsZXZlbCAke2xldmVsfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvZmlsZSBoZWxwZXJzLCBpc3N1ZXMgYSBwcm9maWxlIG9uIG1haW4gdGhyZWFkICYgYWxsIHdvcmtlcnNcbiAgICBfcHJvZmlsZShuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZShgbWFpbiB0aHJlYWQ6ICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy53b3JrZXJzLmZvckVhY2godyA9PiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodywgJ3Byb2ZpbGUnLCBuYW1lKSk7XG4gICAgfVxuXG4gICAgX3Byb2ZpbGVFbmQobmFtZSkge1xuICAgICAgICBjb25zb2xlLnByb2ZpbGVFbmQoYG1haW4gdGhyZWFkOiAke25hbWV9YCk7XG4gICAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKHcgPT4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHcsICdwcm9maWxlRW5kJywgbmFtZSkpO1xuICAgIH1cblxufVxuXG4vLyBTdGF0aWMgbWV0aG9kcy9zdGF0ZVxuXG5TY2VuZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29uZmlnLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFNjZW5lKGNvbmZpZywgb3B0aW9ucyk7XG59O1xuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5pbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9kYXRhX3NvdXJjZS5qcyc7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IHtwYXJzZVJ1bGVzfSBmcm9tICcuL3N0eWxlcy9ydWxlJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XG5cbmV4cG9ydCB2YXIgU2NlbmVXb3JrZXIgPSBzZWxmO1xuXG4vLyBXb3JrZXIgZnVuY3Rpb25hbGl0eSB3aWxsIG9ubHkgYmUgZGVmaW5lZCBpbiB3b3JrZXIgdGhyZWFkXG5VdGlscy5pc1dvcmtlclRocmVhZCAmJiBPYmplY3QuYXNzaWduKHNlbGYsIHtcblxuICAgIHNvdXJjZXM6IHtcbiAgICAgICAgdGlsZXM6IHt9LFxuICAgICAgICBvYmplY3RzOiB7fVxuICAgIH0sXG4gICAgc3R5bGVzOiB7fSxcbiAgICBydWxlczoge30sXG4gICAgbGF5ZXJzOiB7fSxcbiAgICB0aWxlczoge30sXG4gICAgb2JqZWN0czoge30sXG4gICAgY29uZmlnOiB7fSxcblxuICAgIC8vIEluaXRpYWxpemUgd29ya2VyXG4gICAgaW5pdCAod29ya2VyX2lkLCBudW1fd29ya2VycywgZGV2aWNlX3BpeGVsX3JhdGlvKSB7XG4gICAgICAgIHNlbGYuX3dvcmtlcl9pZCA9IHdvcmtlcl9pZDtcbiAgICAgICAgc2VsZi5udW1fd29ya2VycyA9IG51bV93b3JrZXJzO1xuICAgICAgICBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gPSBkZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgIEZlYXR1cmVTZWxlY3Rpb24uc2V0UHJlZml4KHNlbGYuX3dvcmtlcl9pZCk7XG4gICAgICAgIHJldHVybiB3b3JrZXJfaWQ7XG4gICAgfSxcblxuICAgIC8vIFN0YXJ0cyBhIGNvbmZpZyByZWZyZXNoXG4gICAgdXBkYXRlQ29uZmlnICh7IGNvbmZpZywgZ2VuZXJhdGlvbiB9KSB7XG4gICAgICAgIHNlbGYuY29uZmlnID0gbnVsbDtcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWcpO1xuXG4gICAgICAgIHNlbGYuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247XG4gICAgICAgIHNlbGYuc3R5bGVzID0gbnVsbDtcblxuICAgICAgICAvLyBEYXRhIGJsb2NrIGZ1bmN0aW9ucyBhcmUgbm90IG1hY3JvJ2VkIGFuZCB3cmFwcGVkIGxpa2UgdGhlIHJlc3Qgb2YgdGhlIHN0eWxlIGZ1bmN0aW9ucyBhcmVcbiAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgd2FudCBhIGNsZWFuZXIgd2F5IHRvIGV4Y2x1ZGUgdGhlc2VcbiAgICAgICAgZm9yICh2YXIgbGF5ZXIgaW4gY29uZmlnLmxheWVycykge1xuICAgICAgICAgICAgY29uZmlnLmxheWVyc1tsYXllcl0uZGF0YSA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhjb25maWcubGF5ZXJzW2xheWVyXS5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBkYXRhIHNvdXJjZXNcbiAgICAgICAgY29uZmlnLnNvdXJjZXMgPSBVdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMoU3R5bGVQYXJzZXIuZXhwYW5kTWFjcm9zKGNvbmZpZy5zb3VyY2VzKSk7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBEYXRhU291cmNlLmNyZWF0ZShPYmplY3QuYXNzaWduKGNvbmZpZy5zb3VyY2VzW25hbWVdLCB7bmFtZX0pKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UudGlsZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNvdXJjZXMudGlsZXNbbmFtZV0gPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEaXN0cmlidXRlIG9iamVjdCBzb3VyY2VzIGFjcm9zcyB3b3JrZXJzXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCAlIHNlbGYubnVtX3dvcmtlcnMgPT09IHNlbGYuX3dvcmtlcl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHNvdXJjZSBpZiBub3QgY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc291cmNlcy5vYmplY3RzW25hbWVdID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5sb2FkKHNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwYW5kIHN0eWxlc1xuICAgICAgICBzZWxmLmNvbmZpZyA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhTdHlsZVBhcnNlci5leHBhbmRNYWNyb3MoY29uZmlnKSwgU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uKTtcbiAgICAgICAgc2VsZi5zdHlsZXMgPSBTdHlsZU1hbmFnZXIuYnVpbGQoc2VsZi5jb25maWcuc3R5bGVzLCB7IGdlbmVyYXRpb246IHNlbGYuZ2VuZXJhdGlvbiB9KTtcblxuICAgICAgICAvLyBQYXJzZSBlYWNoIHRvcC1sZXZlbCBsYXllciBhcyBhIHNlcGFyYXRlIHJ1bGUgdHJlZVxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgbW9yZSBncmFjZWZ1bCB3YXkgdG8gaW5jb3Jwb3JhdGUgdGhpc1xuXG4gICAgICAgIHNlbGYucnVsZXMgPSBwYXJzZVJ1bGVzKHNlbGYuY29uZmlnLmxheWVycyk7XG5cbiAgICAgICAgLy8gU3luYyB0ZXR4dXJlIGluZm8gZnJvbSBtYWluIHRocmVhZFxuICAgICAgICBzZWxmLnN5bmNpbmdfdGV4dHVyZXMgPSBzZWxmLnN5bmNUZXh0dXJlcygpO1xuXG4gICAgICAgIC8vIFJldHVybiBwcm9taXNlIGZvciB3aGVuIGNvbmZpZyByZWZyZXNoIGZpbmlzaGVzXG4gICAgICAgIHNlbGYuY29uZmlndXJpbmcgPSBzZWxmLnN5bmNpbmdfdGV4dHVyZXMudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBVdGlscy5sb2coJ2RlYnVnJywgYHVwZGF0ZWQgY29uZmlnYCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdoZW4gY29uZmlnIHJlZnJlc2ggaXMgZmluaXNoZWRcbiAgICBhd2FpdENvbmZpZ3VyYXRpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jb25maWd1cmluZztcbiAgICB9LFxuXG4gICAgLy8gQnVpbGQgYSB0aWxlOiBsb2FkIGZyb20gdGlsZSBzb3VyY2UgaWYgYnVpbGRpbmcgZm9yIGZpcnN0IHRpbWUsIG90aGVyd2lzZSByZWJ1aWxkIHdpdGggZXhpc3RpbmcgZGF0YVxuICAgIGJ1aWxkVGlsZSAoeyB0aWxlIH0pIHtcbiAgICAgICAgLy8gVGlsZSBjYWNoZWQ/XG4gICAgICAgIGlmIChzZWxmLnRpbGVzW3RpbGUua2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGxvYWRpbmc/XG4gICAgICAgICAgICBpZiAoc2VsZi50aWxlc1t0aWxlLmtleV0ubG9hZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aWxlIGNhY2hlXG4gICAgICAgIHRpbGUgPSBzZWxmLnRpbGVzW3RpbGUua2V5XSA9IE9iamVjdC5hc3NpZ24oc2VsZi50aWxlc1t0aWxlLmtleV0gfHwge30sIHRpbGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjb25maWcgKHN0eWxlcywgZXRjLiksIHRoZW4gYnVpbGQgdGlsZVxuICAgICAgICByZXR1cm4gc2VsZi5hd2FpdENvbmZpZ3VyYXRpb24oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgYnVpbGRpbmcgdGhlIHRpbGVcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRlZCAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRUaWxlU291cmNlRGF0YSh0aWxlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhcm4gYW5kIGNvbnRpbnVlIG9uIGRhdGEgc291cmNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlsZS5zb3VyY2VfZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnd2FybicsIGB0aWxlIGxvYWQgZXJyb3IocykgZm9yICR7dGlsZS5rZXl9OiAke3RpbGUuc291cmNlX2RhdGEuZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5idWlsZEdlb21ldHJ5KHRpbGUsIHNlbGYuY29uZmlnLmxheWVycywgc2VsZi5ydWxlcywgc2VsZi5zdHlsZXMpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHRpbGU6IFRpbGUuc2xpY2UodGlsZSwga2V5cykgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmVycm9yID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnZXJyb3InLCBgdGlsZSBsb2FkIGVycm9yIGZvciAke3RpbGUua2V5fTogJHtlcnJvci5zdGFja31gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHRpbGU6IFRpbGUuc2xpY2UodGlsZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGlsZSBhbHJlYWR5IGxvYWRlZCwganVzdCByZWJ1aWxkXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYHVzZWQgd29ya2VyIGNhY2hlIGZvciB0aWxlICR7dGlsZS5rZXl9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBnZW9tZXRyeVxuICAgICAgICAgICAgICAgIHJldHVybiBUaWxlLmJ1aWxkR2VvbWV0cnkodGlsZSwgc2VsZi5jb25maWcubGF5ZXJzLCBzZWxmLnJ1bGVzLCBzZWxmLnN0eWxlcykudGhlbihrZXlzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGlsZTogVGlsZS5zbGljZSh0aWxlLCBrZXlzKSB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gTG9hZCB0aGlzIHRpbGUncyBkYXRhIHNvdXJjZVxuICAgIGxvYWRUaWxlU291cmNlRGF0YSAodGlsZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zb3VyY2VzLnRpbGVzW3RpbGUuc291cmNlXS5sb2FkKHRpbGUpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGlsZVxuICAgIHJlbW92ZVRpbGUgKGtleSkge1xuICAgICAgICB2YXIgdGlsZSA9IHNlbGYudGlsZXNba2V5XTtcblxuICAgICAgICBpZiAodGlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgaWYgbG9hZGluZ1xuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgY2FuY2VsIHRpbGUgbG9hZCBmb3IgJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFRpbGUuY2FuY2VsKHRpbGUpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgICAgICAgRmVhdHVyZVNlbGVjdGlvbi5jbGVhclRpbGUoa2V5KTtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLnRpbGVzW2tleV07XG4gICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYHJlbW92ZSB0aWxlIGZyb20gY2FjaGUgZm9yICR7a2V5fWApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBhIGZlYXR1cmUgZnJvbSB0aGUgc2VsZWN0aW9uIG1hcFxuICAgIGdldEZlYXR1cmVTZWxlY3Rpb24gKHsgaWQsIGtleSB9ID0ge30pIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IEZlYXR1cmVTZWxlY3Rpb24ubWFwW2tleV07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGZlYXR1cmU6IChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZlYXR1cmUpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIFJlc2V0cyB0aGUgZmVhdHVyZSBzZWxlY3Rpb24gc3RhdGVcbiAgICByZXNldEZlYXR1cmVTZWxlY3Rpb24gKCkge1xuICAgICAgICBGZWF0dXJlU2VsZWN0aW9uLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIC8vIFNlbGVjdGlvbiBtYXAgc2l6ZSBmb3IgdGhpcyB3b3JrZXJcbiAgICBnZXRGZWF0dXJlU2VsZWN0aW9uTWFwU2l6ZSAoKSB7XG4gICAgICAgIHJldHVybiBGZWF0dXJlU2VsZWN0aW9uLmdldE1hcFNpemUoKTtcbiAgICB9LFxuXG4gICAgLy8gVGV4dHVyZSBpbmZvIG5lZWRzIHRvIGJlIHN5bmNlZCBmcm9tIG1haW4gdGhyZWFkXG4gICAgc3luY1RleHR1cmVzICgpIHtcbiAgICAgICAgLy8gV2UncmUgb25seSBzeW5jaW5nIHRoZSB0ZXh0dXJlcyB0aGF0IGhhdmUgc3ByaXRlcyBkZWZpbmVkLCBzaW5jZSB0aGVzZSBhcmUgKGN1cnJlbnRseSkgdGhlIG9ubHkgb25lcyB3ZVxuICAgICAgICAvLyBuZWVkIGluZm8gYWJvdXQgZm9yIGdlb21ldHJ5IGNvbnN0cnVjdGlvbiAoZS5nLiB3aWR0aC9oZWlnaHQsIHdoaWNoIHdlIG9ubHkga25vdyBhZnRlciB0aGUgdGV4dHVyZSBsb2FkcylcbiAgICAgICAgbGV0IHRleHR1cmVzID0gW107XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50ZXh0dXJlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgW3RleG5hbWUsIHRleHR1cmVdIG9mIFV0aWxzLmVudHJpZXMoc2VsZi5jb25maWcudGV4dHVyZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKHRleG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCAnc3luYyB0ZXh0dXJlcyB0byB3b3JrZXI6JywgdGV4dHVyZXMpO1xuICAgICAgICBpZiAodGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIodGV4dHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gUHJvZmlsaW5nIGhlbHBlcnNcbiAgICBwcm9maWxlIChuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZShgd29ya2VyICR7c2VsZi5fd29ya2VyX2lkfTogJHtuYW1lfWApO1xuICAgIH0sXG5cbiAgICBwcm9maWxlRW5kIChuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZUVuZChgd29ya2VyICR7c2VsZi5fd29ya2VyX2lkfTogJHtuYW1lfWApO1xuICAgIH1cblxufSk7XG4iLCJpbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWF0dXJlU2VsZWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB3b3JrZXJzKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy53b3JrZXJzID0gd29ya2VyczsgLy8gcG9vbCBvZiB3b3JrZXJzIHRvIHJlcXVlc3QgZmVhdHVyZSBsb29rLXVwcyBmcm9tLCBrZXllZCBieSBpZFxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBTZWxlY3Rpb24gc3RhdGUgdHJhY2tpbmdcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IHt9OyAvLyBwZW5kaW5nIHNlbGVjdGlvbiByZXF1ZXN0c1xuICAgICAgICB0aGlzLmZlYXR1cmUgPSBudWxsOyAvLyBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICB0aGlzLnJlYWRfZGVsYXkgPSA1OyAvLyBkZWxheSB0aW1lIGZyb20gc2VsZWN0aW9uIHJlbmRlciB0byBmcmFtZWJ1ZmZlciBzYW1wbGUsIHRvIGF2b2lkIENQVS9HUFUgc3luYyBsb2NrXG4gICAgICAgIHRoaXMucmVhZF9kZWxheV90aW1lciA9IG51bGw7IC8vIGN1cnJlbnQgdGltZXIgKHNldFRpbWVvdXQpIGZvciBkZWxheWVkIHNlbGVjdGlvbiByZWFkc1xuXG4gICAgICAgIHRoaXMucGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgdGhpcy5waXhlbDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBpeGVsLmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gRnJhbWUgYnVmZmVyIGZvciBzZWxlY3Rpb25cbiAgICAgICAgLy8gVE9ETzogaW5pdGlhdGUgbGF6aWx5IGluIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XG4gICAgICAgIHRoaXMuZmJvX3NpemUgPSB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjU2IH07IC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlIC8gYWRhcHRpdmUgYmFzZWQgb24gY2FudmFzIHNpemVcbiAgICAgICAgdGhpcy5mYm9fc2l6ZS5hc3BlY3QgPSB0aGlzLmZib19zaXplLndpZHRoIC8gdGhpcy5mYm9fc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gVGV4dHVyZSBmb3IgdGhlIEZCTyBjb2xvciBhdHRhY2htZW50XG4gICAgICAgIHZhciBmYm9fdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsICdzZWxlY3Rpb25fZmJvJyk7XG4gICAgICAgIGZib190ZXh0dXJlLnNldERhdGEodGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQsIG51bGwsIHsgZmlsdGVyaW5nOiAnbmVhcmVzdCcgfSk7XG4gICAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbC5URVhUVVJFXzJELCBmYm9fdGV4dHVyZS50ZXh0dXJlLCAwKTtcblxuICAgICAgICAvLyBSZW5kZXJidWZmZXIgZm9yIHRoZSBGQk8gZGVwdGggYXR0YWNobWVudFxuICAgICAgICB2YXIgZmJvX2RlcHRoX3JiID0gdGhpcy5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuXG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIH1cblxuICAgIGJpbmQoKSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byBGQk9cbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgLy8gUnVucyBhc3luY2hyb25vdXNseSwgc2NoZWR1bGVzIHNlbGVjdGlvbiBidWZmZXIgdG8gYmUgdXBkYXRlZFxuICAgIGdldEZlYXR1cmVBdChwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gUXVldWUgcmVxdWVzdHMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uLCBhbmQgdGhleSB3aWxsIGJlIHBpY2tlZCB1cCBieSB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQgPSAodGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZCArIDEpIHx8IDA7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzW3RoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWRdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQW55IHBlbmRpbmcgc2VsZWN0aW9uIHJlcXVlc3RzXG4gICAgcGVuZGluZ1JlcXVlc3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0cztcbiAgICB9XG5cbiAgICAvLyBSZWFkIHBlbmRpbmcgcmVzdWx0cyBmcm9tIHRoZSBzZWxlY3Rpb24gYnVmZmVyLiBDYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nIHRvIHNlbGVjdGlvbiBidWZmZXIuXG4gICAgcmVhZCgpIHtcbiAgICAgICAgLy8gRGVsYXkgcmVhZGluZyB0aGUgcGl4ZWwgcmVzdWx0IGZyb20gdGhlIHNlbGVjdGlvbiBidWZmZXIgdG8gYXZvaWQgQ1BVL0dQVSBzeW5jIGxvY2suXG4gICAgICAgIC8vIENhbGxpbmcgcmVhZFBpeGVscyBzeW5jaHJvbm91c2x5IGNhdXNlZCBhIG1hc3NpdmUgcGVyZm9ybWFuY2UgaGl0LCBwcmVzdW1hYmx5IHNpbmNlIGl0XG4gICAgICAgIC8vIGZvcmNlZCB0aGlzIGZ1bmN0aW9uIHRvIHdhaXQgZm9yIHRoZSBHUFUgdG8gZmluaXNoIHJlbmRlcmluZyBhbmQgcmV0cmlldmUgdGhlIHRleHR1cmUgY29udGVudHMuXG4gICAgICAgIGlmICh0aGlzLnJlYWRfZGVsYXlfdGltZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZF9kZWxheV90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkX2RlbGF5X3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW3JdO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZXF1ZXN0IHdhcyBhbHJlYWR5IHNlbnQgdG8gdGhlIHdvcmtlciwgd2UncmUganVzdCBhd2FpdGluZyBpdHMgcmVwbHlcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgc2VsZWN0aW9uIHR5cGVzLCBzdWNoIGFzIGZlYXR1cmVzIHdpdGhpbiBhIGJveFxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnR5cGUgIT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgc2VsZWN0aW9uIG1hcCBhZ2FpbnN0IEZCT1xuICAgICAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IocmVxdWVzdC5wb2ludC54ICogdGhpcy5mYm9fc2l6ZS53aWR0aCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKDEgLSByZXF1ZXN0LnBvaW50LnkpICogdGhpcy5mYm9fc2l6ZS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnBpeGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZV9rZXkgPSAodGhpcy5waXhlbFswXSArICh0aGlzLnBpeGVsWzFdIDw8IDgpICsgKHRoaXMucGl4ZWxbMl0gPDwgMTYpICsgKHRoaXMucGl4ZWxbM10gPDwgMjQpKSA+Pj4gMDtcblxuICAgICAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgZm91bmQsIGFzayBhcHByb3ByaWF0ZSB3ZWIgd29ya2VyIHRvIGxvb2t1cCBmZWF0dXJlXG4gICAgICAgICAgICAgICAgdmFyIHdvcmtlcl9pZCA9IHRoaXMucGl4ZWxbM107XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcl9pZCAhPT0gMjU1KSB7IC8vIDI1NSBpbmRpY2F0ZXMgYW4gZW1wdHkgc2VsZWN0aW9uIGJ1ZmZlciBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53b3JrZXJzW3dvcmtlcl9pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJfaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnZXRGZWF0dXJlU2VsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiByZXF1ZXN0LmlkLCBrZXk6IGZlYXR1cmVfa2V5IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaFJlYWQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObyBmZWF0dXJlIGZvdW5kLCBidXQgc3RpbGwgbmVlZCB0byByZXNvbHZlIHByb21pc2VcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hSZWFkKHsgaWQ6IHJlcXVlc3QuaWQsIGZlYXR1cmU6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICB9LCB0aGlzLnJlYWRfZGVsYXkpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBmaW5kcyBhIGZlYXR1cmUgaW4gdGhlIHNlbGVjdGlvbiBidWZmZXJcbiAgICBmaW5pc2hSZWFkIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlU2VsZWN0aW9uLmZpbmlzaFJlYWQoKSBjYWxsZWQgd2l0aG91dCBhbnkgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmZWF0dXJlID0gbWVzc2FnZS5mZWF0dXJlO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGZlYXR1cmUgIT0gbnVsbCAmJiB0aGlzLmZlYXR1cmUgPT0gbnVsbCkgfHxcbiAgICAgICAgICAgIChmZWF0dXJlID09IG51bGwgJiYgdGhpcy5mZWF0dXJlICE9IG51bGwpIHx8XG4gICAgICAgICAgICAoZmVhdHVyZSAhPSBudWxsICYmIHRoaXMuZmVhdHVyZSAhPSBudWxsICYmIGZlYXR1cmUuaWQgIT09IHRoaXMuZmVhdHVyZS5pZCkpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTsgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHsgZmVhdHVyZSwgY2hhbmdlZCwgcmVxdWVzdCB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbWVzc2FnZS5pZF07IC8vIGRvbmUgcHJvY2Vzc2luZyB0aGlzIHJlcXVlc3RcbiAgICB9XG5cblxuICAgIC8vIFNlbGVjdGlvbiBtYXAgZ2VuZXJhdGlvblxuICAgIC8vIEVhY2ggd29ya2VyIHdpbGwgY3JlYXRlIGl0cyBvd24gaW5kZXBlbmRlbnQsICdsb2NhbCcgc2VsZWN0aW9uIG1hcFxuXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIDMyLWJpdCBjb2xvciB0byBpZGVudGlmeSBhIGZlYXR1cmVcbiAgICAvLyBXb3JrZXJzIGluZGVwZW5kZW50bHkgY3JlYXRlL21vZGlmeSBzZWxlY3Rpb24gY29sb3JzIGluIHRoZWlyIG93biB0aHJlYWRzLCBidXQgd2UgYWxzb1xuICAgIC8vIG5lZWQgdGhlIG1haW4gdGhyZWFkIHRvIGtub3cgd2hlcmUgZWFjaCBmZWF0dXJlIGNvbG9yIG9yaWdpbmF0ZWQuIFRvIGFjY29tcGxpc2ggdGhpcyxcbiAgICAvLyB3ZSBwYXJ0aXRpb24gdGhlIG1hcCBieSBzZXR0aW5nIHRoZSA0dGggY29tcG9uZW50IChhbHBoYSBjaGFubmVsKSB0byB0aGUgd29ya2VyJ3MgaWQuXG4gICAgc3RhdGljIG1ha2VFbnRyeSh0aWxlKSB7XG4gICAgICAgIC8vIDMyLWJpdCBjb2xvciBrZXlcbiAgICAgICAgdGhpcy5tYXBfZW50cnkrKztcbiAgICAgICAgdmFyIGlyID0gdGhpcy5tYXBfZW50cnkgJiAyNTU7XG4gICAgICAgIHZhciBpZyA9ICh0aGlzLm1hcF9lbnRyeSA+PiA4KSAmIDI1NTtcbiAgICAgICAgdmFyIGliID0gKHRoaXMubWFwX2VudHJ5ID4+IDE2KSAmIDI1NTtcbiAgICAgICAgdmFyIGlhID0gdGhpcy5tYXBfcHJlZml4O1xuICAgICAgICB2YXIgciA9IGlyIC8gMjU1O1xuICAgICAgICB2YXIgZyA9IGlnIC8gMjU1O1xuICAgICAgICB2YXIgYiA9IGliIC8gMjU1O1xuICAgICAgICB2YXIgYSA9IGlhIC8gMjU1O1xuICAgICAgICB2YXIga2V5ID0gKGlyICsgKGlnIDw8IDgpICsgKGliIDw8IDE2KSArIChpYSA8PCAyNCkpID4+PiAwOyAvLyBuZWVkIHVuc2lnbmVkIHJpZ2h0IHNoaWZ0IHRvIGNvbnZlcnQgdG8gcG9zaXRpdmUgI1xuXG4gICAgICAgIHRoaXMubWFwW2tleV0gPSB7XG4gICAgICAgICAgICBjb2xvcjogW3IsIGcsIGIsIGFdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hcF9zaXplKys7XG5cbiAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0gPSB0aGlzLnRpbGVzW3RpbGUua2V5XSB8fCBbXTtcbiAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0ucHVzaChrZXkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xuICAgIH1cblxuICAgIHN0YXRpYyBtYWtlQ29sb3IoZmVhdHVyZSwgdGlsZSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLm1ha2VFbnRyeSh0aWxlKTtcbiAgICAgICAgc2VsZWN0b3IuZmVhdHVyZSA9IHtcbiAgICAgICAgICAgIGlkOiBmZWF0dXJlLmlkLFxuICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdGlsZTogdGlsZS5rZXlcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuY29sb3I7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICB0aGlzLm1hcF9zaXplID0gMDtcbiAgICAgICAgdGhpcy5tYXBfZW50cnkgPSAwO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhclRpbGUoa2V5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudGlsZXNba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZXNba2V5XS5mb3JFYWNoKGsgPT4gZGVsZXRlIHRoaXMubWFwW2tdKTtcbiAgICAgICAgICAgIHRoaXMubWFwX3NpemUgLT0gdGhpcy50aWxlc1trZXldLmxlbmd0aDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwX3NpemU7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5tYXBfcHJlZml4ID0gcHJlZml4O1xuICAgIH1cblxufVxuXG4vLyBTdGF0aWMgcHJvcGVydGllc1xuRmVhdHVyZVNlbGVjdGlvbi5tYXAgPSB7fTsgICAvLyB0aGlzIHdpbGwgYmUgdW5pcXVlIHBlciBtb2R1bGUgaW5zdGFuY2UgKHNvIHVuaXF1ZSBwZXIgd29ya2VyKVxuRmVhdHVyZVNlbGVjdGlvbi50aWxlcyA9IHt9OyAvLyBzZWxlY3Rpb24ga2V5cywgYnkgdGlsZVxuRmVhdHVyZVNlbGVjdGlvbi5tYXBfc2l6ZSA9IDA7XG5GZWF0dXJlU2VsZWN0aW9uLm1hcF9lbnRyeSA9IDA7XG5GZWF0dXJlU2VsZWN0aW9uLm1hcF9wcmVmaXggPSAwOyAvLyBzZXQgYnkgd29ya2VyIHRvIHdvcmtlciBpZCAjXG5GZWF0dXJlU2VsZWN0aW9uLmRlZmF1bHRDb2xvciA9IFswLCAwLCAwLCAxXTtcbiIsIi8vIEdlb21ldHJ5IGJ1aWxkaW5nIGZ1bmN0aW9uc1xuXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxudmFyIEJ1aWxkZXJzO1xuZXhwb3J0IGRlZmF1bHQgQnVpbGRlcnMgPSB7fTtcblxuQnVpbGRlcnMuZGVidWcgPSBmYWxzZTtcblxuQnVpbGRlcnMudGlsZV9ib3VuZHMgPSBbXG4gICAgeyB4OiAwLCB5OiAwfSxcbiAgICB7IHg6IEdlby50aWxlX3NjYWxlLCB5OiAtR2VvLnRpbGVfc2NhbGUgfSAvLyBUT0RPOiBjb3JyZWN0IGZvciBmbGlwcGVkIHktYXhpcz9cbl07XG5cbi8vIFJlLXNjYWxlIFVWcyBmcm9tIFswLCAxXSByYW5nZSB0byBhIHNtYWxsZXIgYXJlYSB3aXRoaW4gdGhlIGltYWdlXG5CdWlsZGVycy5zY2FsZVRleGNvb3Jkc1RvU3ByaXRlID0gZnVuY3Rpb24gKHV2LCBhcmVhX29yaWdpbiwgYXJlYV9zaXplLCB0ZXhfc2l6ZSkge1xuICAgIHZhciBhcmVhX29yaWdpbl95ID0gdGV4X3NpemVbMV0gLSBhcmVhX29yaWdpblsxXSAtIGFyZWFfc2l6ZVsxXTtcbiAgICB2YXIgc3V2ID0gW107XG4gICAgc3V2WzBdID0gKHV2WzBdICogYXJlYV9zaXplWzBdICsgYXJlYV9vcmlnaW5bMF0pIC8gdGV4X3NpemVbMF07XG4gICAgc3V2WzFdID0gKHV2WzFdICogYXJlYV9zaXplWzFdICsgYXJlYV9vcmlnaW5feSkgLyB0ZXhfc2l6ZVsxXTtcbiAgICByZXR1cm4gc3V2O1xufTtcblxuQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlID0gZnVuY3Rpb24gKGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZShbMCwgMF0sIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSxcbiAgICAgICAgQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZShbMSwgMV0sIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKVxuICAgIF07XG59O1xuXG4vLyBUZXNzZWxhdGUgYSBmbGF0IDJEIHBvbHlnb25cbi8vIHggJiB5IGNvb3JkaW5hdGVzIHdpbGwgYmUgc2V0IGFzIGZpcnN0IHR3byBlbGVtZW50cyBvZiBwcm92aWRlZCB2ZXJ0ZXhfdGVtcGxhdGVcbkJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMgPSBmdW5jdGlvbiAoXG4gICAgcG9seWdvbnMsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSB9KSB7XG5cbiAgICB2YXIgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xuICAgIHZhciBudW1fcG9seWdvbnMgPSBwb2x5Z29ucy5sZW5ndGg7XG4gICAgZm9yICh2YXIgcD0wOyBwIDwgbnVtX3BvbHlnb25zOyBwKyspIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBwb2x5Z29uc1twXTtcblxuICAgICAgICAvLyBGaW5kIHBvbHlnb24gZXh0ZW50cyB0byBjYWxjdWxhdGUgVVZzLCBmaXQgdGhlbSB0byB0aGUgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveFxuICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBbbWluX3gsIG1pbl95LCBtYXhfeCwgbWF4X3ldID0gR2VvLmZpbmRCb3VuZGluZ0JveChwb2x5Z29uKTtcbiAgICAgICAgICAgIHZhciBzcGFuX3ggPSBtYXhfeCAtIG1pbl94O1xuICAgICAgICAgICAgdmFyIHNwYW5feSA9IG1heF95IC0gbWluX3k7XG4gICAgICAgICAgICB2YXIgc2NhbGVfdSA9IChtYXhfdSAtIG1pbl91KSAvIHNwYW5feDtcbiAgICAgICAgICAgIHZhciBzY2FsZV92ID0gKG1heF92IC0gbWluX3YpIC8gc3Bhbl95O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzc2VsbGF0ZVxuICAgICAgICB2YXIgdmVydGljZXMgPSBCdWlsZGVycy50cmlhbmd1bGF0ZVBvbHlnb24ocG9seWdvbik7XG5cbiAgICAgICAgLy8gQWRkIHZlcnRleCBkYXRhXG4gICAgICAgIHZhciBudW1fdmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIHY9MDsgdiA8IG51bV92ZXJ0aWNlczsgdisrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbdl07XG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSB2ZXJ0ZXhbMF07XG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMV0gPSB2ZXJ0ZXhbMV07XG5cbiAgICAgICAgICAgIC8vIEFkZCBVVnNcbiAgICAgICAgICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDBdID0gKHZlcnRleFswXSAtIG1pbl94KSAqIHNjYWxlX3UgKyBtaW5fdTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9ICh2ZXJ0ZXhbMV0gLSBtaW5feSkgKiBzY2FsZV92ICsgbWluX3Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlcnRleF9kYXRhLmFkZFZlcnRleCh2ZXJ0ZXhfdGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gVGVzc2VsYXRlIGFuZCBleHRydWRlIGEgZmxhdCAyRCBwb2x5Z29uIGludG8gYSBzaW1wbGUgM0QgbW9kZWwgd2l0aCBmaXhlZCBoZWlnaHQgYW5kIGFkZCB0byBHTCB2ZXJ0ZXggYnVmZmVyXG5CdWlsZGVycy5idWlsZEV4dHJ1ZGVkUG9seWdvbnMgPSBmdW5jdGlvbiAoXG4gICAgcG9seWdvbnMsXG4gICAgeiwgaGVpZ2h0LCBtaW5faGVpZ2h0LFxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgbm9ybWFsX2luZGV4LFxuICAgIHsgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkX3NjYWxlIH0pIHtcblxuICAgIC8vIFRvcFxuICAgIHZhciBtaW5feiA9IHogKyAobWluX2hlaWdodCB8fCAwKTtcbiAgICB2YXIgbWF4X3ogPSB6ICsgaGVpZ2h0O1xuICAgIHZlcnRleF90ZW1wbGF0ZVsyXSA9IG1heF96O1xuICAgIEJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIHsgdGV4Y29vcmRfaW5kZXggfSk7XG5cbiAgICAvLyBXYWxsc1xuICAgIC8vIEZpdCBVVnMgdG8gd2FsbCBxdWFkXG4gICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcbiAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgdmFyIHRleGNvb3JkcyA9IFtcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdLFxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1pbl92XSxcblxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIG51bV9wb2x5Z29ucyA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICBmb3IgKHZhciBwPTA7IHAgPCBudW1fcG9seWdvbnM7IHArKykge1xuICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25zW3BdO1xuXG4gICAgICAgIGZvciAodmFyIHE9MDsgcSA8IHBvbHlnb24ubGVuZ3RoOyBxKyspIHtcbiAgICAgICAgICAgIHZhciBjb250b3VyID0gcG9seWdvbltxXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgdz0wOyB3IDwgY29udG91ci5sZW5ndGggLSAxOyB3KyspIHtcbiAgICAgICAgICAgICAgICAvLyBUd28gdHJpYW5nbGVzIGZvciB0aGUgcXVhZCBmb3JtZWQgYnkgZWFjaCB2ZXJ0ZXggcGFpciwgZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wIGhlaWdodFxuICAgICAgICAgICAgICAgIHZhciB3YWxsX3ZlcnRpY2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3KzFdWzBdLCBjb250b3VyW3crMV1bMV0sIG1heF96XSxcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdysxXVswXSwgY29udG91clt3KzFdWzFdLCBtaW5fel0sXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3ddWzBdLCBjb250b3VyW3ddWzFdLCBtaW5fel0sXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3ddWzBdLCBjb250b3VyW3ddWzFdLCBtaW5fel0sXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3ddWzBdLCBjb250b3VyW3ddWzFdLCBtYXhfel0sXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3crMV1bMF0sIGNvbnRvdXJbdysxXVsxXSwgbWF4X3pdXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGMgdGhlIG5vcm1hbCBvZiB0aGUgd2FsbCBmcm9tIHVwIHZlY3RvciBhbmQgb25lIHNlZ21lbnQgb2YgdGhlIHdhbGwgdHJpYW5nbGVzXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFZlY3Rvci5jcm9zcyhcbiAgICAgICAgICAgICAgICAgICAgWzAsIDAsIDFdLFxuICAgICAgICAgICAgICAgICAgICBWZWN0b3Iubm9ybWFsaXplKFtjb250b3VyW3crMV1bMF0gLSBjb250b3VyW3ddWzBdLCBjb250b3VyW3crMV1bMV0gLSBjb250b3VyW3ddWzFdLCAwXSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHZlcnRleCB0ZW1wbGF0ZSB3aXRoIGN1cnJlbnQgc3VyZmFjZSBub3JtYWxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMF0gPSBub3JtYWxbMF07XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW25vcm1hbF9pbmRleCArIDFdID0gbm9ybWFsWzFdO1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtub3JtYWxfaW5kZXggKyAyXSA9IG5vcm1hbFsyXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHd2PTA7IHd2IDwgd2FsbF92ZXJ0aWNlcy5sZW5ndGg7IHd2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzBdID0gd2FsbF92ZXJ0aWNlc1t3dl1bMF07XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHdhbGxfdmVydGljZXNbd3ZdWzFdO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMl0gPSB3YWxsX3ZlcnRpY2VzW3d2XVsyXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDBdID0gdGV4Y29vcmRzW3d2XVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW3d2XVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhLmFkZFZlcnRleCh2ZXJ0ZXhfdGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIEJ1aWxkIHRlc3NlbGxhdGVkIHRyaWFuZ2xlcyBmb3IgYSBwb2x5bGluZVxuQnVpbGRlcnMuYnVpbGRQb2x5bGluZXMgPSBmdW5jdGlvbiAoXG4gICAgbGluZXMsXG4gICAgd2lkdGgsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICB7XG4gICAgICAgIGNsb3NlZF9wb2x5Z29uLFxuICAgICAgICByZW1vdmVfdGlsZV9lZGdlcyxcbiAgICAgICAgdGlsZV9lZGdlX3RvbGVyYW5jZSxcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXG4gICAgICAgIHRleGNvb3JkX3NjYWxlLFxuICAgICAgICBzY2FsaW5nX2luZGV4LFxuICAgICAgICBqb2luLCBjYXBcbiAgICB9KSB7XG5cbiAgICB2YXIgY29ybmVyc09uQ2FwID0gKGNhcCA9PT0gXCJzcXVhcmVcIikgPyAyIDogKChjYXAgPT09IFwicm91bmRcIikgPyAzIDogMCk7ICAvLyBCdXR0IGlzIHRoZSBpbXBsaWNpdCBkZWZhdWx0XG4gICAgdmFyIHRyaWFuZ2xlc09uSm9pbiA9IChqb2luID09PSBcImJldmVsXCIpID8gMSA6ICgoam9pbiA9PT0gXCJyb3VuZFwiKSA/IDMgOiAwKTsgIC8vIE1pdGVyIGlzIHRoZSBpbXBsaWNpdCBkZWZhdWx0XG5cbiAgICAvLyBCdWlsZCB2YXJpYWJsZXNcbiAgICB2YXIgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xuXG4gICAgLy8gVmFsdWVzIHRoYXQgYXJlIGNvbnN0YW50IGZvciBlYWNoIGxpbmUgYW5kIGFyZSBwYXNzZWQgdG8gaGVscGVyIGZ1bmN0aW9uc1xuICAgIHZhciBjb25zdGFudHMgPSB7XG4gICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgIGhhbGZXaWR0aDogd2lkdGgvMixcbiAgICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgICBzY2FsaW5nX2luZGV4LFxuICAgICAgICBzY2FsaW5nVmVjczogc2NhbGluZ19pbmRleCAmJiBbXSxcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXG4gICAgICAgIHRleGNvb3JkczogdGV4Y29vcmRfaW5kZXggJiYgW10sXG4gICAgICAgIG1pbl91LCBtaW5fdiwgbWF4X3UsIG1heF92LFxuICAgICAgICBuUGFpcnM6IDBcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgbG4gPSAwOyBsbiA8IGxpbmVzLmxlbmd0aDsgbG4rKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xuXTtcbiAgICAgICAgdmFyIGxpbmVTaXplID0gbGluZS5sZW5ndGg7XG5cbiAgICAgICAgLy8gSWdub3JlIG5vbi1saW5lc1xuICAgICAgICBpZiAobGluZVNpemUgPCAyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhcmlhYmxlc1xuICAgICAgICB2YXIgY29vcmRQcmV2ID0gWzAsIDBdLCAvLyBQcmV2aW91cyBwb2ludCBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29vcmRDdXJyID0gWzAsIDBdLCAvLyBDdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBjb29yZE5leHQgPSBbMCwgMF07IC8vIE5leHQgcG9pbnQgY29vcmRpbmF0ZXNcblxuICAgICAgICB2YXIgbm9ybVByZXYgPSBbMCwgMF0sICAvLyBSaWdodCBub3JtYWwgdG8gc2VnbWVudCBiZXR3ZWVuIHByZXZpb3VzIGFuZCBjdXJyZW50IG1fcG9pbnRzXG4gICAgICAgICAgICBub3JtQ3VyciA9IFswLCAwXSwgIC8vIFJpZ2h0IG5vcm1hbCBhdCBjdXJyZW50IHBvaW50LCBzY2FsZWQgZm9yIG1pdGVyIGpvaW50XG4gICAgICAgICAgICBub3JtTmV4dCA9IFswLCAwXTsgIC8vIFJpZ2h0IG5vcm1hbCB0byBzZWdtZW50IGJldHdlZW4gY3VycmVudCBhbmQgbmV4dCBtX3BvaW50c1xuXG4gICAgICAgIHZhciBpc1ByZXYgPSBmYWxzZSxcbiAgICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY29yZGluZyB0aGVpciBpbmRleFxuICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG5cbiAgICAgICAgLy8gRG8gdGhpcyB3aXRoIHRoZSByZXN0IChleGNlcHQgdGhlIGxhc3Qgb25lKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTaXplIDsgaSsrKSB7XG5cbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgbmV4dCBvbmU/XG4gICAgICAgICAgICBpc05leHQgPSBpKzEgPCBsaW5lU2l6ZTtcblxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcHJldml1cyBvbmUsIGNvcHkgdGhlIGN1cnJlbnQgKHByZXZpb3VzKSB2YWx1ZXMgb24gKlByZXZcbiAgICAgICAgICAgICAgICBjb29yZFByZXYgPSBjb29yZEN1cnI7XG4gICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwICYmIGNsb3NlZF9wb2x5Z29uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgdGhlIGZpcnN0IHBvaW50IGFuZCBpcyBhIGNsb3NlIHBvbHlnb25cblxuICAgICAgICAgICAgICAgIHZhciBuZWVkVG9DbG9zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZV90aWxlX2VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKEJ1aWxkZXJzLmlzT25UaWxlRWRnZShsaW5lW2ldLCBsaW5lW2xpbmVTaXplLTJdLCB7IHRpbGVfZWRnZV90b2xlcmFuY2UgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb0Nsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZFRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRQcmV2ID0gbGluZVtsaW5lU2l6ZS0yXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzaWduIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAgICAgICAgY29vcmRDdXJyID0gbGluZVtpXTtcblxuICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIGNvb3JkTmV4dCA9IGxpbmVbaSsxXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvc2VkX3BvbHlnb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyB0aGUgbGFzdCBwb2ludCBhIGNsb3NlIHBvbHlnb25cbiAgICAgICAgICAgICAgICBjb29yZE5leHQgPSBsaW5lWzFdO1xuICAgICAgICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBub3QgdGhlIGxhc3Qgb25lIGdldCBuZXh0IGNvb3JkaW5hdGVzIGFuZCBjYWxjdWxhdGUgdGhlIHJpZ2h0IG5vcm1hbFxuXG4gICAgICAgICAgICAgICAgbm9ybU5leHQgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkQ3VyciwgY29vcmROZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZV90aWxlX2VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCdWlsZGVycy5pc09uVGlsZUVkZ2UoY29vcmRDdXJyLCBjb29yZE5leHQsIHsgdGlsZV9lZGdlX3RvbGVyYW5jZSB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgY29vcmRDdXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4UGFpcihjb29yZEN1cnIsIG5vcm1DdXJyLCBpL2xpbmVTaXplLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5uUGFpcnMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB2ZXJ0aWNlcyB0byBidWZmZXIgYWNvcmRpbmcgdGhlaXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgQ29tcHV0ZSBjdXJyZW50IG5vcm1hbFxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgIC8vICBJZiB0aGVyZSBpcyBhIFBSRVZJVVMgLi4uXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIGEgTkVYVCBPTkUsIGNvbXB1dGUgcHJldml1cyBhbmQgbmV4dCBub3JtYWxzIChzY2FsZWQgYnkgdGhlIGFuZ2xlIHdpdGggdGhlIGxhc3QgcHJldilcbiAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5hZGQobm9ybVByZXYsIG5vcm1OZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguYWJzKFZlY3Rvci5kb3Qobm9ybVByZXYsIG5vcm1DdXJyKSkpO1xuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5tdWx0KG5vcm1DdXJyLHNjYWxlKnNjYWxlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIHRoZXJlIGlzIE5PVCBhIE5FWFQgT05FLCBjb3B5IHRoZSBwcmV2aXVzIG5leHQgb25lICh3aGljaCBpcyB0aGUgY3VycmVudCBvbmUpXG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZFByZXYsIGNvb3JkQ3VycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgTk9UIGEgUFJFVklVUyAuLi5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgYSBORVhUIE9ORSxcbiAgICAgICAgICAgICAgICAgICAgbm9ybU5leHQgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkQ3VyciwgY29vcmROZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gbm9ybU5leHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBOT1QgYSBORVhUIE9ORSwgbm90aGluZyB0byBkbyAod2l0aG91dCBwcmV2IG9yIG5leHQgb25lIHRoaXMgaXMganVzdCBhIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXYgfHwgaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgdGhlIEJFR0lOSU5HIG9mIGEgTElORVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmICFpc1ByZXYgJiYgIWNsb3NlZF9wb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENhcChjb29yZEN1cnIsIG5vcm1DdXJyLCBjb3JuZXJzT25DYXAsIHRydWUsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgYSBKT0lOXG4gICAgICAgICAgICAgICAgaWYodHJpYW5nbGVzT25Kb2luICE9PSAwICYmIGlzUHJldiAmJiBpc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSm9pbihbY29vcmRQcmV2LCBjb29yZEN1cnIsIGNvb3JkTmV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25vcm1QcmV2LG5vcm1DdXJyLCBub3JtTmV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS9saW5lU2l6ZSwgdHJpYW5nbGVzT25Kb2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4UGFpcihjb29yZEN1cnIsIG5vcm1DdXJyLCBpLyhsaW5lU2l6ZS0xKSwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLm5QYWlycysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlzUHJldiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjb3JkaW5nIHRoZWlyIGluZGV4XG4gICAgICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcblxuICAgICAgICAgLy8gSWYgaXMgdGhlIEVORCBPRiBhIExJTkVcbiAgICAgICAgaWYoIWNsb3NlZF9wb2x5Z29uKSB7XG4gICAgICAgICAgICBhZGRDYXAoY29vcmRDdXJyLCBub3JtQ3VyciwgY29ybmVyc09uQ2FwICwgZmFsc2UsIGNvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBBZGQgdG8gZXF1aWRpc3RhbnQgcGFpcnMgb2YgdmVydGljZXMgKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcbmZ1bmN0aW9uIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCB1diwgeyBoYWxmV2lkdGgsIHZlcnRpY2VzLCBzY2FsaW5nVmVjcywgdGV4Y29vcmRzIH0pIHtcbiAgICBpZiAoc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgLy8gIGEuIElmIHNjYWxpbmcgaXMgb24gYWRkIHRoZSB2ZXJ0ZXggKHRoZSBjdXJyQ29vcmQpIGFuZCB0aGUgc2NhbGluZyBWZWNzIChub3JtYWxzIHBvaW50aW5nIHdoZXJlIHRvIGV4dHJ1ZGUgdGhlIHZlcnRleGVzKVxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNvb3JkKTtcbiAgICAgICAgc2NhbGluZ1ZlY3MucHVzaChub3JtYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBiLiBBZGQgdGhlIGV4dHJ1ZGVkIHZlcnRleGVzXG4gICAgICAgIHZlcnRpY2VzLnB1c2goW2Nvb3JkWzBdICsgbm9ybWFsWzBdICogaGFsZldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSArIG5vcm1hbFsxXSAqIGhhbGZXaWR0aF0pO1xuICAgIH1cblxuICAgIC8vIGMpIEFkZCB1didzIGlmIHRoZXkgYXJlIGVuYWJsZVxuICAgIGlmICh0ZXhjb29yZHMpIHtcbiAgICAgICAgdGV4Y29vcmRzLnB1c2godXYpO1xuICAgIH1cbn1cblxuLy8gIEFkZCB0byBlcXVpZGlzdGFudCBwYWlycyBvZiB2ZXJ0aWNlcyAoaW50ZXJuYWwgbWV0aG9kIGZvciBwb2x5bGluZSBidWlsZGVyKVxuZnVuY3Rpb24gYWRkVmVydGV4UGFpciAoY29vcmQsIG5vcm1hbCwgdl9wY3QsIGNvbnN0YW50cykge1xuICAgIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCBbY29uc3RhbnRzLm1heF91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XSwgY29uc3RhbnRzKTtcbiAgICBhZGRWZXJ0ZXgoY29vcmQsIFZlY3Rvci5uZWcobm9ybWFsKSwgW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sIGNvbnN0YW50cyk7XG59XG5cbi8vICBUZXNzYWxhdGUgYSBGQU4gZ2VvbWV0cnkgYmV0d2VlbiBwb2ludHMgQSAgICAgICBCXG4vLyAgdXNpbmcgdGhlaXIgbm9ybWFscyBmcm9tIGEgY2VudGVyICAgICAgICBcXCAuIC4gL1xuLy8gIGFuZCBpbnRlcnBvbGF0aW5nIHRoZWlyIFVWcyAgICAgICAgICAgICAgIFxcIHAgL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXC4vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDXG5mdW5jdGlvbiBhZGRGYW4gKGNvb3JkLCBuQSwgbkMsIG5CLCB1QSwgdUMsIHVCLCBzaWduZWQsIG51bVRyaWFuZ2xlcywgY29uc3RhbnRzKSB7XG5cbiAgICBpZiAobnVtVHJpYW5nbGVzIDwgMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWRkIHByZXZpdXMgdmVydGljZXMgdG8gYnVmZmVyIGFuZCBjbGVhbiB0aGUgYnVmZmVycyBhbmQgaW5kZXggcGFpcnNcbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBnb2luZyB0byBhZGQgbW9yZSB0cmlhbmdsZXMuXG4gICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xuXG4gICAgdmFyIG5vcm1DdXJyID0gVmVjdG9yLnNldChuQSk7XG4gICAgdmFyIG5vcm1QcmV2ID0gWzAsMF07XG5cbiAgICB2YXIgYW5nbGVfZGVsdGEgPSBWZWN0b3IuZG90KG5BLCBuQik7XG4gICAgaWYgKGFuZ2xlX2RlbHRhIDwgLTEpIHtcbiAgICAgICAgYW5nbGVfZGVsdGEgPSAtMTtcbiAgICB9XG4gICAgYW5nbGVfZGVsdGEgPSBNYXRoLmFjb3MoYW5nbGVfZGVsdGEpL251bVRyaWFuZ2xlcztcblxuICAgIGlmICghc2lnbmVkKSB7XG4gICAgICAgIGFuZ2xlX2RlbHRhICo9IC0xO1xuICAgIH1cblxuICAgIHZhciB1dkN1cnIgPSBWZWN0b3Iuc2V0KHVBKTtcbiAgICB2YXIgdXZfZGVsdGEgPSBWZWN0b3IuZGl2KFZlY3Rvci5zdWIodUIsdUEpLCBudW1UcmlhbmdsZXMpO1xuXG4gICAgLy8gIEFkZCB0aGUgZmlyc3QgYW5kIENFTlRFUiB2ZXJ0ZXhcbiAgICAvLyAgVGhlIHRyaWFuZ2xlcyB3aWxsIGJlIGNvbXBvc2VkIG9uIEZBTiBzdHlsZSBhcnJvdW5kIGl0XG4gICAgYWRkVmVydGV4KGNvb3JkLCBuQywgdUMsIGNvbnN0YW50cyk7XG5cbiAgICAvLyAgQWRkIGZpcnN0IGNvcm5lclxuICAgIGFkZFZlcnRleChjb29yZCwgbm9ybUN1cnIsIHVBLCBjb25zdGFudHMpO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBjb29ybmVyc1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVHJpYW5nbGVzOyB0KyspIHtcbiAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKG5vcm1DdXJyKTtcbiAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iucm90KCBWZWN0b3Iubm9ybWFsaXplKG5vcm1DdXJyKSwgYW5nbGVfZGVsdGEpOyAgICAgLy8gIFJvdGF0ZSB0aGUgZXh0cnVzaW9uIG5vcm1hbFxuXG4gICAgICAgIGlmIChudW1UcmlhbmdsZXMgPT09IDQgJiYgKHQgPT09IDAgfHwgdCA9PT0gbnVtVHJpYW5nbGVzIC0gMikpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguYWJzKFZlY3Rvci5kb3Qobm9ybVByZXYsIG5vcm1DdXJyKSkpO1xuICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3IubXVsdChub3JtQ3Vyciwgc2NhbGUqc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXZDdXJyID0gVmVjdG9yLmFkZCh1dkN1cnIsdXZfZGVsdGEpO1xuXG4gICAgICAgIGFkZFZlcnRleChjb29yZCwgbm9ybUN1cnIsIHV2Q3VyciwgY29uc3RhbnRzKTsgICAgICAvLyAgQWRkIGNvbXB1dGVkIGNvcm5lclxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICAgICAgYWRkSW5kZXgoaSsyLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgYWRkSW5kZXgoMCwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMSwgY29uc3RhbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMSwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KDAsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleChpKzIsIGNvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhbiB0aGUgYnVmZmVyXG4gICAgY29uc3RhbnRzLnZlcnRpY2VzID0gW107XG4gICAgaWYgKGNvbnN0YW50cy5zY2FsaW5nVmVjcykge1xuICAgICAgICBjb25zdGFudHMuc2NhbGluZ1ZlY3MgPSBbXTtcbiAgICB9XG4gICAgaWYgKGNvbnN0YW50cy50ZXhjb29yZHMpIHtcbiAgICAgICAgY29uc3RhbnRzLnRleGNvb3JkcyA9IFtdO1xuICAgIH1cbn1cblxuLy8gIEFkZCBzcGVjY2lhbHMgam9pbnMgKG5vdCBtaXRlcikgdGlwZXMgdGhhdCByZXF1aXJlIEZBTiB0ZXNzYWxhdGlvbnNcbi8vICBVc2luZyB0aGlzICggaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vQXJ0aWNsZXMvMjI2NTY5L0RyYXdpbmctcG9seWxpbmVzLWJ5LXRlc3NlbGxhdGlvbiApIGFzIHJlZmVyZW5jZVxuZnVuY3Rpb24gYWRkSm9pbiAoY29vcmRzLCBub3JtYWxzLCB2X3BjdCwgblRyaWFuZ2xlcywgY29uc3RhbnRzKSB7XG5cbiAgICB2YXIgVCA9IFtWZWN0b3Iuc2V0KG5vcm1hbHNbMF0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMV0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMl0pXTtcbiAgICB2YXIgc2lnbmVkID0gVmVjdG9yLnNpZ25lZF9hcmVhKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0pID4gMDtcblxuICAgIHZhciBuQSA9IFRbMF0sICAgICAgICAgICAgICAvLyBub3JtYWwgdG8gcG9pbnQgQSAoYVQpXG4gICAgICAgIG5DID0gVmVjdG9yLm5lZyhUWzFdKSwgIC8vIG5vcm1hbCB0byBjZW50ZXIgKC12UClcbiAgICAgICAgbkIgPSBUWzJdOyAgICAgICAgICAgICAgLy8gbm9ybWFsIHRvIHBvaW50IEIgKGJUKVxuXG4gICAgdmFyIHVBID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sXG4gICAgICAgIHVDID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sXG4gICAgICAgIHVCID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG5cbiAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5BLCB1QSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5BID0gVmVjdG9yLm5lZyhUWzBdKTtcbiAgICAgICAgbkMgPSBUWzFdO1xuICAgICAgICBuQiA9IFZlY3Rvci5uZWcoVFsyXSk7XG4gICAgICAgIHVBID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIHVDID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIHVCID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkEsIHVBLCBjb25zdGFudHMpO1xuICAgIH1cblxuICAgIGFkZEZhbihjb29yZHNbMV0sIG5BLCBuQywgbkIsIHVBLCB1QywgdUIsIHNpZ25lZCwgblRyaWFuZ2xlcywgY29uc3RhbnRzKTtcblxuICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkIsIHVCLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQiwgdUIsIGNvbnN0YW50cyk7XG4gICAgfVxufVxuXG4vLyAgRnVuY3Rpb24gdG8gYWRkIHRoZSB2ZXJ0ZXggbmVlZCBmb3IgbGluZSBjYXBzLFxuLy8gIGJlY2F1c2UgcmUtdXNlIHRoZSBidWZmZXJzIG5lZWRzIHRvIGJlIGF0IHRoZSBlbmRcbmZ1bmN0aW9uIGFkZENhcCAoY29vcmQsIG5vcm1hbCwgbnVtQ29ybmVycywgaXNCZWdpbm5pbmcsIGNvbnN0YW50cykge1xuXG4gICAgaWYgKG51bUNvcm5lcnMgPCAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVVnNcbiAgICB2YXIgdXZBID0gW2NvbnN0YW50cy5taW5fdSxjb25zdGFudHMubWluX3ZdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlZ2luaW5nIGFuZ2xlIFVWc1xuICAgICAgICB1dkMgPSBbY29uc3RhbnRzLm1pbl91Kyhjb25zdGFudHMubWF4X3UtY29uc3RhbnRzLm1pbl91KS8yLCBjb25zdGFudHMubWluX3ZdLCAgIC8vIGNlbnRlciBwb2ludCBVVnNcbiAgICAgICAgdXZCID0gW2NvbnN0YW50cy5tYXhfdSxjb25zdGFudHMubWluX3ZdOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZGluZyBhbmdsZSBVVnNcblxuICAgIGlmICghaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgdXZBID0gW2NvbnN0YW50cy5taW5fdSxjb25zdGFudHMubWF4X3ZdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlZ2luaW5nIGFuZ2xlIFVWc1xuICAgICAgICB1dkMgPSBbY29uc3RhbnRzLm1pbl91Kyhjb25zdGFudHMubWF4X3UtY29uc3RhbnRzLm1pbl91KS8yLCBjb25zdGFudHMubWF4X3ZdLCAgIC8vIGNlbnRlciBwb2ludCBVVnNcbiAgICAgICAgdXZCID0gW2NvbnN0YW50cy5tYXhfdSxjb25zdGFudHMubWF4X3ZdO1xuICAgIH1cblxuICAgIGFkZEZhbiggY29vcmQsXG4gICAgICAgICAgICBWZWN0b3IubmVnKG5vcm1hbCksIFswLCAwXSwgbm9ybWFsLFxuICAgICAgICAgICAgdXZBLCB1dkMsIHV2QixcbiAgICAgICAgICAgIGlzQmVnaW5uaW5nLCBudW1Db3JuZXJzKjIsIGNvbnN0YW50cyk7XG59XG5cbi8vIEFkZCBhIHZlcnRleCBiYXNlZCBvbiB0aGUgaW5kZXggcG9zaXRpb24gaW50byB0aGUgVkJPIChpbnRlcm5hbCBtZXRob2QgZm9yIHBvbHlsaW5lIGJ1aWxkZXIpXG5mdW5jdGlvbiBhZGRJbmRleCAoaW5kZXgsIHsgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSwgaGFsZldpZHRoLCB2ZXJ0aWNlcywgc2NhbGluZ19pbmRleCwgc2NhbGluZ1ZlY3MsIHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZHMgfSkge1xuICAgIC8vIFByZXZlbnQgYWNjZXNzIHRvIHVuZGVmaW5lZCB2ZXJ0aWNlc1xuICAgIGlmIChpbmRleCA+PSB2ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCB2ZXJ0ZXggcG9zaXRpb25cbiAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSB2ZXJ0aWNlc1tpbmRleF1bMF07XG4gICAgdmVydGV4X3RlbXBsYXRlWzFdID0gdmVydGljZXNbaW5kZXhdWzFdO1xuXG4gICAgLy8gc2V0IFVWc1xuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1tpbmRleF1bMF07XG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvLyBzZXQgU2NhbGluZyB2ZXJ0ZXggKFgsIFkgbm9ybWFsIGRpcmVjdGlvbiArIFogaGFsdHdpZHRoIGFzIGF0dHJpYnV0ZSlcbiAgICBpZiAoc2NhbGluZ19pbmRleCkge1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDBdID0gc2NhbGluZ1ZlY3NbaW5kZXhdWzBdO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDFdID0gc2NhbGluZ1ZlY3NbaW5kZXhdWzFdO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDJdID0gaGFsZldpZHRoO1xuICAgIH1cblxuICAgIC8vICBBZGQgdmVydGV4IHRvIFZCT1xuICAgIHZlcnRleF9kYXRhLmFkZFZlcnRleCh2ZXJ0ZXhfdGVtcGxhdGUpO1xufVxuXG4vLyBBZGQgdGhlIGluZGV4IHZlcnRleCB0byB0aGUgVkJPIGFuZCBjbGVhbiB0aGUgYnVmZmVyc1xuZnVuY3Rpb24gaW5kZXhQYWlycyAoY29uc3RhbnRzKSB7XG4gICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY29yZGluZyB0aGVpciBpbmRleFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RhbnRzLm5QYWlyczsgaSsrKSB7XG4gICAgICAgIGFkZEluZGV4KDIqaSsyLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkSW5kZXgoMippKzAsIGNvbnN0YW50cyk7XG5cbiAgICAgICAgYWRkSW5kZXgoMippKzIsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDIqaSszLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMSwgY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICBjb25zdGFudHMublBhaXJzID0gMDtcblxuICAgIC8vIENsZWFuIHRoZSBidWZmZXJcbiAgICBjb25zdGFudHMudmVydGljZXMgPSBbXTtcbiAgICBpZiAoY29uc3RhbnRzLnNjYWxpbmdWZWNzKSB7XG4gICAgICAgIGNvbnN0YW50cy5zY2FsaW5nVmVjcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoY29uc3RhbnRzLnRleGNvb3Jkcykge1xuICAgICAgICBjb25zdGFudHMudGV4Y29vcmRzID0gW107XG4gICAgfVxufVxuXG4vLyBCdWlsZCBhIGJpbGxib2FyZCBzcHJpdGUgcXVhZCBjZW50ZXJlZCBvbiBhIHBvaW50LiBTcHJpdGVzIGFyZSBpbnRlbmRlZCB0byBiZSBkcmF3biBpbiBzY3JlZW5zcGFjZSwgYW5kIGhhdmVcbi8vIHByb3BlcnRpZXMgZm9yIHdpZHRoLCBoZWlnaHQsIGFuZ2xlLCBhbmQgYSBzY2FsZSBmYWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byBpbnRlcnBvbGF0ZSB0aGUgc2NyZWVuc3BhY2Ugc2l6ZVxuLy8gb2YgYSBzcHJpdGUgYmV0d2VlbiB0d28gem9vbSBsZXZlbHMuXG5CdWlsZGVycy5idWlsZFF1YWRzRm9yUG9pbnRzID0gZnVuY3Rpb24gKFxuICAgIHBvaW50cyxcbiAgICB3aWR0aCwgaGVpZ2h0LCBhbmdsZSwgc2NhbGUsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICBzY2FsaW5nX2luZGV4LFxuICAgIHsgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkX3NjYWxlIH0pIHtcblxuICAgIGxldCB3MiA9IHdpZHRoIC8gMjtcbiAgICBsZXQgaDIgPSBoZWlnaHQgLyAyO1xuICAgIGxldCBzY2FsaW5nID0gW1xuICAgICAgICBbLXcyLCAtaDJdLFxuICAgICAgICBbdzIsIC1oMl0sXG4gICAgICAgIFt3MiwgaDJdLFxuXG4gICAgICAgIFstdzIsIC1oMl0sXG4gICAgICAgIFt3MiwgaDJdLFxuICAgICAgICBbLXcyLCBoMl1cbiAgICBdO1xuXG4gICAgbGV0IFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcbiAgICBsZXQgdGV4Y29vcmRzO1xuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB0ZXhjb29yZHMgPSBbXG4gICAgICAgICAgICBbbWluX3UsIG1pbl92XSxcbiAgICAgICAgICAgIFttYXhfdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtYXhfdl0sXG5cbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtYXhfdl0sXG4gICAgICAgICAgICBbbWluX3UsIG1heF92XVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGxldCBudW1fcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwPTA7IHAgPCBudW1fcG9pbnRzOyBwKyspIHtcbiAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzW3BdO1xuXG4gICAgICAgIGZvciAobGV0IHBvcz0wOyBwb3MgPCA2OyBwb3MrKykge1xuICAgICAgICAgICAgLy8gQWRkIHRleGNvb3Jkc1xuICAgICAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbcG9zXVswXTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9IHRleGNvb3Jkc1twb3NdWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSBwb2ludFswXTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHBvaW50WzFdO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDBdID0gc2NhbGluZ1twb3NdWzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAxXSA9IHNjYWxpbmdbcG9zXVsxXTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgMl0gPSBhbmdsZTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgM10gPSBzY2FsZTtcblxuICAgICAgICAgICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbi8vIFRyaWFuZ3VsYXRpb24gdXNpbmcgZWFyY3V0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L2VhcmN1dFxuQnVpbGRlcnMudHJpYW5ndWxhdGVQb2x5Z29uID0gZnVuY3Rpb24gKGNvbnRvdXJzKVxue1xuICAgIHJldHVybiBlYXJjdXQoY29udG91cnMpO1xufTtcblxuLy8gVGVzdHMgaWYgYSBsaW5lIHNlZ21lbnQgKGZyb20gcG9pbnQgQSB0byBCKSBpcyBuZWFybHkgY29pbmNpZGVudCB3aXRoIHRoZSBlZGdlIG9mIGEgdGlsZVxuQnVpbGRlcnMuaXNPblRpbGVFZGdlID0gZnVuY3Rpb24gKHBhLCBwYiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHRvbGVyYW5jZV9mdW5jdGlvbiA9IG9wdGlvbnMudG9sZXJhbmNlX2Z1bmN0aW9uIHx8IEJ1aWxkZXJzLnZhbHVlc1dpdGhpblRvbGVyYW5jZTtcbiAgICB2YXIgdG9sZXJhbmNlID0gb3B0aW9ucy50b2xlcmFuY2UgfHwgMzsgLy8gdHdlYWsgdGhpcyBhZGp1c3QgaWYgY2F0Y2hpbmcgdG9vIGZldy9tYW55IGxpbmUgc2VnbWVudHMgbmVhciB0aWxlIGVkZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdG9sZXJhbmNlIGNvbmZpZ3VyYWJsZSBieSBzb3VyY2UgaWYgbmVjZXNzYXJ5XG4gICAgdmFyIHRpbGVfbWluID0gQnVpbGRlcnMudGlsZV9ib3VuZHNbMF07XG4gICAgdmFyIHRpbGVfbWF4ID0gQnVpbGRlcnMudGlsZV9ib3VuZHNbMV07XG4gICAgdmFyIGVkZ2UgPSBudWxsO1xuXG4gICAgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVswXSwgdGlsZV9taW4ueCwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMF0sIHRpbGVfbWluLngsIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgZWRnZSA9ICdsZWZ0JztcbiAgICB9XG4gICAgZWxzZSBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzBdLCB0aWxlX21heC54LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlswXSwgdGlsZV9tYXgueCwgdG9sZXJhbmNlKSkge1xuICAgICAgICBlZGdlID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgZWxzZSBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzFdLCB0aWxlX21pbi55LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlsxXSwgdGlsZV9taW4ueSwgdG9sZXJhbmNlKSkge1xuICAgICAgICBlZGdlID0gJ3RvcCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVsxXSwgdGlsZV9tYXgueSwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMV0sIHRpbGVfbWF4LnksIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgZWRnZSA9ICdib3R0b20nO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZTtcbn07XG5cbkJ1aWxkZXJzLnZhbHVlc1dpdGhpblRvbGVyYW5jZSA9IGZ1bmN0aW9uIChhLCBiLCB0b2xlcmFuY2UpIHtcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEgLSBiKSA8IHRvbGVyYW5jZSk7XG59O1xuXG4vLyBCdWlsZCBhIHppZ3phZyBsaW5lIHBhdHRlcm4gZm9yIHRlc3Rpbmcgam9pbnMgYW5kIGNhcHNcbkJ1aWxkZXJzLmJ1aWxkWmlnemFnTGluZVRlc3RQYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaW4gPSB7IHg6IDAsIHk6IDB9OyAvLyAgdGlsZS5taW47XG4gICAgdmFyIG1heCA9IHsgeDogNDA5NiwgeTogNDA5NiB9OyAvLyB0aWxlLm1heDtcblxuICAgIHZhciBnID0ge1xuICAgICAgICBpZDogMTIzLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjc1ICsgbWF4LnggKiAwLjI1LCBtaW4ueSAqIDAuNzUgKyBtYXgueSAqIDAuMjVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuNzUgKyBtYXgueCAqIDAuMjUsIG1pbi55ICogMC41ICsgbWF4LnkgKiAwLjVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuMjUgKyBtYXgueCAqIDAuNzUsIG1pbi55ICogMC43NSArIG1heC55ICogMC4yNV0sXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC4yNSArIG1heC54ICogMC43NSwgbWluLnkgKiAwLjI1ICsgbWF4LnkgKiAwLjc1XSxcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjQgKyBtYXgueCAqIDAuNiwgbWluLnkgKiAwLjUgKyBtYXgueSAqIDAuNV0sXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC41ICsgbWF4LnggKiAwLjUsIG1pbi55ICogMC4yNSArIG1heC55ICogMC43NV0sXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC43NSArIG1heC54ICogMC4yNSwgbWluLnkgKiAwLjI1ICsgbWF4LnkgKiAwLjc1XSxcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjc1ICsgbWF4LnggKiAwLjI1LCBtaW4ueSAqIDAuNCArIG1heC55ICogMC42XVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBraW5kOiAnZGVidWcnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBnO1xufTtcbiIsIi8vIExpbmUgcmVuZGVyaW5nIHN0eWxlXG5cbmltcG9ydCB7U3R5bGV9IGZyb20gJy4uL3N0eWxlJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi4vc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQgZ2wgZnJvbSAnLi4vLi4vZ2wvY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcbmltcG9ydCBWZXJ0ZXhMYXlvdXQgZnJvbSAnLi4vLi4vZ2wvdmVydGV4X2xheW91dCc7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vYnVpbGRlcnMnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcblxuZXhwb3J0IHZhciBMaW5lcyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xuXG5PYmplY3QuYXNzaWduKExpbmVzLCB7XG4gICAgbmFtZTogJ2xpbmVzJyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcbiAgICB2ZXJ0ZXhfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc192ZXJ0ZXgnLCAvLyByZS11c2UgcG9seWdvbiBzaGFkZXJzXG4gICAgZnJhZ21lbnRfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc19mcmFnbWVudCcsXG4gICAgc2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3Bvc2l0aW9uJywgc2l6ZTogMywgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2V4dHJ1ZGUnLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffc2NhbGUnLCBzaXplOiAxLCB0eXBlOiBnbC5TSE9SVCwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffc2VsZWN0aW9uX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9sYXllcicsIHNpemU6IDEsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gVGVsbCB0aGUgc2hhZGVyIHdlIHdhbnQgYW4gb3JkZXIgYXR0cmlidXRlLCBhbmQgdG8gZXh0cnVkZSBsaW5lc1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9PUkRFUl9BVFRSSUJVVEUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9FWFRSVURFX0xJTkVTID0gdHJ1ZTtcblxuICAgICAgICAvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1RFWFRVUkVfQ09PUkRTID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIHZlcnRleCBhdHRyaWJ1dGUgZm9yIFVWcyBvbmx5IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IG5ldyBWZXJ0ZXhMYXlvdXQoYXR0cmlicyk7XG4gICAgfSxcblxuICAgIF9wYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5mZWF0dXJlX3N0eWxlO1xuXG4gICAgICAgIGxldCBpbm5lcl93aWR0aCA9IHJ1bGVfc3R5bGUud2lkdGggJiYgU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLndpZHRoLCBjb250ZXh0LCAnbWV0ZXJzJyk7XG4gICAgICAgIGlmICghaW5uZXJfd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS53aWR0aCA9IGlubmVyX3dpZHRoICogY29udGV4dC51bml0c19wZXJfbWV0ZXI7XG5cbiAgICAgICAgLy8gU21vb3RobHkgaW50ZXJwb2xhdGUgbGluZSB3aWR0aCBiZXR3ZWVuIHpvb21zOiBnZXQgc2NhbGUgZmFjdG9yIHRvIG5leHQgem9vbVxuICAgICAgICAvLyBBZGp1c3QgYnkgZmFjdG9yIG9mIDIgYmVjYXVzZSB0aWxlIHVuaXRzIGFyZSB6b29tLWRlcGVuZGVudCAoYSBnaXZlbiB2YWx1ZSBpcyB0d2ljZSBhc1xuICAgICAgICAvLyBiaWcgaW4gd29ybGQgc3BhY2UgYXQgdGhlIG5leHQgem9vbSB0aGFuIGF0IHRoZSBwcmV2aW91cylcbiAgICAgICAgY29udGV4dC56b29tICsrO1xuICAgICAgICBjb250ZXh0LnVuaXRzX3Blcl9tZXRlciAqPSAyO1xuICAgICAgICBsZXQgbmV4dF93aWR0aCA9IFN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2UocnVsZV9zdHlsZS5uZXh0X3dpZHRoLCBjb250ZXh0LCAnbWV0ZXJzJyk7XG4gICAgICAgIHN0eWxlLm5leHRfd2lkdGggPSBVdGlscy5zY2FsZUludDE2KG5leHRfd2lkdGggKiBjb250ZXh0LnVuaXRzX3Blcl9tZXRlciAvIHN0eWxlLndpZHRoLCAyNTYpO1xuICAgICAgICBjb250ZXh0Lnpvb20tLTtcbiAgICAgICAgY29udGV4dC51bml0c19wZXJfbWV0ZXIgLz0gMjsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc2NhbGVcblxuICAgICAgICBzdHlsZS5jb2xvciA9IHRoaXMucGFyc2VDb2xvcihydWxlX3N0eWxlLmNvbG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFzdHlsZS5jb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWlnaHQgZGVmYXVsdHMgdG8gZmVhdHVyZSBoZWlnaHQsIGJ1dCBleHRydWRlIHN0eWxlIGNhbiBkeW5hbWljYWxseSBhZGp1c3QgaGVpZ2h0IGJ5IHJldHVybmluZyBhIG51bWJlciBvciBhcnJheSAoaW5zdGVhZCBvZiBhIGJvb2xlYW4pXG4gICAgICAgIHN0eWxlLnogPSAocnVsZV9zdHlsZS56ICYmIFN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2UocnVsZV9zdHlsZS56IHx8IDAsIGNvbnRleHQpKSB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy56O1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBmZWF0dXJlLnByb3BlcnRpZXMuaGVpZ2h0IHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmhlaWdodDtcbiAgICAgICAgc3R5bGUuZXh0cnVkZSA9IHJ1bGVfc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBzdHlsZS5leHRydWRlKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmV4dHJ1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZXh0cnVkZSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFpc2UgbGluZSBoZWlnaHQgaWYgZXh0cnVkZWRcbiAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUgJiYgc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBzdHlsZS56ICs9IHN0eWxlLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmNhcCA9IHJ1bGVfc3R5bGUuY2FwO1xuICAgICAgICBzdHlsZS5qb2luID0gcnVsZV9zdHlsZS5qb2luO1xuICAgICAgICBzdHlsZS50aWxlX2VkZ2VzID0gcnVsZV9zdHlsZS50aWxlX2VkZ2VzO1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbiBvdXRsaW5lIHN0eWxlXG4gICAgICAgIHN0eWxlLm91dGxpbmUgPSBzdHlsZS5vdXRsaW5lIHx8IHt9O1xuICAgICAgICBpZiAocnVsZV9zdHlsZS5vdXRsaW5lICYmIHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvciAmJiBydWxlX3N0eWxlLm91dGxpbmUud2lkdGgpIHtcbiAgICAgICAgICAgIGxldCBvdXRsaW5lX3dpZHRoID0gU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLm91dGxpbmUud2lkdGgsIGNvbnRleHQsICdtZXRlcnMnKSAqIDI7XG5cbiAgICAgICAgICAgIGNvbnRleHQuem9vbSArKztcbiAgICAgICAgICAgIGNvbnRleHQudW5pdHNfcGVyX21ldGVyICo9IDI7XG4gICAgICAgICAgICBsZXQgb3V0bGluZV9uZXh0X3dpZHRoID0gU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLm91dGxpbmUubmV4dF93aWR0aCwgY29udGV4dCwgJ21ldGVycycpICogMjtcbiAgICAgICAgICAgIGNvbnRleHQuem9vbS0tO1xuICAgICAgICAgICAgY29udGV4dC51bml0c19wZXJfbWV0ZXIgLz0gMjsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc2NhbGVcblxuICAgICAgICAgICAgLy8gTWFpbnRhaW4gY29uc2lzdGVudCBvdXRsaW5lIHdpZHRoIGFyb3VuZCB0aGUgaW5uZXIgbGluZVxuICAgICAgICAgICAgc3R5bGUub3V0bGluZS53aWR0aCA9IHsgdmFsdWU6IG91dGxpbmVfd2lkdGggKyBpbm5lcl93aWR0aCB9O1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5uZXh0X3dpZHRoID0geyB2YWx1ZTogb3V0bGluZV9uZXh0X3dpZHRoICsgbmV4dF93aWR0aCB9O1xuXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLmNvbG9yID0gcnVsZV9zdHlsZS5vdXRsaW5lLmNvbG9yO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jYXAgPSBydWxlX3N0eWxlLm91dGxpbmUuY2FwIHx8IHJ1bGVfc3R5bGUuY2FwO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5qb2luID0gcnVsZV9zdHlsZS5vdXRsaW5lLmpvaW4gfHwgcnVsZV9zdHlsZS5qb2luO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5zdHlsZSA9IHJ1bGVfc3R5bGUub3V0bGluZS5zdHlsZSB8fCB0aGlzLm5hbWU7XG5cbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgZGVmaW5lZCBvdXRsaW5lIG9yZGVyLCBvciBpbmhlcml0ZWQgZnJvbSBpbm5lciBsaW5lXG4gICAgICAgICAgICBpZiAocnVsZV9zdHlsZS5vdXRsaW5lLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5vcmRlciA9IHRoaXMucGFyc2VPcmRlcihydWxlX3N0eWxlLm91dGxpbmUub3JkZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5vcmRlciA9IHN0eWxlLm9yZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEb24ndCBsZXQgb3V0bGluZSBiZSBhYm92ZSBpbm5lciBsaW5lXG4gICAgICAgICAgICBpZiAoc3R5bGUub3V0bGluZS5vcmRlciA+IHN0eWxlLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5vcmRlciA9IHN0eWxlLm9yZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdXRsaW5lcyBhcmUgYWx3YXlzIGF0IGhhbGYtbGF5ZXIgaW50ZXJ2YWxzIHRvIGF2b2lkIGNvbmZsaWN0aW5nIHdpdGggaW5uZXIgbGluZXNcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgLT0gMC41O1xuXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLnByZXByb2Nlc3NlZCA9IHRydWU7IC8vIHNpZ25hbCB0aGF0IHdlJ3ZlIGFscmVhZHkgd3JhcHBlZCBwcm9wZXJ0aWVzIGluIGNhY2hlIG9iamVjdHNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBudWxsO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS53aWR0aCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIHByZXByb2Nlc3MgKGRyYXcpIHtcbiAgICAgICAgZHJhdy5jb2xvciA9IGRyYXcuY29sb3IgJiYgeyB2YWx1ZTogZHJhdy5jb2xvciB9O1xuICAgICAgICBkcmF3LndpZHRoID0gZHJhdy53aWR0aCAmJiB7IHZhbHVlOiBkcmF3LndpZHRoIH07XG4gICAgICAgIGRyYXcubmV4dF93aWR0aCA9IGRyYXcud2lkdGggJiYgeyB2YWx1ZTogZHJhdy53aWR0aC52YWx1ZSB9O1xuICAgICAgICBkcmF3LnogPSBkcmF3LnogJiYgeyB2YWx1ZTogZHJhdy56IH07XG5cbiAgICAgICAgaWYgKGRyYXcub3V0bGluZSkge1xuICAgICAgICAgICAgZHJhdy5vdXRsaW5lLmNvbG9yID0gZHJhdy5vdXRsaW5lLmNvbG9yICYmIHsgdmFsdWU6IGRyYXcub3V0bGluZS5jb2xvciB9O1xuICAgICAgICAgICAgZHJhdy5vdXRsaW5lLndpZHRoID0gZHJhdy5vdXRsaW5lLndpZHRoICYmIHsgdmFsdWU6IGRyYXcub3V0bGluZS53aWR0aCB9O1xuICAgICAgICAgICAgZHJhdy5vdXRsaW5lLm5leHRfd2lkdGggPSBkcmF3Lm91dGxpbmUud2lkdGggJiYgeyB2YWx1ZTogZHJhdy5vdXRsaW5lLndpZHRoLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBcInRlbXBsYXRlXCIgdGhhdCBzZXRzIGNvbnN0YW50IGF0dGlidXRlcyBmb3IgZWFjaCB2ZXJ0ZXgsIHdoaWNoIGlzIHRoZW4gbW9kaWZpZWQgcGVyIHZlcnRleCBvciBwZXIgZmVhdHVyZS5cbiAgICAgKiBBIHBsYWluIEpTIGFycmF5IG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cbiAgICAgKi9cbiAgICBtYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpIHtcbiAgICAgICAgLy8gcG9zaXRpb24gLSB4ICYgeSBjb29yZHMgd2lsbCBiZSBmaWxsZWQgaW4gcGVyLXZlcnRleCBiZWxvd1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVswXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzFdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMl0gPSBzdHlsZS56IHx8IDA7XG5cbiAgICAgICAgLy8gZXh0cnVzaW9uIHZlY3RvclxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVszXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzRdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbNV0gPSAxO1xuXG4gICAgICAgIC8vIHNjYWxpbmcgdG8gcHJldmlvdXMgYW5kIG5leHQgem9vbVxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVs2XSA9IHN0eWxlLm5leHRfd2lkdGg7XG5cbiAgICAgICAgLy8gY29sb3JcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbN10gPSBzdHlsZS5jb2xvclswXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbOF0gPSBzdHlsZS5jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbOV0gPSBzdHlsZS5jb2xvclsyXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTBdID0gc3R5bGUuY29sb3JbM10gKiAyNTU7XG5cbiAgICAgICAgLy8gc2VsZWN0aW9uIGNvbG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzExXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclswXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTJdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzFdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxM10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMl0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzE0XSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclszXSAqIDI1NTtcblxuICAgICAgICAvLyBsYXllciBvcmRlclxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxNV0gPSBzdHlsZS5vcmRlcjtcblxuICAgICAgICAvLyBBZGQgdGV4dHVyZSBVVnMgdG8gdGVtcGxhdGUgb25seSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMudGV4Y29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxNl0gPSAwO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTddID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRleF90ZW1wbGF0ZTtcbiAgICB9LFxuXG4gICAgYnVpbGRMaW5lcyhsaW5lcywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG5cbiAgICAgICAgLy8gTWFpbiBsaW5lXG4gICAgICAgIGlmIChzdHlsZS5jb2xvciAmJiBzdHlsZS53aWR0aCkge1xuICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRQb2x5bGluZXMoXG4gICAgICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGgsXG4gICAgICAgICAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwOiBzdHlsZS5jYXAsXG4gICAgICAgICAgICAgICAgICAgIGpvaW46IHN0eWxlLmpvaW4sXG4gICAgICAgICAgICAgICAgICAgIHNjYWxpbmdfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX2V4dHJ1ZGUsXG4gICAgICAgICAgICAgICAgICAgIHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCxcbiAgICAgICAgICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZF9wb2x5Z29uOiBvcHRpb25zICYmIG9wdGlvbnMuY2xvc2VkX3BvbHlnb24sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzOiAhc3R5bGUudGlsZV9lZGdlcyAmJiBvcHRpb25zICYmIG9wdGlvbnMucmVtb3ZlX3RpbGVfZWRnZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3V0bGluZVxuICAgICAgICAgaWYgKHN0eWxlLm91dGxpbmUgJiYgc3R5bGUub3V0bGluZS5jb2xvciAmJiBzdHlsZS5vdXRsaW5lLndpZHRoKSB7XG4gICAgICAgICAgICB2YXIgb3V0bGluZV9zdHlsZSA9IFN0eWxlTWFuYWdlci5zdHlsZXNbc3R5bGUub3V0bGluZS5zdHlsZV07XG4gICAgICAgICAgICBpZiAob3V0bGluZV9zdHlsZSkge1xuICAgICAgICAgICAgICAgIG91dGxpbmVfc3R5bGUuYWRkRmVhdHVyZShjb250ZXh0LmZlYXR1cmUsIHN0eWxlLm91dGxpbmUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAvLyBSZW5kZXIgcG9seWdvbnMgYXMgaW5kaXZpZHVhbCBsaW5lc1xuICAgICAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5Z29ucy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgdGhpcy5idWlsZExpbmVzKHBvbHlnb25zW3BdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQsIHsgY2xvc2VkX3BvbHlnb246IHRydWUsIHJlbW92ZV90aWxlX2VkZ2VzOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcbiIsIi8vIFBvaW50IHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4uLy4uL2dsL3RleHR1cmUnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCB2YXIgUG9pbnRzID0gT2JqZWN0LmNyZWF0ZShTdHlsZSk7XG5cbk9iamVjdC5hc3NpZ24oUG9pbnRzLCB7XG4gICAgbmFtZTogJ3BvaW50cycsXG4gICAgYnVpbHRfaW46IHRydWUsXG4gICAgc2VsZWN0aW9uOiB0cnVlLFxuICAgIGJsZW5kOiAnb3ZlcmxheScsIC8vIG92ZXJsYXlzIGRyYXduIG9uIHRvcCBvZiBhbGwgb3RoZXIgc3R5bGVzLCB3aXRoIGJsZW5kaW5nXG5cbiAgICBpbml0KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBTdHlsZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gQmFzZSBzaGFkZXJzXG4gICAgICAgIHRoaXMudmVydGV4X3NoYWRlcl9rZXkgPSAnc3R5bGVzL3BvaW50cy9wb2ludHNfdmVydGV4JztcbiAgICAgICAgdGhpcy5mcmFnbWVudF9zaGFkZXJfa2V5ID0gJ3N0eWxlcy9wb2ludHMvcG9pbnRzX2ZyYWdtZW50JztcblxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zaXRpb24nLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffc2hhcGUnLCBzaXplOiA0LCB0eXBlOiBnbC5TSE9SVCwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffc2VsZWN0aW9uX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9IC8vIFRPRE86IHBhY2sgaW50byBzaG9ydHNcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgcmVuZGVyaW5nIGFzIG92ZXJsYXksIHdlIG5lZWQgYSBsYXllciBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKHRoaXMuYmxlbmQgIT09ICdvdmVybGF5Jykge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fT1JERVJfQVRUUklCVVRFID0gdHJ1ZTtcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX2xheWVyJywgc2l6ZTogMSwgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcblxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9QT0lOVF9URVhUVVJFID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3JtcyA9IHRoaXMuc2hhZGVycy51bmlmb3JtcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3Jtcy51X3RleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlLmtleTtcblxuICAgICAgICBzdHlsZS5jb2xvciA9IHRoaXMucGFyc2VDb2xvcihydWxlX3N0eWxlLmNvbG9yLCBjb250ZXh0KTtcblxuICAgICAgICAvLyByZXF1aXJlIGNvbG9yIG9yIHRleHR1cmVcbiAgICAgICAgaWYgKCFzdHlsZS5jb2xvciAmJiAhdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLnNwcml0ZSA9IHJ1bGVfc3R5bGUuc3ByaXRlO1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlLnNwcml0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3R5bGUuc3ByaXRlID0gc3R5bGUuc3ByaXRlKGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVxdWlyZSBzcHJpdGUgdG8gZHJhdz9cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiAhc3R5bGUuc3ByaXRlICYmXG4gICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RoaXMudGV4dHVyZV0gJiYgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLnRleHR1cmVdLnNwcml0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gc2tpcCBmZWF0dXJlXG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUueiwgY29udGV4dCkpIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLno7XG5cbiAgICAgICAgLy8gcG9pbnQgc3R5bGUgb25seSBzdXBwb3J0cyBzaXplcyBpbiBwaXhlbCB1bml0cywgc28gdW5pdCBjb252ZXJzaW9uIGZsYWcgaXMgb2ZmXG4gICAgICAgIHN0eWxlLnNpemUgPSBydWxlX3N0eWxlLnNpemUgfHwgeyB2YWx1ZTogWzMyLCAzMl0gfTtcbiAgICAgICAgc3R5bGUuc2l6ZSA9IFN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2Uoc3R5bGUuc2l6ZSwgY29udGV4dCwgJ3BpeGVscycpO1xuXG4gICAgICAgIC8vIHNjYWxlIHNpemUgdG8gMTYtYml0IHNpZ25lZCBpbnQsIHdpdGggYSBtYXggYWxsb3dlZCB3aWR0aCArIGhlaWdodCBvZiAxMjggcGl4ZWxzXG4gICAgICAgIHN0eWxlLnNpemUgPSBbXG4gICAgICAgICAgICBNYXRoLm1pbigoc3R5bGUuc2l6ZVswXSB8fCBzdHlsZS5zaXplKSwgMjU2KSxcbiAgICAgICAgICAgIE1hdGgubWluKChzdHlsZS5zaXplWzFdIHx8IHN0eWxlLnNpemUpLCAyNTYpXG4gICAgICAgIF07XG5cbiAgICAgICAgc3R5bGUuc2l6ZVswXSAqPSBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgIHN0eWxlLnNpemVbMV0gKj0gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuXG4gICAgICAgIHN0eWxlLmFuZ2xlID0gcnVsZV9zdHlsZS5hbmdsZSB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmFuZ2xlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHlsZS5hbmdsZSA9IHN0eWxlLmFuZ2xlKGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFjdG9yIGJ5IHdoaWNoIHBvaW50IHNjYWxlcyBmcm9tIGN1cnJlbnQgem9vbSBsZXZlbCB0byBuZXh0IHpvb20gbGV2ZWxcbiAgICAgICAgc3R5bGUuc2NhbGUgPSBydWxlX3N0eWxlLnNjYWxlIHx8IDE7XG5cbiAgICAgICAgLy8gdG8gc3RvcmUgYmJveCBieSB0aWxlc1xuICAgICAgICBzdHlsZS50aWxlID0gdGlsZTtcblxuICAgICAgICAvLyBwb2x5Z29ucyByZW5kZXJpbmcgYXMgcG9pbnRzIHdpbGwgcmVuZGVyIGVhY2ggaW5kaXZpZHVhbCBwb2x5Z29uIHBvaW50IGJ5IGRlZmF1bHQsIGJ1dFxuICAgICAgICAvLyByZW5kZXJpbmcgYSBzaW5nbGUgcG9pbnQgYXQgdGhlIHBvbHlnb24ncyBjZW50cm9pZCBjYW4gYmUgZW5hYmxlZFxuICAgICAgICBzdHlsZS5jZW50cm9pZCA9IHJ1bGVfc3R5bGUuY2VudHJvaWQ7XG5cbiAgICAgICAgLy8gU2V0cyB0ZXhjb29yZCBzY2FsZSBpZiBuZWVkZWQgKGUuZy4gZm9yIHNwcml0ZSBzdWItYXJlYSlcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiBzdHlsZS5zcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4Y29vcmRfc2NhbGUgPSBUZXh0dXJlLmdldFNwcml0ZVRleGNvb3Jkcyh0aGlzLnRleHR1cmUsIHN0eWxlLnNwcml0ZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4Y29vcmRfc2NhbGUpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihgU3R5bGU6IGluIHN0eWxlICcke3RoaXMubmFtZX0nLCBjb3VsZCBub3QgZmluZCBzcHJpdGUgJyR7c3R5bGUuc3ByaXRlfScgZm9yIHRleHR1cmUgJyR7dGhpcy50ZXh0dXJlfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4Y29vcmRfc2NhbGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBwcmVwcm9jZXNzIChkcmF3KSB7XG4gICAgICAgIGRyYXcuY29sb3IgPSBkcmF3LmNvbG9yICYmIHsgdmFsdWU6IGRyYXcuY29sb3IgfTtcbiAgICAgICAgZHJhdy56ID0gZHJhdy56ICYmIHsgdmFsdWU6IGRyYXcueiB9O1xuICAgICAgICBkcmF3LnNpemUgPSBkcmF3LnNpemUgJiYgeyB2YWx1ZTogZHJhdy5zaXplIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgXCJ0ZW1wbGF0ZVwiIHRoYXQgc2V0cyBjb25zdGFudCBhdHRpYnV0ZXMgZm9yIGVhY2ggdmVydGV4LCB3aGljaCBpcyB0aGVuIG1vZGlmaWVkIHBlciB2ZXJ0ZXggb3IgcGVyIGZlYXR1cmUuXG4gICAgICogQSBwbGFpbiBKUyBhcnJheSBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXG4gICAgICovXG4gICAgbWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHN0eWxlLmNvbG9yIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmNvbG9yO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIC0geCAmIHkgY29vcmRzIHdpbGwgYmUgZmlsbGVkIGluIHBlci12ZXJ0ZXggYmVsb3dcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMF0gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzJdID0gc3R5bGUueiB8fCAwO1xuXG4gICAgICAgIC8vIHNjYWxpbmcgdmVjdG9yIC0gKHgsIHkpIGNvbXBvbmVudHMgcGVyIHBpeGVsLCB6ID0gYW5nbGUsIHcgPSBzY2FsaW5nIGZhY3RvclxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVszXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzRdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbNV0gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVs2XSA9IDA7XG5cbiAgICAgICAgLy8gY29sb3JcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbN10gPSBjb2xvclswXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbOF0gPSBjb2xvclsxXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbOV0gPSBjb2xvclsyXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTBdID0gY29sb3JbM10gKiAyNTU7XG5cbiAgICAgICAgLy8gc2VsZWN0aW9uIGNvbG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzExXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclswXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTJdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzFdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxM10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMl0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzE0XSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclszXSAqIDI1NTtcblxuICAgICAgICAvLyB0ZXh0dXJlIGNvb3Jkc1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxNV0gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxNl0gPSAwO1xuXG4gICAgICAgIC8vIEFkZCBsYXllciBhdHRyaWJ1dGUgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLmRlZmluZXMuVEFOR1JBTV9PUkRFUl9BVFRSSUJVVEUpIHtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzE3XSA9IHN0eWxlLm9yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGV4X3RlbXBsYXRlO1xuICAgIH0sXG5cbiAgICBidWlsZFBvaW50cyAocG9pbnRzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgaWYgKCFzdHlsZS5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuXG4gICAgICAgIGxldCBzaXplID0gc3R5bGUuc2l6ZTtcbiAgICAgICAgbGV0IGFuZ2xlID0gc3R5bGUuYW5nbGU7XG5cbiAgICAgICAgQnVpbGRlcnMuYnVpbGRRdWFkc0ZvclBvaW50cyhcbiAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgIFV0aWxzLnNjYWxlSW50MTYoc2l6ZVswXSwgMjU2KSwgVXRpbHMuc2NhbGVJbnQxNihzaXplWzFdLCAyNTYpLFxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihVdGlscy5yYWRUb0RlZyhhbmdsZSksIDM2MCksXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KHN0eWxlLnNjYWxlLCAyNTYpLFxuICAgICAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9zaGFwZSxcbiAgICAgICAgICAgIHsgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLCB0ZXhjb29yZF9zY2FsZTogdGhpcy50ZXhjb29yZF9zY2FsZSB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICAvLyBSZW5kZXIgcG9seWdvbnMgYXMgaW5kaXZpZHVhbCBwb2ludHMsIG9yIGNlbnRyb2lkXG4gICAgICAgIGlmICghc3R5bGUuY2VudHJvaWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBvbHk9MDsgcG9seSA8IHBvbHlnb25zLmxlbmd0aDsgcG9seSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvbHlnb24gPSBwb2x5Z29uc1twb2x5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByPTA7IHIgPCBwb2x5Z29uLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMocG9seWdvbltyXSwgc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2VudHJvaWQgPSBVdGlscy5tdWx0aUNlbnRyb2lkKHBvbHlnb25zKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMoW2NlbnRyb2lkXSwgc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZExpbmVzKGxpbmVzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgLy8gUmVuZGVyIGxpbmVzIGFzIGluZGl2aWR1YWwgcG9pbnRzXG4gICAgICAgIGZvciAobGV0IGxuPTA7IGxuIDwgbGluZXMubGVuZ3RoOyBsbisrKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKGxpbmVzW2xuXSwgc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG4iLCIvLyBQb2x5Z29uIHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcblxuZXhwb3J0IHZhciBQb2x5Z29ucyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xuXG5PYmplY3QuYXNzaWduKFBvbHlnb25zLCB7XG4gICAgbmFtZTogJ3BvbHlnb25zJyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcblxuICAgIGluaXQoKSB7XG4gICAgICAgIFN0eWxlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBCYXNlIHNoYWRlcnNcbiAgICAgICAgdGhpcy52ZXJ0ZXhfc2hhZGVyX2tleSA9ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfdmVydGV4JztcbiAgICAgICAgdGhpcy5mcmFnbWVudF9zaGFkZXJfa2V5ID0gJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc19mcmFnbWVudCc7XG5cbiAgICAgICAgLy8gVHVybiBmZWF0dXJlIHNlbGVjdGlvbiBvblxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRydWU7XG5cbiAgICAgICAgLy8gQmFzaWMgYXR0cmlidXRlcywgb3RoZXJzIGNhbiBiZSBhZGRlZCAoc2VlIHRleHR1cmUgVVZzIGJlbG93KVxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zaXRpb24nLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffbm9ybWFsJywgc2l6ZTogMywgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAvLyB7IG5hbWU6ICdhX25vcm1hbCcsIHNpemU6IDMsIHR5cGU6IGdsLkJZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSwgLy8gYXR0cmliIGlzbid0IGEgbXVsdGlwbGUgb2YgNCFcbiAgICAgICAgICAgIC8vIHsgbmFtZTogJ2FfY29sb3InLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICAvLyB7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9zZWxlY3Rpb25fY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2xheWVyJywgc2l6ZTogMSwgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBUZWxsIHRoZSBzaGFkZXIgd2UgaGF2ZSBhIG5vcm1hbCBhbmQgb3JkZXIgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9OT1JNQUxfQVRUUklCVVRFID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fT1JERVJfQVRUUklCVVRFID0gdHJ1ZTtcblxuICAgICAgICAvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1RFWFRVUkVfQ09PUkRTID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIHZlcnRleCBhdHRyaWJ1dGUgZm9yIFVWcyBvbmx5IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IG5ldyBWZXJ0ZXhMYXlvdXQoYXR0cmlicyk7XG4gICAgfSxcblxuICAgIF9wYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5mZWF0dXJlX3N0eWxlO1xuXG4gICAgICAgIHN0eWxlLmNvbG9yID0gdGhpcy5wYXJzZUNvbG9yKHJ1bGVfc3R5bGUuY29sb3IsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIXN0eWxlLmNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlaWdodCBkZWZhdWx0cyB0byBmZWF0dXJlIGhlaWdodCwgYnV0IGV4dHJ1ZGUgc3R5bGUgY2FuIGR5bmFtaWNhbGx5IGFkanVzdCBoZWlnaHQgYnkgcmV0dXJuaW5nIGEgbnVtYmVyIG9yIGFycmF5IChpbnN0ZWFkIG9mIGEgYm9vbGVhbilcbiAgICAgICAgc3R5bGUueiA9IChydWxlX3N0eWxlLnogJiYgU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLnosIGNvbnRleHQpKSB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy56O1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBmZWF0dXJlLnByb3BlcnRpZXMuaGVpZ2h0IHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmhlaWdodDtcbiAgICAgICAgc3R5bGUubWluX2hlaWdodCA9IGZlYXR1cmUucHJvcGVydGllcy5taW5faGVpZ2h0IHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLm1pbl9oZWlnaHQ7XG4gICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBydWxlX3N0eWxlLmV4dHJ1ZGU7XG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmV4dHJ1ZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5leHRydWRlID0gc3R5bGUuZXh0cnVkZShjb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5leHRydWRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLmV4dHJ1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmV4dHJ1ZGUpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubWluX2hlaWdodCA9IHN0eWxlLmV4dHJ1ZGVbMF07XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0eWxlLm91dGxpbmUgPSBzdHlsZS5vdXRsaW5lIHx8IHt9O1xuICAgICAgICAvLyBpZiAocnVsZV9zdHlsZS5vdXRsaW5lKSB7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLmNvbG9yID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlX3N0eWxlLm91dGxpbmUuY29sb3IsIGNvbnRleHQpO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS53aWR0aCA9IFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2UocnVsZV9zdHlsZS5vdXRsaW5lLndpZHRoLCBjb250ZXh0KTtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUudGlsZV9lZGdlcyA9IHJ1bGVfc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS5jYXAgPSBydWxlX3N0eWxlLm91dGxpbmUuY2FwIHx8IHJ1bGVfc3R5bGUuY2FwO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS5qb2luID0gcnVsZV9zdHlsZS5vdXRsaW5lLmpvaW4gfHwgcnVsZV9zdHlsZS5qb2luO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS5jb2xvciA9IG51bGw7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gbnVsbDtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUudGlsZV9lZGdlcyA9IGZhbHNlO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBwcmVwcm9jZXNzIChkcmF3KSB7XG4gICAgICAgIGRyYXcuY29sb3IgPSBkcmF3LmNvbG9yICYmIHsgdmFsdWU6IGRyYXcuY29sb3IgfTtcbiAgICAgICAgZHJhdy56ID0gZHJhdy56ICYmIHsgdmFsdWU6IGRyYXcueiB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIFwidGVtcGxhdGVcIiB0aGF0IHNldHMgY29uc3RhbnQgYXR0aWJ1dGVzIGZvciBlYWNoIHZlcnRleCwgd2hpY2ggaXMgdGhlbiBtb2RpZmllZCBwZXIgdmVydGV4IG9yIHBlciBmZWF0dXJlLlxuICAgICAqIEEgcGxhaW4gSlMgYXJyYXkgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxuICAgICAqL1xuICAgIG1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSkge1xuICAgICAgICAvLyBwb3NpdGlvbiAtIHggJiB5IGNvb3JkcyB3aWxsIGJlIGZpbGxlZCBpbiBwZXItdmVydGV4IGJlbG93XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzBdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMV0gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsyXSA9IHN0eWxlLnogfHwgMDtcblxuICAgICAgICAvLyBub3JtYWxcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbM10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVs0XSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzVdID0gMTtcblxuICAgICAgICAvLyBjb2xvclxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVs2XSA9IHN0eWxlLmNvbG9yWzBdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVs3XSA9IHN0eWxlLmNvbG9yWzFdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVs4XSA9IHN0eWxlLmNvbG9yWzJdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVs5XSA9IHN0eWxlLmNvbG9yWzNdICogMjU1O1xuXG4gICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxMF0gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMF0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzExXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTJdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzJdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVsxM10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbM10gKiAyNTU7XG5cbiAgICAgICAgLy8gbGF5ZXIgb3JkZXJcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTRdID0gc3R5bGUub3JkZXI7XG5cbiAgICAgICAgLy8gQWRkIHRleHR1cmUgVVZzIHRvIHRlbXBsYXRlIG9ubHkgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnRleGNvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbMTVdID0gMDtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlWzE2XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0ZXhfdGVtcGxhdGU7XG4gICAgfSxcblxuICAgIGJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICB2YXIgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuXG4gICAgICAgIC8vIEV4dHJ1ZGVkIHBvbHlnb25zIChlLmcuIDNEIGJ1aWxkaW5ncylcbiAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUgJiYgc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBCdWlsZGVycy5idWlsZEV4dHJ1ZGVkUG9seWdvbnMoXG4gICAgICAgICAgICAgICAgcG9seWdvbnMsXG4gICAgICAgICAgICAgICAgc3R5bGUueiwgc3R5bGUuaGVpZ2h0LCBzdHlsZS5taW5faGVpZ2h0LFxuICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfbm9ybWFsLFxuICAgICAgICAgICAgICAgIHsgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLCB0ZXhjb29yZF9zY2FsZTogdGhpcy50ZXhjb29yZF9zY2FsZSB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ3VsYXIgcG9seWdvbnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBCdWlsZGVycy5idWlsZFBvbHlnb25zKFxuICAgICAgICAgICAgICAgIHBvbHlnb25zLFxuICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgeyB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuIiwiaW1wb3J0IHttYXRjaH0gZnJvbSAnbWF0Y2gtZmVhdHVyZSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IGNvbnN0IHdoaXRlTGlzdCA9IFsnZmlsdGVyJywgJ2RyYXcnLCAndmlzaWJsZScsICdkYXRhJywgJ3Byb3BlcnRpZXMnXTtcblxuZXhwb3J0IGxldCBydWxlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gY2FjaGVLZXkgKHJ1bGVzKSB7XG4gICAgdmFyIGsgPSBydWxlc1swXS5pZDtcbiAgICBmb3IgKHZhciBpPTE7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrICs9ICcvJyArIHJ1bGVzW2ldLmlkO1xuICAgIH1cbiAgICByZXR1cm4gaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVHJlZXMobWF0Y2hpbmdUcmVlcywga2V5LCBjb250ZXh0KSB7XG4gICAgdmFyIGRyYXcgPSB7fSxcbiAgICAgICAgZHJhd3MsXG4gICAgICAgIC8vIG9yZGVyID0gW10sXG4gICAgICAgIC8vIG9yZGVyX2RyYXdzID0gW10sXG4gICAgICAgIHRyZWVEZXB0aCA9IDAsXG4gICAgICAgIHgsIHQ7XG5cbiAgICAvLyBWaXNpYmxlIGJ5IGRlZmF1bHRcbiAgICBkcmF3LnZpc2libGUgPSB0cnVlO1xuXG4gICAgLy8gRmluZCBkZWVwZXN0IHRyZWVcbiAgICBmb3IgKHQgPSAwOyB0IDwgbWF0Y2hpbmdUcmVlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICBpZiAobWF0Y2hpbmdUcmVlc1t0XS5sZW5ndGggPiB0cmVlRGVwdGgpIHtcbiAgICAgICAgICAgIHRyZWVEZXB0aCA9IG1hdGNoaW5nVHJlZXNbdF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gcnVsZXMgdG8gcGFyc2VcbiAgICBpZiAodHJlZURlcHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgdHJlZXMgaW4gcGFyYWxsZWxcbiAgICBmb3IgKHggPSAwOyB4IDwgdHJlZURlcHRoOyB4KyspIHtcbiAgICAgICAgZHJhd3MgPSBtYXRjaGluZ1RyZWVzLm1hcCh0cmVlID0+IHRyZWVbeF0gJiYgdHJlZVt4XVtrZXldKTtcbiAgICAgICAgaWYgKGRyYXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9wZXJ0eS1zcGVjaWZpYyBsb2dpY1xuICAgICAgICAvLyBmb3IgKGk9MDsgaSA8IGRyYXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vICAgICBpZiAoIWRyYXdzW2ldKSB7XG4gICAgICAgIC8vICAgICAgICAgY29udGludWU7XG4gICAgICAgIC8vICAgICB9XG5cbiAgICAgICAgLy8gICAgIC8vIENvbGxlY3QgdW5pcXVlIG9yZGVycyAoZG9uJ3QgYWRkIHRoZSBvcmRlciBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNtYWUgZHJhdyBydWxlKVxuICAgICAgICAvLyAgICAgaWYgKGRyYXdzW2ldLm9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gICAgICAgICBpZiAob3JkZXJfZHJhd3MuaW5kZXhPZihkcmF3c1tpXSkgPT09IC0xKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIG9yZGVyLnB1c2goZHJhd3NbaV0ub3JkZXIpO1xuICAgICAgICAvLyAgICAgICAgICAgICBvcmRlcl9kcmF3cy5wdXNoKGRyYXdzW2ldKTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBNZXJnZSByZW1haW5pbmcgZHJhdyBvYmplY3RzXG4gICAgICAgIG1lcmdlT2JqZWN0cyhkcmF3LCAuLi5kcmF3cyk7XG4gICAgfVxuXG4gICAgLy8gU2hvcnQtY2lyY3VpdCBpZiBub3QgdmlzaWJsZVxuICAgIGlmIChkcmF3LnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFN1bSBhbGwgb3JkZXJzXG4gICAgLy8gTm90ZTogdGVtcG9yYXJpbHkgY29tbWVudGluZyBvdXQsIHdpbGwgcmV2aXNpdCB3aXRoIG5ldyBzY2VuZSBmaWxlIHN5bnRheFxuICAgIC8vIGlmIChvcmRlci5sZW5ndGggPiAwKSB7XG4gICAgLy8gICAgIC8vIE9yZGVyIGNhbiBiZSBjYWNoZWQgaWYgaXQgaXMgYWxsIG51bWVyaWNcbiAgICAvLyAgICAgaWYgKG9yZGVyLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2Ygb3JkZXJbMF0gPT09ICdudW1iZXInKSB7XG4gICAgLy8gICAgICAgICBvcmRlciA9IG9yZGVyWzBdO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGVsc2UgaWYgKG9yZGVyLmV2ZXJ5KHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInKSkge1xuICAgIC8vICAgICAgICAgb3JkZXIgPSBjYWxjdWxhdGVPcmRlcihvcmRlciwgY29udGV4dCk7IC8vIFRPRE86IHVzZSBTdHlsZVBhcnNlci5jYWxjdWxhdGVPcmRlclxuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGRyYXcub3JkZXIgPSBvcmRlcjtcbiAgICAvLyB9XG5cbiAgICByZXR1cm4gZHJhdztcbn1cblxuXG5jbGFzcyBSdWxlIHtcblxuICAgIGNvbnN0cnVjdG9yKHtuYW1lLCBwYXJlbnQsIGRyYXcsIHZpc2libGUsIGZpbHRlciwgcHJvcGVydGllc30pIHtcbiAgICAgICAgdGhpcy5pZCA9IFJ1bGUuaWQrKztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZHJhdyA9IGRyYXc7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmxlICE9PSB1bmRlZmluZWQgPyB2aXNpYmxlIDogKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnZpc2libGUpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgPyBwcm9wZXJ0aWVzIDogKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIERlbm9ybWFsaXplIHByb3BlcnRpZXMgdG8gZHJhdyBncm91cHNcbiAgICAgICAgaWYgKHRoaXMuZHJhdykge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgaW4gdGhpcy5kcmF3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1tncm91cF0ucHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuYnVpbGREcmF3KCk7XG4gICAgfVxuXG4gICAgYnVpbGREcmF3KCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZWREcmF3ID0gY2FsY3VsYXRlRHJhdyh0aGlzKTtcbiAgICB9XG5cbiAgICBidWlsZEZpbHRlcigpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdGhpcy5maWx0ZXI7XG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBtYXRjaCh0aGlzLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBkcmF3OiB0aGlzLmRyYXdcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuUnVsZS5pZCA9IDA7XG5cblxuZXhwb3J0IGNsYXNzIFJ1bGVMZWFmIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSkge1xuICAgICAgICBzdXBlcih7bmFtZSwgcGFyZW50LCBkcmF3LCB2aXNpYmxlLCBmaWx0ZXIsIHByb3BlcnRpZXN9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bGVUcmVlIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgcnVsZXMsIGZpbHRlciwgcHJvcGVydGllc30pIHtcbiAgICAgICAgc3VwZXIoe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSk7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcyB8fCBbXTtcbiAgICB9XG5cbiAgICBhZGRSdWxlKHJ1bGUpIHtcbiAgICAgICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIGJ1aWxkRHJhd0dyb3Vwcyhjb250ZXh0KSB7XG4gICAgICAgIGxldCBydWxlcyAgPSBbXTtcbiAgICAgICAgLy9UT0RPLCBzaG91bGQgdGhpcyBmdW5jdGlvbiB0YWtlIGEgUnVsZVRyZWVcbiAgICAgICAgbWF0Y2hGZWF0dXJlKGNvbnRleHQsIFt0aGlzXSwgcnVsZXMpO1xuXG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVfa2V5ID0gY2FjaGVLZXkocnVsZXMpO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGV2YWx1YXRlIGVhY2ggcnVsZSBjb21iaW5hdGlvbiBvbmNlICh1bmRlZmluZWQgbWVhbnMgbm90IHlldCBldmFsdWF0ZWQsXG4gICAgICAgICAgICAvLyBudWxsIG1lYW5zIGV2YWx1YXRlZCB3aXRoIG5vIGRyYXcgb2JqZWN0KVxuICAgICAgICAgICAgaWYgKHJ1bGVDYWNoZVtjYWNoZV9rZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBWaXNpYmxlP1xuICAgICAgICAgICAgICAgIGlmIChydWxlcy5zb21lKHggPT4geC52aXNpYmxlID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgdGhlIHVuaXF1ZSBkcmF3IGJsb2NrcyBmb3IgdGhpcyBydWxlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYXdfcnVsZXMgPSBydWxlcy5tYXAoeCA9PiB4ICYmIHguY2FsY3VsYXRlZERyYXcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHJhd19rZXlzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBkcmF3X3J1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGdyb3VwIG9mIHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd19rZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBlYWNoIGRyYXcgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZHJhd19rZXkgaW4gZHJhd19rZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlQ2FjaGVbY2FjaGVfa2V5XSA9IHJ1bGVDYWNoZVtjYWNoZV9rZXldIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldID0gbWVyZ2VUcmVlcyhkcmF3X3J1bGVzLCBkcmF3X2tleSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc2F2ZSB0aGUgb25lcyB0aGF0IHdlcmVuJ3QgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlQ2FjaGVbY2FjaGVfa2V5XVtkcmF3X2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldLmtleSA9IGNhY2hlX2tleSArICcvJyArIGRyYXdfa2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcnVsZXMgZXZhbHVhdGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlQ2FjaGVbY2FjaGVfa2V5XSAmJiBPYmplY3Qua2V5cyhydWxlQ2FjaGVbY2FjaGVfa2V5XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlQ2FjaGVbY2FjaGVfa2V5XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZUNhY2hlW2NhY2hlX2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gaXNXaGl0ZUxpc3RlZChrZXkpIHtcbiAgICByZXR1cm4gd2hpdGVMaXN0LmluZGV4T2Yoa2V5KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhbGtVcChydWxlLCBjYikge1xuXG4gICAgaWYgKHJ1bGUucGFyZW50KSB7XG4gICAgICAgIHdhbGtVcChydWxlLnBhcmVudCwgY2IpO1xuICAgIH1cblxuICAgIGNiKHJ1bGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Fsa0Rvd24ocnVsZSwgY2IpIHtcblxuICAgIGlmIChydWxlLnJ1bGVzKSB7XG4gICAgICAgIHJ1bGUucnVsZXMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICAgICAgd2Fsa0Rvd24ociwgY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYihydWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwUHJvcHMob2JqKSB7XG4gICAgbGV0IHdoaXRlTGlzdGVkID0ge30sIG5vbldoaXRlTGlzdGVkID0ge307XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChpc1doaXRlTGlzdGVkKGtleSkpIHtcbiAgICAgICAgICAgIHdoaXRlTGlzdGVkW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vbldoaXRlTGlzdGVkW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3doaXRlTGlzdGVkLCBub25XaGl0ZUxpc3RlZF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEcmF3KHJ1bGUpIHtcblxuICAgIGxldCBkcmF3ICA9IFtdO1xuXG4gICAgaWYgKHJ1bGUucGFyZW50KSB7XG4gICAgICAgIGxldCBjcyA9IHJ1bGUucGFyZW50LmNhbGN1bGF0ZWREcmF3IHx8IFtdO1xuICAgICAgICBkcmF3LnB1c2goLi4uY3MpO1xuICAgIH1cblxuICAgIGRyYXcucHVzaChydWxlLmRyYXcpO1xuICAgIHJldHVybiBkcmF3O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG5ld09iaiwgLi4uc291cmNlcykge1xuXG4gICAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBtZXJnZU9iamVjdHMobmV3T2JqW2tleV0gfHwge30sIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBuZXdPYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVPcmRlcihvcmRlcnMsIGNvbnRleHQgPSBudWxsLCBkZWZhdWx0T3JkZXIgPSAwKSB7XG4gICAgbGV0IHN1bSA9IGRlZmF1bHRPcmRlcjtcblxuICAgIGZvciAobGV0IG9yZGVyIG9mIG9yZGVycykge1xuICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcmRlciA9IG9yZGVyKGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXIgPSBwYXJzZUZsb2F0KG9yZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3JkZXIgfHwgaXNOYU4ob3JkZXIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdW0gKz0gb3JkZXI7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUnVsZVRyZWUobmFtZSwgcnVsZSwgcGFyZW50KSB7XG5cbiAgICBsZXQgcHJvcGVydGllcyA9IHtuYW1lLCBwYXJlbnR9O1xuICAgIGxldCBbd2hpdGVMaXN0ZWQsIG5vbldoaXRlTGlzdGVkXSA9IGdyb3VwUHJvcHMocnVsZSk7XG4gICAgbGV0IGVtcHR5ID0gaXNFbXB0eShub25XaGl0ZUxpc3RlZCk7XG4gICAgbGV0IENyZWF0ZTtcblxuICAgIGlmIChlbXB0eSAmJiBwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBDcmVhdGUgPSBSdWxlTGVhZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBDcmVhdGUgPSBSdWxlVHJlZTtcbiAgICB9XG5cbiAgICBsZXQgciA9IG5ldyBDcmVhdGUoT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCB3aGl0ZUxpc3RlZCkpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkUnVsZShyKTtcbiAgICB9XG5cbiAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBub25XaGl0ZUxpc3RlZCkge1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbm9uV2hpdGVMaXN0ZWRba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VSdWxlVHJlZShrZXksIHByb3BlcnR5LCByKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oJ1J1bGUgcHJvcGVydHkgbXVzdCBiZSBhbiBvYmplY3Q6ICcsIG5hbWUsIHJ1bGUsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUnVsZXMocnVsZXMpIHtcbiAgICBsZXQgcnVsZVRyZWVzID0ge307XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBydWxlc1trZXldO1xuICAgICAgICBydWxlVHJlZXNba2V5XSA9IHBhcnNlUnVsZVRyZWUoa2V5LCBydWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZVRyZWVzO1xufVxuXG5cbmZ1bmN0aW9uIGRvZXNNYXRjaChmaWx0ZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gKCh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihjb250ZXh0KSkgfHwgKGZpbHRlciA9PSBudWxsKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaEZlYXR1cmUoY29udGV4dCwgcnVsZXMsIGNvbGxlY3RlZFJ1bGVzKSB7XG4gICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcbiAgICBsZXQgY2hpbGRNYXRjaGVkID0gZmFsc2U7XG5cbiAgICBpZiAocnVsZXMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgZm9yIChsZXQgcj0wOyByIDwgcnVsZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBydWxlc1tyXTtcbiAgICAgICAgY29udGV4dC5wcm9wZXJ0aWVzID0gY3VycmVudC5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgUnVsZUxlYWYpIHtcblxuICAgICAgICAgICAgaWYgKGRvZXNNYXRjaChjdXJyZW50LmZpbHRlciwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWRSdWxlcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFJ1bGVUcmVlKSB7XG4gICAgICAgICAgICBpZiAoZG9lc01hdGNoKGN1cnJlbnQuZmlsdGVyLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgY2hpbGRNYXRjaGVkID0gbWF0Y2hGZWF0dXJlKFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRSdWxlc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRSdWxlcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZWQ7XG59XG4iLCIvLyBSZW5kZXJpbmcgc3R5bGVzXG5cbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVfcGFyc2VyJztcbmltcG9ydCBGZWF0dXJlU2VsZWN0aW9uIGZyb20gJy4uL3NlbGVjdGlvbic7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgVkJPTWVzaCBmcm9tICcuLi9nbC92Ym9fbWVzaCc7XG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi4vbWF0ZXJpYWwnO1xuaW1wb3J0IExpZ2h0IGZyb20gJy4uL2xpZ2h0JztcbmltcG9ydCB7TWV0aG9kTm90SW1wbGVtZW50ZWR9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuLi9nbC9zaGFkZXJfc291cmNlcyc7IC8vIGJ1aWx0LWluIHNoYWRlcnNcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEJhc2UgY2xhc3NcblxuZXhwb3J0IHZhciBTdHlsZSA9IHtcbiAgICBpbml0ICh7IGdlbmVyYXRpb24gfSA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0J1aWx0SW4oKSkge1xuICAgICAgICAgICAgdGhpcy5idWlsdF9pbiA9IGZhbHNlOyAvLyBleHBsaWNpdGx5IHNldCB0byBmYWxzZSB0byBhdm9pZCBhbnkgY29uZnVzaW9uXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlbmVyYXRpb24gPSBnZW5lcmF0aW9uOyAgICAgICAgICAgICAgIC8vIHNjZW5lIGdlbmVyYXRpb24gaWQgdGhpcyBzdHlsZSB3YXMgY3JlYXRlZCBmb3JcbiAgICAgICAgdGhpcy5kZWZpbmVzID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ2RlZmluZXMnKSAmJiB0aGlzLmRlZmluZXMpIHx8IHt9OyAvLyAjZGVmaW5lcyB0byBiZSBpbmplY3RlZCBpbnRvIHRoZSBzaGFkZXJzXG4gICAgICAgIHRoaXMuc2hhZGVycyA9ICh0aGlzLmhhc093blByb3BlcnR5KCdzaGFkZXJzJykgJiYgdGhpcy5zaGFkZXJzKSB8fCB7fTsgLy8gc2hhZGVyIGN1c3RvbWl6YXRpb24gKHVuaWZvcm1zLCBkZWZpbmVzLCBibG9ja3MsIGV0Yy4pXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24gfHwgZmFsc2U7ICAgLy8gZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgc3R5bGUgc3VwcG9ydHMgZmVhdHVyZSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmFtcyBhcmUgY3VycmVudGx5IGNvbXBpbGluZ1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyYW1zIGFyZSBmaW5pc2hlZCBjb21waWxpbmdcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBHTCBwcm9ncmFtIHJlZmVyZW5jZSAoZm9yIG1haW4gcmVuZGVyIHBhc3MpXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0gPSBudWxsOyAgICAgICAgICAgICAgLy8gR0wgcHJvZ3JhbSByZWZlcmVuY2UgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHJlbmRlciBwYXNzXG4gICAgICAgIHRoaXMuZmVhdHVyZV9zdHlsZSA9IHt9OyAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGUgZm9yIGZlYXR1cmUgY3VycmVudGx5IGJlaW5nIHBhcnNlZCwgc2hhcmVkIHRvIGxlc3NlbiBHQy9tZW1vcnkgdGhyYXNoXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlID0gW107ICAgICAgICAgICAgICAgICAgLy8gc2hhcmVkIHNpbmdsZS12ZXJ0ZXggdGVtcGxhdGUsIGZpbGxlZCBvdXQgYnkgZWFjaCBzdHlsZVxuICAgICAgICB0aGlzLnRpbGVfZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmZlYXR1cmVfb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vIERlZmF1bHQgd29ybGQgY29vcmRzIHRvIHdyYXAgZXZlcnkgMTAwLDAwMCBtZXRlcnMsIGNhbiB0dXJuIG9mZiBieSBzZXR0aW5nIHRoaXMgdG8gJ2ZhbHNlJ1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQID0gMTAwMDAwO1xuXG4gICAgICAgIC8vIEJsZW5kaW5nXG4gICAgICAgIHRoaXMuYmxlbmQgPSB0aGlzLmJsZW5kIHx8ICdvcGFxdWUnOyAgICAgICAgLy8gZGVmYXVsdDogb3BhcXVlIHN0eWxlcyBhcmUgZHJhd24gZmlyc3QsIHdpdGhvdXQgYmxlbmRpbmdcbiAgICAgICAgdGhpcy5kZWZpbmVzW2BUQU5HUkFNX0JMRU5EXyR7dGhpcy5ibGVuZC50b1VwcGVyQ2FzZSgpfWBdID0gdHJ1ZTtcblxuICAgICAgICAvLyBJZiB0aGUgc3R5bGUgZGVmaW5lcyBpdHMgb3duIG1hdGVyaWFsLCByZXBsYWNlIHRoZSBpbmhlcml0ZWQgbWF0ZXJpYWwgaW5zdGFuY2VcbiAgICAgICAgaWYgKCEodGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIE1hdGVyaWFsKSkge1xuICAgICAgICAgICAgaWYgKCFNYXRlcmlhbC5pc1ZhbGlkKHRoaXMubWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbCA9IFN0eWxlUGFyc2VyLmRlZmF1bHRzLm1hdGVyaWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCh0aGlzLm1hdGVyaWFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGVyaWFsLmluamVjdCh0aGlzKTtcblxuICAgICAgICAvLyBTZXQgbGlnaHRpbmcgbW9kZTogZnJhZ21lbnQsIHZlcnRleCwgb3Igbm9uZSAoc3BlY2lmaWVkIGFzICdmYWxzZScpXG4gICAgICAgIExpZ2h0LnNldE1vZGUodGhpcy5saWdodGluZywgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSxcblxuICAgIGRlc3Ryb3kgKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbl9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzZXQgKCkge1xuICAgIH0sXG5cbiAgICBpc0J1aWx0SW4gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eSgnYnVpbHRfaW4nKSAmJiB0aGlzLmJ1aWx0X2luO1xuICAgIH0sXG5cbiAgICAvKioqIFN0eWxlIHBhcnNpbmcgYW5kIGdlb21ldHJ5IGNvbnN0cnVjdGlvbiAqKiovXG5cbiAgICAvLyBSZXR1cm5zIGFuIG9iamVjdCB0byBob2xkIGZlYXR1cmUgZGF0YSAoZm9yIGEgdGlsZSBvciBvdGhlciBvYmplY3QpXG4gICAgc3RhcnREYXRhICh0aWxlKSB7XG4gICAgICAgIHRoaXMudGlsZV9kYXRhW3RpbGVdID0ge1xuICAgICAgICAgICAgdmVydGV4X2RhdGE6IG51bGwsXG4gICAgICAgICAgICB1bmlmb3JtczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlX2RhdGFbdGlsZV07XG4gICAgfSxcblxuICAgIC8vIEZpbmFsaXplcyBhbiBvYmplY3QgaG9sZGluZyBmZWF0dXJlIGRhdGEgKGZvciBhIHRpbGUgb3Igb3RoZXIgb2JqZWN0KVxuICAgIGVuZERhdGEgKHRpbGUpIHtcbiAgICAgICAgdmFyIHRpbGVfZGF0YSA9IHRoaXMudGlsZV9kYXRhW3RpbGVdO1xuICAgICAgICBpZiAodGlsZV9kYXRhICYmIHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YSkge1xuICAgICAgICAgICAgLy8gT25seSBrZWVwIGZpbmFsIGJ5dGUgYnVmZmVyXG4gICAgICAgICAgICB0aWxlX2RhdGEudmVydGV4X2RhdGEuZW5kKCk7XG4gICAgICAgICAgICB0aWxlX2RhdGEudmVydGV4X2RhdGEgPSB0aWxlX2RhdGEudmVydGV4X2RhdGEuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlsZV9kYXRhW3RpbGVdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aWxlX2RhdGEpO1xuICAgIH0sXG5cbiAgICAvLyBIYXMgbWVzaCBkYXRhIGZvciBhIGdpdmVuIHRpbGU/XG4gICAgaGFzRGF0YUZvclRpbGUgKHRpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZV9kYXRhW3RpbGVdICE9IG51bGw7XG4gICAgfSxcblxuICAgIGFkZEZlYXR1cmUgKGZlYXR1cmUsIHJ1bGUsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHRpbGUgPSBjb250ZXh0LnRpbGU7XG4gICAgICAgIGlmICh0aWxlLmdlbmVyYXRpb24gIT09IHRoaXMuZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREYXRhKHRpbGUua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdHlsZSA9IHRoaXMucGFyc2VGZWF0dXJlKGZlYXR1cmUsIHJ1bGUsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIFNraXAgZmVhdHVyZT9cbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgZmVhdHVyZSBpbiB0aGlzIHJlbmRlciBzdHlsZT9cbiAgICAgICAgaWYgKCF0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0udmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZV9kYXRhW3RpbGUua2V5XS52ZXJ0ZXhfZGF0YSA9IHRoaXMudmVydGV4X2xheW91dC5jcmVhdGVWZXJ0ZXhEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgc3R5bGUsIHRoaXMudGlsZV9kYXRhW3RpbGUua2V5XS52ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGJ1aWxkR2VvbWV0cnkgKGdlb21ldHJ5LCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvbHlnb25zKFtnZW9tZXRyeS5jb29yZGluYXRlc10sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2x5Z29ucyhnZW9tZXRyeS5jb29yZGluYXRlcywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMaW5lcyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkTGluZXMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhnZW9tZXRyeS5jb29yZGluYXRlcywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcblxuICAgICAgICAgICAgLy8gUHJlcHJvY2VzcyBmaXJzdCB0aW1lXG4gICAgICAgICAgICBpZiAoIXJ1bGVfc3R5bGUucHJlcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVwcm9jZXNzKHJ1bGVfc3R5bGUpO1xuICAgICAgICAgICAgICAgIHJ1bGVfc3R5bGUucHJlcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG9yZGVyIGlmIGl0IHdhcyBub3QgY2FjaGVkXG4gICAgICAgICAgICBzdHlsZS5vcmRlciA9IHRoaXMucGFyc2VPcmRlcihydWxlX3N0eWxlLm9yZGVyLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgLy8gRmVhdHVyZSBzZWxlY3Rpb24gKG9ubHkgaWYgc3R5bGUgc3VwcG9ydHMgaXQpXG4gICAgICAgICAgICB2YXIgc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgc3R5bGUuaW50ZXJhY3RpdmUgPSBydWxlX3N0eWxlLmludGVyYWN0aXZlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5pbnRlcmFjdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gc3R5bGUuaW50ZXJhY3RpdmUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gc3R5bGUuaW50ZXJhY3RpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBmZWF0dXJlIGlzIG1hcmtlZCBhcyBzZWxlY3RhYmxlXG4gICAgICAgICAgICBpZiAoc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLnNlbGVjdGlvbl9jb2xvciA9IEZlYXR1cmVTZWxlY3Rpb24ubWFrZUNvbG9yKGZlYXR1cmUsIGNvbnRleHQudGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3IgPSBGZWF0dXJlU2VsZWN0aW9uLmRlZmF1bHRDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3ViY2xhc3MgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIHN0eWxlID0gdGhpcy5fcGFyc2VGZWF0dXJlKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcignU3R5bGUucGFyc2VGZWF0dXJlOiBzdHlsZSBwYXJzaW5nIGVycm9yJywgZmVhdHVyZSwgc3R5bGUsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZCgnX3BhcnNlRmVhdHVyZScpO1xuICAgIH0sXG5cbiAgICBwcmVwcm9jZXNzICgpIHt9LFxuXG4gICAgLy8gUGFyc2UgYW4gb3JkZXIgdmFsdWVcbiAgICBwYXJzZU9yZGVyIChvcmRlciwgY29udGV4dCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgb3JkZXIgaWYgaXQgd2FzIG5vdCBjYWNoZWRcbiAgICAgICAgaWYgKHR5cGVvZiBvcmRlciAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZVBhcnNlci5jYWxjdWxhdGVPcmRlcihvcmRlciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH0sXG5cbiAgICAvLyBQYXJzZSBhIGNvbG9yIG9mIGNob29zZSBhIGRlZmF1bHQgaWYgYWNjZXB0YWJsZSwgcmV0dXJuIHVuZGVmaW5lZCBpZiBjb2xvciBtaXNzaW5nXG4gICAgcGFyc2VDb2xvcihjb2xvciwgY29udGV4dCkge1xuICAgICAgICAvLyBOZWVkIGVpdGhlciBhIGNvbG9yLCBvciBhIHNoYWRlciBibG9jayBmb3IgJ2NvbG9yJyBvciAnZmlsdGVyJ1xuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZVBhcnNlci5jYWNoZUNvbG9yKGNvbG9yLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNoYWRlcnMuYmxvY2tzLmNvbG9yIHx8IHRoaXMuc2hhZGVycy5ibG9ja3MuZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuZGVmYXVsdHMuY29sb3I7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQnVpbGQgZnVuY3Rpb25zIGFyZSBuby1vcHMgdW50aWwgb3ZlcnJpZGVuXG4gICAgYnVpbGRQb2x5Z29ucyAoKSB7fSxcbiAgICBidWlsZExpbmVzICgpIHt9LFxuICAgIGJ1aWxkUG9pbnRzICgpIHt9LFxuXG5cbiAgICAvKioqIEdMIHN0YXRlIGFuZCByZW5kZXJpbmcgKioqL1xuXG4gICAgc2V0R0wgKGdsKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9LFxuXG4gICAgbWFrZU1lc2ggKHZlcnRleF9kYXRhLCB7IHVuaWZvcm1zIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFZCT01lc2godGhpcy5nbCwgdmVydGV4X2RhdGEsIHRoaXMudmVydGV4X2xheW91dCwgeyB1bmlmb3JtcyB9KTtcbiAgICB9LFxuXG4gICAgY29tcGlsZSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5nbCkge1xuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBzdHlsZS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMubmFtZX0gYmVjYXVzZSBubyBHTCBjb250ZXh0YCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcGlsaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYHN0eWxlLmNvbXBpbGUoKTogc2tpcHBpbmcgZm9yICR7dGhpcy5uYW1lfSBiZWNhdXNlIHN0eWxlIGlzIGFscmVhZHkgY29tcGlsaW5nYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJ1aWxkIGRlZmluZXMgJiBmb3Igc2VsZWN0aW9uIChuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgc2luY2UgdGhlIGZpcnN0IGlzIHN0b3JlZCBhcyBhIHJlZmVyZW5jZSBieSB0aGUgcHJvZ3JhbSlcbiAgICAgICAgdmFyIGRlZmluZXMgPSB0aGlzLmJ1aWxkRGVmaW5lTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25fZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmluZXMpO1xuICAgICAgICAgICAgc2VsZWN0aW9uX2RlZmluZXMuVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYW55IGN1c3RvbSBjb2RlIGJsb2NrcywgdW5pZm9ybSBkZXBlbmRlbmNpZXMsIGV0Yy5cbiAgICAgICAgdmFyIGJsb2NrcyA9ICh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLmJsb2Nrcyk7XG4gICAgICAgIHZhciB1bmlmb3JtcyA9ICh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLnVuaWZvcm1zKTtcblxuICAgICAgICAvLyBDcmVhdGUgc2hhZGVyc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0oXG4gICAgICAgICAgICAgICAgdGhpcy5nbCxcbiAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMudmVydGV4X3NoYWRlcl9rZXldLFxuICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZXNbdGhpcy5mcmFnbWVudF9zaGFkZXJfa2V5XSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0uY29tcGlsZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZXNbdGhpcy52ZXJ0ZXhfc2hhZGVyX2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2ZyYWdtZW50J10sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICh0aGlzLm5hbWUgKyAnIChzZWxlY3Rpb24pJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVzOiBzZWxlY3Rpb25fZGVmaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0uY29tcGlsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYHN0eWxlLmNvbXBpbGUoKTogc3R5bGUgJHt0aGlzLm5hbWV9IGVycm9yOmAsIGVycm9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgc2hhZGVyIGJsb2NrXG4gICAgYWRkU2hhZGVyQmxvY2sgKGtleSwgLi4uYmxvY2tzKSB7XG4gICAgICAgIHRoaXMuc2hhZGVycy5ibG9ja3MgPSB0aGlzLnNoYWRlcnMuYmxvY2tzIHx8IHt9O1xuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gPSB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gfHwgW107XG4gICAgICAgIHRoaXMuc2hhZGVycy5ibG9ja3Nba2V5XS5wdXNoKC4uLmJsb2Nrcyk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhbGwgc2hhZGVyIGJsb2NrcyBmb3Iga2V5XG4gICAgcmVtb3ZlU2hhZGVyQmxvY2sgKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zaGFkZXJzLmJsb2Nrcykge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2Nrc1trZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXBsYWNlU2hhZGVyQmxvY2sgKGtleSwgLi4uYmxvY2tzKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2hhZGVyQmxvY2soa2V5KTtcbiAgICAgICAgdGhpcy5hZGRTaGFkZXJCbG9jayhrZXksIC4uLmJsb2Nrcyk7XG4gICAgfSxcblxuICAgIC8qKiBUT0RPOiBjb3VsZCBwcm9iYWJseSBjb21iaW5lIGFuZCBnZW5lcmFsaXplIHRoaXMgd2l0aCBzaW1pbGFyIG1ldGhvZCBpbiBTaGFkZXJQcm9ncmFtXG4gICAgICogKGxpc3Qgb2YgZGVmaW5lIG9iamVjdHMgdGhhdCBpbmhlcml0IGZyb20gZWFjaCBvdGhlcilcbiAgICAgKi9cbiAgICBidWlsZERlZmluZUxpc3QgKCkge1xuICAgICAgICAvLyBBZGQgYW55IGN1c3RvbSBkZWZpbmVzIHRvIGJ1aWx0LWluIHN0eWxlIGRlZmluZXNcbiAgICAgICAgdmFyIGRlZmluZXMgPSB7fTsgLy8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyBhIHByb3RvdHlwZSB2YWx1ZSB0aGF0IG1heSBiZSBzaGFyZWQgd2l0aCBvdGhlciBzdHlsZXNcbiAgICAgICAgaWYgKHRoaXMuZGVmaW5lcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkIGluIHRoaXMuZGVmaW5lcykge1xuICAgICAgICAgICAgICAgIGRlZmluZXNbZF0gPSB0aGlzLmRlZmluZXNbZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hhZGVycyAhPSBudWxsICYmIHRoaXMuc2hhZGVycy5kZWZpbmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoZCBpbiB0aGlzLnNoYWRlcnMuZGVmaW5lcykge1xuICAgICAgICAgICAgICAgIGRlZmluZXNbZF0gPSB0aGlzLnNoYWRlcnMuZGVmaW5lc1tkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lcztcblxuICAgIH0sXG5cbiAgICAvLyBTZXR1cCBhbnkgR0wgc3RhdGUgZm9yIHJlbmRlcmluZ1xuICAgIHNldHVwICgpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtcygpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnNldHVwUHJvZ3JhbShTaGFkZXJQcm9ncmFtLmN1cnJlbnQpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgc3R5bGUgdW5pZm9ybXMgb24gY3VycmVudGx5IGJvdW5kIHByb2dyYW1cbiAgICBzZXRVbmlmb3JtcyAoKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gU2hhZGVyUHJvZ3JhbS5jdXJyZW50O1xuICAgICAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybXModGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy51bmlmb3JtcywgdHJ1ZSk7IC8vIHJlc2V0IHRleHR1cmUgdW5pdCB0byAwXG4gICAgfSxcblxuICAgIHVwZGF0ZSAoKSB7XG4gICAgICAgIC8vIFN0eWxlLXNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMuYW5pbWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmFuaW1hdGlvbigpO1xuICAgICAgICAvLyB9XG4gICAgfVxufTtcbiIsIi8vIE1hbmFnZSByZW5kZXJpbmcgc3R5bGVzXG5cbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuLi9nbC9zaGFkZXJfc291cmNlcyc7IC8vIGJ1aWx0LWluIHNoYWRlcnNcbmltcG9ydCB7U3R5bGV9IGZyb20gJy4vc3R5bGUnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IHZhciBTdHlsZU1hbmFnZXIgPSB7fTtcbmV4cG9ydCB2YXIgU3R5bGVzID0ge307XG5leHBvcnQgdmFyIEJhc2VTdHlsZXMgPSB7fTtcblxuU3R5bGVNYW5hZ2VyLnN0eWxlcyA9IFN0eWxlcztcblxuLy8gU2V0IHRoZSBiYXNlIG9iamVjdCB1c2VkIHRvIGluc3RhbnRpYXRlIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmJhc2VTdHlsZSA9IFN0eWxlO1xuXG4vLyBHbG9iYWwgY29uZmlndXJhdGlvbiBmb3IgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFN0eWxlTWFuYWdlci5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgU2hhZGVyUHJvZ3JhbS5yZW1vdmVCbG9jaygnZ2xvYmFsJyk7XG5cbiAgICAvLyBMYXllciByZS1vcmRlcmluZyBmdW5jdGlvblxuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soJ2dsb2JhbCcsIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbGF5ZXJfb3JkZXInXSk7XG5cbiAgICAvLyBGZWF0dXJlIHNlbGVjdGlvbiBnbG9iYWxcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKCdnbG9iYWwnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9nbG9iYWxzJ10pO1xuXG4gICAgLy8gV29ybGQgcG9zaXRpb24gd3JhcHBpbmdcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKCdnbG9iYWwnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3dvcmxkX3Bvc2l0aW9uX3dyYXAnXSk7XG5cbiAgICAvLyBGZWF0dXJlIHNlbGVjdGlvbiB2ZXJ0ZXggc2hhZGVyIHN1cHBvcnRcbiAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnZmVhdHVyZS1zZWxlY3Rpb24tdmVydGV4Jywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fdmVydGV4J10pO1xuXG4gICAgLy8gYXNzdW1lIG1pbiAxNi1iaXQgZGVwdGggYnVmZmVyLCBpbiBwcmFjdGljZSB1c2VzIDE0LWJpdHMsIDEgZXh0cmEgYml0IHRvIGhhbmRsZSB2aXJ0dWFsIGhhbGYtbGF5ZXJzXG4gICAgLy8gZm9yIG91dGxpbmVzIChpbnNlcnRlZCBpbiBiZXR3ZWVuIGxheWVycyksIGFub3RoZXIgZXh0cmEgYml0IHRvIHByZXZlbnQgcHJlY2lzaW9uIGxvc3NcbiAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXMuVEFOR1JBTV9MQVlFUl9ERUxUQSA9IDEgLyAoMSA8PCAxNCk7XG5cbiAgICBTdHlsZU1hbmFnZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xufTtcblxuLy8gRGVzdHJveSBhbGwgc3R5bGVzIGZvciBhIGdpdmVuIEdMIGNvbnRleHRcblN0eWxlTWFuYWdlci5kZXN0cm95ID0gZnVuY3Rpb24gKGdsKSB7XG4gICAgT2JqZWN0LmtleXMoU3R5bGVzKS5mb3JFYWNoKChfbmFtZSkgPT4ge1xuICAgICAgICB2YXIgc3R5bGUgPSBTdHlsZXNbX25hbWVdO1xuICAgICAgICBpZiAoc3R5bGUuZ2wgPT09IGdsKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYFN0eWxlTWFuYWdlci5kZXN0cm95OiBkZXN0cm95aW5nIHJlbmRlciBzdHlsZSAke3N0eWxlLm5hbWV9YCk7XG5cbiAgICAgICAgICAgIGlmICghc3R5bGUuaXNCdWlsdEluKCkpIHtcbiAgICAgICAgICAgICAgICBTdHlsZU1hbmFnZXIucmVtb3ZlKHN0eWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBSZWdpc3RlciBhIHN0eWxlXG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBTdHlsZXNbc3R5bGUubmFtZV0gPSBzdHlsZTtcbiAgICBCYXNlU3R5bGVzW3N0eWxlLm5hbWVdID0gc3R5bGU7XG59O1xuXG4vLyBSZW1vdmUgYSBzdHlsZVxuU3R5bGVNYW5hZ2VyLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVsZXRlIFN0eWxlc1tuYW1lXTtcbn07XG5cbi8vIFByZWxvYWRzIG5ldHdvcmsgcmVzb3VyY2VzIGluIHRoZSBzdHlsZXNoZWV0IChzaGFkZXJzLCB0ZXh0dXJlcywgZXRjLilcblN0eWxlTWFuYWdlci5wcmVsb2FkID0gZnVuY3Rpb24gKHN0eWxlcywgYmFzZSkge1xuICAgIC8vIEZpcnN0IGxvYWQgcmVtb3RlIHN0eWxlcywgdGhlbiBsb2FkIHNoYWRlciBibG9ja3MgZnJvbSByZW1vdGUgVVJMc1xuICAgIHJldHVybiBTdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyhzdHlsZXMsIGJhc2UpLnRoZW4oc3R5bGVzID0+IFN0eWxlTWFuYWdlci5sb2FkU2hhZGVyQmxvY2tzKHN0eWxlcywgYmFzZSkpO1xufTtcblxuLy8gTG9hZCBzdHlsZSBkZWZpbml0aW9ucyBmcm9tIGV4dGVybmFsIFVSTHNcblN0eWxlTWFuYWdlci5sb2FkUmVtb3RlU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcywgYmFzZSkge1xuICAgIC8vIENvbGxlY3QgVVJMcyBhbmQgbW9kZXMgdG8gaW1wb3J0IGZyb20gdGhlbVxuICAgIC8vIFRoaXMgaXMgZG9uZSBhcyBhIHNlcGFyYXRlIHN0ZXAgYmVjdWFzZSBpdCBpcyBwb3NzaWJsZSB0byBpbXBvcnQgbXVsdGlwbGUgbW9kZXMgZnJvbSBhIHNpbmdsZVxuICAgIC8vIFVSTCwgYW5kIHdlIHdhbnQgdG8gYXZvaWQgZHVwbGljYXRlIGNhbGxzIGZvciB0aGUgc2FtZSBmaWxlLlxuICAgIHZhciB1cmxzID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW25hbWVdO1xuICAgICAgICBpZiAoc3R5bGUudXJsKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gc3R5bGUudXJsO1xuICAgICAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBVdGlscy5hZGRCYXNlVVJMKHVybCwgYmFzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdXJsc1t1cmxdKSB7XG4gICAgICAgICAgICAgICAgdXJsc1t1cmxdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2UgYSBsaXN0IG9mIHRoZSBzdHlsZXMgdG8gaW1wb3J0IGZvciB0aGlzIFVSTFxuICAgICAgICAgICAgdXJsc1t1cmxdLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhcmdldF9uYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9uYW1lOiBzdHlsZS5uYW1lIHx8IG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXMgZWFjaCBVUkwgZmluaXNoZXMgbG9hZGluZywgcmVwbGFjZSB0aGUgdGFyZ2V0IHN0eWxlKHMpXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHVybHMpLm1hcCh1cmwgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgVXRpbHMubG9hZFJlc291cmNlKHVybCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE1peGluIHJlbW90ZSBzdHlsZXMsIHdpdGhpbiBlYWNoIHJlbW90ZSBmaWxlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc291cmNlX3N0eWxlIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLm1peChkYXRhW3NvdXJjZV9zdHlsZV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCByZW1vdGUgc3R5bGVzIHRvIGxvY2FsIHN0eWxlc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHRhcmdldCBvZiB1cmxzW3VybF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVt0YXJnZXQuc291cmNlX25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbdGFyZ2V0LnRhcmdldF9uYW1lXSA9IGRhdGFbdGFyZ2V0LnNvdXJjZV9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbdGFyZ2V0LnRhcmdldF9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBTdHlsZU1hbmFnZXIucHJlbG9hZDogZXJyb3IgaW1wb3J0aW5nIHN0eWxlICR7dGFyZ2V0LnRhcmdldF9uYW1lfSwgY291bGQgbm90IGZpbmQgc291cmNlIHN0eWxlICR7dGFyZ2V0LnNvdXJjZV9uYW1lfSBpbiAke3VybH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLnByZWxvYWQ6IGVycm9yIGltcG9ydGluZyBzdHlsZShzKSAke0pTT04uc3RyaW5naWZ5KHVybHNbdXJsXSl9IGZyb20gJHt1cmx9YCwgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pKS50aGVuKCgpID0+IFByb21pc2UucmVzb2x2ZShzdHlsZXMpKTtcbn07XG5cbi8vIFByZWxvYWQgc2hhZGVyIGJsb2NrcyBmcm9tIGV4dGVybmFsIFVSTHNcblN0eWxlTWFuYWdlci5sb2FkU2hhZGVyQmxvY2tzID0gZnVuY3Rpb24gKHN0eWxlcywgYmFzZSkge1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIGZvciAodmFyIHN0eWxlIG9mIFV0aWxzLnZhbHVlcyhzdHlsZXMpKSB7XG4gICAgICAgIGlmIChzdHlsZS5zaGFkZXJzICYmIHN0eWxlLnNoYWRlcnMuYmxvY2tzKSB7XG4gICAgICAgICAgICBsZXQgX2Jsb2NrcyA9IHN0eWxlLnNoYWRlcnMuYmxvY2tzO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCBibG9ja10gb2YgVXRpbHMuZW50cmllcyhzdHlsZS5zaGFkZXJzLmJsb2NrcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgX2tleSA9IGtleTtcblxuICAgICAgICAgICAgICAgIC8vIEFycmF5IG9mIGJsb2Nrc1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBiPTA7IGIgPCBibG9jay5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBibG9ja1tiXSA9PT0gJ29iamVjdCcgJiYgYmxvY2tbYl0udXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9pbmRleCA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGJsb2NrW2JdLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBVdGlscy5hZGRCYXNlVVJMKHVybCwgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChVdGlscy5pbyhVdGlscy5jYWNoZUJ1c3RlckZvclVybCh1cmwpKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ibG9ja3NbX2tleV1bX2luZGV4XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3M6IGVycm9yIGxvYWRpbmcgc2hhZGVyIGJsb2NrYCwgX2Jsb2NrcywgX2tleSwgX2luZGV4LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBibG9ja1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBibG9jayA9PT0gJ29iamVjdCcgJiYgYmxvY2sudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBibG9jay51cmw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBVdGlscy5hZGRCYXNlVVJMKHVybCwgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKHVybCkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ibG9ja3NbX2tleV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3M6IGVycm9yIGxvYWRpbmcgc2hhZGVyIGJsb2NrYCwgX2Jsb2NrcywgX2tleSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZSkudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUoc3R5bGVzKSk7IC8vIFRPRE86IGFkZCBlcnJvclxufTtcblxuU3R5bGVNYW5hZ2VyLm1peCA9IGZ1bmN0aW9uIChzdHlsZSwgc3R5bGVzKSB7XG4gICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBoYXZlIGFscmVhZHkgYXBwbGllZCBtaXhpbnMgdG8gdGhpcyBzdHlsZVxuICAgIGlmIChzdHlsZS5taXhlZCkge1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgLy8gTWl4aW4gc291cmNlcywgaW4gb3JkZXJcbiAgICBsZXQgc291cmNlcyA9IFtdO1xuICAgIGlmIChzdHlsZS5taXgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUubWl4KSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKC4uLnN0eWxlLm1peCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goc3R5bGUubWl4KTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzID0gc291cmNlcy5tYXAoeCA9PiBzdHlsZXNbeF0pLmZpbHRlcih4ID0+IHgpO1xuICAgIH1cbiAgICBzb3VyY2VzLnB1c2goc3R5bGUpO1xuXG4gICAgLy8gRmxhZ3MgLSBPUidkLCB0cnVlIGlmIGFueSBzdHlsZSBoYXMgaXQgc2V0XG4gICAgc3R5bGUuYW5pbWF0ZWQgPSBzb3VyY2VzLnNvbWUoeCA9PiB4ICYmIHguYW5pbWF0ZWQpO1xuICAgIHN0eWxlLnRleGNvb3JkcyA9IHNvdXJjZXMuc29tZSh4ID0+IHggJiYgeC50ZXhjb29yZHMpO1xuXG4gICAgLy8gT3ZlcndyaXRlcyAtIGxhc3QgZGVmaW5pdGlvbiB3aW5zXG4gICAgc3R5bGUuYmFzZSA9IHNvdXJjZXMubWFwKHggPT4geC5iYXNlKS5maWx0ZXIoeCA9PiB4KS5wb3AoKTtcbiAgICBzdHlsZS50ZXh0dXJlID0gc291cmNlcy5tYXAoeCA9PiB4LnRleHR1cmUpLmZpbHRlcih4ID0+IHgpLnBvcCgpO1xuXG4gICAgLy8gTWVyZ2VzIC0gcHJvcGVydHktc3BlY2lmaWMgcnVsZXMgZm9yIG1lcmdpbmcgdmFsdWVzXG4gICAgc3R5bGUuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNvdXJjZXMubWFwKHggPT4geC5kZWZpbmVzKS5maWx0ZXIoeCA9PiB4KSk7XG4gICAgc3R5bGUubWF0ZXJpYWwgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zb3VyY2VzLm1hcCh4ID0+IHgubWF0ZXJpYWwpLmZpbHRlcih4ID0+IHgpKTtcblxuICAgIGxldCBtZXJnZSA9IHNvdXJjZXMubWFwKHggPT4geC5zaGFkZXJzKS5maWx0ZXIoeCA9PiB4KTtcbiAgICBsZXQgc2hhZGVycyA9IHt9O1xuICAgIHNoYWRlcnMuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLm1lcmdlLm1hcCh4ID0+IHguZGVmaW5lcykuZmlsdGVyKHggPT4geCkpO1xuICAgIHNoYWRlcnMudW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5tZXJnZS5tYXAoeCA9PiB4LnVuaWZvcm1zKS5maWx0ZXIoeCA9PiB4KSk7XG5cbiAgICBtZXJnZS5tYXAoeCA9PiB4LmJsb2NrcykuZmlsdGVyKHggPT4geCkuZm9yRWFjaChibG9ja3MgPT4ge1xuICAgICAgICBzaGFkZXJzLmJsb2NrcyA9IHNoYWRlcnMuYmxvY2tzIHx8IHt9O1xuXG4gICAgICAgIGZvciAobGV0IFt0LCBibG9ja10gb2YgVXRpbHMuZW50cmllcyhibG9ja3MpKSB7XG4gICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XSA9IHNoYWRlcnMuYmxvY2tzW3RdIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShibG9jaykpIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XS5wdXNoKC4uLmJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYWRlcnMuYmxvY2tzW3RdLnB1c2goYmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzdHlsZS5zaGFkZXJzID0gc2hhZGVycztcbiAgICBzdHlsZS5taXhlZCA9IHRydWU7IC8vIHRyYWNrIHRoYXQgd2UgYWxyZWFkeSBhcHBsaWVkIG1peGlucyAoYXZvaWQgZHVwZSB3b3JrIGxhdGVyKVxuXG4gICAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gQ3JlYXRlIGEgbmV3IHN0eWxlXG4vLyBuYW1lOiBuYW1lIG9mIG5ldyBzdHlsZVxuLy8gY29uZmlnOiBwcm9wZXJ0aWVzIG9mIG5ldyBzdHlsZVxuLy8gc3R5bGVzOiB3b3JraW5nIHNldCBvZiBzdHlsZXMgYmVpbmcgYnVpbHQgKHVzZWQgZm9yIG1peGluZyBpbiBleGlzdGluZyBzdHlsZXMpXG5TdHlsZU1hbmFnZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5hbWUsIGNvbmZpZywgc3R5bGVzID0ge30pIHtcbiAgICBsZXQgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpOyAvLyBzaGFsbG93IGNvcHlcbiAgICBzdHlsZS5uYW1lID0gbmFtZTtcblxuICAgIC8vIFN0eWxlIG1peGluc1xuICAgIFN0eWxlTWFuYWdlci5taXgoc3R5bGUsIHN0eWxlcyk7XG5cbiAgICAvLyBIYXMgYmFzZSBzdHlsZT9cbiAgICAvLyBPbmx5IHJlbmRlcmFibGUgKGluc3RhbnRpYXRlZCkgc3R5bGVzIHNob3VsZCBiZSBpbmNsdWRlZCBmb3IgcnVuLXRpbWUgdXNlXG4gICAgLy8gT3RoZXJzIGFyZSBpbnRlcm1lZGlhcnkvYWJzdHJhY3QsIHVzZWQgZHVyaW5nIHN0eWxlIGNvbXBvc2l0aW9uIGJ1dCBub3QgZXhlY3V0aW9uXG4gICAgaWYgKHN0eWxlLmJhc2UgJiYgQmFzZVN0eWxlc1tzdHlsZS5iYXNlXSkge1xuICAgICAgICBTdHlsZXNbbmFtZV0gPSBzdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShCYXNlU3R5bGVzW3N0eWxlLmJhc2VdKSwgc3R5bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIENhbGxlZCB0byBjcmVhdGUgYW5kIGluaXRpYWxpemUgc3R5bGVzXG5TdHlsZU1hbmFnZXIuYnVpbGQgPSBmdW5jdGlvbiAoc3R5bGVzLCBzY2VuZSA9IHt9KSB7XG4gICAgLy8gU29ydCBzdHlsZXMgYnkgZGVwZW5kZW5jeSwgdGhlbiBidWlsZCB0aGVtXG4gICAgbGV0IHN0eWxlX2RlcHMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLnNvcnQoXG4gICAgICAgIChhLCBiKSA9PiBTdHlsZU1hbmFnZXIuaW5oZXJpdGFuY2VEZXB0aChhLCBzdHlsZXMpIC0gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgoYiwgc3R5bGVzKVxuICAgICk7XG5cbiAgICAvLyBPbmx5IGtlZXAgYnVpbHQtaW4gYmFzZSBzdHlsZXNcbiAgICBmb3IgKGxldCBzbmFtZSBpbiBTdHlsZXMpIHtcbiAgICAgICAgaWYgKCFCYXNlU3R5bGVzW3NuYW1lXSkge1xuICAgICAgICAgICAgZGVsZXRlIFN0eWxlc1tzbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTdHlsZXNbc25hbWVdLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JraW5nIHNldCBvZiBzdHlsZXMgYmVpbmcgYnVpbHRcbiAgICBsZXQgd3MgPSB7fTtcbiAgICBmb3IgKGxldCBzbmFtZSBvZiBzdHlsZV9kZXBzKSB7XG4gICAgICAgIHdzW3NuYW1lXSA9IFN0eWxlTWFuYWdlci5jcmVhdGUoc25hbWUsIHN0eWxlc1tzbmFtZV0sIHdzKTtcbiAgICB9XG5cbiAgICBTdHlsZU1hbmFnZXIuaW5pdFN0eWxlcyhzY2VuZSk7XG4gICAgcmV0dXJuIFN0eWxlcztcbn07XG5cbi8vIEluaXRpYWxpemUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmluaXRTdHlsZXMgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAvLyBJbml0aWFsaXplIGFsbFxuICAgIGZvciAobGV0IHNuYW1lIGluIFN0eWxlcykge1xuICAgICAgICBTdHlsZXNbc25hbWVdLmluaXQoc2NlbmUpO1xuICAgIH1cbn07XG5cbi8vIEdpdmVuIGEgc3R5bGUga2V5IGluIGEgc2V0IG9mIHN0eWxlcyB0byBhZGQsIGNvdW50IHRoZSBsZW5ndGggb2YgdGhlIGluaGVyaXRhbmNlIGNoYWluXG4vLyBUT0RPOiByZW1vdmUgY3VycmVudCAoU3R5bGVzKSBhbmQgZnV0dXJlIChzdHlsZXMpIGR1cGxpY2F0aW9uLCBjb25mdXNpbmdcblN0eWxlTWFuYWdlci5pbmhlcml0YW5jZURlcHRoID0gZnVuY3Rpb24gKGtleSwgc3R5bGVzKSB7XG4gICAgbGV0IHBhcmVudHMgPSAwO1xuXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNjZW5lIGRlZiBlcnJvciwgdHJ5aW5nIHRvIGV4dGVuZCBhIHN0eWxlIHRoYXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgLy8gVE9ETzogd2Fybi90aHJvdz9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVwZW5kZW5jeSBjaGFpbiBlbmRzIHdoZW4gdGhpcyBzdHlsZSBpc24ndCBtaXhpbmcgaW4gYW55IG90aGVyc1xuICAgICAgICBpZiAoIXN0eWxlLm1peCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSBuZXh0IHBhcmVudCBzdHlsZVxuICAgICAgICBwYXJlbnRzKys7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUubWl4KSkge1xuICAgICAgICAgICAgLy8gSWYgbXVsdGlwbGUgbWl4aW5zLCBmaW5kIHRoZSBkZWVwZXN0IG9uZVxuICAgICAgICAgICAgcGFyZW50cyArPSBNYXRoLm1heCguLi5zdHlsZS5taXgubWFwKHMgPT4gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgocywgc3R5bGVzKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBzaW5nbGUgbWl4aW4sIGNvbnRpbnVlIGxvb3AgdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIGtleSA9IHN0eWxlLm1peDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn07XG5cbi8vIENvbXBpbGUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmNvbXBpbGUgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgIGtleXMgPSBrZXlzIHx8IE9iamVjdC5rZXlzKFN0eWxlcyk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFN0eWxlc1trZXldLmNvbXBpbGUoKTtcbiAgICAgICAgICAgIGxvZy50cmFjZShgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoKTogY29tcGlsZWQgc3R5bGUgJHtrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoKTogZXJyb3IgY29tcGlsaW5nIHN0eWxlICR7a2V5fTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2cuZGVidWcoYFN0eWxlTWFuYWdlci5jb21waWxlKCk6IGNvbXBpbGVkIGFsbCBzdHlsZXNgKTtcbn07XG5cbi8vIEdldCBhbGwgc3R5bGVzIHdpdGggbWVzaCBkYXRhIGZvciBhIGdpdmVuIHRpbGVcblN0eWxlTWFuYWdlci5zdHlsZXNGb3JUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICBsZXQgc3R5bGVzID0gW107XG4gICAgZm9yIChsZXQgcyBpbiBTdHlsZXMpIHtcbiAgICAgICAgaWYgKFN0eWxlc1tzXS5oYXNEYXRhRm9yVGlsZSh0aWxlKSkge1xuICAgICAgICAgICAgc3R5bGVzLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbn07XG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuXG5pbXBvcnQgcGFyc2VDU1NDb2xvciBmcm9tICdjc3Njb2xvcnBhcnNlcic7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IHZhciBTdHlsZVBhcnNlciA9IHt9O1xuXG4vLyBTdHlsZSBtYWNyb3NcblxuU3R5bGVQYXJzZXIuZXhwYW5kTWFjcm9zID0gZnVuY3Rpb24gZXhwYW5kTWFjcm9zIChvYmopIHtcbiAgICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgICAgICB2YXIgdmFsID0gb2JqW3BdO1xuXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBvYmplY3QgcHJvcGVydGllc1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9ialtwXSA9IGV4cGFuZE1hY3Jvcyh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgc3RyaW5ncyBiYWNrIGludG8gZnVuY3Rpb25zXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBtIGluIFN0eWxlUGFyc2VyLm1hY3Jvcykge1xuICAgICAgICAgICAgICAgIGlmICh2YWwubWF0Y2goU3R5bGVQYXJzZXIubWFjcm9zW21dKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbCgnZiA9ICcgKyB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3BdID0gZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy50cmFjZShgZXhwYW5kZWQgbWFjcm8gJHt2YWx9IHRvICR7Zn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsLWJhY2sgdG8gb3JpZ2luYWwgdmFsdWUgaWYgcGFyc2luZyBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy50cmFjZShgZmFpbGVkIHRvIGV4cGFuZCBtYWNybyAke3ZhbH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG4vLyBMaXN0IG9mIG1hY3Jvc1xuU3R5bGVQYXJzZXIubWFjcm9zID0gW1xuICAgICdTdHlsZS5jb2xvci5wc2V1ZG9SYW5kb21Db2xvcicsXG4gICAgJ1N0eWxlLmNvbG9yLnJhbmRvbUNvbG9yJ1xuXTtcblxuXG5cbnZhciBTdHlsZSA9IHt9O1xuXG5TdHlsZS5jb2xvciA9IHtcbiAgICAvLyBwc2V1ZG8tcmFuZG9tIGdyYXlzY2FsZSBieSBnZW9tZXRyeSBpZFxuICAgIHBzZXVkb1JhbmRvbUdyYXlzY2FsZSgpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYyA9IE1hdGgubWF4KChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgJSAxMDApIC8gMTAwLCAwLjQpO1xuICAgICAgICAgICAgcmV0dXJuIFswLjcgKiBjLCAwLjcgKiBjLCAwLjcgKiBjXTtcbiAgICAgICAgfWA7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH0sXG5cbiAgICAvLyBwc2V1ZG8tcmFuZG9tIGNvbG9yIGJ5IGdlb21ldHJ5IGlkXG4gICAgcHNldWRvUmFuZG9tQ29sb3IoKSB7XG4gICAgICAgIHZhciBmdW5jID0gYGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAwLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwICUgMSksXG4gICAgICAgICAgICAgICAgMC43ICogKHBhcnNlSW50KGZlYXR1cmUuaWQsIDE2KSAvIDEwMDAwICUgMSksXG4gICAgICAgICAgICAgICAgMC43ICogKHBhcnNlSW50KGZlYXR1cmUuaWQsIDE2KSAvIDEwMDAwMDAgJSAxKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfWA7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAvLyByZXR1cm4gYGZ1bmN0aW9uKCkgeyByZXR1cm4gWzAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAgJSAxKSwgMC43ICogKHBhcnNlSW50KGZlYXR1cmUuaWQsIDE2KSAvIDEwMDAwICUgMSksIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMDAwICUgMSldOyB9YDtcbiAgICB9LFxuXG4gICAgLy8gcmFuZG9tIGNvbG9yXG4gICAgcmFuZG9tQ29sb3IoKSB7XG4gICAgICAgIHZhciBmdW5jID0gYGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFswLjcgKiBNYXRoLnJhbmRvbSgpLCAwLjcgKiBNYXRoLnJhbmRvbSgpLCAwLjcgKiBNYXRoLnJhbmRvbSgpXTtcbiAgICAgICAgfWA7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbn07XG5cbi8vIFdyYXBzIHN0eWxlIGZ1bmN0aW9ucyBhbmQgcHJvdmlkZXMgYSBzY29wZSBvZiBjb21tb25seSBhY2Nlc3NpYmxlIGRhdGE6XG4vLyAtIGZlYXR1cmU6IHRoZSAncHJvcGVydGllcycgb2YgdGhlIGZlYXR1cmUsIGUuZy4gYWNjZXNzZWQgYXMgJ2ZlYXR1cmUubmFtZSdcbi8vIC0gJHpvb206IHRoZSBjdXJyZW50IG1hcCB6b29tIGxldmVsXG4vLyAtICRnZW9tZXRyeTogdGhlIHR5cGUgb2YgZ2VvbWV0cnksICdwb2ludCcsICdsaW5lJywgb3IgJ3BvbHlnb24nXG4vLyAtICRtZXRlcnNfcGVyX3BpeGVsOiBjb252ZXJzaW9uIGZvciBtZXRlcnMvcGl4ZWxzIGF0IGN1cnJlbnQgbWFwIHpvb21cbi8vIC0gcHJvcGVydGllczogdXNlci1kZWZpbmVkIHByb3BlcnRpZXMgb24gdGhlIHN0eWxlLXJ1bGUgb2JqZWN0IGluIHRoZSBzdHlsZXNoZWV0XG5TdHlsZVBhcnNlci53cmFwRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHZhciBmID0gYGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGNvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIHZhciAkem9vbSA9IGNvbnRleHQuem9vbTtcbiAgICAgICAgICAgICAgICB2YXIgJGdlb21ldHJ5ID0gY29udGV4dC5nZW9tZXRyeTtcbiAgICAgICAgICAgICAgICB2YXIgJG1ldGVyc19wZXJfcGl4ZWwgPSBjb250ZXh0Lm1ldGVyc19wZXJfcGl4ZWw7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgke2Z1bmN9KCkpO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIGY7XG59O1xuXG5cbi8vIFN0eWxlIHBhcnNpbmdcblxuLy8gU3R5bGUgZGVmYXVsdHNcblN0eWxlUGFyc2VyLmRlZmF1bHRzID0ge1xuICAgIGNvbG9yOiBbMSwgMSwgMSwgMV0sXG4gICAgd2lkdGg6IDEsXG4gICAgc2l6ZTogMSxcbiAgICBleHRydWRlOiBmYWxzZSxcbiAgICBoZWlnaHQ6IDIwLFxuICAgIG1pbl9oZWlnaHQ6IDAsXG4gICAgb3JkZXI6IDAsXG4gICAgejogMCxcbiAgICBtYXRlcmlhbDoge1xuICAgICAgICBhbWJpZW50OiAxLFxuICAgICAgICBkaWZmdXNlOiAxXG4gICAgfVxufTtcblxuXG4vLyBBIGNvbnRleHQgb2JqZWN0IHRoYXQgaXMgcGFzc2VkIHRvIHN0eWxlIHBhcnNpbmcgZnVuY3Rpb25zIHRvIHByb3ZpZGUgYSBzY29wZSBvZiBjb21tb25seSB1c2VkIHZhbHVlc1xuU3R5bGVQYXJzZXIuZ2V0RmVhdHVyZVBhcnNlQ29udGV4dCA9IGZ1bmN0aW9uIChmZWF0dXJlLCB0aWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgem9vbTogdGlsZS5zdHlsZV96b29tLFxuICAgICAgICBnZW9tZXRyeTogR2VvLmdlb21ldHJ5VHlwZShmZWF0dXJlLmdlb21ldHJ5LnR5cGUpLFxuICAgICAgICBtZXRlcnNfcGVyX3BpeGVsOiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGlsZS5jb29yZHMueiksXG4gICAgICAgIHVuaXRzX3Blcl9tZXRlcjogR2VvLnVuaXRzX3Blcl9tZXRlclt0aWxlLmNvb3Jkcy56XVxuICAgIH07XG59O1xuXG5TdHlsZVBhcnNlci5jb252ZXJ0VW5pdHMgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQsIGNvbnZlcnQgPSAnbWV0ZXJzJykge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdW5pdHMgPSB2YWwubWF0Y2goLyhbMC05Li1dKykoW2Etel0rKS8pO1xuICAgICAgICBpZiAodW5pdHMgJiYgdW5pdHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHVuaXRzWzFdKTtcbiAgICAgICAgICAgIHVuaXRzID0gdW5pdHNbMl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IHRvIG1ldGVyc1xuICAgICAgICBpZiAoY29udmVydCA9PT0gJ21ldGVycycpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSBwaXhlbHNcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3B4Jykge1xuICAgICAgICAgICAgICAgIHZhbCAqPSBHZW8ubWV0ZXJzUGVyUGl4ZWwoY29udGV4dC56b29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSBraWxvbWV0ZXJzXG4gICAgICAgICAgICBlbHNlIGlmICh1bml0cyA9PT0gJ2ttJykge1xuICAgICAgICAgICAgICAgIHZhbCAqPSAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAvLyBBcnJheSBvZiBhcnJheXMsIGUuZy4gem9vbS1pbnRlcnBvbGF0ZWQgc3RvcHNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5tYXAodiA9PiB7IHJldHVybiBbdlswXSwgU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHZbMV0sIGNvbnRleHQsIGNvbnZlcnQpXTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgdmFsdWVzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5tYXAodiA9PiB7IHJldHVybiBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModiwgY29udGV4dCwgY29udmVydCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG4vLyBUYWtlcyBhIGRpc3RhbmNlIGNhY2hlIG9iamVjdCBhbmQgcmV0dXJucyBhIGRpc3RhbmNlIHZhbHVlIGZvciB0aGlzIHpvb21cbi8vIChjYWNoaW5nIHRoZSByZXN1bHQgZm9yIGZ1dHVyZSB1c2UpXG4vLyB7IHZhbHVlOiBvcmlnaW5hbCwgem9vbTogeyB6OiBtZXRlcnMgfSwgZHluYW1pYzogZnVuY3Rpb24oKXsuLi59IH1cblN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2UgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQsIGNvbnZlcnQgPSAndW5pdHMnKSB7XG4gICAgaWYgKHZhbC5keW5hbWljKSB7XG4gICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgIGlmIChjb252ZXJ0ID09PSAndW5pdHMnKSB7XG4gICAgICAgICAgICB2ICo9IGNvbnRleHQudW5pdHNfcGVyX21ldGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwuem9vbSAmJiB2YWwuem9vbVtjb252ZXJ0XSAmJiB2YWwuem9vbVtjb252ZXJ0XVtjb250ZXh0Lnpvb21dKSB7XG4gICAgICAgIHJldHVybiB2YWwuem9vbVtjb252ZXJ0XVtjb250ZXh0Lnpvb21dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRHluYW1pYyBmdW5jdGlvbi1iYXNlZFxuICAgICAgICBpZiAodHlwZW9mIHZhbC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsLmR5bmFtaWMgPSB2YWwudmFsdWU7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbC5keW5hbWljKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnQgPT09ICd1bml0cycpIHtcbiAgICAgICAgICAgICAgICB2ICo9IGNvbnRleHQudW5pdHNfcGVyX21ldGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2Ygem9vbS1pbnRlcnBvbGF0ZWQgc3RvcHMsIGUuZy4gW3pvb20sIGNvbG9yXSBwYWlyc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjb2xvciBmb3IgY3VycmVudCB6b29tXG4gICAgICAgICAgICB2YWwuem9vbSA9IHZhbC56b29tIHx8IHt9O1xuICAgICAgICAgICAgbGV0IHp1bml0cyA9IHZhbC56b29tW2NvbnZlcnRdID0gdmFsLnpvb21bY29udmVydF0gfHwge307XG5cbiAgICAgICAgICAgIHp1bml0c1tjb250ZXh0Lnpvb21dID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHZhbC52YWx1ZSwgY29udGV4dCxcbiAgICAgICAgICAgICAgICAoY29udmVydCA9PT0gJ3VuaXRzJyB8fCBjb252ZXJ0ID09PSAnbWV0ZXJzJykgJiYgJ21ldGVycycpOyAvLyBjb252ZXJ0IHRvIG1ldGVyc1xuICAgICAgICAgICAgenVuaXRzW2NvbnRleHQuem9vbV0gPSBVdGlscy5pbnRlcnBvbGF0ZShjb250ZXh0Lnpvb20sIHp1bml0c1tjb250ZXh0Lnpvb21dKTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0byB0aWxlIHVuaXRzXG4gICAgICAgICAgICBpZiAoY29udmVydCA9PT0gJ3VuaXRzJykge1xuICAgICAgICAgICAgICAgIHp1bml0c1tjb250ZXh0Lnpvb21dICo9IGNvbnRleHQudW5pdHNfcGVyX21ldGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHp1bml0c1tjb250ZXh0Lnpvb21dO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZSA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCwgY29udmVydCA9ICd1bml0cycpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSB2YWwoY29udGV4dCk7XG4gICAgfVxuICAgIHZhbCA9IFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh2YWwsIGNvbnRleHQsXG4gICAgICAgIChjb252ZXJ0ID09PSAndW5pdHMnIHx8IGNvbnZlcnQgPT09ICdtZXRlcnMnKSAmJiAnbWV0ZXJzJyk7IC8vIGNvbnZlcnQgdG8gbWV0ZXJzXG4gICAgdmFsID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwpO1xuXG4gICAgLy8gQ29udmVydCB0byB0aWxlIHVuaXRzXG4gICAgaWYgKGNvbnZlcnQgPT09ICd1bml0cycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWwgKj0gY29udGV4dC51bml0c19wZXJfbWV0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB2YWwuZm9yRWFjaCgodiwgaSkgPT4gdmFsW2ldICo9IGNvbnRleHQudW5pdHNfcGVyX21ldGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gQ2FjaGUgcHJldmlvdXNseSBwYXJzZWQgY29sb3Igc3RyaW5nc1xuU3R5bGVQYXJzZXIuc3RyaW5nX2NvbG9ycyA9IHt9O1xuU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAvLyBDYWNoZWRcbiAgICBpZiAoU3R5bGVQYXJzZXIuc3RyaW5nX2NvbG9yc1tzdHJpbmddKSB7XG4gICAgICAgIHJldHVybiBTdHlsZVBhcnNlci5zdHJpbmdfY29sb3JzW3N0cmluZ107XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGFuZCBjYWNoZVxuICAgIGxldCBjb2xvciA9IHBhcnNlQ1NTQ29sb3IucGFyc2VDU1NDb2xvcihzdHJpbmcpO1xuICAgIGlmIChjb2xvciAmJiBjb2xvci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgY29sb3JbMF0gLz0gMjU1O1xuICAgICAgICBjb2xvclsxXSAvPSAyNTU7XG4gICAgICAgIGNvbG9yWzJdIC89IDI1NTtcbiAgICAgICAgY29sb3JbM10gPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29sb3IgPSBTdHlsZVBhcnNlci5kZWZhdWx0cy5jb2xvcjtcbiAgICB9XG4gICAgU3R5bGVQYXJzZXIuc3RyaW5nX2NvbG9yc1tzdHJpbmddID0gY29sb3I7XG4gICAgcmV0dXJuIGNvbG9yO1xufTtcblxuLy8gVGFrZXMgYSBjb2xvciBjYWNoZSBvYmplY3QgYW5kIHJldHVybnMgYSBjb2xvciB2YWx1ZSBmb3IgdGhpcyB6b29tXG4vLyAoY2FjaGluZyB0aGUgcmVzdWx0IGZvciBmdXR1cmUgdXNlKVxuLy8geyB2YWx1ZTogb3JpZ2luYWwsIHN0YXRpYzogW3IsZyxiLGFdLCB6b29tOiB7IHo6IFtyLGcsYixhXSB9LCBkeW5hbWljOiBmdW5jdGlvbigpey4uLn0gfVxuU3R5bGVQYXJzZXIuY2FjaGVDb2xvciA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCA9IHt9KSB7XG4gICAgaWYgKHZhbC5keW5hbWljKSB7XG4gICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgIHZbM10gPSB2WzNdIHx8IDE7IC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC5zdGF0aWMpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zdGF0aWM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC56b29tICYmIHZhbC56b29tW2NvbnRleHQuem9vbV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbC56b29tW2NvbnRleHQuem9vbV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEeW5hbWljIGZ1bmN0aW9uLWJhc2VkIGNvbG9yXG4gICAgICAgIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWwuZHluYW1pYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgICAgICB2WzNdID0gdlszXSB8fCAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5nbGUgc3RyaW5nIGNvbG9yXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWwuc3RhdGljID0gU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcodmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RhdGljO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzLCBlLmcuIFt6b29tLCBjb2xvcl0gcGFpcnNcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwudmFsdWUpICYmIEFycmF5LmlzQXJyYXkodmFsLnZhbHVlWzBdKSkge1xuICAgICAgICAgICAgaWYgKCF2YWwuem9vbSkge1xuICAgICAgICAgICAgICAgIHZhbC56b29tID0ge307XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW55IHN0cmluZyBjb2xvcnMgaW5zaWRlIHN0b3BzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgdmFsLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2ID0gdmFsLnZhbHVlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2WzFdID0gU3R5bGVQYXJzZXIuY29sb3JGb3JTdHJpbmcodlsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjb2xvciBmb3IgY3VycmVudCB6b29tXG4gICAgICAgICAgICB2YWwuem9vbVtjb250ZXh0Lnpvb21dID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwudmFsdWUpO1xuICAgICAgICAgICAgdmFsLnpvb21bY29udGV4dC56b29tXVszXSA9IHZhbC56b29tW2NvbnRleHQuem9vbV1bM10gfHwgMTsgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgcmV0dXJuIHZhbC56b29tW2NvbnRleHQuem9vbV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luZ2xlIGFycmF5IGNvbG9yXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsLnN0YXRpYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIHZhbC5zdGF0aWNbM10gPSB2YWwuc3RhdGljWzNdIHx8IDE7IC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RhdGljO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU3R5bGVQYXJzZXIucGFyc2VDb2xvciA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gdmFsKGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIENTUy1zdHlsZSBjb2xvcnNcbiAgICAvLyBUT0RPOiBjaGFuZ2UgYWxsIGNvbG9ycyB0byB1c2UgMC0yNTUgcmFuZ2UgaW50ZXJuYWxseSB0byBhdm9pZCBkaXZpZGluZyBhbmQgdGhlbiByZS1tdWx0aXBseWluZyBpbiBnZW9tIGJ1aWxkZXJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gcGFyc2VDU1NDb2xvci5wYXJzZUNTU0NvbG9yKHZhbCk7XG4gICAgICAgIGlmICh2YWwgJiYgdmFsLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgdmFsWzBdIC89IDI1NTtcbiAgICAgICAgICAgIHZhbFsxXSAvPSAyNTU7XG4gICAgICAgICAgICB2YWxbMl0gLz0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgQXJyYXkuaXNBcnJheSh2YWxbMF0pKSB7XG4gICAgICAgIC8vIEFycmF5IG9mIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzLCBlLmcuIFt6b29tLCBjb2xvcl0gcGFpcnNcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbFtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdlsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmMgPSBwYXJzZUNTU0NvbG9yLnBhcnNlQ1NTQ29sb3IodlsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZjICYmIHZjLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICB2Y1swXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIHZjWzFdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgdmNbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB2WzFdID0gdmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuem9vbSkge1xuICAgICAgICB2YWwgPSBVdGlscy5pbnRlcnBvbGF0ZShjb250ZXh0Lnpvb20sIHZhbCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdHNcbiAgICBpZiAodmFsKSB7XG4gICAgICAgIC8vIGFscGhhXG4gICAgICAgIGlmICghdmFsWzNdKSB7XG4gICAgICAgICAgICB2YWxbM10gPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWwgPSBbMCwgMCwgMCwgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIE9yZGVyIGlzIHN1bW1lZCBmcm9tIHRvcCB0byBib3R0b20gaW4gdGhlIHN0eWxlIGhpZXJhcmNoeTpcbi8vIGVhY2ggY2hpbGQgb3JkZXIgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIHBhcmVudCBvcmRlciB2YWx1ZVxuU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXIgPSBmdW5jdGlvbihvcmRlciwgY29udGV4dCkge1xuICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3JkZXIgPSBvcmRlcihjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICAgICAgb3JkZXIgPSBvcmRlci5yZWR1Y2UoKHN1bSwgb3JkZXIpID0+IHtcbiAgICAgICAgICAgIG9yZGVyID0gb3JkZXIgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMub3JkZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIgPSBvcmRlcihjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IGNvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzW29yZGVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gcGFyc2VGbG9hdChvcmRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3JkZXIgfHwgaXNOYU4ob3JkZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW0gKyBvcmRlcjtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzW29yZGVyXSkge1xuICAgICAgICAgICAgb3JkZXIgPSBjb250ZXh0LmZlYXR1cmUucHJvcGVydGllc1tvcmRlcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcmRlciA9IHBhcnNlRmxvYXQob3JkZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZGVyO1xufTtcbiIsIi8qZ2xvYmFsIExhYmVsICovXG5cbmltcG9ydCBib3hJbnRlcnNlY3QgZnJvbSAnYm94LWludGVyc2VjdCc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCB7XG4gICAgY29uc3RydWN0b3IgKHRleHQsIHNpemUsIHsgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUgfSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgcG9zaXRpb246IFtdLFxuICAgICAgICAgICAgYmJveDogW10sXG4gICAgICAgICAgICBtb3ZlX2luX3RpbGUsXG4gICAgICAgICAgICBrZWVwX2luX3RpbGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pZCA9IExhYmVsLmlkKys7XG5cbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlciB8fCAyOyAvLyBUT0RPOiBtYWtlIGNvbmZpZ3VyYWJsZVxuICAgICAgICB0aGlzLmJ1ZmZlciAqPSBHZW8udW5pdHNfcGVyX3BpeGVsO1xuICAgIH1cblxuICAgIGlzQ29tcG9zaXRlICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9jY2x1ZGVkIChiYm94ZXMpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChiYm94ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYm94SW50ZXJzZWN0KFt0aGlzLmJib3hdLCBiYm94ZXMsIChpLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGJib3hlcy5wdXNoKHRoaXMuYmJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0O1xuICAgIH1cblxuICAgIGluVGlsZUJvdW5kcyAoKSB7XG4gICAgICAgIGxldCBtaW4gPSBbIHRoaXMuYmJveFswXSwgdGhpcy5iYm94WzFdIF07XG4gICAgICAgIGxldCBtYXggPSBbIHRoaXMuYmJveFsyXSwgdGhpcy5iYm94WzNdIF07XG5cbiAgICAgICAgaWYgKCFVdGlscy5wb2ludEluVGlsZShtaW4pIHx8ICFVdGlscy5wb2ludEluVGlsZShtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBkaXNjYXJkIChiYm94ZXMpIHtcbiAgICAgICAgbGV0IGRpc2NhcmQgPSBmYWxzZTtcblxuICAgICAgICAvLyBwZXJmb3JtIHNwZWNpZmljIHN0eWxpbmcgcnVsZSwgc2hvdWxkIHdlIGtlZXAgdGhlIGxhYmVsIGluIHRpbGUgYm91bmRzP1xuICAgICAgICBpZiAodGhpcy5rZWVwX2luX3RpbGUpIHtcbiAgICAgICAgICAgIGxldCBpbl90aWxlID0gdGhpcy5pblRpbGVCb3VuZHMoKTtcblxuICAgICAgICAgICAgaWYgKCFpbl90aWxlICYmIHRoaXMubW92ZV9pbl90aWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuIHdlIG1vdmU/XG4gICAgICAgICAgICAgICAgZGlzY2FyZCA9IHRoaXMubW92ZUluVGlsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaW5fdGlsZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRpZG4ndCB3YW50IHRvIG1vdmUgYXQgYWxsLFxuICAgICAgICAgICAgICAgIC8vIGp1c3QgZGlzY2FyZCBzaW5jZSB3ZSdyZSBvdXQgb2YgdGlsZSBib3VuZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCB3ZSBkaXNjYXJkPyBpZiBub3QsIGp1c3QgbWFrZSBvY2NsdXNpb24gdGVzdFxuICAgICAgICByZXR1cm4gZGlzY2FyZCB8fCB0aGlzLm9jY2x1ZGVkKGJib3hlcyk7XG4gICAgfVxufVxuXG5MYWJlbC5pZCA9IDA7XG5cbiIsImltcG9ydCBMYWJlbFBvaW50IGZyb20gJy4vbGFiZWxfcG9pbnQnO1xuaW1wb3J0IExhYmVsTGluZSBmcm9tICcuL2xhYmVsX2xpbmUnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcblxudmFyIExhYmVsQnVpbGRlcjtcbmV4cG9ydCBkZWZhdWx0IExhYmVsQnVpbGRlciA9IHt9O1xuXG5MYWJlbEJ1aWxkZXIubGFiZWxzRnJvbUdlb21ldHJ5ID0gZnVuY3Rpb24gKGdlb21ldHJ5LCB7IHRleHQsIHNpemUgfSwgbGFiZWxfc3R5bGUpIHtcbiAgICBsZXQgbGFiZWxzID0gW107XG5cbiAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsTGluZSh0ZXh0LCBzaXplLCBsaW5lcywgbGFiZWxfc3R5bGUubGluZXMsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikge1xuICAgICAgICBsZXQgbGluZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxMaW5lKHRleHQsIHNpemUsIGxpbmUsIGxhYmVsX3N0eWxlLmxpbmVzLCB7IG1vdmVfaW5fdGlsZTogdHJ1ZSwga2VlcF9pbl90aWxlOiB0cnVlIH0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgIGxldCB3aWR0aCA9IGxhYmVsX3N0eWxlLnBvaW50cy5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gaWYgKHdpZHRoICYmIHNpemUudGV4dF9zaXplWzBdID4gd2lkdGgpIHtcbiAgICAgICAgLy8gICAgIGxldCBsaW5lX2hlaWdodCA9IChzaXplLnB4X2xvZ2ljYWxfc2l6ZSAvIDEwMCkgKiBsYWJlbF9zdHlsZS5wb2ludHMubGluZV9oZWlnaHQ7XG4gICAgICAgIC8vICAgICBsaW5lX2hlaWdodCA9IFV0aWxzLnBpeGVsVG9NZXJjYXRvcihsaW5lX2hlaWdodCk7XG4gICAgICAgIC8vICAgICBsZXQgbGFiZWwgPSBMYWJlbFBvaW50LmV4cGxvZGUodGV4dCwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHNpemUsIHdpZHRoLCBsaW5lX2hlaWdodCwgeyBtb3ZlX2luX3RpbGU6IHRydWUsIGtlZXBfaW5fdGlsZTogdHJ1ZSB9KTtcblxuICAgICAgICAvLyAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICBpZiAoISh3aWR0aCAmJiBzaXplLnRleHRfc2l6ZVswXSA+IHdpZHRoKSkge1xuICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHNpemUsIG51bGwsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIk11bHRpUG9pbnRcIikge1xuICAgICAgICBsZXQgcG9pbnRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KHRleHQsIHBvaW50LCBzaXplLCBudWxsLCB7IG1vdmVfaW5fdGlsZTogdHJ1ZSwga2VlcF9pbl90aWxlOiB0cnVlIH0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgbGV0IGNlbnRyb2lkID0gVXRpbHMuY2VudHJvaWQoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0pO1xuICAgICAgICBsZXQgYXJlYSA9IFV0aWxzLnBvbHlnb25BcmVhKGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKTtcblxuICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludCh0ZXh0LCBjZW50cm9pZCwgc2l6ZSwgYXJlYSwgeyBtb3ZlX2luX3RpbGU6IHRydWUsIGtlZXBfaW5fdGlsZTogdHJ1ZSB9KSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIk11bHRpUG9seWdvblwiKSB7XG4gICAgICAgIGxldCBjZW50cm9pZCA9IFV0aWxzLm11bHRpQ2VudHJvaWQoZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICBsZXQgYXJlYSA9IFV0aWxzLm11bHRpUG9seWdvbkFyZWEoZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KHRleHQsIGNlbnRyb2lkLCBzaXplLCBhcmVhLCB7IG1vdmVfaW5fdGlsZTogdHJ1ZSwga2VlcF9pbl90aWxlOiB0cnVlIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWxzO1xufTtcblxuXG4iLCJpbXBvcnQgVmVjdG9yIGZyb20gJy4uLy4uL3ZlY3Rvcic7XG5pbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XG5pbXBvcnQgTGFiZWwgZnJvbSAnLi9sYWJlbCc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbExpbmUgZXh0ZW5kcyBMYWJlbCB7XG4gICAgY29uc3RydWN0b3IgKHRleHQsIHNpemUsIGxpbmVzLCBzdHlsZSwgeyBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSB9KSB7XG4gICAgICAgIHN1cGVyKHRleHQsIHNpemUsIHsgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUgfSk7XG5cbiAgICAgICAgdGhpcy5zZWdtZW50X2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmV4Y2VlZF9oZXVyaXN0aWMgPSBzdHlsZS5leGNlZWQ7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gc3R5bGUub2Zmc2V0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIG1pZGRsZVNlZ21lbnQgKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChzZWdtZW50WzBdWzBdICsgc2VnbWVudFsxXVswXSkgLyAyLFxuICAgICAgICAgICAgKHNlZ21lbnRbMF1bMV0gKyBzZWdtZW50WzFdWzFdKSAvIDIsXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdXBkYXRlICgpIHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmN1cnJlbnRTZWdtZW50KCk7XG5cbiAgICAgICAgdGhpcy5hbmdsZSA9IHRoaXMuY29tcHV0ZUFuZ2xlKCk7XG5cbiAgICAgICAgbGV0IHBlcnAgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pKTtcbiAgICAgICAgbGV0IGRvdCA9IFZlY3Rvci5kb3QocGVycCwgWzAsIDFdKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IFZlY3Rvci5tdWx0KHBlcnAsIFV0aWxzLnBpeGVsVG9NZXJjYXRvcih0aGlzLm9mZnNldCAqIE1hdGguc2lnbihkb3QpKSk7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFZlY3Rvci5hZGQodGhpcy5taWRkbGVTZWdtZW50KHNlZ21lbnQpLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLmJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XG4gICAgfVxuXG4gICAgbW92ZU5leHRTZWdtZW50ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VnbWVudF9pbmRleCArIDEgPj0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlZ21lbnRfaW5kZXgrKztcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb21wdXRlQW5nbGUgKCkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuY3VycmVudFNlZ21lbnQoKTtcbiAgICAgICAgbGV0IHAwcDEgPSBWZWN0b3Iuc3ViKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO1xuXG4gICAgICAgIHAwcDEgPSBWZWN0b3Iubm9ybWFsaXplKHAwcDEpO1xuXG4gICAgICAgIGxldCBQSV8yID0gTWF0aC5QSSAvIDI7XG4gICAgICAgIGxldCB0aGV0YSA9IE1hdGguYXRhbjIocDBwMVswXSwgcDBwMVsxXSkgKyBQSV8yO1xuXG4gICAgICAgIGlmICh0aGV0YSA+IFBJXzIgfHwgdGhldGEgPCAtUElfMikge1xuICAgICAgICAgICAgdGhldGEgKz0gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICB0aGV0YSAlPSBNYXRoLlBJICogMjtcblxuICAgICAgICByZXR1cm4gdGhldGE7XG4gICAgfVxuXG4gICAgZml0VG9TZWdtZW50IChzaG91bGRfZml0ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXNob3VsZF9maXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmN1cnJlbnRTZWdtZW50KCk7XG4gICAgICAgIGxldCBwMHAxID0gVmVjdG9yLnN1YihzZWdtZW50WzBdLCBzZWdtZW50WzFdKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IFZlY3Rvci5sZW5ndGgocDBwMSk7XG5cbiAgICAgICAgbGV0IGxhYmVsX2xlbmd0aCA9IFV0aWxzLnBpeGVsVG9NZXJjYXRvcih0aGlzLnNpemUudGV4dF9zaXplWzBdKTtcblxuICAgICAgICBpZiAobGFiZWxfbGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhbiBleGNlZWQgaGV1cmVzdGljIG9mIDEwMCUgd291bGQgbGV0IHRoZSBsYWJlbCBmaXQgaW4gYW55IGNhc2VzXG4gICAgICAgICAgICBsZXQgZXhjZWVkID0gKDEgLSAobGVuZ3RoIC8gbGFiZWxfbGVuZ3RoKSkgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4gZXhjZWVkIDwgdGhpcy5leGNlZWRfaGV1cmlzdGljO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsX2xlbmd0aCA8IGxlbmd0aDtcbiAgICB9XG5cbiAgICBjdXJyZW50U2VnbWVudCAoKSB7XG4gICAgICAgIGxldCBwMSA9IHRoaXMubGluZXNbdGhpcy5zZWdtZW50X2luZGV4XTtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5saW5lc1t0aGlzLnNlZ21lbnRfaW5kZXggKyAxXTtcblxuICAgICAgICByZXR1cm4gWyBwMSwgcDIgXTtcbiAgICB9XG5cbiAgICBjb21wdXRlQkJveCAoc2l6ZSkge1xuICAgICAgICBsZXQgdXBwID0gR2VvLnVuaXRzX3Blcl9waXhlbDtcblxuICAgICAgICBsZXQgbWVyY193aWR0aCA9IHRoaXMuc2l6ZS50ZXh0X3NpemVbMF0gKiB1cHA7XG4gICAgICAgIGxldCBtZXJjX2hlaWdodCA9IHRoaXMuc2l6ZS50ZXh0X3NpemVbMV0gKiB1cHA7XG5cbiAgICAgICAgbGV0IGMgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKTtcbiAgICAgICAgbGV0IHMgPSBNYXRoLnNpbih0aGlzLmFuZ2xlKTtcblxuICAgICAgICBsZXQgeCA9IG1lcmNfd2lkdGggKiBjIC0gbWVyY19oZWlnaHQgKiBzO1xuICAgICAgICBsZXQgeSA9IG1lcmNfd2lkdGggKiBzICsgbWVyY19oZWlnaHQgKiBjO1xuXG4gICAgICAgIGxldCBtYXggPSBNYXRoLm1heChNYXRoLmFicyh4KSwgTWF0aC5hYnMoeSkpICogMC41ICsgdGhpcy5idWZmZXI7XG5cbiAgICAgICAgbGV0IGJib3ggPSBbXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdIC0gbWF4LFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtIG1heCxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKyBtYXgsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdICsgbWF4XG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfVxuXG4gICAgbW92ZUluVGlsZSAoKSB7XG4gICAgICAgIGxldCBpbl90aWxlID0gZmFsc2U7XG4gICAgICAgIGxldCBmaXRzX3RvX3NlZ21lbnQgPSB0aGlzLmZpdFRvU2VnbWVudCgpO1xuXG4gICAgICAgIC8vIG1vdmUgdGhpcyBsYWJlbCB1bnRpbCB3ZSBmb3VuZCBhIGxpbmUgd2UgY2FuIGZpdCBpblxuICAgICAgICB3aGlsZSAoIWluX3RpbGUgJiYgIWZpdHNfdG9fc2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1vdmVOZXh0U2VnbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgbW92ZSBmdXJ0aGVyIGluIHRoaXMgbGluZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbl90aWxlID0gdGhpcy5pblRpbGVCb3VuZHMoKTtcbiAgICAgICAgICAgIGZpdHNfdG9fc2VnbWVudCA9IHRoaXMuZml0VG9TZWdtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIWluX3RpbGUgfHzCoCFmaXRzX3RvX3NlZ21lbnQ7XG4gICAgfVxuXG4gICAgZGlzY2FyZCAoYmJveGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVzICYmICF0aGlzLmZpdFRvU2VnbWVudCgpKSB7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuZml0VG9TZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW92ZU5leHRTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpc2NhcmQoYmJveGVzKTtcbiAgICB9XG59XG5cbiIsImltcG9ydCBMYWJlbCBmcm9tICcuL2xhYmVsJztcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XG5pbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsUG9pbnQgZXh0ZW5kcyBMYWJlbCB7XG4gICAgY29uc3RydWN0b3IgKHRleHQsIHBvc2l0aW9uLCBzaXplLCBhcmVhLCB7IG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlIH0pIHtcbiAgICAgICAgc3VwZXIodGV4dCwgc2l6ZSwgeyBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSB9KTtcblxuICAgICAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMuYmJveCA9IHRoaXMuY29tcHV0ZUJCb3goKTtcbiAgICB9XG5cbiAgICBjb21wdXRlQkJveCAoKSB7XG4gICAgICAgIGxldCBoYWxmX21lcmNfd2lkdGggPSBVdGlscy5waXhlbFRvTWVyY2F0b3IodGhpcy5zaXplLnRleHRfc2l6ZVswXSkgKiAwLjUgKyB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGhhbGZfbWVyY19oZWlnaHQgPSBVdGlscy5waXhlbFRvTWVyY2F0b3IodGhpcy5zaXplLnRleHRfc2l6ZVsxXSkgKiAwLjUgKyB0aGlzLmJ1ZmZlcjtcblxuICAgICAgICBsZXQgYmJveCA9IFtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gLSBoYWxmX21lcmNfd2lkdGgsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC0gaGFsZl9tZXJjX2hlaWdodCxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKyBoYWxmX21lcmNfd2lkdGgsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdICsgaGFsZl9tZXJjX2hlaWdodFxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBiYm94O1xuICAgIH1cblxuICAgIG1vdmVJblRpbGUgKGluX3RpbGUpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5iYm94WzJdIC0gdGhpcy5iYm94WzBdO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gLXRoaXMuYmJveFszXSAtICgtdGhpcy5iYm94WzFdKTtcblxuICAgICAgICAvLyBNb3ZlIHBvaW50IGxhYmVscyB0byB0aWxlIGVkZ2VzXG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uWzBdIC0gd2lkdGgvMiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gPSB3aWR0aC8yICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBvc2l0aW9uWzBdICsgd2lkdGgvMiA+IEdlby50aWxlX3NjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdID0gR2VvLnRpbGVfc2NhbGUgLSAod2lkdGgvMiArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAqPSAtMTsgLy8ganVzdCBkb2luZyB0aGlzIHNvIFkgY29vcmQgaXMgcG9zaXRpdmVcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25bMV0gLSBoZWlnaHQvMiA8IDApIHsgLy8gJiYgdGhpcy5wb3NpdGlvblsxXSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gPSBoZWlnaHQvMiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wb3NpdGlvblsxXSArIGhlaWdodC8yID4gR2VvLnRpbGVfc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gPSBHZW8udGlsZV9zY2FsZSAtIChoZWlnaHQvMiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zaXRpb25bMV0gKj0gLTE7XG5cbiAgICAgICAgdGhpcy5iYm94ID0gdGhpcy5jb21wdXRlQkJveCgpO1xuICAgICAgICByZXR1cm4gIXRoaXMuaW5UaWxlQm91bmRzKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGV4cGxvZGUgKHRleHQsIHBvc2l0aW9uLCBzaXplLCBtYXhfd2lkdGgsIHBhZGRpbmcsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKSB7XG4gICAgICAgIGxldCBzcGxpdF90ZXh0ID0gdGV4dC5zcGxpdCgnICcpO1xuXG4gICAgICAgIGlmIChzcGxpdF90ZXh0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGFiZWxQb2ludCh0ZXh0LCBwb3NpdGlvbiwgc2l6ZSwgbnVsbCwgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgVGV4dExpbmUodGV4dCwgc2l6ZS50ZXh0X3NpemVbMF0sIHNwbGl0X3RleHQsIHNpemUuc3BsaXRfc2l6ZSk7XG4gICAgICAgIGxldCBsaW5lcyA9IGxpbmUuZXhwbG9kZShtYXhfd2lkdGgpO1xuICAgICAgICBsZXQgbGFiZWxzID0gW107XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYWJlbFBvaW50KHRleHQsIHBvc2l0aW9uLCBzaXplLCBudWxsLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpIGluIGxpbmVzKSB7XG4gICAgICAgICAgICBsZXQgbCA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgbGV0IHBvcyA9IFtwb3NpdGlvblswXSwgcG9zaXRpb25bMV0gLSBNYXRoLmFicyhwYWRkaW5nKSAqIGldO1xuICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQobC50ZXh0LCBwb3MsIHNpemUsIG51bGwsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IExhYmVsQ29tcG9zaXRlKHRleHQsIHBvc2l0aW9uLCBzaXplLCBsYWJlbHMsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKTtcbiAgICB9XG59XG5cbmNsYXNzIExhYmVsQ29tcG9zaXRlIGV4dGVuZHMgTGFiZWwge1xuICAgIGNvbnN0cnVjdG9yICh0ZXh0LCBwb3NpdGlvbiwgc2l6ZSwgbGFiZWxzLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSkge1xuICAgICAgICBzdXBlcih0ZXh0LCBzaXplLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSk7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLmxhYmVscyA9IGxhYmVscztcbiAgICAgICAgdGhpcy5iYm94ID0gdGhpcy5jb21wdXRlQkJveCgpO1xuICAgIH1cblxuICAgIGlzQ29tcG9zaXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbW92ZUluVGlsZSAoaW5fdGlsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcHV0ZUJCb3ggKCkge1xuICAgICAgICBsZXQgYmJveCA9IFsgSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSBdO1xuXG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5sYWJlbHMpIHtcbiAgICAgICAgICAgIGxldCBiID0gdGhpcy5sYWJlbHNbaV0uYmJveDtcblxuICAgICAgICAgICAgYmJveFswXSA9IE1hdGgubWluKGJbMF0sIGJib3hbMF0pO1xuICAgICAgICAgICAgYmJveFsxXSA9IE1hdGgubWluKGJbMV0sIGJib3hbMV0pO1xuICAgICAgICAgICAgYmJveFsyXSA9IE1hdGgubWF4KGJbMl0sIGJib3hbMl0pO1xuICAgICAgICAgICAgYmJveFszXSA9IE1hdGgubWF4KGJbM10sIGJib3hbM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfVxufVxuXG5jbGFzcyBUZXh0TGluZSB7XG4gICAgY29uc3RydWN0b3IgKHRleHQsIGxpbmVfbGVuZ3RoLCB3b3Jkcywgc2l6ZV9pbmZvKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGluZV9sZW5ndGggPSBsaW5lX2xlbmd0aDtcbiAgICAgICAgdGhpcy5zaXplX2luZm8gPSBzaXplX2luZm87XG4gICAgICAgIHRoaXMud29yZHMgPSB0aGlzLnBvc2l0aW9ucyh3b3Jkcyk7XG4gICAgfVxuXG4gICAgcG9zaXRpb25zICh3b3Jkcywgc2l6ZV9pbmZvKSB7XG4gICAgICAgIGxldCB3b3JkX2luZm9zID0gW107XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgc3BhY2Vfb2Zmc2V0ID0gdGhpcy5zaXplX2luZm9bJyAnXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgICAgICAgbGV0IHdvcmRfbGVuZ3RoID0gdGhpcy5zaXplX2luZm9bd29yZF07XG5cbiAgICAgICAgICAgIHdvcmRfaW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgd29yZDogd29yZCxcbiAgICAgICAgICAgICAgICBzdGFydDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogb2Zmc2V0ICsgd29yZF9sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHdvcmRfbGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gd29yZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHdvcmRfaW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHdvcmQ6ICcgJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBvZmZzZXQgKyBzcGFjZV9vZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3BhY2Vfb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdvcmRfaW5mb3M7XG4gICAgfVxuXG4gICAgZXhwbG9kZSAobWF4X3dpZHRoLCBleHBsb2RlZF9saW5lcyA9IFtdKSB7XG4gICAgICAgIGlmIChtYXhfd2lkdGggPiB0aGlzLmxpbmVfbGVuZ3RoKSB7XG4gICAgICAgICAgICBleHBsb2RlZF9saW5lcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGxvZGVkX2xpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy53b3JkSW5mb0luZGV4KG1heF93aWR0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMud29yZHNbaW5kZXhdLndvcmQgPT09ICcgJykge1xuICAgICAgICAgICAgaW5kZXggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDEpIHtcbiAgICAgICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2godGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZXhwbG9kZWRfbGluZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLndvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHRfbGluZV9sZW5ndGggPSAwLCBwcmV2aW91c19saW5lX2xlbmd0aCA9IDA7XG4gICAgICAgICAgICBsZXQgbmV4dF9saW5lX3dvcmRzID0gJycsIHByZXZpb3VzX2xpbmVfd29yZHMgPSAnJztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy53b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG5leHRfbGluZV93b3JkcyArPSB0aGlzLndvcmRzW2ldLndvcmQ7XG4gICAgICAgICAgICAgICAgbmV4dF9saW5lX2xlbmd0aCArPSB0aGlzLnNpemVfaW5mb1t0aGlzLndvcmRzW2ldLndvcmRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggLSAxICYmIHRoaXMud29yZHNbaV0gIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX3dvcmRzICs9IHRoaXMud29yZHNbaV0ud29yZDtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfbGluZV9sZW5ndGggKz0gdGhpcy5zaXplX2luZm9bdGhpcy53b3Jkc1tpXS53b3JkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2gobmV3IFRleHRMaW5lKFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX3dvcmRzLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX2xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfbGluZV93b3Jkcy5zcGxpdCgnICcpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemVfaW5mb1xuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIGxldCBuZXh0X2xpbmUgPSBuZXcgVGV4dExpbmUobmV4dF9saW5lX3dvcmRzLFxuICAgICAgICAgICAgICAgICAgICBuZXh0X2xpbmVfbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBuZXh0X2xpbmVfd29yZHMuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplX2luZm9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0X2xpbmUuZXhwbG9kZShtYXhfd2lkdGgsIGV4cGxvZGVkX2xpbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2godGhpcyk7XG4gICAgICAgIHJldHVybiBleHBsb2RlZF9saW5lcztcbiAgICB9XG5cbiAgICB3b3JkSW5mb0luZGV4IChwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLmxpbmVfbGVuZ3RoIHx8IHRoaXMud29yZHNbdGhpcy53b3Jkcy5sZW5ndGggLSAxXS5lbmQgPCBwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud29yZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGQgPSB0aGlzLndvcmRzLmxlbmd0aCAvIDI7XG4gICAgICAgIGxldCBpID0gTWF0aC5jZWlsKGQpO1xuICAgICAgICBpID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgaSksIHRoaXMud29yZHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGxldCB3b3JkX2luZm8gPSB0aGlzLndvcmRzW2ldO1xuXG4gICAgICAgIC8vIGRpY2hvdG9taWMgc2VhcmNoXG4gICAgICAgIHdoaWxlICh3b3JkX2luZm8uc3RhcnQgPiBwb3NpdGlvbiB8fCB3b3JkX2luZm8uZW5kIDwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGQgLz0gMjtcbiAgICAgICAgICAgIGkgKz0gd29yZF9pbmZvLmVuZCA8IHBvc2l0aW9uID8gTWF0aC5jZWlsKGQpIDogLU1hdGguY2VpbChkKTtcbiAgICAgICAgICAgIGkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBpKSwgdGhpcy53b3Jkcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHdvcmRfaW5mbyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG59XG5cbiIsIi8vIFRleHQgcmVuZGVyaW5nIHN0eWxlXG5cbmltcG9ydCBCdWlsZGVycyBmcm9tICcuLi9idWlsZGVycyc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi4vLi4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgV29ya2VyQnJva2VyIGZyb20gJy4uLy4uL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7UG9pbnRzfSBmcm9tICcuLi9wb2ludHMvcG9pbnRzJztcbmltcG9ydCBMYWJlbEJ1aWxkZXIgZnJvbSAnLi9sYWJlbF9idWlsZGVyJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBsZXQgVGV4dFN0eWxlID0gT2JqZWN0LmNyZWF0ZShQb2ludHMpO1xuXG5PYmplY3QuYXNzaWduKFRleHRTdHlsZSwge1xuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBzdXBlcjogUG9pbnRzLFxuICAgIGJ1aWx0X2luOiB0cnVlLFxuICAgIHNlbGVjdGlvbjogZmFsc2UsXG5cbiAgICBpbml0KCkge1xuXG4gICAgICAgIHRoaXMuc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB0aGlzIG9iamVjdCB0byBiZSBjYWxsZWQgZnJvbSB3b3JrZXIgdGhyZWFkc1xuICAgICAgICBpZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG4gICAgICAgICAgICBXb3JrZXJCcm9rZXIuYWRkVGFyZ2V0KCdUZXh0U3R5bGUnLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF4X3ByaW9yaXR5ID0gMDtcblxuICAgICAgICAvLyBQb2ludCBzdHlsZSAocGFyZW50IGNsYXNzKSByZXF1aXJlcyB0ZXh0dXJpbmcgdG8gYmUgdHVybmVkIG9uXG4gICAgICAgIC8vIChsYWJlbHMgYXJlIGFsd2F5cyBkcmF3biB3aXRoIHRleHR1cmVzKVxuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9QT0lOVF9URVhUVVJFID0gdHJ1ZTtcblxuICAgICAgICAvLyBkZWZhdWx0IGZvbnQgc3R5bGVcbiAgICAgICAgdGhpcy5mb250X3N0eWxlID0ge1xuICAgICAgICAgICAgdHlwZWZhY2U6ICdIZWx2ZXRpY2EgMTJweCcsXG4gICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICAgICAgY2FwaXRhbGl6ZWQ6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZGVmYXVsdCBsYWJlbCBzdHlsZVxuICAgICAgICB0aGlzLmxhYmVsX3N0eWxlID0ge1xuICAgICAgICAgICAgcHJpb3JpdGllczoge1xuICAgICAgICAgICAgICAgIGFkbWluaXN0cmF0aXZlOiA0LFxuICAgICAgICAgICAgICAgIG1ham9yX3JvYWQ6IDMsXG4gICAgICAgICAgICAgICAgbWlub3Jfcm9hZDogMixcbiAgICAgICAgICAgICAgICByZXN0YXVyYW50OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVzOiB7XG4gICAgICAgICAgICAgICAgZXhjZWVkOiA4MCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludHM6IHtcbiAgICAgICAgICAgICAgICBtYXhfd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICBsaW5lX2hlaWdodDogMTAwIC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN1cGVyLnJlc2V0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHMgPSB7fTsgLy8gdW5pcXVlIHRleHRzLCBrZXllZCBieSB0aWxlXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB7fTtcbiAgICAgICAgdGhpcy5iYm94ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLmZlYXR1cmVfbGFiZWxzID0ge307XG4gICAgICAgIHRoaXMuZmVhdHVyZV9zdHlsZV9rZXkgPSB7fTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHRvIHJlbGVhc2UgdGlsZS1zcGVjaWZpYyByZXNvdXJjZXNcbiAgICBmcmVlVGlsZSAodGlsZSkge1xuICAgICAgICBkZWxldGUgdGhpcy50ZXh0c1t0aWxlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGV4dHVyZXNbdGlsZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhc1t0aWxlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYmJveGVzW3RpbGVdO1xuICAgICAgICBkZWxldGUgdGhpcy5mZWF0dXJlc1t0aWxlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmVhdHVyZV9sYWJlbHNbdGlsZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZlYXR1cmVfc3R5bGVfa2V5W3RpbGVdO1xuICAgIH0sXG5cblxuICAgIC8vIFNldCBmb250IHN0eWxlIHBhcmFtcyBmb3IgY2FudmFzIGRyYXdpbmdcbiAgICBzZXRGb250ICh0aWxlLCB7IGZvbnQsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlX3dpZHRoLCBweF9zaXplLCBweF9sb2dpY2FsX3NpemUgfSkge1xuICAgICAgICB0aGlzLnB4X3NpemUgPSBwYXJzZUludChweF9zaXplKTtcbiAgICAgICAgdGhpcy5weF9sb2dpY2FsX3NpemUgPSBwYXJzZUludChweF9sb2dpY2FsX3NpemUpO1xuICAgICAgICB0aGlzLnRleHRfYnVmZmVyID0gNjsgLy8gcGl4ZWwgcGFkZGluZyBhcm91bmQgdGV4dFxuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jYW52YXNbdGlsZV0uY29udGV4dDtcblxuICAgICAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2Vfd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gMjtcbiAgICB9LFxuXG4gICAgLy8gV2lkdGggYW5kIGhlaWdodCBvZiB0ZXh0IGJhc2VkIG9uIGN1cnJlbnQgZm9udCBzdHlsZVxuICAgIHRleHRTaXplICh0ZXh0LCB0aWxlLCBjYXBpdGFsaXplZCkge1xuICAgICAgICBsZXQgc3RyID0gY2FwaXRhbGl6ZWQgPyB0ZXh0LnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jYW52YXNbdGlsZV0uY29udGV4dDtcbiAgICAgICAgbGV0IHNwbGl0ID0gc3RyLnNwbGl0KCcgJyk7XG4gICAgICAgIGxldCBweF9zaXplID0gdGhpcy5weF9zaXplO1xuICAgICAgICBsZXQgcHhfbG9naWNhbF9zaXplID0gdGhpcy5weF9sb2dpY2FsX3NpemU7XG4gICAgICAgIGxldCBidWZmZXIgPSB0aGlzLnRleHRfYnVmZmVyICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuICAgICAgICBsZXQgc3BsaXRfc2l6ZSA9IHtcbiAgICAgICAgICAgIFwiIFwiOiB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0Lm1lYXN1cmVUZXh0KFwiIFwiKS53aWR0aCAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGkgaW4gc3BsaXQpIHtcbiAgICAgICAgICAgIGxldCB3b3JkID0gc3BsaXRbaV07XG4gICAgICAgICAgICBzcGxpdF9zaXplW3dvcmRdID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoIC8gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0cl93aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuICAgICAgICBsZXQgdGV4dF9zaXplID0gW1xuICAgICAgICAgICAgc3RyX3dpZHRoIC8gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvLFxuICAgICAgICAgICAgdGhpcy5weF9zaXplIC8gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvXG4gICAgICAgIF07XG5cbiAgICAgICAgbGV0IHRleHR1cmVfdGV4dF9zaXplID0gW1xuICAgICAgICAgICAgTWF0aC5jZWlsKHN0cl93aWR0aCkgKyBidWZmZXIgKiAyLFxuICAgICAgICAgICAgdGhpcy5weF9zaXplICsgYnVmZmVyICogMlxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiB7IHNwbGl0X3NpemUsIHRleHRfc2l6ZSwgdGV4dHVyZV90ZXh0X3NpemUsIHB4X3NpemUsIHB4X2xvZ2ljYWxfc2l6ZSB9O1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRleHQgYXQgc3BlY2lmaWVkIGxvY2F0aW9uLCBhZGp1c3RpbmcgZm9yIGJ1ZmZlciBhbmQgYmFzZWxpbmVcbiAgICBkcmF3VGV4dCAodGV4dCwgW3gsIHldLCB0aWxlLCBzdHJva2UsIGNhcGl0YWxpemVkKSB7XG4gICAgICAgIGxldCBzdHIgPSBjYXBpdGFsaXplZCA/IHRleHQudG9VcHBlckNhc2UoKSA6IHRleHQ7XG4gICAgICAgIGxldCBidWZmZXIgPSB0aGlzLnRleHRfYnVmZmVyICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0LnN0cm9rZVRleHQoc3RyLCB4ICsgYnVmZmVyLCB5ICsgYnVmZmVyICsgdGhpcy5weF9zaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0LmZpbGxUZXh0KHN0ciwgeCArIGJ1ZmZlciwgeSArIGJ1ZmZlciArIHRoaXMucHhfc2l6ZSk7XG4gICAgfSxcblxuICAgIHNldFRleHR1cmVUZXh0UG9zaXRpb25zICh0ZXh0cykge1xuICAgICAgICAvLyBGaW5kIHdpZGVzdCBsYWJlbCBhbmQgc3VtIG9mIGFsbCBsYWJlbCBoZWlnaHRzXG4gICAgICAgIGxldCB3aWRlc3QgPSAwLCBoZWlnaHQgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dF9pbmZvcyA9IHRleHRzW3N0eWxlXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRfaW5mbyA9IHRleHRfaW5mb3NbdGV4dF07XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0ZXh0X2luZm8uc2l6ZS50ZXh0dXJlX3RleHRfc2l6ZTtcblxuICAgICAgICAgICAgICAgIHRleHRfaW5mby5wb3NpdGlvbiA9IFswLCBoZWlnaHRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpemVbMF0gPiB3aWRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZXN0ID0gc2l6ZVswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gc2l6ZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbIHdpZGVzdCwgaGVpZ2h0IF07XG4gICAgfSxcblxuICAgIGdldFRleHRTaXplcyAodGlsZSwgdGV4dHMpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgY2FudmFzXG4gICAgICAgIGlmKCF0aGlzLmNhbnZhc1t0aWxlXSkge1xuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNbdGlsZV0gPSB7XG4gICAgICAgICAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IHRleHQgaW4gdGV4dF9pbmZvcykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0X3N0eWxlID0gdGV4dF9pbmZvc1t0ZXh0XS50ZXh0X3N0eWxlO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0ZXh0IHNpemVzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb250KHRpbGUsIHRleHRfc3R5bGUpO1xuICAgICAgICAgICAgICAgIHRleHRfaW5mb3NbdGV4dF0uc2l6ZSA9IHRoaXMudGV4dFNpemUodGV4dCwgdGlsZSwgdGV4dF9zdHlsZS5jYXBpdGFsaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHRzKTtcbiAgICB9LFxuXG4gICAgcmFzdGVyaXplICh0aWxlLCB0ZXh0cywgdGV4dHVyZV9zaXplKSB7XG4gICAgICAgIGxldCBwaXhlbF9zY2FsZSA9IFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcblxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IHRleHQgaW4gdGV4dF9pbmZvcykge1xuICAgICAgICAgICAgICAgIGxldCBpbmZvID0gdGV4dF9pbmZvc1t0ZXh0XTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9udCh0aWxlLCBpbmZvLnRleHRfc3R5bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1RleHQodGV4dCwgaW5mby5wb3NpdGlvbiwgdGlsZSwgaW5mby50ZXh0X3N0eWxlLnN0cm9rZSwgaW5mby50ZXh0X3N0eWxlLmNhcGl0YWxpemVkKTtcblxuICAgICAgICAgICAgICAgIGluZm8udGV4Y29vcmRzID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICBpbmZvLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUudGV4dHVyZV90ZXh0X3NpemUsXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVfc2l6ZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZm8uc3ViX3RleHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IHRoaXMudGV4dF9idWZmZXI7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3RzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHNwYWNlX3NpemUgPSBpbmZvLnNpemUuc3BsaXRfc2l6ZVsnICddO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZvLnN1Yl90ZXh0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3ViX3RleHQgPSBpbmZvLnN1Yl90ZXh0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gc3ViX3RleHQuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgICAgICAgICBkaXN0c1tpXSA9IHdpZHRoICogcGl4ZWxfc2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcGxpdC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdvcmQgPSBzcGxpdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IGluZm8uc2l6ZS5zcGxpdF9zaXplW3dvcmRdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gc3BsaXQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IHNwYWNlX3NpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5mby5zdWJfdGV4dHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gc3BhY2Vfc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdWItdGV4dHMgdXYgbWFwcGluZ1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5mby5zdWJfdGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1Yl90ZXh0ID0gaW5mby5zdWJfdGV4dHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmZvLnN1YnRleGNvb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5zdWJ0ZXhjb29yZHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgaW5mby5zdWJfdGV4dHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gaW5mby5zaXplLnRleHR1cmVfdGV4dF9zaXplWzBdIC0gZGlzdHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5wb3NpdGlvblswXSArIGRpc3RzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5wb3NpdGlvblsxXVxuICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgKGluZm8uc2l6ZS50ZXh0dXJlX3RleHRfc2l6ZVswXSAtIG9mZnNldCkgLSBkaXN0c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uc2l6ZS50ZXh0dXJlX3RleHRfc2l6ZVsxXVxuICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5mby5zdWJ0ZXh0X3NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uc3VidGV4dF9zaXplID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5mby5zdWJ0ZXh0X3NpemVbc3ViX3RleHRdID0gc2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICBpbmZvLnN1YnRleGNvb3Jkc1tzdWJfdGV4dF0gPSBCdWlsZGVycy5nZXRUZXhjb29yZHNGb3JTcHJpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiwgc2l6ZSwgdGV4dHVyZV9zaXplXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCBmcm9tIHdvcmtlciwgdG8gY3JlYXRlIGF0bGFzIG9mIGxhYmVscyBmb3IgYSB0aWxlXG4gICAgYWRkVGV4dHMgKHRpbGUsIHRleHRzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW52YXNbdGlsZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRleHR1cmVfc2l6ZSA9IHRoaXMuc2V0VGV4dHVyZVRleHRQb3NpdGlvbnModGV4dHMpO1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuY2FudmFzW3RpbGVdLmNvbnRleHQ7XG5cbiAgICAgICAgbG9nLnRyYWNlKGB0ZXh0IHN1bW1hcnkgZm9yIHRpbGUgJHt0aWxlfTogZml0cyBpbiAke3RleHR1cmVfc2l6ZVswXX14JHt0ZXh0dXJlX3NpemVbMV19cHhgKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGNhbnZhcyBcImNvbnRleHRcIlxuICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXS5jYW52YXMud2lkdGggPSB0ZXh0dXJlX3NpemVbMF07XG4gICAgICAgIHRoaXMuY2FudmFzW3RpbGVdLmNhbnZhcy5oZWlnaHQgPSB0ZXh0dXJlX3NpemVbMV07XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRleHR1cmVfc2l6ZVswXSwgdGV4dHVyZV9zaXplWzFdKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0dXJlXG4gICAgICAgIGxldCB0ZXh0dXJlID0gJ2xhYmVscy0nICsgdGlsZSArICctJyArIChUZXh0U3R5bGUudGV4dHVyZV9pZCsrKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlc1t0aWxlXSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHsgZmlsdGVyaW5nOiAnbGluZWFyJyB9KTtcbiAgICAgICAgLy8gdGhpcy50ZXh0dXJlc1t0aWxlXS5vd25lciA9IHsgdGlsZSB9O1xuXG4gICAgICAgIC8vIGFzayBmb3IgcmFzdGVyaXphdGlvbiBmb3IgdGhlIHRleHQgc2V0XG4gICAgICAgIHRoaXMucmFzdGVyaXplKHRpbGUsIHRleHRzLCB0ZXh0dXJlX3NpemUpO1xuXG4gICAgICAgIHRoaXMudGV4dHVyZXNbdGlsZV0uc2V0Q2FudmFzKHRoaXMuY2FudmFzW3RpbGVdLmNhbnZhcyk7XG5cbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aWxlIGNhbnZhcy90ZXh0dXJlIG9uY2UgaXQgaGFzIGJlZW4gY29waWVkIHRvIHRvIEdQVVxuICAgICAgICBkZWxldGUgdGhpcy50ZXh0dXJlc1t0aWxlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FudmFzW3RpbGVdO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB0ZXh0cywgdGV4dHVyZSB9KTtcbiAgICB9LFxuXG4gICAgLy8gT3ZlcnJpZGVcbiAgICBzdGFydERhdGEgKHRpbGUpIHtcbiAgICAgICAgbGV0IHRpbGVfZGF0YSA9IHRoaXMuc3VwZXIuc3RhcnREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRpbGVfZGF0YS5xdWV1ZSA9IFtdO1xuICAgICAgICByZXR1cm4gdGlsZV9kYXRhO1xuICAgIH0sXG5cbiAgICBzdWJUZXh0SW5mb3MgKGxhYmVsX2NvbXBvc2l0ZSwgdGV4dF9pbmZvKSB7XG4gICAgICAgIGlmICghdGV4dF9pbmZvLnN1Yl90ZXh0cykge1xuICAgICAgICAgICAgdGV4dF9pbmZvLnN1Yl90ZXh0cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSBpbiBsYWJlbF9jb21wb3NpdGUubGFiZWxzKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBsYWJlbF9jb21wb3NpdGUubGFiZWxzW2ldO1xuICAgICAgICAgICAgdGV4dF9pbmZvLnN1Yl90ZXh0cy5wdXNoKGxhYmVsLnRleHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZUxhYmVscyAodGlsZSwgdGV4dHMpIHtcbiAgICAgICAgbGV0IGxhYmVsc19wcmlvcml0aWVzID0gW107XG5cbiAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzW3RpbGVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlc1t0aWxlXVtzdHlsZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IHRleHQgaW4gdGV4dF9pbmZvcykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0X2luZm8gPSB0ZXh0X2luZm9zW3RleHRdO1xuICAgICAgICAgICAgICAgIHRleHRfaW5mby5yZWYgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzW3RpbGVdW3N0eWxlXVt0ZXh0XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCB0aGlzLmZlYXR1cmVzW3RpbGVdW3N0eWxlXVt0ZXh0XS5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZSA9IHRoaXMuZmVhdHVyZXNbdGlsZV1bc3R5bGVdW3RleHRdW2ZdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gTGFiZWxCdWlsZGVyLmxhYmVsc0Zyb21HZW9tZXRyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGV4dCwgc2l6ZTogdGV4dF9pbmZvLnNpemUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsX3N0eWxlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcmVhID0gbGFiZWwuYXJlYTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzX3ByaW9yaXRpZXNbdGV4dF9pbmZvLnByaW9yaXR5XSA9IGxhYmVsc19wcmlvcml0aWVzW3RleHRfaW5mby5wcmlvcml0eV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNfcHJpb3JpdGllc1t0ZXh0X2luZm8ucHJpb3JpdHldLnB1c2goeyBzdHlsZSwgZmVhdHVyZSwgbGFiZWwsIGFyZWEgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbC5pc0NvbXBvc2l0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJUZXh0SW5mb3MobGFiZWwsIHRleHRfaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb3J0IGJ5IGFyZWEgc2l6ZSBpZiBkZWZpbmVkXG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbGFiZWxzX3ByaW9yaXRpZXMubGVuZ3RoOyArK3ApIHtcbiAgICAgICAgICAgIGlmICghbGFiZWxzX3ByaW9yaXRpZXNbcF0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFiZWxzX3ByaW9yaXRpZXNbcF0uc29ydCgoZTEsIGUyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUxLmFyZWEgJiYgZTIuYXJlYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTEuYXJlYSA8IGUyLmFyZWE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsc19wcmlvcml0aWVzO1xuICAgIH0sXG5cbiAgICBkaXNjYXJkTGFiZWxzICh0aWxlLCBsYWJlbHMsIHRleHRzKSB7XG4gICAgICAgIHRoaXMuYmJveGVzW3RpbGVdID0gW107XG4gICAgICAgIHRoaXMuZmVhdHVyZV9sYWJlbHNbdGlsZV0gPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgZm9yIChsZXQgcHJpb3JpdHkgPSB0aGlzLm1heF9wcmlvcml0eTsgcHJpb3JpdHkgPj0gMDsgcHJpb3JpdHktLSkge1xuICAgICAgICAgICAgaWYgKCFsYWJlbHNbcHJpb3JpdHldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzW3ByaW9yaXR5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHN0eWxlLCBmZWF0dXJlLCBsYWJlbCB9ID0gbGFiZWxzW3ByaW9yaXR5XVtpXTtcblxuICAgICAgICAgICAgICAgIGlmICghbGFiZWwuZGlzY2FyZCh0aGlzLmJib3hlc1t0aWxlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVfbGFiZWxzW3RpbGVdLmhhcyhmZWF0dXJlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlX2xhYmVsc1t0aWxlXS5zZXQoZmVhdHVyZSwgW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZV9sYWJlbHNbdGlsZV0uZ2V0KGZlYXR1cmUpLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0c1tzdHlsZV1bbGFiZWwudGV4dF0ucmVmKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRleHQgaW4gdGV4dHNbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRzW3N0eWxlXVt0ZXh0XS5yZWYgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZXh0c1tzdHlsZV1bdGV4dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuICAgICAgICAgICAgLy8gTm8gbGFiZWxzIGZvciB0aGlzIHN0eWxlXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGV4dF9pbmZvcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRleHRzW3N0eWxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZVxuICAgIGVuZERhdGEgKHRpbGUpIHtcbiAgICAgICAgLy8gQ291bnQgY29sbGVjdGVkIHRleHRcbiAgICAgICAgbGV0IGNvdW50O1xuICAgICAgICBsZXQgdGlsZV9kYXRhID0gdGhpcy50aWxlX2RhdGFbdGlsZV07XG5cbiAgICAgICAgaWYgKHRpbGVfZGF0YS5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb3VudCA9IE9iamVjdC5rZXlzKHRoaXMudGV4dHNbdGlsZV18fHt9KS5sZW5ndGg7XG4gICAgICAgICAgICBsb2cudHJhY2UoYCMgdGV4dHMgZm9yIHRpbGUgJHt0aWxlfTogJHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBjYWxsIHRvIG1haW4gdGhyZWFkLCBhc2sgZm9yIHRleHQgcGl4ZWwgc2l6ZXNcbiAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnVGV4dFN0eWxlJywgJ2dldFRleHRTaXplcycsIHRpbGUsIHRoaXMudGV4dHNbdGlsZV0pLnRoZW4odGV4dHMgPT4ge1xuICAgICAgICAgICAgaWYgKCF0ZXh0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJlZVRpbGUodGlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuZW5kRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbGFiZWxzID0gdGhpcy5jcmVhdGVMYWJlbHModGlsZSwgdGV4dHMpO1xuICAgICAgICAgICAgaWYgKCFsYWJlbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyZWVUaWxlKHRpbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmVuZERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNjYXJkTGFiZWxzKHRpbGUsIGxhYmVscywgdGV4dHMpO1xuXG4gICAgICAgICAgICAvLyBObyBsYWJlbHMgZm9yIHRoaXMgdGlsZVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRleHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyZWVUaWxlKHRpbGUpO1xuICAgICAgICAgICAgICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnVGV4dFN0eWxlJywgJ2ZyZWVUaWxlJywgdGlsZSk7XG4gICAgICAgICAgICAgICAgLy8gZWFybHkgZXhpdFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2Vjb25kIGNhbGwgdG8gbWFpbiB0aHJlYWQsIGZvciByYXN0ZXJpemluZyB0aGUgc2V0IG9mIHRleHRzXG4gICAgICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKCdUZXh0U3R5bGUnLCAnYWRkVGV4dHMnLCB0aWxlLCB0ZXh0cykudGhlbigoeyB0ZXh0cywgdGV4dHVyZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHNbdGlsZV0gPSB0ZXh0cztcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggdGlsZS1zcGVjaWZpYyBsYWJlbCBhdGxhcyB0byBtZXNoIGFzIGEgdGV4dHVyZSB1bmlmb3JtXG4gICAgICAgICAgICAgICAgICAgIHRpbGVfZGF0YS51bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiB0ZXh0dXJlIH07XG4gICAgICAgICAgICAgICAgICAgIHRpbGVfZGF0YS50ZXh0dXJlcyA9IFt0ZXh0dXJlXTsgLy8gYXNzaWduIHRleHR1cmUgb3duZXJzaGlwIHRvIHRpbGUgLSBUT0RPOiBpbXBsZW1lbnQgaW4gVkJPTWVzaFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHF1ZXVlZCBmZWF0dXJlc1xuICAgICAgICAgICAgICAgICAgICB0aWxlX2RhdGEucXVldWUuZm9yRWFjaChxID0+IHRoaXMuc3VwZXIuYWRkRmVhdHVyZS5hcHBseSh0aGlzLCBxKSk7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVfZGF0YS5xdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZnJlZVRpbGUodGlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuZW5kRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZSB0byBxdWV1ZSBmZWF0dXJlcyBpbnN0ZWFkIG9mIHByb2Nlc3NpbmcgaW1tZWRpYXRlbHlcbiAgICBhZGRGZWF0dXJlIChmZWF0dXJlLCBydWxlLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlO1xuICAgICAgICBpZiAodGlsZS5nZW5lcmF0aW9uICE9PSB0aGlzLmdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbGxlY3QgdGV4dFxuICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHJ1bGUudGV4dF9zb3VyY2UgfHwgJ25hbWUnO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGV4dCA9IGZlYXR1cmUucHJvcGVydGllc1tzb3VyY2VdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRleHQgPSBzb3VyY2UoY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgZmVhdHVyZS50ZXh0ID0gdGV4dDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHRzW3RpbGUua2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHNbdGlsZS5rZXldID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHRoaXMuY29uc3RydWN0Rm9udFN0eWxlKHJ1bGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN0eWxlX2tleSA9IHRoaXMuY29uc3RydWN0U3R5bGVLZXkoc3R5bGUpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlX3N0eWxlX2tleVt0aWxlLmtleV0gPSB0aGlzLmZlYXR1cmVfc3R5bGVfa2V5W3RpbGUua2V5XSB8fCBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGVfa2V5W3RpbGUua2V5XS5zZXQoZmVhdHVyZSwgc3R5bGVfa2V5KTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHRzW3RpbGUua2V5XVtzdHlsZV9rZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlLmtleV1bc3R5bGVfa2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxfc3R5bGUucHJpb3JpdGllc1tmZWF0dXJlLnByb3BlcnRpZXMua2luZF0pIHtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9IHRoaXMubGFiZWxfc3R5bGUucHJpb3JpdGllc1tmZWF0dXJlLnByb3BlcnRpZXMua2luZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubWF4X3ByaW9yaXR5ID0gTWF0aC5tYXgocHJpb3JpdHksIHRoaXMubWF4X3ByaW9yaXR5KTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHRzW3RpbGUua2V5XVtzdHlsZV9rZXldW3RleHRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlLmtleV1bc3R5bGVfa2V5XVt0ZXh0XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9zdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXMgfHwge307XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzW3RpbGUua2V5XSA9IHRoaXMuZmVhdHVyZXNbdGlsZS5rZXldIHx8wqB7fTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNbdGlsZS5rZXldW3N0eWxlX2tleV0gPSB0aGlzLmZlYXR1cmVzW3RpbGUua2V5XVtzdHlsZV9rZXldIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc1t0aWxlLmtleV1bc3R5bGVfa2V5XVt0ZXh0XSA9IHRoaXMuZmVhdHVyZXNbdGlsZS5rZXldW3N0eWxlX2tleV1bdGV4dF0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzW3RpbGUua2V5XVtzdHlsZV9rZXldW3RleHRdLnB1c2goZmVhdHVyZSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGEodGlsZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldLnF1ZXVlLnB1c2goW2ZlYXR1cmUsIHJ1bGUsIGNvbnRleHRdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb25zdHJ1Y3RGb250U3R5bGUgKHJ1bGUsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHN0eWxlO1xuXG4gICAgICAgIGlmIChydWxlLmZvbnQpIHtcbiAgICAgICAgICAgIHN0eWxlID0ge307XG5cbiAgICAgICAgICAgIC8vIFVzZSBmaWxsIGlmIHNwZWNpZmllZCwgb3IgZGVmYXVsdFxuICAgICAgICAgICAgc3R5bGUuZmlsbCA9IChydWxlLmZvbnQuZmlsbCAmJiBVdGlscy50b0NhbnZhc0NvbG9yKFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IocnVsZS5mb250LmZpbGwsIGNvbnRleHQpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbnRfc3R5bGUuZmlsbDtcblxuICAgICAgICAgICAgLy8gVXNlIHN0cm9rZSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChydWxlLmZvbnQuc3Ryb2tlICYmIHJ1bGUuZm9udC5zdHJva2UuY29sb3IpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zdHJva2UgPSBVdGlscy50b0NhbnZhc0NvbG9yKFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IocnVsZS5mb250LnN0cm9rZS5jb2xvcikpO1xuICAgICAgICAgICAgICAgIHN0eWxlLnN0cm9rZV93aWR0aCA9IHJ1bGUuZm9udC5zdHJva2Uud2lkdGggfHwgdGhpcy5mb250X3N0eWxlLnN0cm9rZS53aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgdHlwZWZhY2VcbiAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBydWxlLmZvbnQudHlwZWZhY2UgfHzCoHRoaXMuZm9udF9zdHlsZS50eXBlZmFjZTtcbiAgICAgICAgICAgIHN0eWxlLmNhcGl0YWxpemVkID0gcnVsZS5mb250LmNhcGl0YWxpemVkIHx8IHRoaXMuZm9udF9zdHlsZS5jYXBpdGFsaXplZDtcblxuICAgICAgICAgICAgbGV0IHNpemVfcmVnZXggPSAvKFswLTldKlxcLik/WzAtOV0rKHB4fHB0fGVtfCUpL2c7XG4gICAgICAgICAgICBsZXQgZnRfc2l6ZSA9IHN0eWxlLmZvbnQubWF0Y2goc2l6ZV9yZWdleClbMF07XG4gICAgICAgICAgICBsZXQgc2l6ZV9raW5kID0gZnRfc2l6ZS5yZXBsYWNlKC8oWzAtOV0qXFwuKT9bMC05XSsvZywgJycpO1xuXG4gICAgICAgICAgICBzdHlsZS5weF9sb2dpY2FsX3NpemUgPSBVdGlscy50b1BpeGVsU2l6ZShmdF9zaXplLnJlcGxhY2UoLyhbYS16XXwlKS9nLCAnJyksIHNpemVfa2luZCk7XG4gICAgICAgICAgICBzdHlsZS5weF9zaXplID0gc3R5bGUucHhfbG9naWNhbF9zaXplICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuICAgICAgICAgICAgc3R5bGUuc3Ryb2tlX3dpZHRoICo9IFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBzdHlsZS5mb250LnJlcGxhY2Uoc2l6ZV9yZWdleCwgc3R5bGUucHhfc2l6ZSArIFwicHhcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGNvbnN0cnVjdFN0eWxlS2V5ICh7IGZvbnQsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlX3dpZHRoIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke2ZvbnR9LyR7ZmlsbH0vJHtzdHJva2V9LyR7c3Ryb2tlX3dpZHRofWA7XG4gICAgfSxcblxuICAgIGJ1aWxkTGFiZWwgKGxhYmVsLCBzaXplLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLCB0ZXhjb29yZF9zY2FsZSkge1xuICAgICAgICBsZXQgYW5nbGUgPSBsYWJlbC5hbmdsZSB8fCAwO1xuICAgICAgICBCdWlsZGVycy5idWlsZFF1YWRzRm9yUG9pbnRzKFxuICAgICAgICAgICAgWyBsYWJlbC5wb3NpdGlvbiBdLFxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihzaXplWzBdLCAyNTYpLFxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihzaXplWzFdLCAyNTYpLFxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihVdGlscy5yYWRUb0RlZyhhbmdsZSksIDM2MCksXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KDEsIDI1NiksXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YSxcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3NoYXBlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCxcbiAgICAgICAgICAgICAgICB0ZXhjb29yZF9zY2FsZTogdGV4Y29vcmRfc2NhbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgYnVpbGQgKHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICBsZXQgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgaW4gc3R5bGUubGFiZWxzKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBzdHlsZS5sYWJlbHNbaV07XG5cbiAgICAgICAgICAgIGlmIChsYWJlbC5pc0NvbXBvc2l0ZSgpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiBpbiBsYWJlbC5sYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBsYWJlbC5sYWJlbHNbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJ0ZXhjb29yZF9zY2FsZSA9IHRoaXMuc3VidGV4Y29vcmRfc2NhbGVbbC50ZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLnN1YnRleHRfc2l6ZVtsLnRleHRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkTGFiZWwobCwgc2l6ZSwgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSwgc3VidGV4Y29vcmRfc2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZExhYmVsKGxhYmVsLCBsYWJlbC5zaXplLnRleHR1cmVfdGV4dF9zaXplLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLCB0aGlzLnRleGNvb3JkX3NjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZExpbmVzIChsaW5lcywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2ludHMgKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2x5Z29ucyAocG9pbnRzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgdGhpcy5idWlsZChzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgIH0sXG5cbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZmVhdHVyZS50ZXh0O1xuXG4gICAgICAgIGxldCBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcbiAgICAgICAgbGV0IHRpbGUgPSBjb250ZXh0LnRpbGUua2V5O1xuICAgICAgICBsZXQgc3R5bGVfa2V5ID0gdGhpcy5mZWF0dXJlX3N0eWxlX2tleVt0aWxlXS5nZXQoZmVhdHVyZSk7XG4gICAgICAgIGxldCB0ZXh0X2luZm8gPSB0aGlzLnRleHRzW3RpbGVdICYmIHRoaXMudGV4dHNbdGlsZV1bc3R5bGVfa2V5XSAmJiB0aGlzLnRleHRzW3RpbGVdW3N0eWxlX2tleV1bdGV4dF07XG5cbiAgICAgICAgaWYgKCF0ZXh0X2luZm8gfHwgIXRoaXMuZmVhdHVyZV9sYWJlbHNbdGlsZV0uaGFzKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRleGNvb3JkX3NjYWxlID0gdGV4dF9pbmZvLnRleGNvb3JkcztcbiAgICAgICAgdGhpcy5zdWJ0ZXhjb29yZF9zY2FsZSA9IHRleHRfaW5mby5zdWJ0ZXhjb29yZHM7XG4gICAgICAgIHRoaXMuc3VidGV4dF9zaXplID0gdGV4dF9pbmZvLnN1YnRleHRfc2l6ZTtcbiAgICAgICAgc3R5bGUudGV4dCA9IHRleHQ7XG4gICAgICAgIHN0eWxlLmxhYmVscyA9IHRoaXMuZmVhdHVyZV9sYWJlbHNbdGlsZV0uZ2V0KGZlYXR1cmUpO1xuXG4gICAgICAgIC8vIFRPRE86IHBvaW50IHN0eWxlIChwYXJlbnQgY2xhc3MpIHJlcXVpcmVzIGEgY29sb3IsIHNldHRpbmcgaXQgdG8gd2hpdGUgZm9yIG5vdyxcbiAgICAgICAgLy8gYnV0IGNvdWxkIGJlIG1hZGUgY29uZGl0aW9uYWwgaW4gdGhlIHZlcnRleCBsYXlvdXQgdG8gc2F2ZSBzcGFjZVxuICAgICAgICBzdHlsZS5jb2xvciA9IFsxLCAxLCAxLCAxXTtcblxuICAgICAgICAvLyB0ZWxsIHRoZSBwb2ludCBzdHlsZSAoYmFzZSBjbGFzcykgdGhhdCB3ZSB3YW50IHRvIHJlbmRlciBwb2x5Z29uIGxhYmVscyBhdCB0aGUgcG9seWdvbidzIGNlbnRyb2lkXG4gICAgICAgIHN0eWxlLmNlbnRyb2lkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG59KTtcblxuVGV4dFN0eWxlLnRleHR1cmVfaWQgPSAwO1xuIiwiLypnbG9iYWwgVGlsZSAqL1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGUge1xuXG4gICAgLyoqXG4gICAgICAgIFRpbGVcbiAgICAgICAgQGNvbnN0cnVjdG9yXG4gICAgICAgIFJlcXVpcmVkIHByb3BlcnRpZXM6XG4gICAgICAgIGNvb3Jkczogb2JqZWN0IHdpdGgge3gsIHksIHp9IHByb3BlcnRpZXMgaWRlbnRpZnlpbmcgdGlsZSBjb29yZGluYXRlIGxvY2F0aW9uXG4gICAgICAgIHdvcmtlcjogd2ViIHdvcmtlciB0byBoYW5kbGUgdGlsZSBjb25zdHJ1Y3Rpb25cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY29vcmRzLCBzb3VyY2UsIHdvcmtlciwgc3R5bGVfem9vbSB9KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgY29vcmRzOiB7XG4gICAgICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgICAgICB5OiBudWxsLFxuICAgICAgICAgICAgICAgIHo6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1Zzoge30sXG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHdvcmtlcjogbnVsbCxcbiAgICAgICAgICAgIGdlbmVyYXRpb246IG51bGwsXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNlbnRlcl9kaXN0OiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMud29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdHlsZV96b29tID0gc3R5bGVfem9vbTsgLy8gem9vbSBsZXZlbCB0byBiZSB1c2VkIGZvciBzdHlsaW5nXG5cbiAgICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG4gICAgICAgIHRoaXMuY29vcmRzID0gVGlsZS5vdmVyWm9vbWVkQ29vcmRpbmF0ZSh0aGlzLmNvb3JkcywgdGhpcy5zb3VyY2UubWF4X3pvb20pO1xuICAgICAgICB0aGlzLmNvb3JkX2tleSA9IFRpbGUuY29vcmRLZXkodGhpcy5jb29yZHMpO1xuICAgICAgICB0aGlzLmtleSA9IFRpbGUua2V5KHRoaXMuY29vcmRzLCB0aGlzLnNvdXJjZSwgdGhpcy5zdHlsZV96b29tKTtcbiAgICAgICAgdGhpcy5taW4gPSBHZW8ubWV0ZXJzRm9yVGlsZSh0aGlzLmNvb3Jkcyk7XG4gICAgICAgIHRoaXMubWF4ID0gR2VvLm1ldGVyc0ZvclRpbGUoe3g6IHRoaXMuY29vcmRzLnggKyAxLCB5OiB0aGlzLmNvb3Jkcy55ICsgMSwgejogdGhpcy5jb29yZHMueiB9KSxcbiAgICAgICAgdGhpcy5zcGFuID0geyB4OiAodGhpcy5tYXgueCAtIHRoaXMubWluLngpLCB5OiAodGhpcy5tYXgueSAtIHRoaXMubWluLnkpIH07XG4gICAgICAgIHRoaXMuYm91bmRzID0geyBzdzogeyB4OiB0aGlzLm1pbi54LCB5OiB0aGlzLm1heC55IH0sIG5lOiB7IHg6IHRoaXMubWF4LngsIHk6IHRoaXMubWluLnkgfSB9O1xuXG4gICAgICAgIHRoaXMubWVzaGVzID0ge307IC8vIHJlbmRlcmFibGUgVkJPIG1lc2hlcyBrZXllZCBieSBzdHlsZVxuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107IC8vIHRleHR1cmVzIHRoYXQgdGhlIHRpbGUgb3ducyAobGFiZWxzLCBldGMuKVxuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IFRpbGUoc3BlYyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvb3JkS2V5KHt4LCB5LCB6fSkge1xuICAgICAgICByZXR1cm4gW3gsIHksIHpdLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICBzdGF0aWMga2V5IChjb29yZHMsIHNvdXJjZSwgc3R5bGVfem9vbSkge1xuICAgICAgICBjb29yZHMgPSBUaWxlLm92ZXJab29tZWRDb29yZGluYXRlKGNvb3Jkcywgc291cmNlLm1heF96b29tKTtcbiAgICAgICAgcmV0dXJuIFtzb3VyY2UubmFtZSwgc3R5bGVfem9vbSwgY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMuel0uam9pbignLycpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb29yZGluYXRlQXRab29tKHt4LCB5LCB6fSwgem9vbSkge1xuICAgICAgICBpZiAoeiAhPT0gem9vbSkge1xuICAgICAgICAgICAgbGV0IHpzY2FsZSA9IE1hdGgucG93KDIsIHogLSB6b29tKTtcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKHggLyB6c2NhbGUpO1xuICAgICAgICAgICAgeSA9IE1hdGguZmxvb3IoeSAvIHpzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt4LCB5LCB6OiB6b29tfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC56ID4gcGFyZW50LnopIHtcbiAgICAgICAgICAgIGxldCB7eCwgeX0gPSBUaWxlLmNvb3JkaW5hdGVBdFpvb20oY2hpbGQsIHBhcmVudC56KTtcbiAgICAgICAgICAgIHJldHVybiAocGFyZW50LnggPT09IHggJiYgcGFyZW50LnkgPT09IHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgb3Zlclpvb21lZENvb3JkaW5hdGUoe3gsIHksIHp9LCBtYXhfem9vbSkge1xuICAgICAgICBpZiAoeiA+IG1heF96b29tKSB7XG4gICAgICAgICAgICByZXR1cm4gVGlsZS5jb29yZGluYXRlQXRab29tKHt4LCB5LCB6fSwgbWF4X3pvb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eCwgeSwgen07XG4gICAgfVxuXG4gICAgLy8gU29ydCBhIHNldCBvZiB0aWxlIGluc3RhbmNlcyAod2hpY2ggYWxyZWFkeSBoYXZlIGEgZGlzdGFuY2UgZnJvbSBjZW50ZXIgdGlsZSBjb21wdXRlZClcbiAgICBzdGF0aWMgc29ydCh0aWxlcykge1xuICAgICAgICByZXR1cm4gdGlsZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGFkID0gYS5jZW50ZXJfZGlzdDtcbiAgICAgICAgICAgIGxldCBiZCA9IGIuY2VudGVyX2Rpc3Q7XG4gICAgICAgICAgICByZXR1cm4gKGJkID4gYWQgPyAtMSA6IChiZCA9PT0gYWQgPyAwIDogMSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmcmVlUmVzb3VyY2VzKCkge1xuICAgICAgICBpZiAodGhpcy5tZXNoZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG0gaW4gdGhpcy5tZXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2hlc1ttXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RdO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVzaGVzID0ge307XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLndvcmtlck1lc3NhZ2UoJ3JlbW92ZVRpbGUnLCB0aGlzLmtleSk7XG4gICAgICAgIHRoaXMuZnJlZVJlc291cmNlcygpO1xuICAgICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgfVxuXG4gICAgYnVpbGRBc01lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgY29vcmRfa2V5OiB0aGlzLmNvb3JkX2tleSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UubmFtZSxcbiAgICAgICAgICAgIGNvb3JkczogdGhpcy5jb29yZHMsXG4gICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgIHN0eWxlX3pvb206IHRoaXMuc3R5bGVfem9vbSxcbiAgICAgICAgICAgIGdlbmVyYXRpb246IHRoaXMuZ2VuZXJhdGlvbixcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgd29ya2VyTWVzc2FnZSAoLi4ubWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMud29ya2VyLCAuLi5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBidWlsZChnZW5lcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2VyTWVzc2FnZSgnYnVpbGRUaWxlJywgeyB0aWxlOiB0aGlzLmJ1aWxkQXNNZXNzYWdlKCkgfSkuY2F0Y2goZSA9PiB7IHRocm93IGU7IH0pO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgZ2VvbWV0cnkgZm9yIHRpbGUgLSBjYWxsZWQgYnkgd2ViIHdvcmtlclxuICAgIC8vIFJldHVybnMgYSBzZXQgb2YgdGlsZSBrZXlzIHRoYXQgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIG1haW4gdGhyZWFkIChzbyB0aGF0IHdlIGNhbiBtaW5pbWl6ZSBkYXRhIGV4Y2hhbmdlIGJldHdlZW4gd29ya2VyIGFuZCBtYWluIHRocmVhZClcbiAgICBzdGF0aWMgYnVpbGRHZW9tZXRyeSAodGlsZSwgbGF5ZXJzLCBydWxlcywgc3R5bGVzKSB7XG4gICAgICAgIHRpbGUuZGVidWcucmVuZGVyaW5nID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHRpbGUuZGVidWcuZmVhdHVyZXMgPSAwO1xuXG4gICAgICAgIGxldCBkYXRhID0gdGlsZS5zb3VyY2VfZGF0YTtcblxuICAgICAgICAvLyBUcmVhdCB0b3AtbGV2ZWwgc3R5bGUgcnVsZXMgYXMgJ2xheWVycydcbiAgICAgICAgZm9yIChsZXQgbGF5ZXJfbmFtZSBpbiBsYXllcnMpIHtcbiAgICAgICAgICAgIGxldCBsYXllciA9IGxheWVyc1tsYXllcl9uYW1lXTtcbiAgICAgICAgICAgIC8vIFNraXAgbGF5ZXJzIHdpdGggbm8gZGF0YSBzb3VyY2UgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFsYXllci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oYExheWVyICR7bGF5ZXJ9IHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZW9tZXRyeSBkYXRhIHNvdXJjZSBhbmQgd2lsbCBub3QgYmUgcmVuZGVyZWQuYCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNvdXJjZSBuYW1lcyBkb24ndCBtYXRjaFxuICAgICAgICAgICAgaWYgKGxheWVyLmRhdGEuc291cmNlICE9PSB0aWxlLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZ2VvbSA9IFRpbGUuZ2V0RGF0YUZvclNvdXJjZShkYXRhLCBsYXllci5kYXRhLCBsYXllcl9uYW1lKTtcbiAgICAgICAgICAgIGlmICghZ2VvbSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW5kZXIgZmVhdHVyZXMgaW4gbGF5ZXJcbiAgICAgICAgICAgIGxldCBudW1fZmVhdHVyZXMgPSBnZW9tLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGYgPSBudW1fZmVhdHVyZXMtMTsgZiA+PSAwOyBmLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZSA9IGdlb20uZmVhdHVyZXNbZl07XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBTdHlsZVBhcnNlci5nZXRGZWF0dXJlUGFyc2VDb250ZXh0KGZlYXR1cmUsIHRpbGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGRyYXcgZ3JvdXBzIGZvciB0aGlzIGZlYXR1cmVcbiAgICAgICAgICAgICAgICBsZXQgbGF5ZXJfcnVsZXMgPSBydWxlc1tsYXllcl9uYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgZHJhd19ncm91cHMgPSBsYXllcl9ydWxlcy5idWlsZERyYXdHcm91cHMoY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkcmF3X2dyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZHJhdyBncm91cHNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBncm91cF9uYW1lIGluIGRyYXdfZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IGRyYXdfZ3JvdXBzW2dyb3VwX25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZV9uYW1lID0gZ3JvdXAuc3R5bGUgfHwgZ3JvdXBfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gc3R5bGVzW3N0eWxlX25hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBTdHlsZSAnJHtzdHlsZV9uYW1lfScgbm90IGZvdW5kIGZvciBydWxlIGluIGxheWVyICcke2xheWVyX25hbWV9JzpgLCBncm91cCwgZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IGdyb3VwLnByb3BlcnRpZXM7IC8vIGFkZCBydWxlLXNwZWNpZmljIHByb3BlcnRpZXMgdG8gY29udGV4dFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmFkZEZlYXR1cmUoZmVhdHVyZSwgZ3JvdXAsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IG51bGw7IC8vIGNsZWFyIGdyb3VwLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aWxlLmRlYnVnLmZlYXR1cmVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGlsZS5kZWJ1Zy5yZW5kZXJpbmcgPSArbmV3IERhdGUoKSAtIHRpbGUuZGVidWcucmVuZGVyaW5nO1xuXG4gICAgICAgIC8vIEZpbmFsaXplIGFycmF5IGJ1ZmZlciBmb3IgZWFjaCByZW5kZXIgc3R5bGVcbiAgICAgICAgbGV0IHRpbGVfc3R5bGVzID0gU3R5bGVNYW5hZ2VyLnN0eWxlc0ZvclRpbGUodGlsZS5rZXkpO1xuICAgICAgICB0aWxlLm1lc2hfZGF0YSA9IHt9O1xuICAgICAgICBsZXQgcXVldWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgc3R5bGVfbmFtZSBvZiB0aWxlX3N0eWxlcykge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gc3R5bGVzW3N0eWxlX25hbWVdO1xuICAgICAgICAgICAgcXVldWUucHVzaChzdHlsZS5lbmREYXRhKHRpbGUua2V5KS50aGVuKChzdHlsZV9kYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlX2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5tZXNoX2RhdGFbc3R5bGVfbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YTogc3R5bGVfZGF0YS52ZXJ0ZXhfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBzdHlsZV9kYXRhLnVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXM6IHN0eWxlX2RhdGEudGV4dHVyZXNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGtleXMgdG8gYmUgdHJhbnNmZXJlZCB0byBtYWluIHRocmVhZFxuICAgICAgICAgICAgcmV0dXJuIFsnbWVzaF9kYXRhJ107XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBSZXRyaWV2ZXMgZ2VvbWV0cnkgZnJvbSBhIHRpbGUgYWNjb3JkaW5nIHRvIGEgZGF0YSBzb3VyY2UgZGVmaW5pdGlvblxuICAgICovXG4gICAgc3RhdGljIGdldERhdGFGb3JTb3VyY2UgKHNvdXJjZV9kYXRhLCBzb3VyY2VfY29uZmlnLCBkZWZhdWx0X2xheWVyID0gbnVsbCkge1xuICAgICAgICB2YXIgZ2VvbTtcblxuICAgICAgICBpZiAoc291cmNlX2NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBsYXllciBzcGVjaWZpZWQsIGFuZCBhIGRlZmF1bHQgc291cmNlIGxheWVyIGV4aXN0c1xuICAgICAgICAgICAgaWYgKCFzb3VyY2VfY29uZmlnLmxheWVyICYmIHNvdXJjZV9kYXRhLmxheWVycy5fZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGdlb20gPSBzb3VyY2VfZGF0YS5sYXllcnMuX2RlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBubyBsYXllciBzcGVjaWZpZWQsIGFuZCBhIGRlZmF1bHQgcmVxdWVzdGVkIGxheWVyIGV4aXN0c1xuICAgICAgICAgICAgZWxzZSBpZiAoIXNvdXJjZV9jb25maWcubGF5ZXIgJiYgZGVmYXVsdF9sYXllcikge1xuICAgICAgICAgICAgICAgIGdlb20gPSBzb3VyY2VfZGF0YS5sYXllcnNbZGVmYXVsdF9sYXllcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhIGxheWVyIGlzIHNwZWNpZmllZCBieSBuYW1lLCB1c2UgaXRcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VfY29uZmlnLmxheWVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGdlb20gPSBzb3VyY2VfZGF0YS5sYXllcnNbc291cmNlX2NvbmZpZy5sYXllcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3NlbWJsZSBhIGN1c3RvbSBsYXllciB2aWEgYSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggYWxsIHNvdXJjZSBsYXllcnNcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VfY29uZmlnLmxheWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZ2VvbSA9IHNvdXJjZV9jb25maWcubGF5ZXIoc291cmNlX2RhdGEubGF5ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZ1xuICAgICAgIGZvciBhIHNpbmdsZSB0aWxlLlxuICAgICovXG4gICAgYnVpbGRNZXNoZXMoc3R5bGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbnVwIGV4aXN0aW5nIFZCT3NcbiAgICAgICAgdGhpcy5mcmVlUmVzb3VyY2VzKCk7XG5cbiAgICAgICAgLy8gRGVidWdcbiAgICAgICAgdGhpcy5kZWJ1Zy5nZW9tZXRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5kZWJ1Zy5idWZmZXJfc2l6ZSA9IDA7XG5cbiAgICAgICAgLy8gQ3JlYXRlIFZCT3NcbiAgICAgICAgbGV0IG1lc2hfZGF0YSA9IHRoaXMubWVzaF9kYXRhO1xuICAgICAgICBpZiAobWVzaF9kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIG1lc2hfZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNoX2RhdGFbc10udmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5idWZmZXJfc2l6ZSArPSBtZXNoX2RhdGFbc10udmVydGV4X2RhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZXNbc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgY3JlYXRlIG1lc2ggYmVjYXVzZSBzdHlsZSAnJHtzfScgbm90IGZvdW5kLCBmb3IgdGlsZSAke3RoaXMua2V5fSwgYWJvcnRpbmcgdGlsZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNoZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzaGVzW3NdID0gc3R5bGVzW3NdLm1ha2VNZXNoKG1lc2hfZGF0YVtzXS52ZXJ0ZXhfZGF0YSwgbWVzaF9kYXRhW3NdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5nZW9tZXRyaWVzICs9IHRoaXMubWVzaGVzW3NdLmdlb21ldHJ5X2NvdW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBvd25lcnNoaXAgdG8gdGV4dHVyZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKG1lc2hfZGF0YVtzXS50ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVzLnB1c2goLi4ubWVzaF9kYXRhW3NdLnRleHR1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlYnVnLmdlb21fcmF0aW8gPSAodGhpcy5kZWJ1Zy5nZW9tZXRyaWVzIC8gdGhpcy5kZWJ1Zy5mZWF0dXJlcykudG9GaXhlZCgxKTtcbiAgICAgICAgdGhpcy5tZXNoX2RhdGEgPSBudWxsOyAvLyBUT0RPOiBtaWdodCB3YW50IHRvIHByZXNlcnZlIHRoaXMgZm9yIHJlYnVpbGRpbmcgZ2VvbWV0cmllcyB3aGVuIHN0eWxlcy9ldGMuIGNoYW5nZT9cbiAgICAgICAgdGhpcy5wcmludERlYnVnKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIHdlYiB3b3JrZXIgY29tcGxldGVzIHByb2Nlc3NpbmcsIGJ1dCB0aWxlIGhhcyBzaW5jZSBiZWVuIGRpc2NhcmRlZFxuICAgICAgICBGcmVlcyByZXNvdXJjZXMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gdHJhbnNmZXJyZWQgdG8gdGhlIHRpbGUgb2JqZWN0LlxuICAgICAgICBTdGF0aWMgbWV0aG9kIGJlY2F1c2UgdGhlIHRpbGUgb2JqZWN0IG5vIGxvbmdlciBleGlzdHMgKHRoZSB0aWxlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHdvcmtlciBpcyBwYXNzZWQgaW5zdGVhZCkuXG4gICAgKi9cbiAgICBzdGF0aWMgYWJvcnRCdWlsZCAodGlsZSkge1xuICAgICAgICBpZiAodGlsZS5tZXNoX2RhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gdGlsZS5tZXNoX2RhdGEpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZXMgPSB0aWxlLm1lc2hfZGF0YVtzXS50ZXh0dXJlcztcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGRlc3Ryb3lpbmcgdGV4dHVyZSAke3R9IGZvciB0aWxlICR7dGlsZS5rZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcmludERlYnVnICgpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBUaWxlOiBkZWJ1ZyBmb3IgJHt0aGlzLmtleX06IFsgICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kZWJ1Zyl9IF1gKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoc2NlbmUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzO1xuICAgICAgICBpZiAoY29vcmRzLnogIT09IHNjZW5lLmNlbnRlcl90aWxlLnopIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IFRpbGUuY29vcmRpbmF0ZUF0Wm9vbShjb29yZHMsIHNjZW5lLmNlbnRlcl90aWxlLnopO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2VudGVyX2Rpc3QgPSBNYXRoLmFicyhzY2VuZS5jZW50ZXJfdGlsZS54IC0gY29vcmRzLngpICsgTWF0aC5hYnMoc2NlbmUuY2VudGVyX3RpbGUueSAtIGNvb3Jkcy55KTtcbiAgICB9XG5cbiAgICAvLyBTbGljZSBhIHN1YnNldCBvZiBrZXlzIG91dCBvZiBhIHRpbGVcbiAgICAvLyBJbmNsdWRlcyBhIG1pbmltdW0gc2V0IG9mIHByZS1kZWZpbmVkIGtleXMgZm9yIGxvYWQgc3RhdGUsIGRlYnVnLiBldGMuXG4gICAgLy8gV2UgdXNlIHRoaXMgdG8gc2VuZCBhIHN1YnNldCBvZiB0aGUgdGlsZSBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCwgdG8gbWluaW1pemUgdW5uZWNlc3NhcnkgZGF0YSB0cmFuc2ZlclxuICAgIC8vIChlLmcuIHZlcnkgbGFyZ2UgaXRlbXMgbGlrZSBmZWF0dXJlIGdlb21ldHJ5IGFyZSBub3QgbmVlZGVkIG9uIHRoZSBtYWluIHRocmVhZClcbiAgICBzdGF0aWMgc2xpY2UgKHRpbGUsIGtleXMpIHtcbiAgICAgICAgbGV0IGtlZXAgPSBbXG4gICAgICAgICAgICAna2V5JyxcbiAgICAgICAgICAgICdsb2FkaW5nJyxcbiAgICAgICAgICAgICdsb2FkZWQnLFxuICAgICAgICAgICAgJ2dlbmVyYXRpb24nLFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICdkZWJ1ZydcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgIGtlZXAucHVzaCguLi5rZXlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0aWxlIHN1YnNldFxuICAgICAgICB2YXIgdGlsZV9zdWJzZXQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGtlZXApIHtcbiAgICAgICAgICAgIHRpbGVfc3Vic2V0W2tleV0gPSB0aWxlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZV9zdWJzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIENhbGxlZCBvbiB3b3JrZXIgdG8gY2FuY2VsIGxvYWRpbmdcbiAgICAgICAgU3RhdGljIG1ldGhvZCBiZWNhdXNlIHRoZSB3b3JrZXIgb25seSBoYXMgb2JqZWN0IHJlcHJlc2VudGF0aW9ucyBvZiB0aWxlIGRhdGEsIHRoZXJlIGlzIG5vXG4gICAgICAgIHRpbGUgaW5zdGFuY2UgY3JlYXRlZCB5ZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgY2FuY2VsKHRpbGUpIHtcbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5zb3VyY2VfZGF0YSAmJiB0aWxlLnNvdXJjZV9kYXRhLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRpbGUuc291cmNlX2RhdGEucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAna2V5Jykge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG90aGVyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxudmFyIFRpbGVNYW5hZ2VyO1xuXG5leHBvcnQgZGVmYXVsdCBUaWxlTWFuYWdlciA9IHtcblxuICAgIGluaXQoc2NlbmUpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnRpbGVzID0ge307XG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzID0gW107XG4gICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZvckVhY2hUaWxlKHRpbGUgPT4gdGlsZS5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnRpbGVzID0ge307XG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzID0gW107XG4gICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xuICAgIH0sXG5cbiAgICBrZWVwVGlsZSh0aWxlKSB7XG4gICAgICAgIHRoaXMudGlsZXNbdGlsZS5rZXldID0gdGlsZTtcbiAgICB9LFxuXG4gICAgaGFzVGlsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZXNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBmb3JnZXRUaWxlKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy50aWxlc1trZXldO1xuICAgICAgICB0aGlzLnRpbGVCdWlsZFN0b3Aoa2V5KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgc2luZ2xlIHRpbGVcbiAgICByZW1vdmVUaWxlKGtleSkge1xuICAgICAgICBsb2cudHJhY2UoYHRpbGUgdW5sb2FkIGZvciAke2tleX1gKTtcblxuICAgICAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNba2V5XTtcblxuICAgICAgICBpZiAodGlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aWxlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9yZ2V0VGlsZSh0aWxlLmtleSk7XG4gICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdygpO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gYSBmdW5jdGlvbiBvbiBlYWNoIHRpbGVcbiAgICBmb3JFYWNoVGlsZShmdW5jKSB7XG4gICAgICAgIGZvciAobGV0IHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgICAgICAgZnVuYyh0aGlzLnRpbGVzW3RdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGlsZXMgdGhhdCBwYXNzIGEgZmlsdGVyIGNvbmRpdGlvblxuICAgIHJlbW92ZVRpbGVzKGZpbHRlcikge1xuICAgICAgICBsZXQgcmVtb3ZlX3RpbGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLnRpbGVzW3RdO1xuICAgICAgICAgICAgaWYgKGZpbHRlcih0aWxlKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZV90aWxlcy5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHI9MDsgciA8IHJlbW92ZV90aWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgbGV0IGtleSA9IHJlbW92ZV90aWxlc1tyXTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZShrZXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZVRpbGVzRm9yVmlldygpIHtcbiAgICAgICAgLy8gRmluZCB2aXNpYmxlIHRpbGVzIGFuZCBsb2FkIG5ldyBvbmVzXG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgbGV0IHRpbGVfY29vcmRzID0gdGhpcy5zY2VuZS5maW5kVmlzaWJsZVRpbGVDb29yZGluYXRlcygpO1xuICAgICAgICBmb3IgKGxldCBjb29yZHMgb2YgdGlsZV9jb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVDb29yZGluYXRlKGNvb3Jkcyk7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVfY29vcmRzW1RpbGUuY29vcmRLZXkoY29vcmRzKV0gPSBjb29yZHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGlsZXMgdG9vIGZhciBvdXRzaWRlIG9mIHZpZXdcbiAgICAgICAgdGhpcy5zY2VuZS5wcnVuZVRpbGVDb29yZGluYXRlc0ZvclZpZXcoKTsgLy8gVE9ETzogcmV0dXJuIGxpc3QgdG8gcHJ1bmU/XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoVGlsZSh0aWxlID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSh0aWxlKTtcbiAgICAgICAgICAgIHRpbGUudXBkYXRlKHRoaXMuc2NlbmUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlzaWJpbGl0eSh0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLnN0eWxlX3pvb20gIT09IHRoaXMuc2NlbmUudGlsZV96b29tKSB7XG4gICAgICAgICAgICB0aWxlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZpc2libGVfY29vcmRzW3RpbGUuY29vcmRfa2V5XSkge1xuICAgICAgICAgICAgdGlsZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJydXRlIGZvcmNlXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy52aXNpYmxlX2Nvb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChUaWxlLmlzQ2hpbGQodGlsZS5jb29yZHMsIHRoaXMudmlzaWJsZV9jb29yZHNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlsZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVyYWJsZVRpbGVzKCkge1xuICAgICAgICBsZXQgdGlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMudGlsZXNbdF07XG4gICAgICAgICAgICBpZiAodGlsZS52aXNpYmxlICYmIHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGlsZXMucHVzaCh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZXM7XG4gICAgfSxcblxuICAgIC8vIFF1ZXVlIGEgdGlsZSBmb3IgbG9hZFxuICAgIHF1ZXVlQ29vcmRpbmF0ZShjb29yZHMpIHtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzW3RoaXMucXVldWVkX2Nvb3Jkcy5sZW5ndGhdID0gY29vcmRzO1xuICAgIH0sXG5cbiAgICAvLyBMb2FkIGFsbCBxdWV1ZWQgdGlsZXNcbiAgICBsb2FkUXVldWVkQ29vcmRpbmF0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZF9jb29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IHF1ZXVlZCB0aWxlcyBmcm9tIGNlbnRlciB0aWxlXG4gICAgICAgIHRoaXMucXVldWVkX2Nvb3Jkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWQgPSBNYXRoLmFicyh0aGlzLnNjZW5lLmNlbnRlcl90aWxlLnggLSBhLngpICsgTWF0aC5hYnModGhpcy5zY2VuZS5jZW50ZXJfdGlsZS55IC0gYS55KTtcbiAgICAgICAgICAgIGxldCBiZCA9IE1hdGguYWJzKHRoaXMuc2NlbmUuY2VudGVyX3RpbGUueCAtIGIueCkgKyBNYXRoLmFicyh0aGlzLnNjZW5lLmNlbnRlcl90aWxlLnkgLSBiLnkpO1xuICAgICAgICAgICAgcmV0dXJuIChiZCA+IGFkID8gLTEgOiAoYmQgPT09IGFkID8gMCA6IDEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVldWVkX2Nvb3Jkcy5mb3JFYWNoKGNvb3JkcyA9PiB0aGlzLmxvYWRDb29yZGluYXRlKGNvb3JkcykpO1xuICAgICAgICB0aGlzLnF1ZXVlZF9jb29yZHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLy8gTG9hZCBhbGwgdGlsZXMgdG8gY292ZXIgYSBnaXZlbiBsb2dpY2FsIHRpbGUgY29vcmRpbmF0ZVxuICAgIGxvYWRDb29yZGluYXRlKGNvb3Jkcykge1xuICAgICAgICAvLyBTa2lwIGlmIG5vdCBhdCBjdXJyZW50IHNjZW5lIHpvb21cbiAgICAgICAgaWYgKGNvb3Jkcy56ICE9PSB0aGlzLnNjZW5lLmNlbnRlcl90aWxlLnopIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBuZWNlc3NhcnkgdGlsZXMgZm9yIGVhY2ggc291cmNlXG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBVdGlscy52YWx1ZXModGhpcy5zY2VuZS5zb3VyY2VzKSkge1xuICAgICAgICAgICAgbGV0IGtleSA9IFRpbGUua2V5KGNvb3Jkcywgc291cmNlLCB0aGlzLnNjZW5lLnRpbGVfem9vbSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzVGlsZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSBUaWxlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAvLyBtYXhfem9vbTogdGhpcy5zY2VuZS5maW5kTWF4Wm9vbSgpLCAvLyBUT0RPOiByZXBsYWNlIHdpdGggYmV0dGVyIG1heCB6b29tIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcjogdGhpcy5zY2VuZS5uZXh0V29ya2VyKCksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlX3pvb206IHRoaXMuc2NlbmUuc3R5bGVab29tKGNvb3Jkcy56KSAvLyBUT0RPOiByZXBsYWNlP1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVGlsZSh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBTb3J0IGFuZCBidWlsZCBhIGxpc3Qgb2YgdGlsZXNcbiAgICBidWlsZFRpbGVzKHRpbGVzKSB7XG4gICAgICAgIFRpbGUuc29ydCh0aWxlcykuZm9yRWFjaCh0aWxlID0+IHRoaXMuYnVpbGRUaWxlKHRpbGUpKTtcbiAgICAgICAgdGhpcy5jaGVja0J1aWxkUXVldWUoKTtcbiAgICB9LFxuXG4gICAgYnVpbGRUaWxlKHRpbGUpIHtcbiAgICAgICAgdGhpcy50aWxlQnVpbGRTdGFydCh0aWxlLmtleSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSh0aWxlKTtcbiAgICAgICAgdGlsZS51cGRhdGUodGhpcy5zY2VuZSk7XG4gICAgICAgIHRpbGUuYnVpbGQodGhpcy5zY2VuZS5nZW5lcmF0aW9uKVxuICAgICAgICAgICAgLnRoZW4obWVzc2FnZSA9PiB0aGlzLmJ1aWxkVGlsZUNvbXBsZXRlZChtZXNzYWdlKSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgICAgICAgICBUaWxlLmFib3J0QnVpbGQodGlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gYSB3ZWIgd29ya2VyIGNvbXBsZXRlcyBwcm9jZXNzaW5nIGZvciBhIHNpbmdsZSB0aWxlIChpbml0aWFsIGxvYWQsIG9yIHJlYnVpbGQpXG4gICAgYnVpbGRUaWxlQ29tcGxldGVkKHsgdGlsZSB9KSB7XG4gICAgICAgIC8vIFJlbW92ZWQgdGhpcyB0aWxlIGR1cmluZyBsb2FkP1xuICAgICAgICBpZiAodGhpcy50aWxlc1t0aWxlLmtleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGBkaXNjYXJkZWQgdGlsZSAke3RpbGUua2V5fSBpbiBUaWxlTWFuYWdlci5idWlsZFRpbGVDb21wbGV0ZWQgYmVjYXVzZSBwcmV2aW91c2x5IHJlbW92ZWRgKTtcbiAgICAgICAgICAgIFRpbGUuYWJvcnRCdWlsZCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsdCB3aXRoIGFuIG91dGRhdGVkIHNjZW5lIGNvbmZpZ3VyYXRpb24/XG4gICAgICAgIGVsc2UgaWYgKHRpbGUuZ2VuZXJhdGlvbiAhPT0gdGhpcy5zY2VuZS5nZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoYGRpc2NhcmRlZCB0aWxlICR7dGlsZS5rZXl9IGluIFRpbGVNYW5hZ2VyLmJ1aWxkVGlsZUNvbXBsZXRlZCBiZWNhdXNlIGJ1aWx0IHdpdGggYCArXG4gICAgICAgICAgICAgICAgYHNjZW5lIGNvbmZpZyBnZW4gJHt0aWxlLmdlbmVyYXRpb259LCBjdXJyZW50ICR7dGhpcy5zY2VuZS5nZW5lcmF0aW9ufWApO1xuICAgICAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgICAgIFRpbGUuYWJvcnRCdWlsZCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aWxlIHdpdGggcHJvcGVydGllcyBmcm9tIHdvcmtlclxuICAgICAgICAgICAgaWYgKHRoaXMudGlsZXNbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbdGlsZS5rZXldLm1lcmdlKHRpbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkodGlsZSk7XG4gICAgICAgICAgICB0aWxlLnVwZGF0ZSh0aGlzLnNjZW5lKTtcbiAgICAgICAgICAgIHRpbGUuYnVpbGRNZXNoZXModGhpcy5zY2VuZS5zdHlsZXMpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbGVCdWlsZFN0b3AodGlsZS5rZXkpO1xuICAgIH0sXG5cbiAgICAvLyBUcmFjayB0aWxlIGJ1aWxkIHN0YXRlXG4gICAgdGlsZUJ1aWxkU3RhcnQoa2V5KSB7XG4gICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSB0aGlzLmJ1aWxkaW5nX3RpbGVzIHx8IHt9O1xuICAgICAgICB0aGlzLmJ1aWxkaW5nX3RpbGVzW2tleV0gPSB0cnVlO1xuICAgICAgICBsb2cudHJhY2UoYHRpbGVCdWlsZFN0YXJ0IGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZ190aWxlcykubGVuZ3RofWApO1xuICAgIH0sXG5cbiAgICB0aWxlQnVpbGRTdG9wKGtleSkge1xuICAgICAgICAvLyBEb25lIGJ1aWxkaW5nP1xuICAgICAgICBpZiAodGhpcy5idWlsZGluZ190aWxlcykge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGB0aWxlQnVpbGRTdG9wIGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZ190aWxlcykubGVuZ3RofWApO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYnVpbGRpbmdfdGlsZXNba2V5XTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCdWlsZFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgc3RhdHVzIG9mIHRpbGUgYnVpbGRpbmcgcXVldWUgYW5kIG5vdGlmeSBzY2VuZSB3aGVuIHdlJ3JlIGRvbmVcbiAgICBjaGVja0J1aWxkUXVldWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWlsZGluZ190aWxlcyB8fCBPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nX3RpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS50aWxlTWFuYWdlckJ1aWxkRG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuIiwiXG5cbmV4cG9ydCBjbGFzcyBNZXRob2ROb3RJbXBsZW1lbnRlZCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSAgICA9ICdNZXRob2ROb3RJbXBsZW1lbnRlZCc7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdNZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MnO1xuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1YnNjcmliZU1peGluICh0YXJnZXQpIHtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgLy8gdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG5cbiAgICAgICAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgLy8gICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmlnZ2VyKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcltldmVudF0oLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxufVxuIiwiLy8gTWlzY2VsbGFuZW91cyB1dGlsaXRpZXNcbi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHlhbWwgZnJvbSAnanMteWFtbCc7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbnZhciBVdGlscztcbmV4cG9ydCBkZWZhdWx0IFV0aWxzID0ge307XG5cbi8vIEFkZCBhIGJhc2UgVVJMIGZvciBzY2hlbWVsZXNzIG9yIHByb3RvY29sLWxlc3MgVVJMc1xuLy8gRGVmYXVsdHMgdG8gYWRkaW5nIGN1cnJlbnQgd2luZG93IHByb3RvY29sIGFuZCBiYXNlLCBvciBhZGRzIGEgY3VzdG9tIGJhc2UgaWYgc3BlY2lmaWVkXG4vLyBNYXliZSB1c2UgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMgaWYgbW9yZSByb2J1c3QgZnVuY3Rpb25hbGl0eSBpcyBuZWVkZWRcblV0aWxzLmFkZEJhc2VVUkwgPSBmdW5jdGlvbiAodXJsLCBiYXNlKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNjaGVtZWxlc3MsIGFkZCBwcm90b2NvbFxuICAgIGlmICh1cmwuc3Vic3RyKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIHVybDtcbiAgICB9XG4gICAgLy8gTm8gaHR0cChzKSBvciBkYXRhLCBhZGQgYmFzZVxuICAgIGVsc2UgaWYgKHVybC5zZWFyY2goLyhodHRwfGh0dHBzfGRhdGEpOlxcL1xcLy8pIDwgMCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSAodXJsWzBdICE9PSAnLycpO1xuICAgICAgICB2YXIgYmFzZV9pbmZvO1xuICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgYmFzZV9pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpOyAvLyB1c2UgYSB0ZW1wb3JhcnkgZWxlbWVudCB0byBwYXJzZSBVUkxcbiAgICAgICAgICAgIGJhc2VfaW5mby5ocmVmID0gYmFzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VfaW5mbyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJhc2VfaW5mby5vcmlnaW4pIHtcbiAgICAgICAgICAgIGJhc2VfaW5mby5vcmlnaW4gPSBiYXNlX2luZm8ucHJvdG9jb2wgKyBcIi8vXCIgKyBiYXNlX2luZm8uaG9zdG5hbWUgKyAoYmFzZV9pbmZvLnBvcnQgPyAnOicgKyBiYXNlX2luZm8ucG9ydDogJycpICsgJy8nO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGJhc2VfaW5mby5vcmlnaW4gKyAocmVsYXRpdmUgPyBiYXNlX2luZm8ucGF0aG5hbWUgOiAnJykgKyB1cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuXG5VdGlscy5wYXRoRm9yVVJMID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHJldHVybiB1cmwuc3Vic3RyKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG59O1xuXG5VdGlscy5jYWNoZUJ1c3RlckZvclVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gdXJsICsgJz8nICsgKCtuZXcgRGF0ZSgpKTtcbn07XG5cblV0aWxzLmlvID0gZnVuY3Rpb24gKHVybCwgdGltZW91dCA9IDYwMDAwLCByZXNwb25zZVR5cGUgPSAndGV4dCcsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0ge30pIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3RleHQnLCAnanNvbiddLmluZGV4T2YocmVxdWVzdC5yZXNwb25zZVR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKCdSZXF1ZXN0IGVycm9yIHdpdGggYSBzdGF0dXMgb2YgJyArIHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ1RoZXJlIHdhcyBhIG5ldHdvcmsgZXJyb3InICsgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ3RpbWVvdXQgJysgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ3JlcXVlc3QnLCB7XG4gICAgICAgIHZhbHVlOiByZXF1ZXN0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblV0aWxzLnBhcnNlUmVzb3VyY2UgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBldmFsKCdkYXRhID0gJyArIGJvZHkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0geWFtbC5zYWZlTG9hZChib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLmVycm9yKCdVdGlscy5wYXJzZVJlc291cmNlOiBmYWlsZWQgdG8gcGFyc2UnLCBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG5VdGlscy5sb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBVdGlscy5pbyhVdGlscy5jYWNoZUJ1c3RlckZvclVybChzb3VyY2UpKS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBVdGlscy5wYXJzZVJlc291cmNlKGJvZHkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBOZWVkZWQgZm9yIG9sZGVyIGJyb3dzZXJzIHRoYXQgc3RpbGwgc3VwcG9ydCBXZWJHTCAoU2FmYXJpIDYgZXRjLilcblV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZVBvbHlmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDEwMDAgLzYwKTtcbiAgICAgICAgICAgIH07XG4gICAgfVxufTtcblxuLy8gU3RyaW5naWZ5IGFuIG9iamVjdCBpbnRvIEpTT04sIGJ1dCBjb252ZXJ0IGZ1bmN0aW9ucyB0byBzdHJpbmdzXG5VdGlscy5zZXJpYWxpemVXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIC8vIENvbnZlcnQgZnVuY3Rpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG4vLyBQYXJzZSBhIEpTT04gc3RyaW5nLCBidXQgY29udmVydCBmdW5jdGlvbi1saWtlIHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuVXRpbHMuZGVzZXJpYWxpemVXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgd3JhcCkge1xuICAgIHZhciBvYmogPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgIG9iaiA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhvYmosIHdyYXApO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG4vLyBSZWN1cnNpdmVseSBwYXJzZSBhbiBvYmplY3QsIGF0dGVtcHRpbmcgdG8gY29udmVydCBzdHJpbmcgcHJvcGVydGllcyB0aGF0IGxvb2sgbGlrZSBmdW5jdGlvbnMgYmFjayBpbnRvIGZ1bmN0aW9uc1xuVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqLCB3cmFwKSB7XG4gICAgLy8gQ29udmVydCBzdHJpbmdcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqID0gVXRpbHMuc3RyaW5nVG9GdW5jdGlvbihvYmosIHdyYXApO1xuICAgIH1cbiAgICAvLyBMb29wIHRocm91Z2ggb2JqZWN0IHByb3BlcnRpZXNcbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGxldCBwIGluIG9iaikge1xuICAgICAgICAgICAgb2JqW3BdID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKG9ialtwXSwgd3JhcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8vIENvbnZlcnQgc3RyaW5nIGJhY2sgaW50byBhIGZ1bmN0aW9uXG4vLyBUT0RPOiBtYWtlIGZ1bmN0aW9uIG1hdGNoaW5nIHRvbGVyYW50IG9mIHdoaXRlc3BhY2UgYW5kIG11bHRpbGluZXNcblV0aWxzLnN0cmluZ1RvRnVuY3Rpb24gPSBmdW5jdGlvbih2YWwsIHdyYXApIHtcbiAgICAvLyBDb252ZXJ0IHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuICAgIGlmICh2YWwubWF0Y2goL15cXHMqZnVuY3Rpb25cXHMqXFx3KlxccypcXChbXFxzXFxTXSpcXClcXHMqXFx7W1xcc1xcU10qXFx9L20pICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdyYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBldmFsKCdmID0gJyArIHdyYXAodmFsKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZhbCgnZiA9ICcgKyB2YWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBmYWxsLWJhY2sgdG8gb3JpZ2luYWwgdmFsdWUgaWYgcGFyc2luZyBmYWlsZWRcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIExvZyB3cmFwcGVyLCBzZW5kcyBtZXNzYWdlIHRvIG1haW4gdGhyZWFkIGZvciBkaXNwbGF5LCBhbmQgaW5jbHVkZXMgd29ya2VyIGlkICNcblV0aWxzLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgLi4ubXNnKSB7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAnaW5mbyc7XG4gICAgaWYgKFV0aWxzLmlzV29ya2VyVGhyZWFkKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2xvZycsXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICB3b3JrZXJfaWQ6IHNlbGYuX3dvcmtlcl9pZCxcbiAgICAgICAgICAgIG1zZzogbXNnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbG9nW2xldmVsXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dbbGV2ZWxdKC4uLm1zZyk7XG4gICAgfVxufTtcblxuLy8gRGVmYXVsdCB0byBhbGxvd2luZyBoaWdoIHBpeGVsIGRlbnNpdHlcblV0aWxzLnVzZV9oaWdoX2RlbnNpdHlfZGlzcGxheSA9IHRydWU7XG5VdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyA9IChVdGlscy51c2VfaGlnaF9kZW5zaXR5X2Rpc3BsYXkgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG59O1xuXG4vLyBNYXJrIHRocmVhZCBhcyBtYWluIG9yIHdvcmtlclxuKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXRpbHMuaXNXb3JrZXJUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIFV0aWxzLmlzTWFpblRocmVhZCAgID0gdHJ1ZTtcbiAgICAgICAgICAgIFV0aWxzLnVwZGF0ZURldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc2VsZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBVdGlscy5pc1dvcmtlclRocmVhZCA9IHRydWU7XG4gICAgICAgICAgICBVdGlscy5pc01haW5UaHJlYWQgICA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSkoKTtcblxuLy8gR2V0IFVSTCB0aGF0IHRoZSBjdXJyZW50IHNjcmlwdCB3YXMgbG9hZGVkIGZyb21cbi8vIElmIGN1cnJlbnRTY3JpcHQgaXMgbm90IGF2YWlsYWJsZSwgbG9vcHMgdGhyb3VnaCA8c2NyaXB0PiBlbGVtZW50cyBzZWFyY2hpbmcgZm9yIGEgbGlzdCBvZiBwcm92aWRlZCBwYXRoc1xuLy8gZS5nLiBVdGlscy5maW5kQ3VycmVudFVSTCgndGFuZ3JhbS5kZWJ1Zy5qcycsICd0YW5ncmFtLm1pbi5qcycpO1xuVXRpbHMuZmluZEN1cnJlbnRVUkwgPSBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICAvLyBGaW5kIGN1cnJlbnRseSBleGVjdXRpbmcgc2NyaXB0XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7XG4gICAgaWYgKHNjcmlwdCkge1xuICAgICAgICByZXR1cm4gc2NyaXB0LnNyYztcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgb24gbG9vcGluZyB0aHJvdWdoIDxzY3JpcHQ+IGVsZW1lbnRzIGlmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgZm9yICh2YXIgcz0wOyBzIDwgc2NyaXB0cy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHRzW3NdLnNyYy5pbmRleE9mKHBhdGgpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tzXS5zcmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gVXNlZCBmb3IgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gcG93ZXItb2YtMiBhbmQgbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcbi8vIFZpYTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMjI0Ny93ZWJnbC13YWl0LWZvci10ZXh0dXJlLXRvLWxvYWRcblV0aWxzLmlzUG93ZXJPZjIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDA7XG59O1xuXG5VdGlscy5uZXh0UG93ZXJPZjIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHZhbHVlKSkpO1xufTtcblxuLy8gSW50ZXJwb2xhdGUgJ3gnIGFsb25nIGEgc2VyaWVzIG9mIGNvbnRyb2wgcG9pbnRzXG4vLyAncG9pbnRzJyBpcyBhbiBhcnJheSBvZiBjb250cm9sIHBvaW50cyBpbiB0aGUgZm9ybSBbeCwgeV1cbi8vXG4vLyBFeGFtcGxlOlxuLy8gICAgIENvbnRyb2wgcG9pbnRzOlxuLy8gICAgICAgICBbMCwgNV06ICB3aGVuIHg9MCwgeT01XG4vLyAgICAgICAgIFs0LCAxMF06IHdoZW4geD00LCB5PTEwXG4vL1xuLy8gICAgIFV0aWxzLmludGVycG9sYXRlKDIsIFtbMCwgNV0sIFs0LCAxMF1dKTtcbi8vICAgICAtPiBjb21wdXRlcyB4PTIsIGhhbGZ3YXkgYmV0d2VlbiB4PTAgYW5kIHg9NDogKDEwIC0gNSkgLyAyICs1XG4vLyAgICAgLT4gcmV0dXJucyA3LjVcbi8vXG4vLyBUT0RPOiBhZGQgb3RoZXIgaW50ZXJwb2xhdGlvbiBtZXRob2RzIGJlc2lkZXMgbGluZWFyXG4vL1xuVXRpbHMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4LCBwb2ludHMpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3QgcmVzZW1ibGUgYSBsaXN0IG9mIGNvbnRyb2wgcG9pbnRzLCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSB8fCAhQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgdmFyIHgxLCB4MiwgZCwgeTtcblxuICAgIC8vIE1pbiBib3VuZHNcbiAgICBpZiAoeCA8PSBwb2ludHNbMF1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1swXVsxXTtcbiAgICB9XG4gICAgLy8gTWF4IGJvdW5kc1xuICAgIGVsc2UgaWYgKHggPj0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdWzFdO1xuICAgIH1cbiAgICAvLyBGaW5kIHdoaWNoIGNvbnRyb2wgcG9pbnRzIHggaXMgYmV0d2VlblxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA+PSBwb2ludHNbaV1bMF0gJiYgeCA8IHBvaW50c1tpKzFdWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICB4MSA9IHBvaW50c1tpXVswXTtcbiAgICAgICAgICAgICAgICB4MiA9IHBvaW50c1tpKzFdWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzW2ldWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYyA8IHBvaW50c1tpXVsxXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdW2NdIC0gcG9pbnRzW2ldWzFdW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeVtjXSA9IGQgKiAoeCAtIHgxKSAvICh4MiAtIHgxKSArIHBvaW50c1tpXVsxXVtjXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgdmFsdWVcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdIC0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gZCAqICh4IC0geDEpIC8gKHgyIC0geDEpICsgcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbn07XG5cbi8vIEl0ZXJhdG9ycyAoRVM2IGdlbmVyYXRvcnMpXG5cbi8vIEl0ZXJhdG9yIGZvciBrZXkvdmFsdWUgcGFpcnMgb2YgYW4gb2JqZWN0XG5VdGlscy5lbnRyaWVzID0gZnVuY3Rpb24qIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XV07XG4gICAgfVxufTtcblxuLy8gSXRlcmF0b3IgZm9yIHZhbHVlcyBvZiBhbiBvYmplY3RcblV0aWxzLnZhbHVlcyA9IGZ1bmN0aW9uKiAob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgeWllbGQgb2JqW2tleV07XG4gICAgfVxufTtcblxuLy8gUmVjdXJzaXZlIGl0ZXJhdG9ycyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBubyBtYXR0ZXIgaG93IGRlZXBseSBuZXN0ZWRcbi8vIFRPRE86IGZpeCBmb3IgY2lyY3VsYXIgc3RydWN0dXJlc1xuVXRpbHMucmVjdXJzZUVudHJpZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XSwgb2JqXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VFbnRyaWVzKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblV0aWxzLnJlY3Vyc2VWYWx1ZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VWYWx1ZXMob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuVXRpbHMuc2NhbGVJbnQxNiA9IGZ1bmN0aW9uICh2YWwsIG1heCkge1xuICAgIHJldHVybiAodmFsIC8gbWF4KSAqIDMyNzY4O1xufTtcblxuVXRpbHMuZGVnVG9SYWQgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbn07XG5cblV0aWxzLnJhZFRvRGVnID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59O1xuXG5VdGlscy50b0NhbnZhc0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArICBNYXRoLnJvdW5kKGNvbG9yWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JbMV0gICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpICsgJyknO1xufTtcblxuVXRpbHMuY2VudHJvaWQgPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIGxldCBuID0gcG9seWdvbi5sZW5ndGg7XG4gICAgbGV0IGNlbnRyb2lkID0gWzAsIDBdO1xuXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbi5sZW5ndGg7IHArKykge1xuICAgICAgICBjZW50cm9pZFswXSArPSBwb2x5Z29uW3BdWzBdO1xuICAgICAgICBjZW50cm9pZFsxXSArPSBwb2x5Z29uW3BdWzFdO1xuICAgIH1cblxuICAgIGNlbnRyb2lkWzBdIC89IG47XG4gICAgY2VudHJvaWRbMV0gLz0gbjtcblxuICAgIHJldHVybiBjZW50cm9pZDtcbn07XG5cblV0aWxzLm11bHRpQ2VudHJvaWQgPSBmdW5jdGlvbiAocG9seWdvbnMpIHtcbiAgICBsZXQgbiA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICBsZXQgY2VudHJvaWQgPSBbMCwgMF07XG5cbiAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5Z29ucy5sZW5ndGg7IHArKykge1xuICAgICAgICBsZXQgcG9seWdvbiA9IHBvbHlnb25zW3BdWzBdO1xuICAgICAgICBsZXQgYyA9IFV0aWxzLmNlbnRyb2lkKHBvbHlnb24pO1xuICAgICAgICBjZW50cm9pZFswXSArPSBjWzBdO1xuICAgICAgICBjZW50cm9pZFsxXSArPSBjWzFdO1xuICAgIH1cblxuICAgIGNlbnRyb2lkWzBdIC89IG47XG4gICAgY2VudHJvaWRbMV0gLz0gbjtcblxuICAgIHJldHVybiBjZW50cm9pZDtcbn07XG5cblV0aWxzLnBvbHlnb25BcmVhID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICBsZXQgYXJlYSA9IDA7XG4gICAgbGV0IG4gPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICBsZXQgcDAgPSBwb2x5Z29uW2ldO1xuICAgICAgICBsZXQgcDEgPSBwb2x5Z29uW2krMV07XG5cbiAgICAgICAgYXJlYSArPSBwMFswXSAqIHAxWzFdIC0gcDFbMF0gKiBwMFsxXTtcbiAgICB9XG5cbiAgICBhcmVhICs9IHBvbHlnb25bbiAtIDFdWzBdICogcG9seWdvblswXVsxXSAtIHBvbHlnb25bMF1bMF0gKiBwb2x5Z29uW24gLSAxXVsxXTtcblxuICAgIHJldHVybiBNYXRoLmFicyhhcmVhKSAvIDI7XG59O1xuXG5VdGlscy5tdWx0aVBvbHlnb25BcmVhID0gZnVuY3Rpb24gKHBvbHlnb25zKSB7XG4gICAgbGV0IGFyZWEgPSAwO1xuXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgbGV0IHBvbHlnb24gPSBwb2x5Z29uc1twXVswXTtcbiAgICAgICAgYXJlYSArPSBVdGlscy5wb2x5Z29uQXJlYShwb2x5Z29uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYTtcbn07XG5cblV0aWxzLnRvUGl4ZWxTaXplID0gZnVuY3Rpb24gKHNpemUsIGtpbmQpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJweFwiKSB7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJlbVwiKSB7XG4gICAgICAgIHJldHVybiAxNiAqIHNpemU7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInB0XCIpIHtcbiAgICAgICAgcmV0dXJuIHNpemUgLyAwLjc1O1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCIlXCIpIHtcbiAgICAgICAgcmV0dXJuIHNpemUgLyA2LjI1O1xuICAgIH1cbn07XG5cblV0aWxzLnBvaW50SW5UaWxlID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIHBvaW50WzBdID4gMCAmJsKgcG9pbnRbMV0gPiAtR2VvLnRpbGVfc2NhbGUgJiYgcG9pbnRbMF0gPCBHZW8udGlsZV9zY2FsZSAmJiBwb2ludFsxXSA8IDA7XG59O1xuXG5VdGlscy5waXhlbFRvTWVyY2F0b3IgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBzaXplICogR2VvLnVuaXRzX3Blcl9waXhlbDtcbn07XG5cbiIsInZhciB2ZXJzaW9uO1xuZXhwb3J0IGRlZmF1bHQgdmVyc2lvbiA9IHtcbiAgICBzdHJpbmc6ICd2MC4xLjInLFxuICAgIG1ham9yOiAwLFxuICAgIG1pbm9yOiAxLFxuICAgIHBhdGNoOiAyXG59O1xuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cblxuLy8gV29ya2VyQnJva2VyIHJvdXRlcyBtZXNzYWdlcyBiZXR3ZWVuIHdlYiB3b3JrZXJzIGFuZCB0aGUgbWFpbiB0aHJlYWQsIGFsbG93aW5nIGZvciBzaW1wbGVyXG4vLyBhc3luYyBjb2RlIHZpYSBwcm9taXNlcy4gRXhhbXBsZSB1c2FnZTpcbi8vXG4vLyBJbiB3ZWIgd29ya2VyLCBkZWZpbmUgYSBtZXRob2Q6XG4vL1xuLy8gICAgIHNlbGYuc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbi8vICAgICAgICAgcmV0dXJuIHggKiB4O1xuLy8gICAgIH07XG4vL1xuLy8gSW4gbWFpbiB0aHJlYWQsIGludm9rZSB0aGF0IG1ldGhvZCBhbmQgcmVjZWl2ZSB0aGUgcmVzdWx0IChpZiBhbnkpIGFzIGEgcHJvbWlzZTpcbi8vXG4vLyAgICAgd29ya2VyID0gbmV3IFdvcmtlciguLi4pO1xuLy8gICAgIFdvcmtlckJyb2tlci5hZGRXb3JrZXIod29ya2VyKTtcbi8vXG4vLyAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3NxdWFyZScsIDUpLnRoZW4oZnVuY3Rpb24oeSkge1xuLy8gICAgICAgICBjb25zb2xlLmxvZyh5KTtcbi8vICAgICB9KTtcbi8vXG4vLyAgICAgLT4gcHJpbnRzIDI1XG4vL1xuLy8gQXN5bmMgY29kZTpcbi8vXG4vLyBGb3Igc3luY2hyb25vdXMgY29kZSB0aGF0IG11c3QgcGFzcyBhIHJldHVybiB2YWx1ZSB0byB0aGUgbWFpbiB0aHJlYWQsIHRoZSBmdW5jdGlvbiBjYW4gc2ltcGx5XG4vLyByZXR1cm4gYW4gaW1tZWRpYXRlIHZhbHVlIChzZWUgZXhhbXBsZSBhYm92ZSkuIEZvciBjYXNlcyB3aGVyZSB0aGUgd29ya2VyIG1ldGhvZCBuZWVkcyB0byBydW5cbi8vIGFzeW5jaHJvbm91cyBjb2RlLCB0aGUgZnVuY3Rpb24gY2FuIHJldHVybiBhIHByb21pc2UsIGFuZCB0aGUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdmFsdWUgd2lsbFxuLy8gYmUgc2VudCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCB3aGVuIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbi8vXG4vLyBFcnJvciBoYW5kbGluZzpcbi8vXG4vLyBJZiB0aGUgd29ya2VyIG1ldGhvZCBlaXRoZXIgdGhyb3dzIGFuIGVycm9yLCBvciByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlamVjdGVkLCBpdCB3aWxsIGJlXG4vLyBzZW50IGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkIGFzIGEgcHJvbWlzZSByZWplY3Rpb24uIFRoZXNlIHR3byBleGFtcGxlcyBhcmUgZXF1aXZhbGVudDpcbi8vXG4vLyAgICAgSW4gd29ya2VyLCB0aHJvd2luZyBhbiBlcnJvcjpcbi8vXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBpbiB3b3JrZXIhJyk7XG4vLyAgICAgICAgIH07XG4vL1xuLy8gICAgIEluIHdvcmtlciwgcmV0dXJuaW5nIGEgcmVqZWN0ZWQgcHJvbWlzZTpcbi8vXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZXJyb3IgaW4gd29ya2VyIScpKTtcbi8vICAgICAgICAgfTtcbi8vXG4vLyAgICAgSW4gbWFpbiB0aHJlYWQsIGJvdGggZXJyb3JzIGFyZSByZWNlaXZlZCBhcyBhIHByb21pc2UgcmVqZWN0aW9uOlxuLy9cbi8vICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ2Jyb2tlbicpLnRoZW4oXG4vLyAgICAgICAgICAgICAvLyBQcm9taXNlIHJlc29sdmVkXG4vLyAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc3VjY2VzcyEnKTtcbi8vICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgICAvLyBQcm9taXNlIHJlamVjdGVkXG4vLyAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciEnLCBlcnJvcik7XG4vLyAgICAgICAgICAgICB9KTtcbi8vXG4vLyAgICAgICAgIC0+IHByaW50cyAnZXJyb3IhIGVycm9yIGluIHdvcmtlcidcbi8vXG4vLyBUT0RPOiBhZGQgZG9jdW1lbnRhdGlvbiBmb3IgaW52b2tpbmcgbWFpbiB0aHJlYWQgbWV0aG9kcyBmcm9tIGEgd29ya2VyIChiYXNpY2FsbHkgc2FtZSBBUEksIGJ1dCBpbiByZXZlcnNlKVxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG52YXIgV29ya2VyQnJva2VyO1xuZXhwb3J0IGRlZmF1bHQgV29ya2VyQnJva2VyID0ge307XG5cbi8vIEdsb2JhbCBsaXN0IG9mIGFsbCB3b3JrZXIgbWVzc2FnZXNcbi8vIFVuaXF1ZWx5IHRyYWNrcyBldmVyeSBjYWxsIG1hZGUgYmV0d2VlbiBtYWluIHRocmVhZCBhbmQgYSB3b3JrZXJcbnZhciBtZXNzYWdlX2lkID0gMDtcbnZhciBtZXNzYWdlcyA9IHt9O1xuXG4vLyBNYWluIHRocmVhZDpcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byB3b3JrZXJzLCBhbmQgb3B0aW9uYWxseSByZWNlaXZlIGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxuLy8gLSBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gd29ya2VycywgYW5kIG9wdGlvbmFsbHkgc2VuZCBhbiBhc3luYyByZXNwb25zZSBiYWNrIGFzIGEgcHJvbWlzZVxuZnVuY3Rpb24gc2V0dXBNYWluVGhyZWFkICgpIHtcblxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIGEgd29ya2VyLCBhbmQgb3B0aW9uYWxseSBnZXQgYW4gYXN5bmMgcmVzcG9uc2VcbiAgICAvLyBBcmd1bWVudHM6XG4gICAgLy8gICAtIHdvcmtlcjogdGhlIHdlYiB3b3JrZXIgaW5zdGFuY2VcbiAgICAvLyAgIC0gbWV0aG9kOiB0aGUgbWV0aG9kIHdpdGggdGhpcyBuYW1lIHdpbGwgYmUgaW52b2tlZCBpbiB0aGUgd29ya2VyXG4gICAgLy8gICAtIG1lc3NhZ2U6IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbCBpbiB0aGUgd29ya2VyXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgIC0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaWYgdGhlIHdvcmtlciBtZXRob2QgcmV0dXJucyBhIHZhbHVlIChjb3VsZCBiZSBpbW1lZGlhdGVseSwgb3IgYXN5bmMpXG4gICAgLy9cbiAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAod29ya2VyLCBtZXRob2QsIC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVHJhY2sgc3RhdGUgb2YgdGhpcyBtZXNzYWdlXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IG1ldGhvZCwgbWVzc2FnZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnbWFpbl9zZW5kJywgICAgICAvLyBtYXJrIG1lc3NhZ2UgYXMgbWV0aG9kIGludm9jYXRpb24gZnJvbSBtYWluIHRocmVhZFxuICAgICAgICAgICAgbWVzc2FnZV9pZCwgICAgICAgICAgICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIG1lc3NhZ2UsIGZvciBsaWZlIG9mIHByb2dyYW1cbiAgICAgICAgICAgIG1ldGhvZCwgICAgICAgICAgICAgICAgIC8vIHdpbGwgZGlzcGF0Y2ggdG8gYSBmdW5jdGlvbiBvZiB0aGlzIG5hbWUgd2l0aGluIHRoZSB3b3JrZXJcbiAgICAgICAgICAgIG1lc3NhZ2UgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgcGF5bG9hZFxuICAgICAgICB9KTtcblxuICAgICAgICBtZXNzYWdlX2lkKys7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYSB3b3JrZXIgdG8gY29tbXVuaWNhdGUgd2l0aCAtIGVhY2ggd29ya2VyIG11c3QgYmUgcmVnaXN0ZXJlZCBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgIHZhciB3b3JrZXJfaWQgPSAwO1xuICAgIHZhciB3b3JrZXJzID0ge307XG5cbiAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyID0gZnVuY3Rpb24gKHdvcmtlcikge1xuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgYWxsIHJlZ2lzdGVyZWQgd29ya2Vyc1xuICAgICAgICAvLyBUT0RPOiBhZGRpbmcgYSBwcm9wZXJ0eSBkaXJlY3RseSB0byB0aGUgd29ya2VyLCB3b3VsZCBiZSBiZXR0ZXIgdG8gdHJhY2sgbm9uLWluc3RydXNpdmVseSxcbiAgICAgICAgLy8gbWF5YmUgd2l0aCBhbiBFUzYgTWFwXG4gICAgICAgIHdvcmtlci5fd29ya2VyX2Jyb2tlcl9pZCA9IHdvcmtlcl9pZCsrO1xuICAgICAgICB3b3JrZXJzW3dvcmtlci5fd29ya2VyX2Jyb2tlcl9pZF0gPSB3b3JrZXI7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBjb21pbmcgYmFjayBmcm9tIHRoZSB3b3JrZXIsIGFuZCBmdWxmaWxsIHRoYXQgbWVzc2FnZSdzIHByb21pc2VcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgIT09ICd3b3JrZXJfcmVwbHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXNzIHRoZSByZXN1bHQgdG8gdGhlIHByb21pc2VcbiAgICAgICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVqZWN0KGV2ZW50LmRhdGEuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlc29sdmUoZXZlbnQuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2VzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBpbml0aWF0aW5nIGEgY2FsbCBmcm9tIHRoZSB3b3JrZXIsIGRpc3BhdGNoIHRoZW0sXG4gICAgICAgIC8vIGFuZCBzZW5kIGFueSByZXR1cm4gdmFsdWUgYmFjayB0byB0aGUgd29ya2VyXG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBVbmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSAmIHJldHVybiBjYWxsIHRvIG1haW4gdGhyZWFkXG4gICAgICAgICAgICB2YXIgaWQgPSBldmVudC5kYXRhLm1lc3NhZ2VfaWQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnd29ya2VyX3NlbmQnIHx8IGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHJlcXVlc3RlZCBtZXRob2QgYW5kIHNhdmUgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbZXZlbnQuZGF0YS50YXJnZXRdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IG9uIHRhcmdldCAke2V2ZW50LmRhdGEudGFyZ2V0fSBiZWNhdXNlIG5vIG9iamVjdCB3aXRoIHRoYXQgbmFtZSBpcyByZWdpc3RlcmVkIG9uIG1haW4gdGhyZWFkYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZXRob2QgPSAodHlwZW9mIHRhcmdldFtldmVudC5kYXRhLm1ldGhvZF0gPT09ICdmdW5jdGlvbicpICYmIHRhcmdldFtldmVudC5kYXRhLm1ldGhvZF07XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHtldmVudC5kYXRhLm1ldGhvZH0gb24gdGFyZ2V0ICR7ZXZlbnQuZGF0YS50YXJnZXR9IGJlY2F1c2Ugb2JqZWN0IGhhcyBubyBtZXRob2Qgd2l0aCB0aGF0IG5hbWVgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZXJyb3I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0YXJnZXQsIGV2ZW50LmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3duIGVycm9ycyB3aWxsIGJlIHBhc3NlZCBiYWNrIChpbiBzdHJpbmcgZm9ybSkgdG8gd29ya2VyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZW5kIHJldHVybiB2YWx1ZSB0byB3b3JrZXJcbiAgICAgICAgICAgIC8vIEFzeW5jIHJlc3VsdFxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWFpbl9yZXBseScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbW1lZGlhdGUgcmVzdWx0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWFpbl9yZXBseScsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgLy8gUmVnaXN0ZXIgYW4gb2JqZWN0IHRvIHJlY2VpdmUgY2FsbHMgZnJvbSB0aGUgd29ya2VyXG4gICAgdmFyIHRhcmdldHMgPSB7fTtcbiAgICBXb3JrZXJCcm9rZXIuYWRkVGFyZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIHRhcmdldCkge1xuICAgICAgICB0YXJnZXRzW25hbWVdID0gdGFyZ2V0O1xuICAgIH07XG5cbiAgICAvLyBFeHBvc2UgZm9yIGRlYnVnZ2luZ1xuICAgIFdvcmtlckJyb2tlci5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH07XG5cbiAgICBXb3JrZXJCcm9rZXIuZ2V0TWVzc2FnZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZV9pZDtcbiAgICB9O1xuXG59XG5cbi8vIFdvcmtlciB0aHJlYWRzOlxuLy8gLSBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gbWFpbiB0aHJlYWQsIGFuZCBvcHRpb25hbGx5IHNlbmQgYW4gYXN5bmMgcmVzcG9uc2UgYmFjayBhcyBhIHByb21pc2Vcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgcmVjZWl2ZSBhbiBhc3luYyByZXNwb25zZSBhcyBhIHByb21pc2VcbmZ1bmN0aW9uIHNldHVwV29ya2VyVGhyZWFkICgpIHtcblxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgZ2V0IGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxuICAgIC8vIEFyZ3VtZW50czpcbiAgICAvLyAgIC0gdGFyZ2V0OiB0aGUgbmFtZSBvZiB0aGUgb2JqZWN0IGluIHRoZSBtYWluIHRocmVhZCB0byBiZSBjYWxsZWRcbiAgICAvLyAgIC0gbWV0aG9kOiB0aGUgbWV0aG9kIHdpdGggdGhpcyBuYW1lIHdpbGwgYmUgaW52b2tlZCBvbiB0aGUgbWFpbiB0aHJlYWQgdGFyZ2V0IG9iamVjdFxuICAgIC8vICAgLSBtZXNzYWdlOiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGwgaW4gdGhlIG1haW4gdGhyZWFkXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgIC0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaWYgdGhlIG1haW4gdGhyZWFkIG1ldGhvZCByZXR1cm5zIGEgdmFsdWUgKGNvdWxkIGJlIGltbWVkaWF0ZWx5LCBvciBhc3luYylcbiAgICAvL1xuICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG1ldGhvZCwgLi4ubWVzc2FnZSkge1xuICAgICAgICAvLyBUcmFjayBzdGF0ZSBvZiB0aGlzIG1lc3NhZ2VcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlc1ttZXNzYWdlX2lkXSA9IHsgdGFyZ2V0LCBtZXRob2QsIG1lc3NhZ2UsIHJlc29sdmUsIHJlamVjdCB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfc2VuZCcsICAgIC8vIG1hcmsgbWVzc2FnZSBhcyBtZXRob2QgaW52b2NhdGlvbiBmcm9tIHdvcmtlclxuICAgICAgICAgICAgbWVzc2FnZV9pZCwgICAgICAgICAgICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIG1lc3NhZ2UsIGZvciBsaWZlIG9mIHByb2dyYW1cbiAgICAgICAgICAgIHRhcmdldCwgICAgICAgICAgICAgICAgIC8vIG5hbWUgb2YgdGhlIG9iamVjdCB0byBiZSBjYWxsZWQgb24gbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIG1ldGhvZCwgICAgICAgICAgICAgICAgIC8vIHdpbGwgZGlzcGF0Y2ggdG8gYSBtZXRob2Qgb2YgdGhpcyBuYW1lIG9uIHRoZSBtYWluIHRocmVhZFxuICAgICAgICAgICAgbWVzc2FnZSAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBwYXlsb2FkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lc3NhZ2VfaWQrKztcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIC8vIExpc3RlbiBmb3IgbWVzc2FnZXMgY29taW5nIGJhY2sgZnJvbSB0aGUgbWFpbiB0aHJlYWQsIGFuZCBmdWxmaWxsIHRoYXQgbWVzc2FnZSdzIHByb21pc2VcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ21haW5fcmVwbHknKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXNzIHRoZSByZXN1bHQgdG8gdGhlIHByb21pc2VcbiAgICAgICAgdmFyIGlkID0gZXZlbnQuZGF0YS5tZXNzYWdlX2lkO1xuICAgICAgICBpZiAobWVzc2FnZXNbaWRdKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVzb2x2ZShldmVudC5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2VzW2lkXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVjZWl2ZSBtZXNzYWdlcyBmcm9tIG1haW4gdGhyZWFkLCBkaXNwYXRjaCB0aGVtLCBhbmQgc2VuZCBiYWNrIGEgcmVwbHlcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gVW5pcXVlIGlkIGZvciB0aGlzIG1lc3NhZ2UgJiByZXR1cm4gY2FsbCB0byBtYWluIHRocmVhZFxuICAgICAgICB2YXIgaWQgPSBldmVudC5kYXRhLm1lc3NhZ2VfaWQ7XG4gICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgIT09ICdtYWluX3NlbmQnIHx8IGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGwgdGhlIHJlcXVlc3RlZCB3b3JrZXIgbWV0aG9kIGFuZCBzYXZlIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgdmFyIG1ldGhvZF9uYW1lID0gZXZlbnQuZGF0YS5tZXRob2Q7XG4gICAgICAgIHZhciBtZXRob2QgPSAodHlwZW9mIHNlbGZbbWV0aG9kX25hbWVdID09PSAnZnVuY3Rpb24nKSAmJiBzZWxmW21ldGhvZF9uYW1lXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHttZXRob2RfbmFtZX0gYmVjYXVzZSB3b3JrZXIgaGFzIG5vIG1ldGhvZCB3aXRoIHRoYXQgbmFtZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCwgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoc2VsZiwgZXZlbnQuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBUaHJvd24gZXJyb3JzIHdpbGwgYmUgcGFzc2VkIGJhY2sgKGluIHN0cmluZyBmb3JtKSB0byBtYWluIHRocmVhZFxuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCByZXR1cm4gdmFsdWUgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgbGV0IHRyYW5zZmVyYWJsZXM7XG4gICAgICAgIC8vIEFzeW5jIHJlc3VsdFxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcyA9IGZpbmRUcmFuc2ZlcmFibGVzKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgJyR7bWV0aG9kX25hbWV9JyB0cmFuc2ZlcnJlZCAke3RyYW5zZmVyYWJsZXMubGVuZ3RofSBvYmplY3RzIHRvIG1haW4gdGhyZWFkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW1tZWRpYXRlIHJlc3VsdFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSBmaW5kVHJhbnNmZXJhYmxlcyhyZXN1bHQpO1xuXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyX3JlcGx5JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyk7XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byBtYWluIHRocmVhZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbn1cblxuLy8gQnVpbGQgYSBsaXN0IG9mIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZyb20gYSBzb3VyY2Ugb2JqZWN0XG4vLyBUT0RPOiBhZGQgb3B0aW9uIGluIGNhc2UgeW91IERPTidUIHdhbnQgdG8gdHJhbnNmZXIgb2JqZWN0c1xuZnVuY3Rpb24gZmluZFRyYW5zZmVyYWJsZXMoc291cmNlLCBsaXN0ID0gW10pIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAvLyBDaGVjayBlYWNoIGFycmF5IGVsZW1lbnRcbiAgICAgICAgc291cmNlLmZvckVhY2goeCA9PiBmaW5kVHJhbnNmZXJhYmxlcyh4LCBsaXN0KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIElzIHRoZSBvYmplY3QgYSB0cmFuc2ZlcmFibGUgYXJyYXkgYnVmZmVyP1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9yIGxvb2tzIGxpa2UgYSB0eXBlZCBhcnJheSAoaGFzIGFuIGFycmF5IGJ1ZmZlciBwcm9wZXJ0eSk/XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHNvdXJjZS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBjaGVjayBlYWNoIHByb3BlcnR5XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmaW5kVHJhbnNmZXJhYmxlcyhzb3VyY2VbcF0sIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyBTZXR1cCB0aGlzIHRocmVhZCBhcyBhcHByb3ByaWF0ZVxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgIHNldHVwTWFpblRocmVhZCgpO1xufVxuXG5pZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICBzZXR1cFdvcmtlclRocmVhZCgpO1xufVxuIiwiLyoqKiBWZWN0b3IgZnVuY3Rpb25zIC0gdmVjdG9ycyBwcm92aWRlZCBhcyBbeCwgeSwgel0gYXJyYXlzICoqKi9cblxudmFyIFZlY3RvcjtcbmV4cG9ydCBkZWZhdWx0IFZlY3RvciA9IHt9O1xuXG5WZWN0b3Iuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgViA9IFtdO1xuICAgIHZhciBsaW0gPSB2Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIFZbaV0gPSB2W2ldO1xuICAgIH1cbiAgICByZXR1cm4gVjtcbn07XG5cblZlY3Rvci5uZWcgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBWID0gW107XG4gICAgdmFyIGxpbSA9IHYubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltOyBpKyspIHtcbiAgICAgICAgVltpXSA9IHZbaV0gKiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIFY7XG59O1xuXG4vLyBBZGRpdGlvbiBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLmFkZCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIHZbaV0gPSB2MVtpXSArIHYyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIFN1YnN0cmFjdGlvbiBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLnN1YiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltOyBpKyspIHtcbiAgICAgICAgdltpXSA9IHYxW2ldIC0gdjJbaV07XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuVmVjdG9yLnNpZ25lZF9hcmVhID0gZnVuY3Rpb24gKHYxLCB2MiwgdjMpIHtcbiAgICByZXR1cm4gKHYyWzBdLXYxWzBdKSoodjNbMV0tdjFbMV0pIC0gKHYzWzBdLXYxWzBdKSoodjJbMV0tdjFbMV0pO1xufTtcblxuLy8gTXVsdGlwbGljYXRpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5tdWx0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciB2ID0gW10sXG4gICAgICAgIGxlbiA9IHYxLmxlbmd0aCxcbiAgICAgICAgaTtcblxuICAgIGlmICh0eXBlb2YgdjIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIE11bGl0cGx5IGJ5IHNjYWxhclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAqIHYyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNdWx0aXBseSB0d28gdmVjdG9yc1xuICAgICAgICBsZW4gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gKiB2MltpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIERpdmlzaW9uIG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IuZGl2ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciB2ID0gW10sXG4gICAgICAgIGk7XG4gICAgaWYodHlwZW9mIHYyID09PSAnbnVtYmVyJyl7XG4gICAgICAgIC8vIERpdmlkZSBieSBzY2FsYXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGl2aWRlIHRvIHZlY3RvcnNcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHYxLmxlbmd0aCx2Mi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuLy8gR2V0IDJEIHBlcnBlbmRpY3VsYXJcblZlY3Rvci5wZXJwID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHJldHVybiBbIHYyWzFdIC0gdjFbMV0sXG4gICAgICAgICAgICAgdjFbMF0gLSB2MlswXSBdO1xufTtcblxuLy8gR2V0IDJEIHZlY3RvciByb3RhdGVkXG5WZWN0b3Iucm90ID0gZnVuY3Rpb24gKHYsIGEpIHtcbiAgICB2YXIgdnIgPSBWZWN0b3IubGVuZ3RoKHYpO1xuICAgIHZhciB2YSA9IFZlY3Rvci5hbmdsZSh2KTtcbiAgICByZXR1cm4gW3ZyICogTWF0aC5jb3ModmErYSksXG4gICAgICAgICAgICB2ciAqIE1hdGguc2luKHZhK2EpXTtcbn07XG5cbi8vIEdldCAyRCBoZWFkaW5nIGFuZ2xlXG5WZWN0b3IuYW5nbGUgPSBmdW5jdGlvbiAoW3gsIHldKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSx4KTtcbn07XG5cbi8vIENvbXBhcmUgdHdvIHBvaW50c1xuVmVjdG9yLmlzRXF1YWwgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIGxlbiA9IHYxLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh2MVtpXSAhPT0gdjJbaV0pe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gVmVjdG9yIGxlbmd0aCBzcXVhcmVkXG5WZWN0b3IubGVuZ3RoU3EgPSBmdW5jdGlvbiAodilcbntcbiAgICBpZiAodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl0pO1xuICAgIH1cbn07XG5cbi8vIFZlY3RvciBsZW5ndGhcblZlY3Rvci5sZW5ndGggPSBmdW5jdGlvbiAodilcbntcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFZlY3Rvci5sZW5ndGhTcSh2KSk7XG59O1xuXG4vLyBOb3JtYWxpemUgYSB2ZWN0b3JcblZlY3Rvci5ub3JtYWxpemUgPSBmdW5jdGlvbiAodilcbntcbiAgICB2YXIgZDtcbiAgICBpZiAodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXTtcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2WzBdIC8gZCwgdlsxXSAvIGRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXSArIHZbMl0qdlsyXTtcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2WzBdIC8gZCwgdlsxXSAvIGQsIHZbMl0gLyBkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgIH1cbn07XG5cbi8vIENyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5jcm9zcyAgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHYxWzFdICogdjJbMl0pIC0gKHYxWzJdICogdjJbMV0pLFxuICAgICAgICAodjFbMl0gKiB2MlswXSkgLSAodjFbMF0gKiB2MlsyXSksXG4gICAgICAgICh2MVswXSAqIHYyWzFdKSAtICh2MVsxXSAqIHYyWzBdKVxuICAgIF07XG59O1xuXG4vLyBEb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLmRvdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGxpbSA9IE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIG4gKz0gdjFbaV0gKiB2MltpXTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuXG4vLyBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGxpbmVzIHNwZWNpZmllZCBhcyBzZWdtZW50cyBmcm9tIHBvaW50cyAocDEsIHAyKSBhbmQgKHAzLCBwNClcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZS1saW5lX2ludGVyc2VjdGlvblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DcmFtZXInc19ydWxlXG5WZWN0b3IubGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChwMSwgcDIsIHAzLCBwNCwgcGFyYWxsZWxfdG9sZXJhbmNlKSB7XG4gICAgcGFyYWxsZWxfdG9sZXJhbmNlID0gcGFyYWxsZWxfdG9sZXJhbmNlIHx8IDAuMDE7XG5cbiAgICAvLyBhMSp4ICsgYjEqeSA9IGMxIGZvciBsaW5lICh4MSwgeTEpIHRvICh4MiwgeTIpXG4gICAgLy8gYTIqeCArIGIyKnkgPSBjMiBmb3IgbGluZSAoeDMsIHkzKSB0byAoeDQsIHk0KVxuICAgIHZhciBhMSA9IHAxWzFdIC0gcDJbMV07IC8vIHkxIC0geTJcbiAgICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdOyAvLyB4MSAtIHgyXG4gICAgdmFyIGEyID0gcDNbMV0gLSBwNFsxXTsgLy8geTMgLSB5NFxuICAgIHZhciBiMiA9IHAzWzBdIC0gcDRbMF07IC8vIHgzIC0geDRcbiAgICB2YXIgYzEgPSAocDFbMF0gKiBwMlsxXSkgLSAocDFbMV0gKiBwMlswXSk7IC8vIHgxKnkyIC0geTEqeDJcbiAgICB2YXIgYzIgPSAocDNbMF0gKiBwNFsxXSkgLSAocDNbMV0gKiBwNFswXSk7IC8vIHgzKnk0IC0geTMqeDRcbiAgICB2YXIgZGVub20gPSAoYjEgKiBhMikgLSAoYTEgKiBiMik7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGVub20pID4gcGFyYWxsZWxfdG9sZXJhbmNlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoKGMxICogYjIpIC0gKGIxICogYzIpKSAvIGRlbm9tLFxuICAgICAgICAgICAgKChjMSAqIGEyKSAtIChhMSAqIGMyKSkgLyBkZW5vbVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDsgLy8gcmV0dXJuIG51bGwgaWYgbGluZXMgYXJlIChjbG9zZSB0bykgcGFyYWxsZWxcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9iYWJlbC9wb2x5ZmlsbFwiKTtcbiJdfQ==
